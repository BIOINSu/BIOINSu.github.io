<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/maze.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/maze.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/maze.png">
  <link rel="mask-icon" href="/images/maze.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="LeetCode中与链表有关的题目。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 链表">
<meta property="og:url" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/index.html">
<meta property="og:site_name" content="BIOINSu">
<meta property="og:description" content="LeetCode中与链表有关的题目。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/0.jpg">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/1.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/0.png">
<meta property="article:published_time" content="2021-09-14T03:28:53.557Z">
<meta property="article:modified_time" content="2021-09-14T03:38:31.764Z">
<meta property="article:author" content="BIOINSu">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/0.jpg">


<link rel="canonical" href="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>LeetCode 链表 | BIOINSu</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BIOINSu</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#lru%E7%BC%93%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">146 LRU缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">234 回文链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &amp;#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &amp;#123;&amp;#125;
 *     ListNode(int val) &amp;#123; this.val &#x3D; val; &amp;#125;
 *     ListNode(int val, ListNode next) &amp;#123; this.val &#x3D; val; this.next &#x3D; next; &amp;#125;
 * &amp;#125;
 *&#x2F;
class Solution &amp;#123;
    public boolean isPalindrome(ListNode head) &amp;#123;
        
        &#x2F;&#x2F;head为空时返回true
        if(head &#x3D;&#x3D; null)
            return true;
        
        ListNode slow &#x3D; head, fast &#x3D; head, pre &#x3D; null, tmp &#x3D; null;
        
        &#x2F;*
        当节点数量为奇数时，fast.next &#x3D;&#x3D; null
        当节点数量为偶数时，fast &#x3D;&#x3D; null
        *&#x2F;
        while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null)&amp;#123;
            
            &#x2F;&#x2F;fast先走两步
            fast &#x3D; fast.next.next;
            
            &#x2F;&#x2F;慢指针走一步并同时进行翻转
            tmp &#x3D; slow.next;
            slow.next &#x3D; pre;
            pre &#x3D; slow;
            slow &#x3D; tmp;
            
        &amp;#125;
        
        &#x2F;&#x2F;如果是奇数节点，例如5个，慢指针刚好指向第3个位置，因此多走一步指向第二个链表头
        &#x2F;&#x2F;注意这里要两个条件，避免fast指向null时出错
        if(fast !&#x3D; null &amp;&amp; fast.next &#x3D;&#x3D; null)
            slow &#x3D; slow.next;
        
        &#x2F;&#x2F;pre和slow同时开始遍历，判断是否是回文
        while(pre !&#x3D; null &amp;&amp; slow !&#x3D; null)&amp;#123;
            if(pre.val !&#x3D; slow.val)
                return false;
            
            pre &#x3D; pre.next;
            slow &#x3D; slow.next;
        &amp;#125;
        
        return true;

    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">1.</span> <span class="nav-text">2 两数相加</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-1"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &amp;#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &amp;#123;&amp;#125;
 *     ListNode(int val) &amp;#123; this.val &#x3D; val; &amp;#125;
 *     ListNode(int val, ListNode next) &amp;#123; this.val &#x3D; val; this.next &#x3D; next; &amp;#125;
 * &amp;#125;
 *&#x2F;
class Solution &amp;#123;
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &amp;#123;
        
        int carry &#x3D; 0; &#x2F;&#x2F;记录进位
        int sum &#x3D; 0; &#x2F;&#x2F; 记录每一位相加
        ListNode vhead &#x3D; new ListNode(0);
        ListNode tmp &#x3D; vhead;

        while(l1 !&#x3D; null || l2 !&#x3D; null)&amp;#123;

            sum &#x3D; (l1 &#x3D;&#x3D; null? 0 : l1.val) + (l2 &#x3D;&#x3D; null? 0 : l2.val) + carry;

            carry &#x3D; sum &#x2F; 10;

            sum &#x3D; sum % 10;

            tmp.next &#x3D; new ListNode(sum);
            tmp &#x3D; tmp.next;

            if(l1 !&#x3D; null) l1 &#x3D; l1.next;
            if(l2 !&#x3D; null) l2 &#x3D; l2.next;

        &amp;#125;

        if(carry !&#x3D; 0)
            tmp.next &#x3D; new ListNode(carry);

        return vhead.next;

    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">148 排序链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-2"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &amp;#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &amp;#123;&amp;#125;
 *     ListNode(int val) &amp;#123; this.val &#x3D; val; &amp;#125;
 *     ListNode(int val, ListNode next) &amp;#123; this.val &#x3D; val; this.next &#x3D; next; &amp;#125;
 * &amp;#125;
 *&#x2F;
class Solution &amp;#123;
    
    &#x2F;&#x2F;获取链表的长度用于判断归并终止条件
    public int getLength(ListNode head)&amp;#123;        
        int count &#x3D; 0;
        while(head !&#x3D; null)&amp;#123;
            count++;
            head &#x3D; head.next;
        &amp;#125;
        return count;              
    &amp;#125;
    
    &#x2F;&#x2F;split(l,n) 即切掉链表l的前n个节点，并返回后半部分的链表头
    public ListNode split(ListNode head, int n)&amp;#123;
        if(head &#x3D;&#x3D; null) return null;
        
        ListNode tmp &#x3D; head;
        for(int i &#x3D; 1; i &lt; n &amp;&amp; tmp.next!&#x3D; null; i++)&amp;#123; &#x2F;&#x2F;走n步刚好到达后半部分链表头，从1开始走n-1步则走到前一个节点（为了断链）
            tmp &#x3D; tmp.next;
        &amp;#125;
        ListNode right &#x3D; tmp.next; &#x2F;&#x2F;返回后半部分的链表头
        tmp.next &#x3D; null;&#x2F;&#x2F;断链操作
        return right;
    &amp;#125;
    
    &#x2F;&#x2F;合并两个有序链表
    public ListNode merge(ListNode h1, ListNode h2)&amp;#123;
        
        ListNode vhead &#x3D; new ListNode(-1);
        ListNode p &#x3D; vhead;
        
        while(h1 !&#x3D; null &amp;&amp; h2 !&#x3D; null)&amp;#123;
            
            if(h1.val &lt; h2.val)&amp;#123;
                p.next &#x3D; h1;
                h1 &#x3D; h1.next;       
            &amp;#125;else&amp;#123;
                p.next &#x3D; h2;
                h2 &#x3D; h2.next;
            &amp;#125;
            p &#x3D; p.next;
        &amp;#125;
        
        p.next &#x3D; h1 &#x3D;&#x3D; null ? h2 : h1;
        
        return vhead.next;
        
    &amp;#125;
    
    
    public ListNode sortList(ListNode head) &amp;#123;
        
        if(head &#x3D;&#x3D; null)
            return null;
        
        int len &#x3D; getLength(head);
        &#x2F;&#x2F;新建虚拟头节点，该头节点的next指针永远指向链表的第一个位置
        ListNode dummy &#x3D; new ListNode(-1);
        dummy.next &#x3D; head;
        
        for(int step &#x3D; 1; step &lt; len; step &#x3D; step*2)&amp;#123; &#x2F;&#x2F;依次将链表分成1块，2块，4块...
            
            ListNode pre &#x3D; dummy; &#x2F;&#x2F;每次迭代开始时pre都指向虚拟头节点，并用pre将排序好的链表串联起来
            ListNode cur &#x3D; dummy.next;
            
            while(cur !&#x3D; null)&amp;#123;
                
                ListNode h1 &#x3D; cur;
                ListNode h2 &#x3D; split(h1, step); &#x2F;&#x2F;将第一部分数组切割，并返回第二部分数组头
                cur &#x3D; split(h2, step); &#x2F;&#x2F;将第二部分数组切割，将cur往后移动
                
                ListNode tmp &#x3D; merge(h1, h2); &#x2F;&#x2F;合并两个排序链表
                pre.next &#x3D; tmp; &#x2F;&#x2F;用pre将排序链表串起来（首次执行时pre &#x3D; dummy，则虚拟头永远可以指向链表头）
                while(pre.next !&#x3D; null)
                    pre &#x3D; pre.next;
                  
            &amp;#125;
            
        &amp;#125;
        
        return dummy.next;

    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">23 合并K个升序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%E6%9D%A5%E6%BA%90"><span class="nav-number">2.</span> <span class="nav-text">题解来源</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">BIOINSu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/BIOINSu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BIOINSu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="BIOINSu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BIOINSu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode 链表
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-09-14 11:28:53 / 修改时间：11:38:31" itemprop="dateCreated datePublished" datetime="2021-09-14T11:28:53+08:00">2021-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>LeetCode中与链表有关的题目。</p>
<a id="more"></a>
<h3 id="lru缓存">146 LRU缓存</h3>
<p>题目描述</p>
<p>实现一个最近最少使用的缓存策略。</p>
<p>题解</p>
<p>时间复杂度O(1)：</p>
<p>空间复杂度O(n)：使用Hash表和双向链表对元素进行存储</p>
<p>当添加元素的时候，如果还有位置，则直接添加到头部，否则需要将最久没有被访问过的元素移出去。</p>
<p>Java中使用LinkedHashMap进行实现，其本质是HashMap加双向链表的形式。</p>
<p>HashMap用于保证查找和删除的时间为O(1)。LinkedHashMap用来存储元素的访问顺序。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/0.jpg" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现双向链表</span></span><br><span class="line"><span class="comment">//首先实现双向链表中的每个节点，假设Key、Value都是int类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key,value;</span><br><span class="line">    <span class="keyword">public</span> Node pre,next;<span class="comment">//前后节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在头部添加节点，即插入元素或访问一个已存在元素</span></span><br><span class="line">    <span class="comment">//注意它只能在头部插入元素表示访问该元素，其他位置都不需要插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = tail = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head.pre = node;</span><br><span class="line">            head = head.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表中某个节点，即当访问某个元素时，它被提到双向链表最前面，因此需要先删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果只剩下一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == node &amp;&amp; tail == node)&#123;</span><br><span class="line">          head = <span class="keyword">null</span>;</span><br><span class="line">          tail = <span class="keyword">null</span>;   </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head == node)&#123; <span class="comment">//删除头节点</span></span><br><span class="line">            head.next.pre = <span class="keyword">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tail == node)&#123; <span class="comment">//删除尾节点</span></span><br><span class="line">            tail = tail.pre;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            node.pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//删除中间节点</span></span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            node.pre = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表最末尾的元素，为新增加的元素空出位置，要返回这个节点便于HashMao删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node tmp = tail;</span><br><span class="line">        remove(tail);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">        cap = capacity;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该函数的作用就是访问一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(key).value;</span><br><span class="line">        <span class="comment">//改变双向链表中元素的顺序</span></span><br><span class="line">        put(key,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个函数的作用就是把元素插入到哈希表和双向链表中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node tmp = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">		<span class="comment">//如果这个元素已经存在，那么只要调整在双向链表中的位置即可</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//在双向链表中删除</span></span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">            <span class="comment">//插入头部</span></span><br><span class="line">            cache.addFirst(tmp);</span><br><span class="line">            <span class="comment">//更新map中的值</span></span><br><span class="line">            map.put(key, tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//元素不存在</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果容量已经满了</span></span><br><span class="line">            <span class="keyword">if</span>(cache.size() == cap)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//从双向链表和HashMao中删除最近最少使用页面</span></span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//插入头部</span></span><br><span class="line">            cache.addFirst(tmp);</span><br><span class="line">            <span class="comment">//更新map中的值</span></span><br><span class="line">            map.put(key, tmp);</span><br><span class="line">            </span><br><span class="line">                  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回文链表">234 回文链表</h3>
<p>题目描述</p>
<p>请判断一个链表是否为回文链表。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2 输出: false 示例 2:</p>
<p>输入: 1-&gt;2-&gt;2-&gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(1)：不使用额外存储空间</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/1.png" style="zoom:50%;"></p>
<p>使用快慢指针找到链表一半处的位置。两个指针都从头部开始，慢指针每次走一步，快指针每次走两步，并且需要维护一个pre指针指向慢指针的前一个节点。这样当节点数量为<strong>偶数</strong>时（例如4个），快指针 == null，pre指向链表节点一半处（第二个节点）；当节点数量为<strong>奇数</strong>时（例如5个），快指针 == null，pre指向链表节点一半处的前一个节点（第二个节点）。</p>
<p>技巧是边遍历边反转，直到慢指针到达链表一半处的位置。</p>
<h2 id="section"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//head为空时返回true</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head, fast = head, pre = <span class="keyword">null</span>, tmp = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        当节点数量为奇数时，fast.next == null</span></span><br><span class="line"><span class="comment">        当节点数量为偶数时，fast == null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//fast先走两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//慢指针走一步并同时进行翻转</span></span><br><span class="line">            tmp = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是奇数节点，例如5个，慢指针刚好指向第3个位置，因此多走一步指向第二个链表头</span></span><br><span class="line">        <span class="comment">//注意这里要两个条件，避免fast指向null时出错</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next == <span class="keyword">null</span>)</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//pre和slow同时开始遍历，判断是否是回文</span></span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.val != slow.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            pre = pre.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="两数相加">2 两数相加</h3>
<p><strong>题目描述</strong></p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储一位数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(max(m,n))：m、n分别为两个链表的长度</p>
<p>空间复杂度O(max(m,n))</p>
<p>直接采用模拟竖式加法的过程，新建一个虚拟头节点，然后同时遍历两个链表，从最低位至最高位，逐位相加，如果和大于等于 10，则保留个位数字，同时记录进位为 1留给下一轮相加。当某个链表为空时，补上0 。</p>
<p>注意不能将数字转为int相加，因为链表本身代表的数字有可能越界。</p>
<p>注意最后的进位如果不是0，要新建一个节点给它。</p>
<h2 id="section-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//记录进位</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 记录每一位相加</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tmp = vhead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            sum = (l1 == <span class="keyword">null</span>? <span class="number">0</span> : l1.val) + (l2 == <span class="keyword">null</span>? <span class="number">0</span> : l2.val) + carry;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            tmp.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)</span><br><span class="line">            tmp.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vhead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="排序链表">148 排序链表</h3>
<p><strong>题目描述</strong></p>
<p>给你链表的头结点 head ，请将其按升序排列并返回 排序后的链表 。要求在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(nlogn\)</span>)：归并排序</p>
<p>空间复杂度O(1)：不使用额外存储空间，仅改变链表指针的指向</p>
<p>时间复杂度是 O(<span class="math inline">\(nlogn\)</span>)的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(<span class="math inline">\(n^2\)</span>))），其中最适合链表的排序算法是归并排序。</p>
<p>归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(<span class="math inline">\(logn\)</span>)。如果要达到 O(1)的空间复杂度，则需要使用自底向上的实现方式。</p>
<p>所谓自底向上，就是将链表拆分成子链表进行合并。</p>
<p>第一轮子链表长度为1，归并第1、2节点，第3、4节点等；</p>
<p>第二轮子链表长度为2，归并第1-2、3-4节点、第5-6、7-8节点等；</p>
<p>第三轮子链表长度为4，归并第1-4、5-8节点、第9-12、13-16节点等。</p>
<p>直到子链表的长度等于整个链表的长度为止，停止归并。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/0.png" style="zoom: 33%;"></p>
<p>需要使用两个个子函数辅助实现：</p>
<p>1、<strong>断链操作</strong>，<code>split(l,n)</code> 即<strong>切掉</strong>链表l的前n个节点，并返回后半部分的链表头。注意，此时子链表中不一定有n个节点，或后半部分链表头不一定存在，这时候该函数返回null。</p>
<p>2、<strong>合并两个有序链表</strong>，这是一道经典题目，创建一个虚拟头并逐个比较。（递归法不满足空间复杂度要求）</p>
<p>算法的大致流程为：</p>
<p>1、依次将链表分成1块，2块，4块...</p>
<p>2、每次分割时，分别找到第一部分和第二部分数组的头节点，两个两个数组合并</p>
<p>3、用一个指针将前面的部分与排序好的部分连接</p>
<h2 id="section-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取链表的长度用于判断归并终止条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;              </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//split(l,n) 即切掉链表l的前n个节点，并返回后半部分的链表头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">split</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; tmp.next!= <span class="keyword">null</span>; i++)&#123; <span class="comment">//走n步刚好到达后半部分链表头，从1开始走n-1步则走到前一个节点（为了断链）</span></span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode right = tmp.next; <span class="comment">//返回后半部分的链表头</span></span><br><span class="line">        tmp.next = <span class="keyword">null</span>;<span class="comment">//断链操作</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并两个有序链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode h1, ListNode h2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = vhead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(h1 != <span class="keyword">null</span> &amp;&amp; h2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(h1.val &lt; h2.val)&#123;</span><br><span class="line">                p.next = h1;</span><br><span class="line">                h1 = h1.next;       </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = h2;</span><br><span class="line">                h2 = h2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p.next = h1 == <span class="keyword">null</span> ? h2 : h1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vhead.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = getLength(head);</span><br><span class="line">        <span class="comment">//新建虚拟头节点，该头节点的next指针永远指向链表的第一个位置</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt; len; step = step*<span class="number">2</span>)&#123; <span class="comment">//依次将链表分成1块，2块，4块...</span></span><br><span class="line">            </span><br><span class="line">            ListNode pre = dummy; <span class="comment">//每次迭代开始时pre都指向虚拟头节点，并用pre将排序好的链表串联起来</span></span><br><span class="line">            ListNode cur = dummy.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                ListNode h1 = cur;</span><br><span class="line">                ListNode h2 = split(h1, step); <span class="comment">//将第一部分数组切割，并返回第二部分数组头</span></span><br><span class="line">                cur = split(h2, step); <span class="comment">//将第二部分数组切割，将cur往后移动</span></span><br><span class="line">                </span><br><span class="line">                ListNode tmp = merge(h1, h2); <span class="comment">//合并两个排序链表</span></span><br><span class="line">                pre.next = tmp; <span class="comment">//用pre将排序链表串起来（首次执行时pre = dummy，则虚拟头永远可以指向链表头）</span></span><br><span class="line">                <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                  </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="合并k个升序链表">23 合并K个升序链表</h3>
<p><strong>题目描述</strong></p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例 1：</p>
<p>输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6] 将它们合并到一个有序链表中得到。 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(nlogk\)</span>)：循环遍历所有元素，并且每次堆的复杂度为<span class="math inline">\(logk\)</span></p>
<p>空间复杂度O(<span class="math inline">\(k\)</span>)：<span class="math inline">\(k\)</span>表示指针数组中指针元素的个数</p>
<p>设置一个最小堆，这个堆里面存储的是k个链表的指针，排序方式是按照指针指向的数字排序。每次将一个指针出堆，让该指针往后移动，并将后面的链表节点入堆（除非为null），如此重复直到堆中没有任何元素。</p>
<p>相当于我们需要准备一个「集合」，将所有链表的头结点放入「集合」，然后每次都从「集合」中挑出最小值，并将最小值的下一个节点添加进「集合」（如果有的话），循环这个过程，直到「集合」为空（说明所有节点都处理完，进过集合又从集合中出来）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立最小堆</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;( <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;   </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123; <span class="comment">//返回负数表示不需要交换1和2的位置</span></span><br><span class="line">                <span class="keyword">return</span> l1.val - l2.val;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        插曲：最大堆时，希望o1&gt;o2，但是o1-o2会是正数，这样会交换位置</span></span><br><span class="line"><span class="comment">        因此反过来用o2-o1，这样会得到负数，就不交换位置因此形成最大堆</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用链表数组中的元素初始化堆</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode h: lists)</span><br><span class="line">            <span class="keyword">if</span>(h != <span class="keyword">null</span>) heap.add(h);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建虚拟头节点</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tmp = vhead;</span><br><span class="line">        ListNode out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当堆不为空时，循环出入堆的操作</span></span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</span><br><span class="line">            </span><br><span class="line">            out = heap.remove();</span><br><span class="line">            tmp.next = out;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(out.next != <span class="keyword">null</span>)</span><br><span class="line">                heap.add(out.next);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vhead.next;</span><br><span class="line">               </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>LRU：https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/</p>
<p>回文链表：https://leetcode-cn.com/problems/palindrome-linked-list/solution/di-gui-zhan-deng-3chong-jie-jue-fang-shi-zui-hao-d/</p>
<p>两数相加：https://leetcode-cn.com/problems/add-two-numbers/solution/po-su-jie-fa-shao-bing-ji-qiao-by-ac_oie-etln/</p>
<p>排序链表：https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-di-gui-die-dai-xiang-jie-by-cherr/</p>
<p>https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/</p>
<p>https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/</p>
<p>合并K个升序链表：https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/shua-chuan-lc-you-xian-dui-lie-jie-fa-sh-3flb/</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="prev" title="LeetCode 字符串">
                  <i class="fa fa-chevron-left"></i> LeetCode 字符串
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="next" title="LeetCode 动态规划">
                  LeetCode 动态规划 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BIOINSu</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
