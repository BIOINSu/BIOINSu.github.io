<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/maze.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/maze.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/maze.png">
  <link rel="mask-icon" href="/images/maze.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="LeetCode中与动态规划有关的题目。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 动态规划">
<meta property="og:url" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="BIOINSu">
<meta property="og:description" content="LeetCode中与动态规划有关的题目。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/0.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/7.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/6.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/8.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/13.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/10.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/9.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/11.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/12.png">
<meta property="og:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/14.png">
<meta property="article:published_time" content="2021-09-14T03:35:34.137Z">
<meta property="article:modified_time" content="2021-09-14T03:36:39.829Z">
<meta property="article:author" content="BIOINSu">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/0.png">


<link rel="canonical" href="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>LeetCode 动态规划 | BIOINSu</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BIOINSu</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">1.</span> <span class="nav-text">5 最长回文子串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
class Solution &amp;#123;
    public String longestPalindrome(String s) &amp;#123;

        &#x2F;&#x2F;
        boolean [][] dp &#x3D; new boolean[s.length()][s.length()];
        
        &#x2F;&#x2F;对dp数组进行初始化，这里仅初始化对角线为true，只有一个字符必是回文
        &#x2F;&#x2F;因为dp[i][j]表示的是从i到j的字符，因此j不能小于等于i，所以对角线下的位置全为false
        for(int i &#x3D; 0; i &lt; s.length(); i++)
            dp[i][i] &#x3D; true;
        
        &#x2F;&#x2F;记录最长的回文子串的下标
        int left &#x3D; 0;
        int right &#x3D; 0;
        
        &#x2F;&#x2F;从右下角往上遍历，即对字符串来说从后往前判断
        for(int i &#x3D; s.length()-1; i &gt;&#x3D; 0; i--)&amp;#123;
            for(int j &#x3D; i+1; j &lt; s.length(); j++)&amp;#123;
                
                &#x2F;&#x2F;判断当前dp[i][j]是否是回文子串
                if(s.charAt(i) &#x3D;&#x3D; s.charAt(j))&amp;#123;
                    if(j-i&#x3D;&#x3D;1)&amp;#123;
                        dp[i][j] &#x3D; true;
                    &amp;#125;else&amp;#123;
                        dp[i][j] &#x3D; dp[i+1][j-1];
                    &amp;#125;
                    
                &amp;#125;else&amp;#123;
                    dp[i][j] &#x3D; false;
                &amp;#125;
                
                &#x2F;&#x2F;假如dp[i][j]是回文子串
                if(dp[i][j])&amp;#123;
                    &#x2F;&#x2F;判断是不是最长的
                    if( j - i &gt; right - left )&amp;#123;
                        left &#x3D; i;
                        right &#x3D; j;
                    &amp;#125;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        
        return s.substring(left,right+1); &#x2F;&#x2F;substring方法不包括结束索引，因此+1
    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">1.</span> <span class="nav-text">62 不同路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-1"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
class Solution &amp;#123;
    public int uniquePaths(int m, int n) &amp;#123;
        
        &#x2F;&#x2F;定义辅助数组
        int [][] dp &#x3D; new int [m][n];
        
        &#x2F;&#x2F;初始化矩阵第一行和第一列
        for(int i &#x3D; 0; i &lt; m; i++)
            dp[i][0] &#x3D; 1;
        for(int i &#x3D; 0; i &lt; n; i++)
            dp[0][i] &#x3D; 1;
        
        &#x2F;&#x2F;进行动态填充
        for(int i &#x3D; 1; i &lt; m; i++)&amp;#123;
            for(int j &#x3D; 1; j &lt; n; j++)
                dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];
        &amp;#125;
        
        &#x2F;&#x2F;返回存储的路径数量
        return dp[m-1][n-1];

    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">1.</span> <span class="nav-text">64 最小路径和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-2"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
import java.lang.Math;
class Solution &amp;#123;
    public int minPathSum(int[][] grid) &amp;#123;
        
        int rows &#x3D; grid.length;
        int cols &#x3D; grid[0].length;
        int [][] dp &#x3D; new int[rows][cols];
        
        &#x2F;&#x2F;初始化边界
        dp[0][0] &#x3D; grid[0][0];
        &#x2F;&#x2F;dp第一行就是grid中第一行值累加
        for(int i &#x3D; 1; i &lt; cols; i++)
            	dp[0][i] &#x3D; dp[0][i-1]+grid[0][i];
        
        &#x2F;&#x2F;dp第一列就是grid中第一列值累加
        for(int i &#x3D; 1; i &lt; rows; i++)
            	dp[i][0] &#x3D; dp[i-1][0]+grid[i][0];
        
        &#x2F;&#x2F;进行进行动态填充
        for(int i &#x3D; 1; i &lt; rows; i++)&amp;#123;
            for(int j &#x3D; 1; j &lt; cols; j++)
                dp[i][j] &#x3D; Math.min(dp[i-1][j], dp[i][j-1])+grid[i][j];
        &amp;#125;

        &#x2F;&#x2F;返回存储的最总和
        return dp[rows-1][cols-1];
    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">96 不同的二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-3"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
class Solution &amp;#123;
    public int numTrees(int n) &amp;#123;
        
        if(n &lt;&#x3D; 1)
            return n;
		
        int[] dp &#x3D; new int[n+1];
        
        dp[0] &#x3D; 1;
        dp[1] &#x3D; 1;
        
        
        for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&amp;#123;
            for(int j &#x3D; 1; j &lt;&#x3D; i; j++) &#x2F;&#x2F;注意，这里j不能超过i
                &#x2F;&#x2F;本质上，这里就是遍历1:i中，将每个数当作根节点建树的情况
                dp[i] &#x3D; dp[i] + dp[j-1]*dp[i-j];
        &amp;#125;
        
        return dp[n];
    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">1.</span> <span class="nav-text">139 单词拆分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-4"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
class Solution &amp;#123;
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &amp;#123;
        
        &#x2F;&#x2F;声明dp数组,dp[i]表示字符串s[0:i-1]是否能被拆分
        boolean [] dp &#x3D; new boolean [s.length()+1];
        
        &#x2F;&#x2F;边界条件
        dp[0] &#x3D; true;
        
        &#x2F;&#x2F;进行动态填充，i实际上表示s[0:i-1]
        for(int i &#x3D; 1; i &lt;&#x3D; s.length(); i++ )&amp;#123;            
            for(int j &#x3D; 0; j &lt;&#x3D; i-1; j++)&amp;#123;&#x2F;&#x2F;j是在字符串当中遍历的，由于s[0:i-1]，所以只能取到i-1 
                if( dp[j] &amp;&amp; wordDict.contains(s.substring(j,i)) )&amp;#123; &#x2F;&#x2F;注意substring不能取到i
                    dp[i] &#x3D; true;
                    break;
                &amp;#125;
            &amp;#125;
        &amp;#125;
        
        return dp[s.length()];

    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">152 乘积最大子数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-5"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
import java.lang.Math;
class Solution &amp;#123;
    public int maxProduct(int[] nums) &amp;#123;
        
        int max &#x3D; 1;
        int min &#x3D; 1;
        int res &#x3D; Integer.MIN_VALUE;
        
        for(int i &#x3D; 0; i &lt; nums.length; i++)&amp;#123;
            
            &#x2F;&#x2F;若是负数，交换最大最小值
            if(nums[i] &lt; 0)&amp;#123;
                int tmp &#x3D; max;
                max &#x3D; min;
                min &#x3D; tmp;
            &amp;#125;
            
            max &#x3D; Math.max(max*nums[i], nums[i]);
            min &#x3D; Math.min(min*nums[i], nums[i]);
            
            res &#x3D; Math.max(res, max);
        &amp;#125;
        
        return res;
    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">1.</span> <span class="nav-text">198 打家劫舍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-6"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
import java.lang.Math;
class Solution &amp;#123;
    public int rob(int[] nums) &amp;#123;
        
        if(nums.length &#x3D;&#x3D; 0)
            return 0;
        
        &#x2F;&#x2F;dp[i]，表示到array[i]时偷盗总和的最大值。
        int [] dp &#x3D; new int[nums.length+1];
        
        &#x2F;&#x2F;涉及到i-2，因此需要dp[0]
        dp[0] &#x3D; 0;
        dp[1] &#x3D; nums[0];
        
        &#x2F;&#x2F;动态填充数组
        for(int i &#x3D; 2; i &lt;&#x3D; nums.length; i++)&amp;#123;
            dp[i] &#x3D; Math.max( dp[i-1], dp[i-2]+nums[i-1]);
        &amp;#125;
        
        &#x2F;&#x2F;返回最大总和
        return dp[nums.length];
    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">1.</span> <span class="nav-text">221 最大正方形</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-7"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
import java.lang.Math;
class Solution &amp;#123;
    public int maximalSquare(char[][] matrix) &amp;#123; &#x2F;&#x2F;注意这里给的是char数组！不是整形数组
        
        int m_row &#x3D; matrix.length;
        int m_col &#x3D; matrix[0].length;
        
        &#x2F;&#x2F;定义二维整形数组dp[i][j]，表示以（i，j）为右下角节点的最大正方形边长
        int [][] dp &#x3D; new int[m_row][m_col];
        
        &#x2F;&#x2F;记录最长边长
        int max_len &#x3D; 0;
        
        &#x2F;&#x2F;初始化矩阵边界，注意在这里就要记录最长边长！
        for(int i &#x3D; 0; i &lt; m_row; i++)&amp;#123;
            dp[i][0] &#x3D; matrix[i][0] - &amp;#x27;0&amp;#x27;;
            max_len &#x3D; Math.max(max_len, dp[i][0]);
        &amp;#125;
        for(int i &#x3D; 0; i &lt; m_col; i++)&amp;#123;
            dp[0][i] &#x3D; matrix[0][i] - &amp;#x27;0&amp;#x27;;
            max_len &#x3D; Math.max(max_len, dp[0][i]);
        &amp;#125;
        
        &#x2F;&#x2F;填充数组
        for(int i &#x3D; 1; i &lt; m_row; i++)&amp;#123;
            for(int j &#x3D; 1; j &lt; m_col; j++)&amp;#123;
                if(matrix[i][j] &#x3D;&#x3D; &amp;#x27;0&amp;#x27;) &#x2F;&#x2F;如果当前位置是0，无论如何都不能形成正方形
                    dp[i][j] &#x3D; 0;
                else &#x2F;&#x2F;否则，朝三个方向，找到能形成正方形的最短边长（只要三个方向有一个是0都不能形成正方形）
                	dp[i][j] &#x3D; Math.min( dp[i-1][j-1], Math.min( dp[i-1][j], dp[i][j-1] ) ) + 1;
                
                &#x2F;&#x2F;记录最长的边长
                max_len &#x3D; Math.max(max_len, dp[i][j]);
            &amp;#125;
        &amp;#125;

        return max_len*max_len;
    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">279 完全平方数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-8"><span class="nav-number"></span> <span class="nav-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
import java.lang.Math;
class Solution &amp;#123;
    public int numSquares(int n) &amp;#123;
        
        &#x2F;&#x2F;定义一维整型数组，让dp[i]刚好和数字i对应，代表能够被分解的最小个数
        int [] dp &#x3D; new int[n+1];
        
        for(int i &#x3D; 0; i &lt;&#x3D; n; i++)
            dp[i] &#x3D; Integer.MAX_VALUE;
        
        &#x2F;&#x2F;
        dp[0] &#x3D; 0;
        dp[1] &#x3D; 1;
        
        for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&amp;#123;
            for(int j &#x3D; 1; j*j &lt;&#x3D; i; j++)&amp;#123; &#x2F;&#x2F;注意这里是 &lt;&#x3D; i，刚好等于i的时候可以被分解！
                &#x2F;&#x2F;这里本质上就是将i拆分成多个完全平方数，并利用之前的结果
                dp[i] &#x3D; Math.min( dp[i], dp[ i - j*j ] + 1 );
            &amp;#125;
        &amp;#125;
        
        return dp[n];
    &amp;#125;
&amp;#125;
</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.</span> <span class="nav-text">300 最长递增子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="nav-number">2.</span> <span class="nav-text">309 最佳买卖股票时机含冷冻期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">3.</span> <span class="nav-text">322 零钱兑换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text">1143 最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%E6%9D%A5%E6%BA%90"><span class="nav-number">5.</span> <span class="nav-text">题解来源</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">BIOINSu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/BIOINSu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BIOINSu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="BIOINSu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BIOINSu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode 动态规划
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-09-14 11:35:34 / 修改时间：11:36:39" itemprop="dateCreated datePublished" datetime="2021-09-14T11:35:34+08:00">2021-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>LeetCode中与动态规划有关的题目。</p>
<a id="more"></a>
<h3 id="最长回文子串">5 最长回文子串</h3>
<p><strong>题目描述</strong></p>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>示例 1：</p>
<p>输入：s = "babad" 输出："bab" 解释："aba" 同样是符合题意的答案。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：每个字符都要往后判断是否是回文串</p>
<p>空间复杂度O(<span class="math inline">\(n^2\)</span>)：二维dp数组</p>
<p>定义二维布尔数组dp[i][j]数组表示：字符串s[i⋯j]是否为回文子串，如果是，dp[i][j] = true，如果不是，dp[i][j] = false。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/0.png" style="zoom: 33%;"></p>
<p>首先需要寻找递推关系，如上图所示，如果现在已经知道了dp[i+1][j-1]了，那我们如何计算dp[i][j]呢？通过观察，我们发现：</p>
<ul>
<li>如果s[i] == s[j]那么说明只要<span class="math inline">\(dp[i+1][j-1]\)</span>是回文子串，那么是dp[i][j]也就是回文子串。</li>
<li>如果<span class="math inline">\(s[i]\ne s[j]\)</span>s[i] 那么说明dp[i][j]必定不是回文子串。</li>
</ul>
<p>接着需要寻找边界条件，由定义可知，i必须要在j的前面，且当i和j相同时，即只有一个字符时是回文字串，因此可以得到dp数组中，对角线处为true，对角线下方为fasle。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.png" style="zoom:50%;"></p>
<p>又由递推关系可以知道当前dp[i][j]和<span class="math inline">\(dp[i+1][j-1]\)</span>有关，因此数组是从下往上遍历，即对字符串来说从后往前判断。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.png" style="zoom:50%;"></p>
<p>注意递推式中假如i和j是相邻的两个字符，那么就没有i+1和j-1的比较，直接进行判断即可。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.png" style="zoom: 50%;"></p>
<p>最后，因为dp数组仅仅记录的是是否是回文串，因此需要用另外的变量记录长度。</p>
<h2 id="section"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> [][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对dp数组进行初始化，这里仅初始化对角线为true，只有一个字符必是回文</span></span><br><span class="line">        <span class="comment">//因为dp[i][j]表示的是从i到j的字符，因此j不能小于等于i，所以对角线下的位置全为false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录最长的回文子串的下标</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从右下角往上遍历，即对字符串来说从后往前判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断当前dp[i][j]是否是回文子串</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i==<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//假如dp[i][j]是回文子串</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                    <span class="comment">//判断是不是最长的</span></span><br><span class="line">                    <span class="keyword">if</span>( j - i &gt; right - left )&#123;</span><br><span class="line">                        left = i;</span><br><span class="line">                        right = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>); <span class="comment">//substring方法不包括结束索引，因此+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="不同路径">62 不同路径</h3>
<p><strong>题目描述</strong></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例：</p>
<p>输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向下</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(mn\)</span>)：每个位置都进行填充</p>
<p>空间复杂度O(<span class="math inline">\(mn\)</span>)：二维dp数组，可以优化为O(<span class="math inline">\(m\)</span>)（每次只由左边和上边值决定，上边的值就是当前存储的值，代表上一轮）</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.png" style="zoom: 50%;"></p>
<p>定义二维整型dp[i][j]数组表示坐标为（i，j）的点共有多少种不同的路径。</p>
<p>由于每次只能向右或者向下一步，因此有递推式：dp[i][j] = dp[i-1][j] + dp[i][j-1]。</p>
<p>接着寻找边界条件，由于每次只能向右或向下，因此矩阵第一行和第一列都只能拥有一种走法，则统一初始化为1。</p>
<p>递归会超时！除非把计算过的值使用一个map存储起来，用的时候先查看是否计算过，如果计算过就直接拿来用。</p>
<h2 id="section-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义辅助数组</span></span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化矩阵第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行动态填充</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回存储的路径数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="最小路径和">64 最小路径和</h3>
<p><strong>题目描述</strong></p>
<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(mn\)</span>)：每个位置都进行填充</p>
<p>空间复杂度O(<span class="math inline">\(mn\)</span>)：二维dp数组，可以优化为O(<span class="math inline">\(m\)</span>)（每次只由左边和上边值决定，上边的值就是当前存储的值，代表上一轮）</p>
<p>定义二维整型dp[i][j]数组表示坐标为（i，j）的点，<strong>从左上角到这个位置，路径上的数字总和的最小值</strong>。</p>
<p>因为每次只能向右或向下走，因此可以得到递推式：<span class="math inline">\(dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1])+grid[i][j];\)</span></p>
<p>表示当前位置的最小总和，由左边或上边小的那个总和，再加上当前位置的矩阵值所得。</p>
<p>接着寻找边界条件，由于每次只能向右或向下，因此矩阵第一行和第一列都只能是其前面数值的累加，因此对其初始化。</p>
<h2 id="section-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//dp第一行就是grid中第一行值累加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cols; i++)</span><br><span class="line">            	dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dp第一列就是grid中第一列值累加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)</span><br><span class="line">            	dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行进行动态填充</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++)</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回存储的最总和</span></span><br><span class="line">        <span class="keyword">return</span> dp[rows-<span class="number">1</span>][cols-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="不同的二叉搜索树">96 不同的二叉搜索树</h3>
<p>题目描述</p>
<p>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p>输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<blockquote>
<p>1 3 3 2 1   / / /  <br>
3 2 1 1 3 2 / /  <br>
2 1 2 3</p>
</blockquote>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：<span class="math inline">\([0,i]\)</span>中，每个数字都当作根节点建树</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一维dp数组</p>
<p>定义一维整形数组<span class="math inline">\(dp[i]\)</span>表示有i个节点的二叉搜索树有多少种。</p>
<p>对于<span class="math inline">\([0,i]\)</span>中的某个数k，以<span class="math inline">\(k\)</span>为节点的二叉搜索树的种类 <span class="math inline">\(f(k) = dp[k-1]*dp[i-k]\)</span> ，即左子树的数量乘上右子树的数量，将以k为节点的二叉搜索树的种类用k-1和i-k个节点的二叉搜索树表示。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.png" style="zoom:67%;"></p>
<p>那么<span class="math inline">\(dp[i] = f(1)+f(2)+...f(i) = dp[0]*dp[i-1] + dp[1]*dp[i-2] + ... dp[i-1]*dp[0]\)</span></p>
<p>因此得到递推式，这是<strong>卡特兰数</strong>公式。</p>
<p>接着判断边界条件，由于可以存在某棵子树为空的情况，因此dp[0] = 1，同时dp[1] = 1。</p>
<h2 id="section-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) <span class="comment">//注意，这里j不能超过i</span></span><br><span class="line">                <span class="comment">//本质上，这里就是遍历1:i中，将每个数当作根节点建树的情况</span></span><br><span class="line">                dp[i] = dp[i] + dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="单词拆分">139 单词拆分</h3>
<p><strong>题目描述</strong></p>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。</p>
<p>示例 1：</p>
<p>输入: s = "leetcode", wordDict = ["leet", "code"] 输出: true 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：<span class="math inline">\([0,n]\)</span>中，每个字符分成两半进行判断</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一维dp数组</p>
<p>定义一维布尔型数组dp[i]，表示长度为i的s[0:i-1]子串是否能拆分成单词。题目要我们求dp[s.length] 。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/7.png" style="zoom:50%;"></p>
<p>思考状态转移方程，s[0:i-1]子串是否能拆分成单词和i之前是否能拆分为单词的关系，用指针 j 去划分s[0:i] 子串，如下图：</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/6.png" style="zoom:50%;"></p>
<p>s[0:i] 子串的 dp[i+1] ，是否为真（是否可拆分成单词），取决于两点：</p>
<ul>
<li>它的<strong>前缀子串 s[0:j-1] 的 dp[j] ，是否为真</strong>。</li>
<li><strong>剩余子串 s[j:i]，是否是单个单词</strong>，即是否在wordDict中存在。</li>
</ul>
<p>则可以得到状态转移方程：<strong>dp[i] = dp[j] &amp;&amp; check(word[i,j] in wordDict)</strong>，只要任意一个j满足条件即可</p>
<p>接着判断边界条件，dp[0]需要等于true，因为由上图可知，当j从0开始时，右边的word如果在wordDict中存在也是可以满足条件的。</p>
<p>常见误区1：使用双指针</p>
<p>使用双指针left，right按顺序遍历字符串的子串，如果[left,right]之间子串在字典中，那么，以该子串之后的第一个位置作为下一个子串的开始，同样，遍历下一个子串，直到right到达s的末尾。但是这样是错误的，考虑s='leetcode'，假如wordDict = ['leet'，'leetcode']，如果我们先遍历到leet子串，剩余部分是code，字典中没有，就认为该单词无法拆分，实际上wordDict直接就有leetcode，显然，这种策略是不正确的。 为了避免上述这种字典中存在长的能覆盖短的情形，让right从字符串右端开始向左滑动，以保证最长的拆分子串以及最少的拆分次数。那么，right从后面开始遍历就对了么，事实上，也是不对的，考虑s='abcd'，假如wordDict = ["a","abc","b","cd"]，right从后边开始，我们先找到了abc，剩余的d就没有匹配的了，然而，我们是可以按照a+b+cd的组合匹配的，于是，right不管从头部还是从尾部开始，我们都无法解决问题，双指针是不行的。</p>
<p>常见误区2：使用递归</p>
<p>超时</p>
<h2 id="section-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//声明dp数组,dp[i]表示字符串s[0:i-1]是否能被拆分</span></span><br><span class="line">        <span class="keyword">boolean</span> [] dp = <span class="keyword">new</span> <span class="keyword">boolean</span> [s.length()+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行动态填充，i实际上表示s[0:i-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++ )&#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i-<span class="number">1</span>; j++)&#123;<span class="comment">//j是在字符串当中遍历的，由于s[0:i-1]，所以只能取到i-1 </span></span><br><span class="line">                <span class="keyword">if</span>( dp[j] &amp;&amp; wordDict.contains(s.substring(j,i)) )&#123; <span class="comment">//注意substring不能取到i</span></span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="乘积最大子数组">152 乘积最大子数组</h3>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>示例 1:</p>
<p>输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：只遍历一遍数组，记录最大和最小乘积</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一维dp数组，也可以优化为O(1)，由递推式可知当前值只与前一个值有关</p>
<p>这道题和<strong>连续子数组的最大和</strong>非常类似，</p>
<p><strong>定义一维整型数组dp[i]，表示以元素 array[i] 为结尾的连续子数组最大乘积</strong>。</p>
<p>思考状态转移方程，因为是整数数组，有正负之分，假如dp[i-1]表示以元素 array[i-1] 为结尾的连续子数组最大乘积，那么当array[i]为负数时，dp[i-1] * array[i]就会变成最小乘积，此时若 dp数组内保存的是连续最小乘积，则<strong>乘上负数就会变成最大乘积</strong>。</p>
<p>因此本质上需要维护两个dp数组，分别表示以元素 array[i] 为结尾的连续子数组<strong>最大和最小乘积</strong>。</p>
<p>dp_max[i] = Math.max( dp_max[i-1]*array[i]，array[i] )</p>
<p>dp_min[i] = Math.min( dp_min[i-1]*array[i]，array[i] )</p>
<p>当array[i]为负数时，首先<strong>swap( dp_max[i-1]， dp_min[i-1])</strong>，然后再乘上array[i]进行比较。</p>
<h2 id="section-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//若是负数，交换最大最小值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = max;</span><br><span class="line">                max = min;</span><br><span class="line">                min = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            max = Math.max(max*nums[i], nums[i]);</span><br><span class="line">            min = Math.min(min*nums[i], nums[i]);</span><br><span class="line">            </span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="打家劫舍">198 打家劫舍</h3>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：只遍历一遍数组，记录最大和</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一维dp数组，也可以优化为O(1)，由递推式可知当前值只与前两个值有关，相当于斐波那契数列</p>
<p>本题很容易想到纯奇数的和与纯偶数的和，并比较它们的大小，但这样会存在问题，如下所示：</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/8.png" style="zoom: 50%;"></p>
<p>偷[0]、[2]时的总和为2。偷[1]、[3]时总和为6，偷了[3]就不能偷[4]。</p>
<p>但是假如只偷[1]和[4]总和为103，就比偷[0]、[2]、[4]的总和102要高，这是因为[0]、[1]、[2]时，奇数的总和已经超过了偶数的总和，所以奇数和即使不需要加上[3]也已经超过偶数和。</p>
<p>因此，需要定义一维整形数组dp[i]，表示到array[i]时偷盗总和的最大值。</p>
<p>思考递推式，<strong>dp[i] = Math.max( dp[i-1]，dp[i-2]+ array[i]</strong>。即要么一直偷到i-1房间，不偷i房间，要么偷到i-2房间，且偷i房间。</p>
<p>由于涉及到 i-2，因此令dp[i]表示array[i-1]的情况，这样i从1开始，就可以表示array[0]。</p>
<p>因此dp[0] = 0，dp[1] = array[0]。</p>
<h2 id="section-6"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dp[i]，表示到array[i]时偷盗总和的最大值。</span></span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//涉及到i-2，因此需要dp[0]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//动态填充数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            dp[i] = Math.max( dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回最大总和</span></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="最大正方形">221 最大正方形</h3>
<p><strong>题目描述</strong></p>
<p>在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/13.png" style="zoom:33%;"></p>
<p>输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]] 输出：4</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(mn\)</span>)：</p>
<p>空间复杂度O($ mn$)：</p>
<p>暴力的方法就是找到每个由1组成的正方形，求出所有的面积，比较后拿出最大的。其实这个过程中存在重复的子问题。当知道子正方形的情况时，可以避免大量重复计算。</p>
<p>对矩阵中的某个点（i，j）来说，以（i，j）为正方形右下角节点，考虑它能组成多大的正方形，则它只能朝着左上角扩展。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/10.png" style="zoom:50%;"></p>
<p>这时可以发现，如果以（i，j）为右下角节点向左上角扩展正方形，那么必然会涉及到红、绿、蓝这三个方向的正方形。此时思考究竟能够扩展到多大的位置？可以发现，<strong>能够扩展的长度，是红绿蓝这三个正方形的最短边长</strong>。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/9.png" style="zoom: 67%;"></p>
<p>定义二维整形数组dp[i][j]，表示以（i，j）为右下角节点的最大正方形边长，则可以得到递推式：</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/11.png" style="zoom:67%;"></p>
<p>其中： dp[i-1][j-1]表示<strong>绿色</strong>的正方形的方向</p>
<p>dp[i-1][j]表示<strong>红色</strong>的正方形</p>
<p>dp[i][j-1]表示<strong>蓝色</strong>的正方形</p>
<p>然后，定义边界条件，矩阵中，第一行和第一列的点，以他们为右下角节点的最大正方形边长，如果它们本身是1，则可以组成一个最小正方形，否则它们是0，则不能组成正方形，其边长是1。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/12.png" style="zoom: 50%;"></p>
<h2 id="section-7"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123; <span class="comment">//注意这里给的是char数组！不是整形数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m_row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> m_col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义二维整形数组dp[i][j]，表示以（i，j）为右下角节点的最大正方形边长</span></span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m_row][m_col];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录最长边长</span></span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化矩阵边界，注意在这里就要记录最长边长！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_row; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            max_len = Math.max(max_len, dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_col; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            max_len = Math.max(max_len, dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//填充数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m_row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m_col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="comment">//如果当前位置是0，无论如何都不能形成正方形</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//否则，朝三个方向，找到能形成正方形的最短边长（只要三个方向有一个是0都不能形成正方形）</span></span><br><span class="line">                	dp[i][j] = Math.min( dp[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min( dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>] ) ) + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//记录最长的边长</span></span><br><span class="line">                max_len = Math.max(max_len, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len*max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="完全平方数">279 完全平方数</h3>
<p><strong>题目描述</strong></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>示例 1：</p>
<p>输入：n = 12 输出：3 解释：12 = 4 + 4 + 4</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：</p>
<p>空间复杂度O($ n$)：</p>
<p>解法一 回溯法 相当于一种暴力的方法，去考虑所有的分解方案，找出最小的解，举个例子。</p>
<blockquote>
<p>n = 12 先把 n 减去一个平方数，然后求剩下的数分解成平方数和所需的最小个数</p>
<p>把 n 减去 4, 然后求出 8 分解成平方数和所需的最小个数,记做 n2 那么当前方案总共需要 n2 + 1 个平方数</p>
<p>把 n 减去 9, 然后求出 3 分解成平方数和所需的最小个数,记做 n3 那么当前方案总共需要 n3 + 1 个平方数</p>
<p>下一个平方数是 16, 大于 12, 不能再分了。</p>
<p>接下来我们只需要从 (n1 + 1), (n2 + 1), (n3 + 1) 三种方案中选择最小的个数, 此时就是 12 分解成平方数和所需的最小个数了</p>
<p>至于求 11、8、3 分解成最小平方数和所需的最小个数继续用上边的方法去求</p>
<p>直到如果求 0 分解成最小平方数的和的个数, 返回 0 即可</p>
</blockquote>
<p>代码的话，就是回溯的写法，或者说是 DFS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numSquaresHelper(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numSquaresHelper</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里很巧妙的一点是，假如最终这个数不能分解为完全平方数的和，就返回MAX_VALUE</span></span><br><span class="line">    <span class="keyword">int</span> count = Integer.MAX_VALUE; </span><br><span class="line">    <span class="comment">//依次减去一个平方数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//选最小的</span></span><br><span class="line">        count = Math.min(count, numSquaresHelper(n - i * i) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然上边的会造成超时，很多解会重复的计算，之前也遇到很多这种情况了。需要 memoization 技术，也就是把过程中的解利用 HashMap 全部保存起来即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numSquaresHelper(n, <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numSquaresHelper</span><span class="params">(<span class="keyword">int</span> n, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        count = Math.min(count, numSquaresHelper(n - i * i, map) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(n, count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，转换为动态规划的解法也是相同的。</p>
<p>定义一维整型数组dp[i]，表示给定正整数i，它能够被分解为完全平方数时，这些数最少的数量，并将它初始化为正无穷。</p>
<p>思考递推式，令 j 从 1：i，且 j^2&lt;=i（注意等号！） ，则 dp[i] = Math.min( dp[i]，dp[i-j^2]+1）</p>
<p>思考边界条件，让dp的下标和整数数字刚好对应，因此dp的大小为 i + 1。</p>
<h2 id="section-8"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义一维整型数组，让dp[i]刚好和数字i对应，代表能够被分解的最小个数</span></span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j*j &lt;= i; j++)&#123; <span class="comment">//注意这里是 &lt;= i，刚好等于i的时候可以被分解！</span></span><br><span class="line">                <span class="comment">//这里本质上就是将i拆分成多个完全平方数，并利用之前的结果</span></span><br><span class="line">                dp[i] = Math.min( dp[i], dp[ i - j*j ] + <span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2>
<h3 id="最长递增子序列">300 最长递增子序列</h3>
<p><strong>题目描述</strong></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<p>输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：</p>
<p>空间复杂度O($ n$)：</p>
<p>这道题和<strong>连续子数组的最大和、乘积最大子数组</strong>非常类似，</p>
<p><strong>定义一维整型数组dp[i]，表示以元素 array[i] 为结尾的最长递增子序列的长度</strong>。</p>
<p>思考状态转移方程，此时要判断 array[i] 和之前的数字的关系，可以发现，假如 array[i] &gt; array[j]，j &lt; i，那么它可以扩展以array[j]为结尾的最长递增子序列的长度。因此可以得到状态转移方程：dp[i] = Math.max( dp[i]，dp[j] +1 )。</p>
<p>边界条件，可以发现dp[i]只和前面的数字大小有关，因此dp数组的长度和子序列长度一样即可。</p>
<p><strong>注意所有位置都初始化为1！</strong>因为其本身就可以构成1个递增子序列！如果不是1则会导致最后结果少1 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义一维整型数组dp[i]，表示以元素 array[i] 为结尾的最长递增子序列的长度</span></span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义边界条件，所有位置都初始化为1！因为其本身就可以构成1个递增子序列！</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历每一个数字，判断和前面所有数字的大小关系看是否能够构成子序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max( dp[i], dp[j]+<span class="number">1</span> );</span><br><span class="line">                    res = Math.max( res, dp[i]);</span><br><span class="line">                &#125;                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分查找法见题解。纸牌游戏。注意如果牌能够比堆顶元素小，则在数组中就直接覆盖掉堆顶元素。</p>
<hr>
<h3 id="最佳买卖股票时机含冷冻期">309 最佳买卖股票时机含冷冻期</h3>
<p><strong>题目描述</strong></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例:</p>
<p>输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<p><strong>题解</strong></p>
<p>最开始可能考虑的是一维dp数组，但是发现令dp[i]表示到第i天为止所得的最大利润时，考虑array[i]中的值和之前值的关系，发现它取决于是否买入和是否卖出等多种状态，因此需要定义二维数组分别表示这些状态。</p>
<p><strong>令二维整型数组dp[i][j]表示第i天在第j种状态下，到目前为止所得利润的最大值。</strong>j有三种状态，在三种状态下分别讨论和之前array中值的关系：</p>
<ul>
<li><p>dp[i][0]：不持股，且今天没卖出</p>
<p>则对于前一天来说，可能不持股且当天卖出了，或者前一天同样不持股。</p>
<p>dp[i][0] = Math.max( dp[i-1][2], dp[i-1][0] )</p></li>
<li><p>dp[i][1]：持股</p>
<p>则对于前一天来说，可能是之前就买了股票，也就是一直都是持股的。或者是今天刚刚买入的，但是今天刚买入的话，前一天必须是不持股且没有卖出的（因为存在冷冻期），因此是第一种状态；并且买入后利润减少。</p>
<p>dp[i][1] = Math.max( dp[i-1][1], dp[i-1][0] - array[i] )</p></li>
<li><p>dp[i][2]：不持股，且当天卖出</p>
<p>则对于前一天来说，它必须是持股的，且今天卖出后利润增加。</p>
<p>dp[i][2] = dp[i-1][1] + array[i]</p></li>
</ul>
<p>则边界条件为第0天的时候：</p>
<p>dp[0][0] = 0</p>
<p>dp[0][1] = -array[0]：表示第0天的时候已经是买入状态</p>
<p>dp[0][2] = 0</p>
<p>注意，不用计算买入和卖出的差值，直接将价格从利润中减去即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理为空的输入情况</span></span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//三种状态分别考虑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max( dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>] );</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max( dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i][<span class="number">1</span>] + prices[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max( dp[prices.length-<span class="number">1</span>][<span class="number">0</span>], Math.max( dp[prices.length-<span class="number">1</span>][<span class="number">1</span>], dp[prices.length-<span class="number">1</span>][<span class="number">2</span>] ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="零钱兑换">322 零钱兑换</h3>
<p><strong>题目描述</strong></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1</p>
</blockquote>
<p><strong>题解</strong></p>
<p>最原始的方法是进行递归，对于amount，每次都减去coins中的所有数字，然后判断是否为0，这样一直到底即可。</p>
<p>但是这样可以发现，随着amount逐渐变小，中间有些数字会被重复计算，比如 11 -1 -2 和 11 -2 -1 是相同的结果。</p>
<p>因此存在含有重叠的子问题，这时候考虑动态规划。</p>
<p><strong>令一维整型数组dp[i]表示在金额为 amount = i 时的最少的硬币个数。</strong></p>
<p>考虑 dp[i] 和 之前状态的关系，可以发现对于金额为 i 的时候，<strong>考虑每一个coins是否能够组合成当前金额 i</strong> 。</p>
<p>dp[i] = Math.min( dp[i], dp[ i - coins[j] ] + 1 )</p>
<p>则边界条件为当金额为0的时候，使用的硬币个数也为0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(coins.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//因为下面要用min来比较，所以这里取最大值</span></span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;coins.length; j++)&#123;</span><br><span class="line">            	<span class="keyword">if</span>( (i-coins[j]&gt;=<span class="number">0</span>) &amp;&amp; dp[ i-coins[j] ] != Integer.MAX_VALUE ) <span class="comment">//防止前一个位置是无法组成的情况</span></span><br><span class="line">                    dp[i] = Math.min( dp[i], dp[ i-coins[j] ]+<span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是无法组成的情况就返回-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列">1143 最长公共子序列</h3>
<p><strong>题目描述</strong></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>示例 1:</p>
<p>输入：text1 = "abcde", text2 = "ace" 输出：3<br>
解释：最长公共子序列是 "ace"，它的长度为 3。</p>
<p><strong>题解</strong></p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/14.png" style="zoom:50%;"></p>
<p><strong>定义二维整型数组dp[i][j]：表示长度为 [0, i - 1] 的字符串 text1 与长度为 [0, j - 1] 的字符串 text2 的最长公共子序列为 dp[i][j]。</strong></p>
<p>则思考状态转移方程：</p>
<ol type="1">
<li><p>若当前字符相同，则找到了一个公共元素，最长公共子序列长度可以往后推进：dp[i][j] = dp[i-1][j-1] + 1</p></li>
<li><p>若当前字符不同，则没有公共元素，最长公共子序列长度为text1或text2回退一个字符时的最大值：</p></li>
</ol>
<p>dp[i][j] = Math.max( dp[i - 1][j], dp[i][j - 1] )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>最长回文子串：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua-jie-/</p>
<p>不同路径：https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-di-gui-gong-shi-deng-3z-9mp1/</p>
<p>不同的二叉搜索树：https://leetcode-cn.com/problems/unique-binary-search-trees/solution/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/</p>
<p>单词拆分：https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/</p>
<p>https://leetcode-cn.com/problems/word-break/solution/wu-qu-chan-shu-by-tinylife/</p>
<p>打家劫舍：https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-ikaruga/</p>
<p>https://leetcode-cn.com/problems/house-robber/solution/hua-jie-suan-fa-198-da-jia-jie-she-by-guanpengchn/</p>
<p>最大正方形：https://leetcode-cn.com/problems/maximal-square/solution/221-zui-da-zheng-fang-xing-tu-jie-shi-pin-yan-shi-/</p>
<p>完全平方数：https://leetcode-cn.com/problems/perfect-squares/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--51/</p>
<p>最长递增子序列：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/</p>
<p>最佳买卖股票时机含冷冻期：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</p>
<p>零钱兑换：https://leetcode-cn.com/problems/coin-change/solution/javadi-gui-ji-yi-hua-sou-suo-dong-tai-gui-hua-by-s/</p>
<p>最长公共子序列：</p>
<p>https://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-dong-tai-g-fhyd/</p>
<p>https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-tu-wen-jie-xi-by-yijiaoqian/</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/" rel="prev" title="LeetCode 链表">
                  <i class="fa fa-chevron-left"></i> LeetCode 链表
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E6%95%B0%E7%BB%84/" rel="next" title="LeetCode 数组">
                  LeetCode 数组 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BIOINSu</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
