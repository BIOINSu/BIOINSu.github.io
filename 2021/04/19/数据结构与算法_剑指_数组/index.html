<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/maze.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/maze.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/maze.png">
  <link rel="mask-icon" href="/images/maze.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="剑指Offer中关于数组的题目解析。">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer 数组">
<meta property="og:url" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="BIOINSu">
<meta property="og:description" content="剑指Offer中关于数组的题目解析。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/0.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/1.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/2.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/3.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/4.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/5.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/6.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/7.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/8.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/9.png">
<meta property="og:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/10.png">
<meta property="article:published_time" content="2021-04-19T01:51:06.275Z">
<meta property="article:modified_time" content="2021-04-19T01:55:07.308Z">
<meta property="article:author" content="BIOINSu">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="剑指Offer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/0.png">


<link rel="canonical" href="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>剑指Offer 数组 | BIOINSu</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">BIOINSu</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">1.</span> <span class="nav-text">01 斐波那契数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">2.</span> <span class="nav-text">02 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">03 构建乘积数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">04 数字在排序数组中出现的次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number">5.</span> <span class="nav-text">05 和为S的两个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">6.</span> <span class="nav-text">06 数组中重复的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">7.</span> <span class="nav-text">07 二维数组中的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="nav-number">8.</span> <span class="nav-text">08 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">9.</span> <span class="nav-text">09 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">10 把数组排成最小的数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">11.</span> <span class="nav-text">11 机器人的运动范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">12.</span> <span class="nav-text">12 数组中的逆序对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">13.</span> <span class="nav-text">013 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">14.</span> <span class="nav-text">014 连续子数组的最大和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E5%8F%8A2"><span class="nav-number">15.</span> <span class="nav-text">015 数组中只出现一次的数字（及2）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-number">16.</span> <span class="nav-text">016 和为s的连续正数序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%E6%9D%A5%E6%BA%90"><span class="nav-number">17.</span> <span class="nav-text">题解来源</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">BIOINSu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/BIOINSu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BIOINSu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="BIOINSu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BIOINSu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剑指Offer 数组
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-19 09:51:06 / 修改时间：09:55:07" itemprop="dateCreated datePublished" datetime="2021-04-19T09:51:06+08:00">2021-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87Offer/" itemprop="url" rel="index"><span itemprop="name">剑指Offer</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>剑指Offer中关于数组的题目解析。</p>
<a id="more"></a>
<h3 id="斐波那契数列">01 斐波那契数列</h3>
<p><strong>题目描述</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>斐波那契额数字的规律为，当<span class="math inline">\(n\geq2\)</span>时，<span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span></p>
<p><strong>方法一：递归法</strong></p>
<p>时间复杂度：O(<span class="math inline">\(2^n\)</span>) 空间复杂度：递归栈的空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>)+Fibonacci(n-<span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归法会产生大量的重复计算：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/0.png" style="zoom:50%;"></p>
<p><strong>方法二：存储法</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(<span class="math inline">\(1\)</span>)</p>
<p>每次仅用到了最近的两个数，所以可以只存储最近的两个数</p>
<p>sum 存储第 n 项的值，one 存储第 n-1 项的值，two 存储第 n-2 项的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            sum = one + two;</span><br><span class="line">            two = one;</span><br><span class="line">            one = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中出现次数超过一半的数字">02 数组中出现次数超过一半的数字</h3>
<p><strong>题目描述</strong> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,2,2,2,5,4,2]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p>若某个数字出现的次数超过数组长度的一半，则它可以<strong>抵消掉</strong>所有剩下的数字。</p>
<p>用一个变量记录数字，一个变量记录它出现的次数。当次数被其他数字抵消为0时，即可更换新的数字。那么最后变量中存储的数字，可能满足条件也可能不满足，因此需要检验它的次数是否超过数组长度的一半。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不断抵消</span></span><br><span class="line">        <span class="keyword">int</span> num = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;array.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">                    num = array[i];</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                </span><br><span class="line">                <span class="keyword">if</span>(array[i] == num)&#123;</span><br><span class="line">                	cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">            	&#125;                </span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//统计次数</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == num)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//超过一半则为满足条件的数字</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;array.length/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建乘积数组">03 构建乘积数组</h3>
<p><strong>题目描述</strong></p>
<p>给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]<em>A[1]...A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] </em> A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）</p>
<p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[120,60,40,30,24]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/1.png" style="zoom: 50%;"></p>
<p>先计算下三角，再计算上三角。下三角从上往下，下三角从下往上。因为按照这个顺序时，可以发现前一个值上多乘一个数就是后一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(A.length&lt;=<span class="number">1</span> || A==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下三角</span></span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.length; i++)</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上三角，用一个数纪录累乘结果</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">//i=0时，即B[0]也是要计算的</span></span><br><span class="line">            tmp = tmp*A[i+<span class="number">1</span>];</span><br><span class="line">            B[i] = B[i]*tmp;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">		<span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字在排序数组中出现的次数">04 数字在排序数组中出现的次数</h3>
<p><strong>题目描述</strong></p>
<p>统计一个数字在升序数组中出现的次数。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,3,3,3,4,5],3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(logn\)</span>) 空间复杂度：O(1)</p>
<p>使用二分法分别找到 左边界left和右边界right，易得数字target的数量为 right - left - 1。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/2.png" style="zoom: 67%;"></p>
<ol type="1">
<li>初始化： 左边界 i = 0，右边界 j = len(nums) - 1。</li>
<li>循环二分： 当闭区间 [i, j] 无元素时跳出（不满足i<span class="math inline">\(\leq\)</span>j时）；
<ol type="1">
<li>计算中点 m = (i + j) / 2（向下取整）；</li>
<li>若 nums[m] &lt; target ，则 target在闭区间 [m + 1, j] 中，因此执行 i = m + 1；</li>
<li>若 target &lt; nums[m] ，则 target在闭区间 [i, m - 1] 中，因此执行 j = m - 1;</li>
<li>若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；左边界 left 在闭区间 [i, m-1] 中。因此分为以下两种情况：
<ol type="1">
<li>若查找 右边界 right ，则执行 i = m + 1，可以并入nums[m] &lt; target的情况 ；（跳出时 i 指向右边界）</li>
<li>若查找 左边界 left ，则执行 j = m - 1，可以并入target &lt; nums[m] 的情况 ；（跳出时 j 指向左边界）</li>
</ol></li>
</ol></li>
<li>返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right - left - 1 即可。</li>
</ol>
<p>注意到，如果不存在target的时候，right就是最接近target的那个比target大的数，left亦然。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//寻找右边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&lt;=k)&#123; <span class="comment">//这里是将(nums[m] &lt; target) 和 (nums[m] == target &amp;&amp; 探寻右边界) 的情况合并在一起</span></span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rbound = i;</span><br><span class="line">        <span class="comment">//此时i指向右边界，j指向最右边的target</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//寻找左边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&lt;k)&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lbound = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rbound - lbound - <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种简化代码的方式就是只寻找右边界。</p>
<h3 id="和为s的两个数字">05 和为S的两个数字</h3>
<p><strong>题目描述</strong></p>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>返回值描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,4,7,11,15],15</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4,11]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> small = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> large = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = Integer.MAX_VALUE; <span class="comment">//判断两数的乘积</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[left]+array[right]&lt;sum)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[left]+array[right]&gt;sum)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(array[left]*array[right]&lt;tmp)&#123;</span><br><span class="line">                    small = array[left];</span><br><span class="line">                    large = array[right];</span><br><span class="line">                    tmp = small*large;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                      </span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(tmp != Integer.MAX_VALUE)&#123;</span><br><span class="line">            res.add(small);</span><br><span class="line">            res.add(large);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中重复的数字">06 数组中重复的数字</h3>
<p><strong>题目描述</strong></p>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p>返回描述：</p>
<p>如果数组中有重复的数字，函数返回true，否则返回false。</p>
<p>如果数组中有重复的数字，把重复的数字放到参数duplication[0]中。（ps:duplication已经初始化，可以直接赋值使用。）</p>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>)：可以设想把交换数字、查找数字解耦，分开看。在此方法下，每访问数组的一个单元格 nums[i] ，就可以把一个数字填到属于它的位置；因此， 将 n 个数字填到正确的位置最多需要 N 次操作，复杂度为 O(N) 。而搜索重复数字的条件是 <code>nums[nums[i]] == nums[i]</code> ，找到这样的数字只需要遍历一遍数组，复杂度为 O(N)。这里只是将两个步骤合在一起写了。 空间复杂度：O(1)</p>
<p>原地交换</p>
<p><strong>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内</strong> 。 此说明含义：数组元素的 索引和 值 是 一对多 的关系。 因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/3.png" style="zoom:67%;"></p>
<p>nums[i]为当前遍历到的数组中的数字，它分为如下三种情况：</p>
<p>若 nums[i] = i： 说明此数字已在对应索引位置，无需交换，因此跳过； 若 nums[nums[i]] = nums[i]： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找到一组重复值，返回此值 nums[i]； 否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。</p>
<p>注意，每遍历到一个位置，都要交换到数组中的数字和下标相同为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发现数组中的值，和要交换的目标相同，即发现重复</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[ numbers[i] ])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前遍历到的数字交换到它所对应的下标上</span></span><br><span class="line">            <span class="keyword">int</span> tmp = numbers[numbers[i]];</span><br><span class="line">            numbers[numbers[i]] = numbers[i];</span><br><span class="line">            numbers[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找">07 二维数组中的查找</h3>
<p><strong>题目描述</strong></p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p>将矩阵旋转后可以发现类似二叉搜索树，根节点为左下角或右上角，选左下角较为方便。暴力遍历二维矩阵的复杂度为O(<span class="math inline">\(mn\)</span>)。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/4.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//令根节点为左下角</span></span><br><span class="line">        <span class="keyword">int</span> row = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( row &gt;= <span class="number">0</span> &amp;&amp; col &lt; array[<span class="number">0</span>].length )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[row][col] &lt; target)&#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[row][col] &gt; target)&#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整数组顺序使奇数位于偶数前面">08 调整数组顺序使奇数位于偶数前面</h3>
<p>题目描述</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(n^2\)</span>) 空间复杂度：O(1)</p>
<p>插入排序思想，从前往后遍历，不断地挪动位置来使得相对位置保持不变。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/5.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//基数继续移动，偶数停止移动</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; array.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">//偶数继续移动，基数停止移动</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找不到基数则可以停止</span></span><br><span class="line">            <span class="keyword">if</span>(j == array.length)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//此时将a[j]插入到a[i]的位置，即把基数插入到前面</span></span><br><span class="line">            <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j-<span class="number">1</span>; k&gt;=i ; k--)&#123;</span><br><span class="line">                array[k+<span class="number">1</span>] = array[k];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i] = tmp;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(<span class="math inline">\(n^2\)</span>) 空间复杂度：O(1)</p>
<p>冒泡排序思想，即每次将一个偶数交换到最后一个位置，同样可以保持相对顺序不变，冒泡排序稍微快一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123; <span class="comment">//第一个循环只是用来表明有几个数被交换了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123; <span class="comment">// -i是因为已经将i个偶数交换到最后了</span></span><br><span class="line">                <span class="keyword">if</span>(array[j]%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; array[j+<span class="number">1</span>]%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺时针打印矩阵">09 顺时针打印矩阵</h3>
<p>题目描述</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1,2,3],[4,5,6],[7,8,9]][[1,2],[3,4]]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(mn\)</span>) 空间复杂度：O(1)</p>
<p>时间复杂度为遍历矩阵。直接模拟遍历，主要是设置四个边界，并将边界往中间缩减。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/6.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义边界</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在四个方向上移动</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 左右移动，在上边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r; j++) res.add( matrix[t][j] );</span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>; <span class="comment">//++t&gt;b 等价于先给t自增1 ，再判断。这里非常巧妙地避免了重复打印，又缩小边界</span></span><br><span class="line">            <span class="comment">// 上下移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j &lt;= b; j++) res.add( matrix[j][r] );</span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 右左移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = r; j &gt;= l; j--) res.add( matrix[b][j] );</span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 下上移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = b; j &gt;= t; j--) res.add( matrix[j][l] );</span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把数组排成最小的数">10 把数组排成最小的数</h3>
<p><strong>题目描述</strong></p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,32,321]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;321323&quot;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(nlogn\)</span>) 空间复杂度：O(<span class="math inline">\(n\)</span>)</p>
<p>自定义排序规则，将所有数字转为字符串（空间复杂度），若<code>a+b &lt; b+a</code>，为了使得组合数字尽可能小，因此得到规则<code>a&lt;b</code>，将a尽可能放到前面（排序，时间复杂度）。</p>
<p>Java中的compareto方法，返回参与比较的前后a、b两个字符串的asc码的差值，负数则说明a&lt;b。</p>
<p>Java编译器对String做了特殊处理，使得可以直接用+拼接字符串。在循环拼接字符串的过程中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转成字符串</span></span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(numbers[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义排序规则并排序</span></span><br><span class="line">        Arrays.sort(strs, (x,y)-&gt; (x+y).compareTo((y+x)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; numbers.length; i++)</span><br><span class="line">            res.append(strs[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="机器人的运动范围">11 机器人的运动范围</h3>
<p><strong>题目描述</strong></p>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5,10,10</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(mn\)</span>) 遍历整个矩阵计算是否可达 空间复杂度：O(<span class="math inline">\(mn\)</span>) 记录是否已经到达过</p>
<p>由于机器人从(0,0)开始走，因此可以只向右走和向下走，就能遍历到矩阵的所有元素，不会漏掉。</p>
<p>求数位和的方法就是不断地取模10，累加余数。</p>
<p>Java中布尔型(boolean)变量默认值为false。</p>
<p>采用DFS方法，回溯地遍历整个整个矩阵。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义求数位和的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x !=<span class="number">0</span> )&#123;</span><br><span class="line">            res = res + x % <span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">return</span> dfs(rows, cols, threshold, visited, <span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> threshold, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>( x &gt;= rows || y &gt;= cols || visited[x][y] || sums(x) + sums(y) &gt; threshold ) <span class="comment">//注意先判断是否越界，否则visited可能会导致数组越界异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归遍历</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(rows, cols, threshold, visited, x, y+<span class="number">1</span>) + dfs(rows, cols, threshold, visited, x+<span class="number">1</span>, y);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的逆序对">12 数组中的逆序对</h3>
<p><strong>题目描述</strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>对于50%的数据,<span class="math inline">\(size\leq 10^4\)</span> 对于75%的数据,<span class="math inline">\(size\leq 10^5\)</span> 对于100%的数据,<span class="math inline">\(size\leq 2*10^5\)</span></p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,0]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(nlogn\)</span>) 空间复杂度：O(<span class="math inline">\(n\)</span>)</p>
<p>利用归并排序的思想，在两个有序数组的归并过程中，统计逆序对的数量。这样就将蛮力法两次循环的复杂度（<span class="math inline">\(O(n^2)\)</span>），降低为归并排序的复杂度。</p>
<p>假设我们有两个已排序的序列等待合并，分别是$ L = { 8, 12, 16, 22, 100 }<span class="math inline">\(和\)</span>R={9,26,55,64,91}<span class="math inline">\(。一开始我们用指针\)</span>lPtr = 0<span class="math inline">\(指向\)</span>L<span class="math inline">\(的首部，\)</span>rPtr = 0$ 指向<span class="math inline">\(R\)</span>的头部。记已经合并好的部分为 M。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; []</span><br><span class="line">     |                          |</span><br><span class="line">   lPtr                       rPtr</span><br></pre></td></tr></table></figure>
<p>lPtr 指向的元素小于 rPtr 指向的元素，于是把 lPtr 指向的元素放入辅助数组，并把 lPtr 后移一位。这个时候把左边的 8 加入了辅助数组，可以发现发现右边没有数比 8 小，所以 8 对逆序对总数的「贡献」为 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>
<p>接着继续合并，把 9 加入了辅助数组，此时 lPtr 指向 12，rPtr 指向 26。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8, 9]</span><br><span class="line">        |                          |</span><br><span class="line">       lPtr                       rPtr</span><br></pre></td></tr></table></figure>
<p>然后，继续合并，将左边的12加入辅助数组。此时 lPtr 比 rPtr 小，把 lPtr 对应的数加入答案，并考虑它对逆序对总数的贡献为 rPtr 相对 R 首位置的偏移 1（即右边只有一个数比 12 小，所以只有它和 12 构成逆序对），以此类推。</p>
<p>用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，只在 lPtr 右移的时候计算，当前 lPtr 指向的数字比 rPtr 小，但是比 R 中 [0 ... rPtr - 1] 的其他数字大，[0 ... rPtr - 1] 的其他数字本应当排在 lPtr 对应数字的左边，但是它排在了右边，所以这里就贡献了 rPtr 个逆序对。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">//全局变量记录结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span> || array == <span class="keyword">null</span> || left == right) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//此时左右数组皆为有序</span></span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right) &#123;</span><br><span class="line">            </span><br><span class="line">            result = array[l]&lt;array[r]? (result+r-(mid+<span class="number">1</span>))%<span class="number">1000000007</span> : result; <span class="comment">//左指针数字更小，则发生判断表明右边产生逆序对，即右指针的偏移量</span></span><br><span class="line">            help[p++] = array[l]&lt;array[r]? array[l++] : array[r++]; <span class="comment">//进行排序，将小的数字放入辅助数组</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缺点就在这个位置</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid)&#123; </span><br><span class="line">            result = (result + right-mid)%<span class="number">1000000007</span>;</span><br><span class="line">            help[p++] = array[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right) help[p++] = array[r++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将辅助数组的值复制到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;help.length; i++)</span><br><span class="line">            array[left+i] = help[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到，统计右边数组的偏移量时，假如右边数组先偏移完成，会导致左边数组每次偏移的时候都要统计一遍，因为此时左数组中的每个值都比右数组大，因此左边数组剩下的每一个数都可以和右边数组产生逆序对。</p>
<p>因此做出如下改动，当右数组的值小于左数组的时候，将右数组的值加入辅助数组，左数组剩余的个数即为逆序对个数，因为此时左数组中剩余的数都可以和当前右数组的数构成逆序对。</p>
<p><strong>即当左数组偏移的时候，表明左数组的数小，不和右数组构成逆序对。当右数组偏移的时候，表明右数组的数小，左数组剩余的数每个都可以和当前右数组的值构成逆序对。因此，不会产生遗漏。</strong></p>
<p>例如此时，12比9大，因此将9加入辅助数组，此时可以发现，左数组中剩余的每个数，都可以和当前右数组中的值9构成逆序对，因此发生统计行为。所以此时是右数组发生偏移的时候，才产生统计操作，而非左数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>
<p>接着继续合并，把 9 加入了辅助数组，此时 lPtr 指向 12，rPtr 指向 26。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">//全局变量记录结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span> || array == <span class="keyword">null</span> || left == right) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//此时左右数组皆为有序</span></span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[l] &lt;= array[r])&#123;</span><br><span class="line">                help[p++] = array[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//右数组的数小，左数组每个剩余的数都可以和当前右数组数构成逆序对</span></span><br><span class="line">                result = (result + mid-l+<span class="number">1</span>)%<span class="number">1000000007</span>;</span><br><span class="line">                help[p++] = array[r++];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid) help[p++] = array[l++];   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right) help[p++] = array[r++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将辅助数组的值复制到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;help.length; i++)</span><br><span class="line">            array[left+i] = help[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最快的方法是不要每次都新开数组help，直接在一开始就开辟一个同样长度的数组，然后每次都在这个数组上进行操作。</p>
<h3 id="旋转数组的最小数字">013 旋转数组的最小数字</h3>
<p><strong>题目描述</strong></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,4,5,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(logn\)</span>)：二分法的复杂度，当数组中的数字全部相同时退化为O(<span class="math inline">\(n\)</span>) 空间复杂度O(1)：</p>
<p>排序数组的查找问题，首先想到二分法。旋转后数组可以分为两部分，前半部分比后半部分都要大，因此每次二分时有如下情况：</p>
<p>1、mid &gt; high，比后半部分数组大的情况，说明mid现在在前半部分数组中，要找的最小数字应该在mid之后，low = mid + 1。</p>
<p>2、mid &lt; high， 比后半部分数组小的情况，说明mid现在在后半部分数组中，要找的最小数字应该在mid之前，high = mid。注意！这里不是high = mid -1，因为要找的最小数字可能是mid！</p>
<p>3、当mid = high，无法判断mid所在位置，将high--缩小范围。</p>
<p>直到 low == high时，找到最小的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt; array[high])</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; array[high])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连续子数组的最大和">014 连续子数组的最大和</h3>
<p>题目描述</p>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,-2,3,10,-4,7,2,-5]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历一遍数组 空间复杂度O(<span class="math inline">\(n\)</span>)：使用辅助数组，或者直接在原数组上修改也可</p>
<p>首先，注意是<strong>连续子数组</strong>。</p>
<p>使用一维数组动态规划的方法，dp[i]代表以元素 array[i] 为结尾的连续子数组最大和。</p>
<p>讨论，dp[i]和dp[i-1]的关系，假如dp[i-1]为负数或者0，说明dp[i-1]对dp[i]没有产生贡献，即dp[i-1]+array[i]还不如array[i]本身要大。<strong>此时连续子数组的开头变更为array[i]</strong>。</p>
<p>因此，注意dp[array.length -1]，即到最后一个元素时，<strong>以最后一个元素为结尾的连续子数组最大和并不一定是最大的</strong>！可能是前面的某个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= array.length-<span class="number">1</span>; i++)&#123;            </span><br><span class="line">            dp[i] = Math.max( array[i], array[i]+dp[i-<span class="number">1</span>] );</span><br><span class="line">            max = Math.max( max, dp[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中只出现一次的数字及2">015 数组中只出现一次的数字（及2）</h3>
<p>题目描述</p>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历两遍数组 空间复杂度O(1)：不使用额外空间</p>
<p>异或运算：相同为0，不同为1</p>
<p>异或运算拥有如下性质：</p>
<p>任何数和0异或，仍为本身：a⊕0 = a 任何数和本身异或，为0：a⊕a = 0 异或运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b</p>
<p>则可以知道，当<strong>任何数出现两次之后，其异或值都为0，即可以消去</strong>。假如将数组中的所有数都异或，则剩下那两个只出现一次的数的异或结果，这是<strong>由异或的交换律和结合律</strong>决定的：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/7.png" style="zoom:33%;"></p>
<p>当得到两个数的异或结果时，由异或不同位置为1的计算可以知道，<strong>这两个数在有1的位置上，肯定是有一个是1，有一个是0</strong> 。那么，<strong>将剩余的数按照这个位置分成两组，两组内分别异或</strong>之后就可以消去出现两次的数，则分别只剩下只出现一次的数。</p>
<p>问题1：如何找到异或结果中为1的位置？</p>
<p>x &amp; (-x) 来保留最右边的 1。</p>
<p>一个数（x）的负数（-x），其二进制表示为反码+1（~x+1）。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/8.png" style="zoom: 43%;"></p>
<p>某个数最右边的1，反码之后为0，加1肯定是这个位置变成1（因为它是最右边，或者进位），因此x &amp; (-x) 的运算结果就是二进制下保留最右边的 1，其余位置皆为0。</p>
<p>问题2：如何将剩余的数按照某个位置分成组？</p>
<p>x &amp; 010 即可对 x 进行分组。</p>
<p>因为只有一位为1，因此&amp;就运算结果为0的就分为一组，不为0的就可以分为另一组。</p>
<p>最后，初始化两个变量为0，分别和不同分组的数做异或运算即可（初始化为0利用了a⊕0 = a的性质）。</p>
<p>因此，整个算法流程如下：</p>
<p>1、所有数做异或运算，得到仅出现一次的两个数的异或结果。</p>
<p>2、x &amp; (-x) 来保留异或结果最右边的 1</p>
<p>3、利用&amp;操作对数字进行分组，再次对所有数进行异或，即可得到两个结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//得到仅出现一次的两个数的异或结果</span></span><br><span class="line">        <span class="keyword">int</span> xorall = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)</span><br><span class="line">            xorall = xorall ^ i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//x &amp; (-x) 来保留异或结果最右边的 1</span></span><br><span class="line">        <span class="keyword">int</span> split = xorall &amp; (-xorall);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//利用&amp;操作对数字进行分组，并再次对所有数进行异或</span></span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>; num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)&#123;      </span><br><span class="line">            <span class="keyword">if</span>((i&amp;split) == <span class="number">0</span>)</span><br><span class="line">            	num1[<span class="number">0</span>] = num1[<span class="number">0</span>] ^ i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] = num2[<span class="number">0</span>] ^ i;         </span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目描述</strong></p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>输入: [2,2,3,2] 输出: 3</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(32n\)</span>)：整数二进制一共有32位，每一位都要遍历一遍数组，统计1的个数 空间复杂度O(1)：不使用额外空间</p>
<p>由于出现多次的数字变成了奇数，因此不能用异或进行消去。转为二进制<strong>考虑数组中所有数字，转为二进制后，每一位上面1个个数和</strong>：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/9.png" style="zoom:43%;"></p>
<p>如果其他数都出现 3 次，只有目标数出现 1 次，那么每一位的 1 的个数无非有这2种情况，为 3 的倍数（全为出现三次的数） 或 3 的倍数 +1（包含出现一次的数）。这个 3 的倍数 +1 的情况也就是我们的目标数的那一位。</p>
<p>因此算法首先将结果初始化为0，然后统计每一位上1的个数，并将%3!=0的位置修改为1。</p>
<p><strong>&lt;&lt;</strong> 左移动运算符：运算数的各二进位全部左移若干位，高位丢弃，低位补0。（将二进制的1挪动到需要的位置上）</p>
<p><strong>&gt;&gt;</strong> 右移动运算符：运算数的各二进位全部右移若干位，低位丢弃，高位补0。（判断每位的1的个数时，移动到该位置）</p>
<p>a &amp; 1：a &amp; 1 中 1 只有最后一位为 1，其余位皆为 0 ，因此 a &amp; 1的作用就是判断 a 的最后一位是否为 1。（判断每位的1的个数）</p>
<p>a | 1：只要对应的二个二进制位有一个为1时，结果位就为1。（将结果的某个位置修改为1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">              <span class="comment">//先将数右移，并求出最后一位为 1 的个数</span></span><br><span class="line">              <span class="comment">//比如 0 3 4，就会先判断4，再到3，再到0</span></span><br><span class="line">              <span class="keyword">if</span> ((nums[j] &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;             </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到某一位取余为 1 的数，把1左移到那个位置，再和结果取或，就可以把对应位置修改为1</span></span><br><span class="line">          <span class="keyword">if</span> (count % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">              res = <span class="number">1</span> &lt;&lt; i | res;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和为s的连续正数序列">016 和为s的连续正数序列</h3>
<p><strong>题目描述</strong></p>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<p>输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：</p>
<p>输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：最多循环n次（left和right都到达n/2） 空间复杂度O(1)：不使用额外空间</p>
<p>注意到题目中所说的连续序列，则联想到滑动窗口。</p>
<p>滑动窗口可以看成<strong>数组中框起来的一个部分</strong>。滑动窗口一般表示成一个<strong>左闭右开区间</strong>。在一开始，i=1, j=1，滑动窗口位于序列的最左侧，窗口大小为零。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/10.png" style="zoom:50%;"></p>
<p>则可以知道每次判断滑动窗口内数字的和，根据和的大小来判断左右端点的变化。</p>
<ul>
<li>当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li>
<li>当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li>
<li>当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i, j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动。</li>
</ul>
<p>左端点最多只能到target/2处，它加上后面的任何一个数都已经比target要大了。</p>
<p><strong>实际上，把题目中的正整数序列换成任意的递增整数序列，滑动窗口方法都可以解。</strong></p>
<p>滑动窗口的重要性质是：窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">       </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;<span class="comment">//注意右边是开区间，不能取到这个数</span></span><br><span class="line">        <span class="keyword">int</span> tmpsum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= sum/<span class="number">2</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tmpsum &lt; sum)&#123; <span class="comment">//扩展窗口右边界，增大tmpsum</span></span><br><span class="line">                tmpsum = tmpsum + right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &gt; sum)&#123; <span class="comment">//扩展窗口左边界，减小tmpsum</span></span><br><span class="line">                tmpsum = tmpsum - left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//记录结果</span></span><br><span class="line">                ArrayList&lt;Integer&gt; tmpres = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++)</span><br><span class="line">                    tmpres.add(i);</span><br><span class="line">                res.add(tmpres);</span><br><span class="line">                </span><br><span class="line">                tmpsum = tmpsum - left;<span class="comment">//扩展窗口左边界，减小tmpsum</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>数字在排序数组中出现的次数：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/</p>
<p>数组中重复的数字：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/</p>
<p>二维数组中的查找：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/</p>
<p>调整数组顺序使奇数位于偶数前面：牛客Ariser.cn</p>
<p>顺时针打印矩阵：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/</p>
<p>机器人的运动范围：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/jian-zhi-offerer-shua-javadfs-bfs-tu-jie-py05/</p>
<p>数组中的逆序对：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</p>
<p>旋转数组的最小数字：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</p>
<p>连续子数组的最大和：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</p>
<p>数组中只出现一次的数字（及2）：https://leetcode-cn.com/problems/single-number/solution/dong-hua-dong-tu-yi-ding-hui-by-yuan-chu-vs4p/</p>
<p>和为s的连续正数序列：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
              <a href="/tags/%E5%89%91%E6%8C%87Offer/" rel="tag"># 剑指Offer</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/" rel="prev" title="剑指Offer 链表">
                  <i class="fa fa-chevron-left"></i> 剑指Offer 链表
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="next" title="剑指Offer 字符串">
                  剑指Offer 字符串 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BIOINSu</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
