<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSAPP 00 绪论</title>
    <url>/2022/03/16/CSAPP_00_%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p>CSAPP，其全称为《Computer System : A Programer Perspective》，即程序员视角下的计算机系统。</p>
<p>大约涵盖计算机组成 + 操作系统 + 汇编 + C语言 + Linux系统编程。</p>
<p>主要内容包括：</p>
<ul>
<li>信息表示（如何使用二进制表示整型、浮点数等）</li>
<li>C 和汇编语言的学习（通过汇编语言更深入地理解C语言是什么）</li>
<li>计算机体系结构（存储层次结构、局部性原理、处理器体系结构）</li>
<li>编译链接（C语言如何从文本变成可执行文件、静态链接、动态链接）</li>
<li>操作系统的使用（异常控制流、虚拟内存、多个系统调用介绍）</li>
<li>网络及并发编程（并发的基本概念、网络相关的系统调用的介绍）。</li>
</ul>
<p>学习该课程的目的主要是再回顾一下计算机的整个体系，巩固计算机基础知识，在工作上用途不是特别大，但是仍然需要了解。</p>
<p>因此，学习方式主要以B站up主<a href="https://space.bilibili.com/354767108?from=search&amp;seid=5169803745574715384&amp;spm_id_from=333.337.0.0">九曲阑干</a>的视频为主，辅以其他的资料。</p>
<a id="more"></a>
<h3 id="目录">目录</h3>
<p>出版者的话 中文版序一 中文版序二 译者序 前言 关于作者</p>
<h4 id="第1章-计算机系统漫游">第1章　计算机系统漫游</h4>
<p>1.1　信息就是位+上下文1 1.2　程序被其他程序翻译成不同的格式3 1.3　了解编译系统如何工作是大有益处的4 1.4　处理器读并解释储存在内存中的指令5 1.4.1　系统的硬件组成5 1.4.2　运行hello程序7 1.5　高速缓存至关重要9 1.6　存储设备形成层次结构9 1.7　操作系统管理硬件10 1.7.1　进程11 1.7.2　线程12 1.7.3　虚拟内存12 1.7.4　文件14 1.8　系统之间利用网络通信14 1.9　重要主题16 1.9.1　Amdahl定律16 1.9.2　并发和并行17 1.9.3　计算机系统中抽象的重要性19 1.10　小结20 参考文献说明20 练习题答案20 第一部分 程序结构和执行</p>
<h4 id="第2章-信息的表示和处理">第2章　信息的表示和处理</h4>
<p>2.1　信息存储24 2.1.1　十六进制表示法25 2.1.2　字数据大小27 2.1.3　寻址和字节顺序29 2.1.4　表示字符串34 2.1.5　表示代码34 2.1.6　布尔代数简介35 2.1.7　C语言中的位级运算37 2.1.8　C语言中的逻辑运算39 2.1.9　C语言中的移位运算40 2.2　整数表示41 2.2.1　整型数据类型42 2.2.2　无符号数的编码43 2.2.3　补码编码44 2.2.4　有符号数和无符号数之间的转换49 2.2.5　C语言中的有符号数与无符号数52 2.2.6　扩展一个数字的位表示54 2.2.7　截断数字56 2.2.8　关于有符号数与无符号数的建议58 2.3　整数运算60 2.3.1　无符号加法60 2.3.2　补码加法62 2.3.3　补码的非66 2.3.4　无符号乘法67 2.3.5　补码乘法67 2.3.6　乘以常数70 2.3.7　除以2的幂71 2.3.8　关于整数运算的最后思考74 2.4　浮点数75 2.4.1　二进制小数76 2.4.2　IEEE浮点表示78 2.4.3　数字示例79 2.4.4　舍入83 2.4.5　浮点运算85 2.4.6　C语言中的浮点数86 2.5　小结87 参考文献说明88 家庭作业88 练习题答案97</p>
<h4 id="第3章-程序的机器级表示">第3章　程序的机器级表示</h4>
<p>3.1　历史观点110 3.2　程序编码113 3.2.1　机器级代码113 3.2.2　代码示例114 3.2.3　关于格式的注解117 3.3　数据格式119 3.4　访问信息119 3.4.1　操作数指示符121 3.4.2　数据传送指令122 3.4.3　数据传送示例125 3.4.4　压入和弹出栈数据127 3.5　算术和逻辑操作128 3.5.1　加载有效地址129 3.5.2　一元和二元操作130 3.5.3　移位操作131 3.5.4　讨论131 3.5.5　特殊的算术操作133 3.6　控制135 3.6.1　条件码135 3.6.2　访问条件码136 3.6.3　跳转指令138 3.6.4　跳转指令的编码139 3.6.5　用条件控制来实现条件分支…141 3.6.6　用条件传送来实现条件分支…145 3.6.7　循环149 3.6.8　switch语句159 3.7　过程164 3.7.1　运行时栈164 3.7.2　转移控制165 3.7.3　数据传送168 3.7.4　栈上的局部存储170 3.7.5　寄存器中的局部存储空间172 3.7.6　递归过程174 3.8　数组分配和访问176 3.8.1　基本原则176 3.8.2　指针运算177 3.8.3　嵌套的数组178 3.8.4　定长数组179 3.8.5　变长数组181 3.9　异质的数据结构183 3.9.1　结构183 3.9.2　联合186 3.9.3　数据对齐189 3.10　在机器级程序中将控制与数据结合起来192 3.10.1　理解指针192 3.10.2　应用：使用GDB调试器193 3.10.3　内存越界引用和缓冲区溢出194 3.10.4　对抗缓冲区溢出攻击198 3.10.5　支持变长栈帧201 3.11　浮点代码204 3.11.1　浮点传送和转换操作205 3.11.2　过程中的浮点代码209 3.11.3　浮点运算操作210 3.11.4　定义和使用浮点常数212 3.11.5　在浮点代码中使用位级操作212 3.11.6　浮点比较操作213 3.11.7　对浮点代码的观察结论215 3.12　小结216 参考文献说明216 家庭作业216 练习题答案226</p>
<h4 id="第4章-处理器体系结构">第4章　处理器体系结构</h4>
<p>4.1　Y86-64指令集体系结构245 4.1.1　程序员可见的状态245 4.1.2　Y86-64指令245 4.1.3　指令编码246 4.1.4　Y86-64异常250 4.1.5　Y86-64程序251 4.1.6　一些Y86-64指令的详情255 4.2　逻辑设计和硬件控制语言HCL256 4.2.1　逻辑门257 4.2.2　组合电路和HCL布尔表达式257 4.2.3　字级的组合电路和HCL整数表达式258 4.2.4　集合关系261 4.2.5　存储器和时钟262 4.3　Y86-64的顺序实现264 4.3.1　将处理组织成阶段264 4.3.2　SEQ硬件结构272 4.3.3　SEQ的时序274 4.3.4　SEQ阶段的实现277 4.4　流水线的通用原理282 4.4.1　计算流水线282 4.4.2　流水线操作的详细说明284 4.4.3　流水线的局限性284 4.4.4　带反馈的流水线系统287 4.5　Y86-64的流水线实现288 4.5.1　SEQ+：重新安排计算阶段288 4.5.2　插入流水线寄存器289 4.5.3　对信号进行重新排列和标号292 4.5.4　预测下一个PC293 4.5.5　流水线冒险295 4.5.6　异常处理306 4.5.7　PIPE各阶段的实现308 4.5.8　流水线控制逻辑314 4.5.9　性能分析322 4.5.10　未完成的工作323 4.6　小结325 参考文献说明326 家庭作业327 练习题答案331</p>
<h4 id="第5章-优化程序性能">第5章　优化程序性能</h4>
<p>5.1　优化编译器的能力和局限性342 5.2　表示程序性能345 5.3　程序示例347 5.4　消除循环的低效率350 5.5　减少过程调用353 5.6　消除不必要的内存引用354 5.7　理解现代处理器357 5.7.1　整体操作357 5.7.2　功能单元的性能361 5.7.3　处理器操作的抽象模型362 5.8　循环展开366 5.9　提高并行性369 5.9.1　多个累积变量370 5.9.2　重新结合变换373 5.10　优化合并代码的结果小结377 5.11　一些限制因素378 5.11.1　寄存器溢出378 5.11.2　分支预测和预测错误处罚379 5.12　理解内存性能382 5.12.1　加载的性能382 5.12.2　存储的性能383 5.13　应用：性能提高技术387 5.14　确认和消除性能瓶颈388 5.14.1　程序剖析388 5.14.2　使用剖析程序来指导优化390 5.15　小结392 参考文献说明393 家庭作业393 练习题答案395</p>
<h4 id="第6章-存储器层次结构">第6章　存储器层次结构</h4>
<p>6.1　存储技术399 6.1.1　随机访问存储器400 6.1.2　磁盘存储406 6.1.3　固态硬盘414 6.1.4　存储技术趋势415 6.2　局部性418 6.2.1　对程序数据引用的局部性418 6.2.2　取指令的局部性419 6.2.3　局部性小结420 6.3　存储器层次结构421 6.3.1　存储器层次结构中的缓存422 6.3.2　存储器层次结构概念小结424 6.4　高速缓存存储器425 6.4.1　通用的高速缓存存储器组织结构425 6.4.2　直接映射高速缓存427 6.4.3　组相联高速缓存433 6.4.4　全相联高速缓存434 6.4.5　有关写的问题437 6.4.6　一个真实的高速缓存层次结构的解剖438 6.4.7　高速缓存参数的性能影响439 6.5　编写高速缓存友好的代码440 6.6　综合：高速缓存对程序性能的影响444 6.6.1　存储器山444 6.6.2　重新排列循环以提高空间局部性447 6.6.3　在程序中利用局部性450 6.7　小结450 参考文献说明451 家庭作业451 练习题答案459 第二部分 在系统上运行程序</p>
<h4 id="第7章-链接">第7章　链接</h4>
<p>7.1　编译器驱动程序465 7.2　静态链接466 7.3　目标文件466 7.4　可重定位目标文件467 7.5　符号和符号表468 7.6　符号解析470 7.6.1　链接器如何解析多重定义的全局符号471 7.6.2　与静态库链接475 7.6.3　链接器如何使用静态库来解析引用477 7.7　重定位478 7.7.1　重定位条目479 7.7.2　重定位符号引用479 7.8　可执行目标文件483 7.9　加载可执行目标文件484 7.10　动态链接共享库485 7.11　从应用程序中加载和链接共享库487 7.12　位置无关代码489 7.13　库打桩机制492 7.13.1　编译时打桩492 7.13.2　链接时打桩492 7.13.3　运行时打桩494 7.14　处理目标文件的工具496 7.15　小结496 参考文献说明497 家庭作业497 练习题答案499</p>
<h4 id="第8章-异常控制流"><strong>第8章　异常控制流</strong></h4>
<p>8.1　异常502 8.1.1　异常处理503 8.1.2　异常的类别504 8.1.3　Linux/x86-64系统中的异常505 8.2　进程508 8.2.1　逻辑控制流508 8.2.2　并发流509 8.2.3　私有地址空间509 8.2.4　用户模式和内核模式510 8.2.5　上下文切换511 8.3　系统调用错误处理512 8.4　进程控制513 8.4.1　获取进程ID513 8.4.2　创建和终止进程513 8.4.3　回收子进程516 8.4.4　让进程休眠521 8.4.5　加载并运行程序521 8.4.6　利用fork和execve运行程序524 8.5　信号526 8.5.1　信号术语527 8.5.2　发送信号528 8.5.3　接收信号531 8.5.4　阻塞和解除阻塞信号532 8.5.5　编写信号处理程序533 8.5.6　同步流以避免讨厌的并发错误540 8.5.7　显式地等待信号543 8.6　非本地跳转546 8.7　操作进程的工具550 8.8　小结550 参考文献说明550 家庭作业550 练习题答案556</p>
<h4 id="第9章-虚拟内存">第9章　虚拟内存</h4>
<p>9.1　物理和虚拟寻址560 9.2　地址空间560 9.3　虚拟内存作为缓存的工具561 9.3.1　DRAM缓存的组织结构562 9.3.2　页表562 9.3.3　页命中563 9.3.4　缺页564 9.3.5　分配页面565 9.3.6　又是局部性救了我们565 9.4　虚拟内存作为内存管理的工具565 9.5　虚拟内存作为内存保护的工具567 9.6　地址翻译567 9.6.1　结合高速缓存和虚拟内存570 9.6.2　利用TLB加速地址翻译570 9.6.3　多级页表571 9.6.4　综合：端到端的地址翻译573 9.7　案例研究：Intel Core i7/Linux内存系统576 9.7.1　Core i7地址翻译576 9.7.2　Linux虚拟内存系统580 9.8　内存映射582 9.8.1　再看共享对象583 9.8.2　再看fork函数584 9.8.3　再看execve函数584 9.8.4　使用mmap函数的用户级内存映射585 9.9　动态内存分配587 9.9.1　malloc和free函数587 9.9.2　为什么要使用动态内存分配589 9.9.3　分配器的要求和目标590 9.9.4　碎片591 9.9.5　实现问题592 9.9.6　隐式空闲链表592 9.9.7　放置已分配的块593 9.9.8　分割空闲块594 9.9.9　获取额外的堆内存594 9.9.10　合并空闲块594 9.9.11　带边界标记的合并595 9.9.12　综合：实现一个简单的分配器597 9.9.13　显式空闲链表603 9.9.14　分离的空闲链表604 9.10　垃圾收集605 9.10.1　垃圾收集器的基本知识606 9.10.2　Mark&amp;Sweep垃圾收集器607 9.10.3　C程序的保守Mark&amp;Sweep608 9.11　C程序中常见的与内存有关的错误609 9.11.1　间接引用坏指针609 9.11.2　读未初始化的内存609 9.11.3　允许栈缓冲区溢出610 9.11.4　假设指针和它们指向的对象是相同大小的610 9.11.5　造成错位错误611 9.11.6　引用指针，而不是它所指向的对象611 9.11.7　误解指针运算611 9.11.8　引用不存在的变量612 9.11.9　引用空闲堆块中的数据612 9.11.10　引起内存泄漏613 9.12　小结613 参考文献说明613 家庭作业614 练习题答案617 第三部分 程序间的交互和通信</p>
<h4 id="第10章-系统级io">第10章　系统级I/O</h4>
<p>10.1　Unix I/O622 10.2　文件623 10.3　打开和关闭文件624 10.4　读和写文件625 10.5　用RIO包健壮地读写626 10.5.1　RIO的无缓冲的输入输出函数627 10.5.2　RIO的带缓冲的输入函数627 10.6　读取文件元数据632 10.7　读取目录内容633 10.8　共享文件634 10.9　I/O重定向637 10.10　标准I/O638 10.11　综合：我该使用哪些I/O函数？638 10.12　小结640 参考文献说明640 家庭作业640 练习题答案641 #### 第11章　网络编程 11.1　客户端服务器编程模型642 11.2　网络643 11.3　全球IP因特网646 11.3.1　IP地址647 11.3.2　因特网域名649 11.3.3　因特网连接651 11.4　套接字接口652 11.4.1　套接字地址结构653 11.4.2　socket函数654 11.4.3　connect函数654 11.4.4　bind函数654 11.4.5　listen函数655 11.4.6　accept函数655 11.4.7　主机和服务的转换656 11.4.8　套接字接口的辅助函数660 11.4.9　echo客户端和服务器的示例662 11.5　Web服务器665 11.5.1　Web基础665 11.5.2　Web内容666 11.5.3　HTTP事务667 11.5.4　服务动态内容669 11.6　综合：TINY Web服务器671 11.7　小结678 参考文献说明678 家庭作业678 练习题答案679 #### 第12章　并发编程 12.1　基于进程的并发编程682 12.2　基于I/O多路复用的并发编程684 12.3　基于线程的并发编程691 12.4　多线程程序中的共享变量696 12.5　用信号量同步线程698 12.6　使用线程提高并行性710 12.7　其他并发问题716 12.8　小结722 参考文献说明723 家庭作业723 练习题答案726 附录A　错误处理729 参考文献733</p>
<h3 id="参考资料">参考资料</h3>
<p>https://zhuanlan.zhihu.com/p/384292380（CSAPP简介）</p>
<p>https://space.bilibili.com/354767108?from=search&amp;seid=5169803745574715384&amp;spm_id_from=333.337.0.0（九曲阑干）</p>
<p>https://zhuanlan.zhihu.com/p/455061631（笔记）</p>
<p>https://github.com/EugeneLiu/translationCSAPP （课程+课件）</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>01 Flink简介</title>
    <url>/2021/05/03/Flink01_%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><img src="/2021/05/03/Flink01_%E7%AE%80%E4%BB%8B/0.jpg" style="zoom:67%;"></p>
<p>Apache Flink是一个分布式的计算框架，用于在无界数据（流处理）和有界数据（批处理）上进行有状态的计算。本文主要介绍了分布式计算框架的四个阶段，以及对Flink的简介，主要包括Flink的四大基石及其特性，以及Flink包括的技术栈。</p>
<a id="more"></a>
<h3 id="flink">Flink</h3>
<p>Apache Flink是一个分布式的计算框架，用于在无界数据（流处理）和有界数据（批处理）上进行有状态的计算。</p>
<h4 id="分布式计算框架">分布式计算框架</h4>
<ul>
<li><p>Hadoop的MapReduce，将计算过程严格区分为Map阶段和Reduce阶段，当需要实现复杂的操作时，需要编写多个Map和Reduce程序实现这个过程，因此会发生多次的磁盘溢写。</p></li>
<li><p>Apache Tez，在Hadoop Yarn之上基于DAG（有向无环图，Directed Acyclic Graph）的计算框架，可以将多个有依赖的MapReduce作业转换为一个作业（这样只需写一次HDFS），从而大大提升DAG作业的性能。</p></li>
<li><p>Spark，基于内存的计算，提供Spark Streaming支持微批次的计算（伪实时），将流处理和批处理本质上都看成是批处理进行计算（不考虑Struct Streaming）。</p></li>
<li><p>Flink，同样支持基于内存的计算，将流处理和批处理本质上都看成流处理进行计算，进一步提升实时性，提供适用于机器学习的迭代计算。</p></li>
</ul>
<h4 id="无界有界数据">无界/有界数据</h4>
<ul>
<li>无界数据：数据不停地产生，对每条数据进行处理。</li>
<li>有界数据：将数据划分（按照时间等标准）成多组数据，每次处理一个组内的数据。</li>
</ul>
<h4 id="spark-streaming-vs-flink">Spark Streaming VS Flink</h4>
<table>
<thead>
<tr class="header">
<th></th>
<th>Spark Streaming</th>
<th>Flink</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>实时计算</td>
<td>基于RDD的微批次处理</td>
<td>流处理</td>
</tr>
<tr class="even">
<td>容错</td>
<td>血缘机制和Checkpoint</td>
<td>基于快照的轻量级Checkpoint（成本低）</td>
</tr>
<tr class="odd">
<td>内存管理</td>
<td>通过JVM实现内存管理，需要用户注意程序的编写</td>
<td>由Flink实现的一套内存管理机制</td>
</tr>
<tr class="even">
<td>延迟</td>
<td>100ms</td>
<td>10ms</td>
</tr>
</tbody>
</table>
<h3 id="flink四大基石">Flink四大基石</h3>
<h4 id="checkpoint">Checkpoint</h4>
<p>Checkpoint 是 Flink 实现容错机制最核心的功能，基于chandy-lamport算法实现分布式计算任务的一致性语义。</p>
<p>根据配置周期性地基于 Stream 中各个 Operator/Task 的状态来生成快照，从而将这些状态数据定期 持久化存储下来，当 Flink 程序一旦</p>
<p>意外崩溃时，重新运行程序时可以有选择地从这些快照进行 恢复，从而修正因为故障带来的程序数据异常。</p>
<h4 id="state">State</h4>
<p>Flink支持状态管理机制，state 一般指一个具体的 task/operator 的状态，可以认为状态管理机制保存了程序的中间计算结果或者是历史计算结果。</p>
<h4 id="window">Window</h4>
<p>窗口机制是一种将无界数据按照一定的规则切割为有界数据的方式，它将一个无限的数据流拆分成有限大小的数据组，并在每一组数据上进行处理。</p>
<h4 id="time">Time</h4>
<p>Flink可以根据不同的时间标准来处理数据。</p>
<p>Event Time：是事件创建的时间。它通常由事件中的时间戳描述，例如采集的日志数据中，每一条日志都会记录自己的生成时间</p>
<p>Ingestion Time：是数据进入 Flink 的时间。</p>
<p>Processing Time：是每一个执行基于时间操作的算子的本地系统时间，与机器相关。</p>
<h3 id="flink特性">Flink特性</h3>
<ul>
<li><p>支持高吞吐、低延迟、高性能的流处理</p></li>
<li><p>有状态计算的Exactly-once语义。状态是指flink能够维护数据在时序上的聚类和聚合，同时它的checkpoint机制</p></li>
<li><p>支持带有事件时间（event time）语义的流处理和窗口处理。事件时间的语义使流计算的结果更加精确，尤其在事件到达无序或者延迟的情况下。</p></li>
<li><p>支持高度灵活的窗口（window）操作。支持基于time、count、session，以及data-driven的窗口操作，能很好的对现实环境中的创建的数据进行建模。</p></li>
<li><p>轻量的容错处理（ fault tolerance）。 它使得系统既能保持高的吞吐率又能保证exactly-once的一致性。通过轻量的state snapshots实现</p></li>
<li><p>支持savepoints 机制（一般手动触发）。即可以将应用的运行状态保存下来；在升级应用或者处理历史数据是能够做到无状态丢失和最小停机时间。</p></li>
<li><p>支持大规模的集群模式，支持yarn、Mesos。可运行在成千上万的节点上</p></li>
<li><p>运行时同时支持流处理和批处理</p></li>
<li><p>支持具有Backpressure（背压）功能的持续流模型</p></li>
<li><p>Flink在JVM内部实现了自己的内存管理</p></li>
<li><p>支持迭代计算</p></li>
<li><p>支持程序自动优化：避免特定情况下Shuffle、排序等昂贵操作，中间结果进行缓存</p></li>
</ul>
<h3 id="flink技术栈">Flink技术栈</h3>
<p><img src="/2021/05/03/Flink01_%E7%AE%80%E4%BB%8B/0.png" style="zoom: 67%;"></p>
<ul>
<li><p>Deployment层： 该层主要涉及了Flink的部署模式，Flink支持多种部署模式：本地、集群（Standalone/YARN）、云（GCE/EC2）。</p></li>
<li><p>Runtime层：Runtime层提供了支持Flink计算的全部核心实现，比如支持分布式Stream处理、JobGraph到ExecutionGraph的映射、调度等，为上层API层提供基础服务。</p></li>
<li><p>API层： 主要实现了面向无界数据的流处理 DataStream API 和 面向有界数据的批处理 DataSet API。</p></li>
<li><p>Libraries层：Flink应用框架层，构建满足特定应用的计算框架，分别对应于面向流处理和面向批处理两类。面向流处理支持：CEP（复杂事件处理）、基于SQL的操作（基于Table的关系操作）；面向批处理支持：FlinkML（机器学习库）、Gelly（图计算）、基于SQL的操作（基于Table的关系操作）。</p></li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p>https://www.jianshu.com/p/2ee7134d7373（特性）</p>
<p>https://blog.csdn.net/weixin_43563705/article/details/107614714（基石）</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>02 Flink架构体系</title>
    <url>/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>介绍Flink的架构组件，编程模型（支持的API类型），任务的提交流程，程序的流程，并行度以及槽。</p>
<a id="more"></a>
<h3 id="flink架构">Flink架构</h3>
<h3 id="flink编程模型">Flink编程模型</h3>
<p>编程模型指的是Flink提供的API的类型，根据不同的抽象级别提供不同的API进行流处理或批处理。</p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/0.png" style="zoom: 50%;"></p>
<ul>
<li><p>Stateful Stream Process</p>
<p>最底层的API进行的是有状态的流式计算，它提供的过程函数（Process Function） 与 DataStream API 相集成， 使其可以对某些特定的操作进行底层的抽象， 它允许用户可以自由地处理来自一个或多个数据流的事件。这类API可以<strong>获得状态数据和事件的时间</strong>，从而可以注册事件时间并处理时间回调，完成复杂的逻辑。</p></li>
<li><p>DataStream/DataSet API</p>
<p><strong>针对流处理和批处理</strong>分别封装了DataStream API（有界或无界流数据） 和 DataSet API（有界数据集），提供了一些进行数据处理的通用算子如转换 （ transformations） ， 连接（joins） ， 聚合（aggregations） ， 窗口操作（windows） 等。</p></li>
<li><p>Table API</p>
<p>将数据封装成<strong>二维表格</strong>的形式，提供进行表格处理的API， 其中表可能会动态变化（流式数据） 。 Table API 可以提供例如 select、 project、 join、 group-by、 aggregate 等操作。 此外，Table API 程序在执行之前会经过内置优化器进行优化，可以在表格与DataStream/DataSet 之间无缝切换 ，允许程序混用 Table API 与 DataStream/DataSet API。</p></li>
<li><p>SQL</p>
<p>以SQL形式抽象的API和Table API比较相似，SQL 查询可以直接在 Table API 定义的表上执行。</p></li>
</ul>
<h3 id="任务的提交流程">任务的提交流程</h3>
<h3 id="程序与数据流">程序与数据流</h3>
<h4 id="flink中的程序">Flink中的程序</h4>
<p>可以将Flink中的程序分成三个步骤：数据读取（Source）、数据转换（Transformation）、数据写入（Sink）。</p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/1.png" style="zoom:50%;"></p>
<p>每个 Flink 上运行的程序会被映射成一个 Streaming Dataflows，它包含了 Streams 和 Transformations Operators。</p>
<p>一个 Stream 可 以看成一个中间结果，即<strong>数据</strong>。</p>
<p>一个 Transformations 是以一个或多个 Stream 作为输入的某种 Operator，即操作，该 Operator 利用这些 Streams 进行计算从而产生一个或多个 Result Stream。</p>
<h4 id="flink中的并行并行度">Flink中的并行（并行度）</h4>
<p>Flink 程序的执行具有并行、分布式的特性。在执行过程中，一个 Stream 包含一个或多个 Stream Partition。而每个 Operator 包含一个或多个 Operator Subtask，这些 Operator Subtasks 在不同的<strong>线程</strong>、不同的<strong>物理机</strong>或不同的<strong>容器</strong>中彼此互不依赖的执行。</p>
<p>一个特定 Operator 的 Subtask 的个数被称之为其 <strong>Parallelism(并行度)</strong>，注意这里指的是Operator的并行度，不是整个Flink程序的并行度。一个 Stream 的并行度总是等同于产生它的 Operator 的并行度。一个程序中，不同的 Operator 可能具有不同的并行度。</p>
<blockquote>

</blockquote>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/2.png" style="zoom: 80%;"></p>
<p>如上图，Source被分成Source1和Source2，它们分别为Source这个Operator的Subtask。每一个Operator Subtask都是在不同的线程当中独立执行的。一个Operator的并行度，就等于Operator Subtask的个数。上图Source这个Operator的并行度为2。而一个Stream的并行度就等于它生成的Operator的并行度。</p>
<p>数据在两个Operator之间传递的时候有两种模式，这取决于Operator的种类：</p>
<p><strong>One to One</strong>模式：两个operator用此模式传递的时候，会保持数据的分区数和数据的排序；如上图中的Source1到Map1，它就保留的Source的分区特性，以及分区元素处理的有序性。（此时，可以把这两个Operator合并为一个Operator Chain）</p>
<p><strong>Redistributing</strong> （重新分配）模式：这种模式会<strong>改变数据的分区数</strong>；每个一个Operator Subtask会根据选择Transformation把数据发送到不同的目标subtasks，比如keyBy()会通过<strong>hashcode重新分区</strong>，broadcast()和rebalance()方法会<strong>随机重新分区</strong>，这些操作都会引起 Redistributing 过程，而 Redistributing 过程就类似 于 Spark 中的 shuffle 过程。</p>
<h4 id="operator-chain">Operator Chain</h4>
<p>Flink的所有操作都称之为Operator，客户端在提交任务的时候会对Operator进行优化操作，<strong>能进行合并的</strong>Operator（One to One模式）会被合并为一个Operator，<strong>合并后的Operator称为Operator Chain</strong>，实际上就是一个执行链它包括了多个操作，每个执行链会在TaskManager上一个独立的<strong>线程</strong>中执行。</p>
<p>每个Operator Chain或Operator就称为一个<strong>Task</strong>，每个Task会在一个单独的线程中执行。将 Operators 链接成 Task 是非常有效的优化，它能减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。</p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/3.png" style="zoom:67%;"></p>
<h3 id="slot槽与-sharing-slot共享槽">Slot（槽）与 Sharing Slot（共享槽）</h3>
<h4 id="slot">Slot</h4>
<p>每个<strong>TaskManager是一个JVM的进程</strong>, 可以在不同的线程中执行一个或多个子任务。 通过Task Slot来控制能接收多少个Task，至少要有一个Task Slot。</p>
<p>每个Task Slot表示TaskManager中拥有一定资源的一个固定大小的子集，<strong>代表一个线程</strong>，它能够执行一个Task。</p>
<p><strong>一个Flink程序的最大并行度由集群中所有Task Manager的Slot的数量决定。</strong></p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/4.png" style="zoom: 80%;"></p>
<p>一般来说，<strong>槽的个数都是和一台主机中CPU的核数相等</strong>，比如8核，那么就分配8个槽。</p>
<p>同时这个Task Manager进程的内存被划分到多个Slot中。图中有2个TaskManager，每个TaskManager有3个Slot的，每个Slot占有约1/3的TaskManager进程的内存。</p>
<p>内存被划分到不同的Slot之后可以获得如下好处:</p>
<ul>
<li>TaskManager最多能同时并发执行的任务是可以控制的，那就是3个，因为不能超过Slot的数量。</li>
<li>Slot有独占的内存空间，这样在一个TaskManager中可以运行多个不同的作业，作业之间不受影响。</li>
</ul>
<h4 id="sharing-slot">Sharing Slot</h4>
<p>Flink允许子任务（Operator）共享槽，即使它们是不同任务（Operator）的子任务（Operator Subtask），只要它们来自同一个作业即可。</p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/5.png" style="zoom:90%;"></p>
<p>允许槽共享有几个主要好处：</p>
<ul>
<li><p>只需计算一个作业（Job）中最高的并行度（parallelism）所需要的Task Slot即可，只要这个满足，整个作业都能满足。</p></li>
<li><p>资源分配更加公平，如果有比较空闲的Slot可以将更多的任务分配给它。图中若没有任务槽共享，负载较低的Source/Map等Subtask将会占据许多资源，而负载较高的窗口Subtask则会缺乏资源。</p></li>
<li><p>有了槽共享，可以将基本并行度（base parallelism）从2提升到6（不允许槽共享，则一个TaskManager中只有一个槽执行该作业的Task），提高了槽资源的利用率。</p></li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/weixin_44318830/article/details/107453663?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162022478716780261941913%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162022478716780261941913&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>blog</sub>first_rank_v2~rank_v29-8-107453663.pc_v2_rank_blog_default&amp;utm_term=flink</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>04 Flink Dataset</title>
    <url>/2021/05/09/Flink04_DatasetAPI/</url>
    <content><![CDATA[<p>Flink中对有界数据进行计算（批处理）。</p>
<a id="more"></a>
<h3 id="基础">基础</h3>
<h4 id="换算单位">换算单位</h4>
<h3 id="并行度设置">并行度设置</h3>
<p>一个Flink程序由多个Operator组成(source、transformation和 sink)。一个Operator由多个并行的Task(线程)来执行， 一个Operator的并行Task(线程)数目就被称为该Operator(任务)的并行度(Parallel)。</p>
<p>1、Operator Level（算子级别）</p>
<p>Operator的并行度可以通过调用 setParallelism()方法来指定。</p>
<p><img src="/2021/05/09/Flink04_DatasetAPI/0.png" style="zoom: 80%;"></p>
<p>2、Execution Environment Level（Env级别）</p>
<p>执行环境的默认并行度可以通过调用setParallelism()方法指定。执行环境的并行度可以通过显式设置算子的并行度而改变。</p>
<p><img src="/2021/05/09/Flink04_DatasetAPI/1.png" style="zoom:80%;"></p>
<p>3、Client Level（客户端级别）</p>
<p>并行度可以在客户端将job提交到Flink时设定，可以通过-p参数指定并行度：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/flink run -p 10 WordCount-java.jar</span><br></pre></td></tr></table></figure>
<p>4、System Level（系统默认级别）</p>
<p>在系统级可以通过设置flink-conf.yaml文件中的parallelism.default属性来指定所有执行环境的默认并行度。</p>
<p>总结：</p>
<p>1、并行度的优先级：算子级别 &gt; env级别 &gt; Client级别 &gt; 系统默认级别 (越靠前具体的代码并行度的优先级越高)</p>
<p>2、建议不设置算子并行度，如果算子并行度发生变化，可能会在算子之间发生Redistributing，造成数据的shuffle;</p>
<p>3、不建议使用系统默认配置，配置太过于死板，修改起来比较麻烦；</p>
<p>4、可以设置env级别或者Client级别。</p>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>07 Flink四大基石：检查点与状态</title>
    <url>/2021/08/14/Flink07_CheckpointAndState/</url>
    <content><![CDATA[<p>checkpoint机制是Flink可靠性的基石，可以保证Flink集群在某个算子因为某些原因(如 异常退出)出现故障时，能够将整个应用流图的状态恢复到故障之前的某一状态，保 证应用流图状态的一致性。Flink的checkpoint机制原理来自“Chandy-Lamport algorithm”算法。</p>
<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>State</td>
<td>State是指流计算过程中计算节点的中间计算结果或元数据属性。<br>State一般指一个具体的task/operator的状态。</td>
</tr>
<tr class="even">
<td>State优势</td>
<td>1、增量计算 2、错误恢复</td>
</tr>
<tr class="odd">
<td>State存储</td>
<td>1、内存 2、HDFS 3、RocksDB+HDFS</td>
</tr>
<tr class="even">
<td>Checkpoint</td>
<td>是一种容错机制，它保证Flink集群在某个算子出现故障时，能够将状态恢复到故障之前。<br>Checkpoint表示了一个Flink Job，在一个特定时刻的一份全局状态快照，即包含了所有task/operator的State。</td>
</tr>
<tr class="odd">
<td>Checkpoint过程</td>
<td>检查点协调器周期性的向该流应用的所有source算子发送 barrier，每个算子持久化它的state，当协调器收到所有算子的确认后即认为快照制作成功</td>
</tr>
<tr class="even">
<td>Exactly Once</td>
<td>一条数据只影响一次最终结果。<br>Source：保存读取数据的偏移量。<br>Flink：Checkpoint机制保证系统的一致性。<br>Sink：两阶段提交，当所有算子的快照完成的时候才真正提交。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="sate">Sate</h3>
<h4 id="概念">概念</h4>
<p>State是指流计算过程中计算节点的中间计算结果或元数据属性。</p>
<p>比如 在aggregation过程中要在state中记录中间聚合结果。</p>
<p>比如 Kafka 作为数据源时候，要记录已经读取记录的offset。</p>
<p>这些State数据在计算过程中会进行持久化(插入或更新)。所以Apache Flink中的State就是与时间相关的，Apache Flink任务的内部数据（计算数据和元数据属性）的快照。</p>
<h4 id="原因">原因</h4>
<p>与批计算相比，State是流计算特有的，批计算没有failover机制，要么成功，要么重新计算。</p>
<p>流计算在 大多数场景下是增量计算，数据逐条处理（大多数场景)，每次计算是在上一次计算结果之上进行处理的，这样的机制势必要将上一次的计算结果进行存储（生产模式要持久化）。</p>
<p>另外由于 机器，网络，脏数据等原因导致的程序错误，在重启job时候需要从成功的检查点进行State的恢复。</p>
<h4 id="分类">分类</h4>
<p>KeyedState：这里面的key是我们在SQL语句中对应的GroupBy/PartitioneBy里面的字段，key的值就是groupby/PartitionBy字段组成的Row的字节数组，每一个key都有一个属于自己的State，key与key之间的State是不可见的。</p>
<p>OperatorState：Apache Flink内部的Source Connector的实现中就会用OperatorState来记录source数据读取的offset。</p>
<h4 id="存储">存储</h4>
<p>基于内存的HeapStateBackend - 在debug模式使用，不建议在生产模式下应用；</p>
<p>基于HDFS的FsStateBackend - 分布式文件持久化，每次读写都产生网络IO，整体性能不佳；</p>
<p>基于RocksDB的RocksDBStateBackend - 本地文件+异步HDFS持久化；</p>
<blockquote>
<p>RocksDB+HDFS的方式进行State的存储，State存储分两个阶段，首先本地存储到RocksDB，然后异步的同步到远程的HDFS。 这样而设计既消除了HeapStateBackend的局限（内存大小，机器坏掉丢失等），也减少了纯分布式存储的网络IO开销。</p>
</blockquote>
<h3 id="checkpoint">Checkpoint</h3>
<h4 id="单个数据源">单个数据源</h4>
<p>每个需要checkpoint的应用在启动时，Flink的<strong>JobManager</strong>为其创建一个 <strong>CheckpointCoordinator</strong>(检查点协调器)，CheckpointCoordinator全权负责本应用的<strong>快照制作</strong>。</p>
<p><img src="/2021/08/14/Flink07_CheckpointAndState/image-20210814123400883.png" alt="image-20210814123400883" style="zoom:67%;"></p>
<ol type="1">
<li><p>CheckpointCoordinator(检查点协调器) 周期性的向该流应用的<strong>所有source算子发送 barrier</strong>(屏障)。</p></li>
<li><p>当某个source算子收到一个barrier时，<strong>便暂停数据处理过程，然后将自己的当前状态制作成快照，并保存到指定的持久化存储中</strong>，最后向CheckpointCoordinator报告自己快照制作情况，同时向自身所有下游算子广播该barrier，恢复数据处理</p></li>
<li><p>下游算子收到barrier之后，会暂停自己的数据处理过程，然后将自身的相关状态制作成快照，并保存到指定的持久化存储中，最后向CheckpointCoordinator报告自身快照情况，同时向自身所有下游算子广播该barrier，恢复数据处理。</p></li>
<li><p>每个算子按照步骤3不断制作快照并向下游广播，直到最后barrier传递到sink算子，快照制作完成。</p></li>
<li><p>当<strong>CheckpointCoordinator收到所有算子的报告之后，认为该周期的快照制作成功</strong>; 否则，如果在规定的时间内没有收到所有算子的报告，则认为本周期快照制作失败。</p></li>
</ol>
<h4 id="多个数据源">多个数据源</h4>
<p>如果一个算子有多个输入源，则暂时阻塞先收到barrier的输入源，等到另一个个输入源相 同编号的barrier到来时，再制作自身快照并向下游广播该barrier。</p>
<p><img src="/2021/08/14/Flink07_CheckpointAndState/image-20210814123659052.png" alt="image-20210814123659052" style="zoom:67%;"></p>
<ol type="1">
<li><p>假设算子C有A和B两个输入源</p></li>
<li><p>在第i个快照周期中，由于某些原因(如处理时延、网络时延等)输入源A发出的 barrier 先到来，这时算子C暂时将输入源A的输入通道阻塞，仅收输入源B的数据。</p></li>
<li><p>当输入源B发出的barrier到来时，算子C制作自身快照并向 CheckpointCoordinator 报告自身的快照制作情况，然后将两个barrier合并为一个，向下游所有的算子广播。</p></li>
<li><p>当由于某些原因出现故障时，CheckpointCoordinator通知流图上所有算子统一恢复到某个周期的checkpoint状态，然后恢复数据流处理。分布式checkpoint机制保证了数据仅被处理一次(Exactly Once)。</p></li>
</ol>
<h4 id="exactly-once">Exactly Once</h4>
<p>Exactly once指的是一个系统能保证一条数据<strong>只影响一次最终结果</strong>。端倒端，指的是从source到sink。</p>
<p>Checkpoint和故障恢复过程可以保证内部状态的一致性，但有数据重发的问题，如下图所示。</p>
<p><img src="/2021/08/14/Flink07_CheckpointAndState/image-20210902103129900.png" alt="image-20210902103129900" style="zoom:50%;"></p>
<p>假设系统最近一次Checkpoint时间戳是3，系统在时间戳10处发生故障，在Checkpoint之后和故障之前的3到10期间，系统已经处理了一些数据（图中时间戳为5和8的数据）。</p>
<p>这引发了一个问题，那就是时间戳3至10之间的数据被重发了。故障之前，这部分数据已经被一些算子处理了，甚至可能已经发送到外部系统了，重启后，这些数据又重新发送一次。一条数据不是只被处理一次，而是有可能被处理了多次（At-Least-Once）。</p>
<p>此处需要做到的是Exactly once，即一条数据<strong>只影响一次最终结果</strong>。（而不是一条数据每个算子只处理一次，因为可能会随时产生故障，这样只流转到中间算子的数据在故障恢复时仍然会被同一个算子再次处理；事件的处理可以发生多次，但是该处理的效果只在持久后端状态存储中反映一次）</p>
<p>实现方法：</p>
<p>对于Flink + Kafka的数据管道系统（Kafka进、Kafka出）而言，各组件保证Exactly Once语义方式：</p>
<p>1、内部—— 利用checkpoint机制，把状态存盘，发生故障的时候可以恢复，保证内部的状态一致性。</p>
<p>2、source —— kafka consumer作为source，可以将偏移量保存下来，如果后续任务出现了故障，恢复的时候可以重置偏移量，重新消费数据，保证一致性</p>
<p>3、sink —— kafka producer作为sink，采用两阶段提交 sink。</p>
<blockquote>
<p>1、预提交：sink 收到 barrier，保存当前状态，存入 checkpoint，通知 jobmanager，并开启下一阶段的事务，用于提交下个检查点的数据。</p>
<p>2、正式提交：jobmanager 收到所有算子返回的确认消息，向sink发出确认，表示 checkpoint 完成，则sink正式提交这段时间的数据。外部kafka关闭事务，提交的数据就可以正常消费了。</p>
</blockquote>
<h3 id="参考资料">参考资料</h3>
<p>https://segmentfault.com/a/1190000039108197</p>
<p>https://cloud.tencent.com/developer/article/1591349</p>
<p>https://www.codenong.com/cs106082486/</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>08 Flink反压</title>
    <url>/2021/09/04/Flink08_%E5%8F%8D%E5%8E%8B/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>反压</td>
<td>某个计算节点的处理速度跟不上上游数据的发送速度，导致该节点成为计算瓶颈。</td>
</tr>
<tr class="even">
<td>Flink 的网络传输架构</td>
<td>1、每个TaskManager内分为Flink、Netty、Socket三层的Buffer，向Buffer中写入数据。<br>2、TaskManager间采用TCP协议进行数据传输。</td>
</tr>
<tr class="odd">
<td>TCP-based反压机制</td>
<td>1、当缓冲区被耗尽之后，写入数据和读取数据的组件都分别停止工作，将停止发送数据的信号传递给上层直到Source端。<br>2、TaskManager间采用TCP协议的流控机制（滑动窗口）来告知发送方停止发送数据。</td>
</tr>
<tr class="even">
<td>Credit-based反压机制</td>
<td>1、ResultSubPartition 向 InputChannel 发送消息的时候都会发送一个 backlog size 告诉下游准备发送多少消息。<br>2、下游计算有多少的 Buffer 去接收消息。<br>3、算完之后如果有充足的 Buffer 就会返还给上游一个 Credit 告知他可以发送消息。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="概念">概念</h3>
<p>反压（back pressure），某个计算节点的处理速度跟不上上游数据的发送速度，导致该节点成为计算瓶颈。</p>
<h3 id="flink-的网络传输架构">Flink 的网络传输架构</h3>
<p><img src="/2021/09/04/Flink08_%E5%8F%8D%E5%8E%8B/image-20210904202201543.png" alt="image-20210904202201543" style="zoom:67%;"></p>
<p>Flink的网络传输本质上就是在两个不同的TaskManager（机器节点）之间传输数据。</p>
<p>在每一个TaskManager中，可以分为三层：</p>
<p>1、Flink管理的 Network Buffer</p>
<p>2、Netty框架管理的 ChannelOutbound Buffer</p>
<p>3、Socket 管理的 Send/Receive Buffer</p>
<p>所有这里的Buffer都是内存中的一块空间，用来存储数据。</p>
<p>由于底层的通信是通过计算机网络中传输层协议TCP进行通信的，因此Flink 1.5之前的版本就是通过 TCP 的流量控制机制来实现 feedback的。</p>
<h3 id="基于tcp的流控">基于TCP的流控</h3>
<p>即TCP协议中基于滑动窗口的流量控制机制，具体见参考资料。</p>
<h3 id="反压的传播">反压的传播</h3>
<p>每个Task都拥有一个InputGate类的实例（负责接收数据）和ResultPartition类的实例（用来发送数据）。</p>
<p>InputGate中包含InputChannel类的实例，ResultPartition中包含ResultSubpartition类的实例。</p>
<p>每个InputGate会包含一个以上的InputChannel，即一个InputChannel接收一个ResultSubpartition的输出。</p>
<p>ResultSubpartition是ResultPartition的一个子分区。每个ResultPartition包含多个ResultSubpartition用来发送数据。</p>
<p><img src="/2021/09/04/Flink08_%E5%8F%8D%E5%8E%8B/image-20210904204809895.png" alt="image-20210904204809895" style="zoom: 67%;"></p>
<p>反压的传播实际上是分为两个阶段的，对应着上面的执行图，一共涉及 3 个 TaskManager，在每个 TaskManager 里面都有相应的 Task 在执行，还有负责接收数据的 InputGate，发送数据的 ResultPartition，这就是一个最基本的数据传输的通道。</p>
<p>在这时候假设最下游的 Task （Sink）出现了问题，处理速度降了下来这时候是如何将这个压力反向传播回去呢？这时候就分为两种情况：</p>
<ul>
<li><p>跨 TaskManager ，反压如何从 InputGate 传播到 ResultPartition。</p></li>
<li><p>TaskManager 内，反压如何从 ResultPartition 传播到 InputGate。</p></li>
</ul>
<h3 id="数据传输过程">数据传输过程</h3>
<p><img src="/2021/09/04/Flink08_%E5%8F%8D%E5%8E%8B/image-20210904222517382.png" alt="image-20210904222517382" style="zoom: 67%;"></p>
<p>左边发送方，右边接收方。</p>
<p>对于发送方来说，发送数据需要 ResultPartition，在每个 ResultPartition 里面会有分区 ResultSubPartition，中间还会有一些关于内存管理的 Buffer。</p>
<p>对于一个 TaskManager，在初始化时会从 Off-heap Memory（堆外内存） 中申请内存给一个统一的 Network BufferPool 被所有的 Task 共享，申请到内存的后续内存管理就是同步 Network BufferPool 来进行的，不需要依赖 JVM GC 的机制去释放。有了 Network BufferPool 之后可以为每一个 ResultSubPartition 创建 Local BufferPool 。这样，Flink、Netty、Socket层的Buffer就被创建好了。</p>
<p>右边接受方也是类似的。</p>
<p>整个流程为：</p>
<p>1、左边的 TaskManager 的 Record Writer 写了 &lt;1，2&gt; 这个两个数据进来</p>
<p>2、因为 ResultSubPartition 初始化的时候为空，没有 Buffer 用来接收，就会向 Local BufferPool 申请内存</p>
<p>3、这时 Local BufferPool 也没有足够的内存于是将请求转到 Network BufferPool</p>
<p>4、最终将申请到的 Buffer 按原链路返还给 ResultSubPartition，&lt;1，2&gt; 这个两个数据就可以被写入了。</p>
<p>5、之后会将 ResultSubPartition 的 Buffer 拷贝到 Netty 的 Buffer 当中，最终拷贝到 Socket 的 Buffer 将消息发送出去。</p>
<p>6、然后接收端按照类似的机制去处理将消息消费掉。</p>
<h3 id="flink-tcp-based反压机制before-v1.5">Flink TCP-based反压机制（before V1.5）</h3>
<h4 id="跨taskmanager">跨TaskManager</h4>
<p>接下来我们来模拟上下游处理速度不匹配的场景，发送端的速率为 2，接收端的速率为 1，看一下反压的过程是怎样的。</p>
<p><img src="/2021/09/04/Flink08_%E5%8F%8D%E5%8E%8B/image-20210904222350722.png" alt="image-20210904222350722" style="zoom:80%;"></p>
<p>1、因为速度不匹配就会导致一段时间后 InputChannel 的 Buffer 被用尽，于是他会向 Local BufferPool 申请新的 Buffer ，这时候可以看到 Local BufferPool 中的一个 Buffer 就会被标记为 Used。</p>
<p>发送端还在持续以不匹配的速度发送数据，然后就会导致 InputChannel 向 Local BufferPool 申请 Buffer 的时候发现没有可用的 Buffer 了，这时候就只能向 Network BufferPool 去申请，当然<strong>每个 Local BufferPool 都有最大的可用的 Buffer</strong>，防止一个 Local BufferPool 把 Network BufferPool 耗尽。如果 Network BufferPool 还是有可用的 Buffer 的话，则可以向其申请。</p>
<p>2、 一段时间后，发现 Network BufferPool 没有可用的 Buffer，或是 Local BufferPool 的最大可用 Buffer 到了上限无法向 Network BufferPool 申请，没有办法去读取新的数据，这时 Netty AutoRead 就会被禁掉，<strong>Netty 就不会从 Socket 的 Buffer 中读取数据了</strong>。</p>
<p>3、再过不久 Socket 的 Buffer 也被用尽，这时就会将 Window = 0 发送给发送端（即 TCP 滑动窗口的流控机制）。这时发送端的 Socket 就会停止发送。</p>
<p>4、 很快发送端的 Socket 的 Buffer 也被用尽，Netty 检测到 Socket 无法写了之后就会停止向 Socket 写数据。</p>
<p>5、Netty 停止写了之后，所有的数据就会阻塞在 Netty 的 Buffer 当中了，但是 Netty 的 Buffer 是无界的，可以通过 Netty 的水位机制中的 high watermark 控制他的上界。当超过了 high watermark，Netty 就会将其 channel 置为不可写，ResultSubPartition 在写之前都会检测 Netty 是否可写，发现不可写就会停止向 Netty 写数据。</p>
<p>6、 这时候所有的压力都来到了 ResultSubPartition，和接收端一样他会不断的向 Local BufferPool 和 Network BufferPool 申请内存。最终失败后则Record Writer就停止写入数据。</p>
<h4 id="taskmanager-内">TaskManager 内</h4>
<p><img src="/2021/09/04/Flink08_%E5%8F%8D%E5%8E%8B/image-20210904224837923.png" alt="image-20210904224837923" style="zoom:67%;"></p>
<p>1、下游的 TaskManager 反压导致本 TaskManager 的 ResultSubPartition 无法继续写入数据，于是 Record Writer 的写也被阻塞住了。</p>
<p>2、因为 Operator 需要有输入才能有计算后的输出，输入跟输出都是在同一线程执行， Record Writer 阻塞了，Record Reader 也停止从 InputChannel 读数据。</p>
<p>3、这时上游的 TaskManager 还在不断地发送数据，最终将这个 TaskManager 的 Buffer 耗尽。</p>
<h3 id="fink-credit-based反压机制since-v1.5">Fink Credit-based反压机制（since V1.5）</h3>
<h4 id="tcp-based反压的弊端">TCP-based反压的弊端</h4>
<p><img src="/2021/09/04/Flink08_%E5%8F%8D%E5%8E%8B/image-20210905092414582.png" alt="image-20210905092414582" style="zoom:67%;"></p>
<p>1、在一个 TaskManager 中可能要执行多个 Task，如果<strong>多个 Task 的数据最终都要传输到下游的同一个 TaskManager</strong> 就会<strong>复用</strong>同一个 Socket 进行传输。</p>
<p>这个时候如果单个 Task 产生反压，就会导致复用的 Socket 阻塞，其余的 Task 也无法使用传输。</p>
<p>checkpoint barrier 也无法发出导致下游执行 checkpoint 的延迟增大。</p>
<p>2、依赖最底层的 TCP 去做流控，会导致反压传播路径太长，导致生效的延迟比较大。</p>
<h4 id="credit-based-反压">Credit-based 反压</h4>
<p>Credit 可以类比为 TCP 的 Window 机制。</p>
<p>每一次 ResultSubPartition 向 InputChannel 发送消息的时候都会发送一个 <strong>backlog size 告诉下游准备发送多少消息</strong>，下游就会去计算有多少的 Buffer 去接收消息，算完之后如果有充足的 Buffer 就会<strong>返还给上游一个 Credit 告知他可以发送消息</strong>。</p>
<p><img src="/2021/09/04/Flink08_%E5%8F%8D%E5%8E%8B/image-20210905093913110.png" alt="image-20210905093913110" style="zoom:67%;"></p>
<p>假设上下游的速度不匹配，上游发送速率为 2，下游接收速率为 1，则会在 ResultSubPartition 中累积了两条消息，10 和 11， backlog 就为 2，这时就会将发送的数据 &lt;8,9&gt; 和 backlog = 2 一同发送给下游。</p>
<p>下游收到了之后就会去计算是否有 2 个 Buffer 去接收，InputChannel 中的Buffer如果已经不足了这时就会从 Local BufferPool 和 Network BufferPool 申请，好在这个时候 Buffer 还是可以申请到的。</p>
<p>1、过了一段时间后由于上游的发送速率要大于下游的接受速率，下游的 TaskManager 的 Buffer 已经到达了申请上限，这时候下游就会向上游返回 Credit = 0</p>
<p>2、ResultSubPartition 接收到之后就<strong>不会向 Netty 去传输数据</strong>，上游 TaskManager 的 Buffer 也很快耗尽，达到反压的效果。</p>
<p>这样在 ResultSubPartition 层就能感知到反压，不用通过 Socket 和 Netty 一层层地向上反馈，降低了反压生效的延迟。同时也不会将 Socket 去阻塞，解决了由于一个 Task 反压导致 TaskManager 和 TaskManager 之间的 Socket 阻塞的问题。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://mp.weixin.qq.com/s/78dkQMxf7uRfMzmzHEqHrA</p>
<p>https://www.cnblogs.com/Java3y/p/14167540.html</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS容错</title>
    <url>/2021/09/14/HDFS_%E5%AE%B9%E9%94%99/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NameNode容错</td>
<td>1、持久化的元数据（fsimage、edit log）进行备份到远程网络文件系统（NFS）<br>2、SecondaryNamenode中存有前一个时间点的fsimage的备份，结合NFS形成Namenode<br>3、搭建HDFS高可用模式，直接切换成StandbyNamenode</td>
</tr>
<tr class="even">
<td>DataNode容错</td>
<td>1、副本机制<br>2、心跳机制<br>3、安全模式<br>4、校验和</td>
</tr>
<tr class="odd">
<td>HDFS写容错</td>
<td>将出错的DataNode移除，剩余的继续传输，最后维持副本的数量。</td>
</tr>
<tr class="even">
<td>HDFS读容错</td>
<td>直接更换DataNode读数据。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="namenode容错">NameNode容错</h3>
<p>没有Namenode，HDFS就不能工作。事实上，如果运行namenode的机器坏掉的话，系统中的文件将会完全丢失，因为没有其他方法能够将位于不同datanode上的文件块(blocks)重建文件。因此，namenode的容错机制非常重要，Hadoop提供了两种机制。</p>
<p>第一种方式是将持久化存储在本地硬盘的文件系统元数据备份。Hadoop可以通过配置来让Namenode将他的持久化状态文件写到不同的文件系统中。这种写操作是同步并且是原子化的。比较常见的配置是在将持久化状态写到本地硬盘的同时，也写入到一个远程挂载的网络文件系统（NFS）。</p>
<p>第二种方式是运行一个SecondaryNamenode。 事实上SecondaryNamenode并不能直接被用作Namenode。它的主要作用是定期的将元数据镜像（fsimage）与操作日志文件（edit log）合并，以防止操作日志文件(edit log)变得过大。通常，SecondaryNamenode 运行在一个单独的物理机上，因为合并操作需要占用大量的CPU时间以及和Namenode相当的内存。SecondaryNamenode保存着合并后的元数据镜像（fsimage）的一个备份，万一哪天Namenode宕机了，这个备份就可以用上了。</p>
<p>但是SecondaryNamenode总是落后于主Namenode，所以在Namenode宕机时，数据丢失是不可避免的。在这种情况下，一般的，要结合第一种方式中提到的远程挂载的网络文件系统(NFS)中的Namenode的元数据文件来使用，把NFS中的Namenode元数据文件，拷贝到SecondaryNamenode，并把SecondaryNamenode作为主Namenode来运行。</p>
<p>第三种方式就是在高可用模式下直接切换成StandbyNamenode。</p>
<h3 id="datanode容错">DataNode容错</h3>
<p>1、副本机制</p>
<p>2、心跳机制</p>
<p>DataNode启动后向NameNode注册，心跳是每3秒一次，目的是告诉Namenode存活状态以及可用空间。心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。</p>
<p>3、安全模式</p>
<p>NameNode启动后会进入一个称为安全模式的特殊状态。处于安全模式的NameNode对于客户端来说是只读的。NameNode从所有的DataNode接收心跳信号和块状态报告（blockreport）。</p>
<p>每个数据块都有一个指定的最小副本数（dfs.replication.min），当NameNode检测确认某个数据块的副本数目达到这个最小值，那么该数据块就会被认为是副本安全(safely replicated)的。</p>
<p>在一定百分比（这个参数配置于dfs.safemode.threshold.pct，默认值是99.9%）的数据块被NameNode检测确认是安全之后，再过若干时间后（这个参数配置于dfs.safemode.extension，默认值是30秒），NameNode将退出安全模式状态。接下来NameNode会确定还有哪些数据块的副本没有达到指定数目，并将这些数据块复制到其他DataNode上。</p>
<p>4、校验和</p>
<p>HDFS会对写入的所有数据计算校验和（checksum）和数据本身一并存储，在读取数据时再次计算校验和并且验证和写入时是否相同。</p>
<p>此外Datanode还会定期运行一个进程检验本身存在的数据块是否和校验和一致。</p>
<h3 id="hdfs读写容错">HDFS读写容错</h3>
<h4 id="写容错">写容错</h4>
<p>如果传输过程中，有某个 datanode 出现了故障，那么当前的 pipeline 会被关闭，出现故 障的 datanode 会从当前的 pipeline 中移除，剩余的 block 会继续剩下的 datanode 中继续 以 pipeline 的形式传输，同时 namenode 会分配一个新的 datanode，保持 replicas 设定的 数量。</p>
<h4 id="读容错">读容错</h4>
<p>由于在读HDFS的过程中会从NameNode获取到数据块位置列表，如果某个DataNode失效，从可用列表中更换另一个DataNode进行读取即可。</p>
<h3 id="参考资料">参考资料</h3>
<p>http://article.docway.net/details?id=5f33d50ab4f20b6366ff6676#215NameNode_25</p>
<p>https://blog.csdn.net/ThreeAspects/article/details/105983047?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link</p>
<p>https://www.cnblogs.com/zeq912/p/9606105.html（NFS网络文件系统）</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop Shuffle与Spark Shuffle</title>
    <url>/2021/09/15/Hadoop_Shuffle%E4%B8%8ESparkShuffle/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 3%">
<col style="width: 48%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Hadoop Shuffle</th>
<th>Spark Shuffle</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>流程</td>
<td>Hadoop的Shuffle操作发生在Map之后，Reduce之前。<br>将流程分为溢写（spill）、合并（merge）、拉取（copy）、排序（sort）、合并（合并）。</td>
<td>Spark的Shuffle操作是发生在宽依赖之间。<br>Shuffle Write：形成磁盘文件和索引。<br>Shuffle Read：Reducer拉取数据。</td>
</tr>
<tr class="even">
<td>排序</td>
<td>在四个阶段均会发生数据排序。<br>目的是将Key相同的数据聚合在一起。</td>
<td>Spark 1.2之后，Sort-Based Shuffle变为默认的Shuffle实现。<br>普通：和Hadoop类似；内存数据结构reduceByKey用Map，join用Array；Reducer从索引文件内读取自己应该拉取的范围。<br>bypass：按key哈希写入磁盘文件，最后将磁盘文件合并，但不排序。</td>
</tr>
<tr class="odd">
<td>功能</td>
<td>没有差别，目的都是将Key相同的数据拉取到同一个Reducer。</td>
<td>没有差别，目的都是将Key相同的数据拉取到同一个Reducer。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="参考资料">参考资料</h3>
<p>https://tech.meituan.com/2016/05/12/spark-tuning-pro.html</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop中的排序</title>
    <url>/2021/09/12/Hadoop_%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hadoop排序发生阶段</td>
<td>Map<br>1、环形缓冲区到达阈值后先排序再溢写<br>2、溢写后不同分区的文件进行归并排序形成一个文件<br>Reduce<br>1、Reduce对每一个接收到的分区在内存中进行merge和排序<br>2、当溢写到磁盘的文件数量达到合并因子后进行归并排序<br>3、Reduce Task前分组排序</td>
</tr>
<tr class="even">
<td>排序发生原因</td>
<td>Map<br>减轻reduce端排序的压力。<br>Reduce<br>选择排序的方式将Key相同的数据分到一起，为之后的Reduce Task做准备。</td>
</tr>
<tr class="odd">
<td>如何避免排序</td>
<td>Hadoop2.x是可以关闭的，将Reduce Task设置为0，没有Reduce Task就不会发生排序。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="mr的基本过程">MR的基本过程</h3>
<p><img src="/2021/09/12/Hadoop_%E6%8E%92%E5%BA%8F/image-20210912110532672.png" alt="image-20210912110532672" style="zoom:150%;"></p>
<p>① : 每个数据的Split对应一个Map任务作为Map的输入，一般来说是HDFS的一个Block。</p>
<p>② : Map产生的数据会先写入到一个环形的内存的Buffer空间里。</p>
<p>③ : 当Buffer满了以后, 会Spill溢出数据到磁盘里。在溢出之前会先按照Partition函数对数据进行<strong>分区</strong>(默认是取key的hash值然后根据Reducer的个数进行取模)，然后按照Key进行<strong>排序</strong>(快速排序)。如果设置了Combiner会在写入磁盘前，对数据进行Combine操作，通过减少key的数据量来减轻Reducer拉取数据的网络传输。</p>
<p>④ : 最后将所有的溢出文件<strong>合并</strong>为一个文件，合并的过程中先按照分区再按照key进行<strong>排序</strong>（归并排序）, 如果溢出文件超过一定的数量（可配置)， 会在合并的前还会执行Combine操作（如果设置了Combiner）。</p>
<p>⑤ : 当Map端有任务完成后，Reducer端就会启动对应的fetch &amp; copy线程去从Map端复制数据。</p>
<p>⑥ : 当Copy过来的数据内存中放不下后，会往<strong>磁盘写</strong>，写之前会先进行merge和sort操作（归并排序），combiner操作，最终会合并得到一份Reduce的输入数据。</p>
<p>⑦ : 当输入数据准备好后，进行Reduce操作。</p>
<p>⑧ : 输出数据到指定的位置。</p>
<h3 id="排序发生的阶段">排序发生的阶段</h3>
<figure>
<img src="/2021/09/12/Hadoop_%E6%8E%92%E5%BA%8F/image-20210912111555925.png" alt="image-20210912111555925"><figcaption aria-hidden="true">image-20210912111555925</figcaption>
</figure>
<p><strong>Map阶段</strong></p>
<p>1、环形缓冲区的数据达到阈值后，对key按照字典序进行排序（快速排序，只排索引，不会移动数据在缓冲区的位置），然后再根据分区溢写到磁盘上。</p>
<p>2、对溢写到磁盘的不同分区的数据进行归并排序。</p>
<p><strong>Reduce阶段</strong></p>
<p>3、当reduce接收到所有map传输过来的数据之后，对每一个接收到的分区在内存中进行merge和排序，当内存不足时就会溢写到磁盘上再次形成小文件。</p>
<p>4、当溢写到磁盘的文件数量达到合并因子（默认是10）的时候就会进行合并和排序（归并排序）。比如map有50个输出，那么合并将进行5趟。每趟将10个文件合并成一个文件。</p>
<p>5、Reduce Task前分组排序：自定义。</p>
<h3 id="排序原因">排序原因</h3>
<p><strong>Map端排序的目的</strong></p>
<p>减轻reduce端排序的压力。在Map端排序后，每一个分区内的数据已经是部分有序的了，这样当不同机器的分区被拉取到同一个reducer内的时候，就可以执行归并排序的过程，而不需要对所有数据再次排序。</p>
<p><strong>Reduce端排序的目的</strong></p>
<p>在Reduce阶段需要将Key相同的数据放在一起进行聚合操作。每一个Reducer内可能存在多种不同Key的数据，为了将Key相同的数据放在一起，有两种实现方式：</p>
<p>1、Hash方法，太过于耗费内存。</p>
<p>2、外部排序方法，可以降低内存的使用量，只要磁盘空间足够即可。</p>
<p>因此，选择排序的方式将Key相同的数据分到一起，为之后的Reduce Task做准备。</p>
<h3 id="避免排序">避免排序</h3>
<p>这些排序过程在Hadoop1.x中无法避免，也不可以关闭，但Hadoop2.x是可以关闭的，将Reduce Task设置为0，即不使用 Reducer ，则不会排序。</p>
<blockquote>
<p>为了避免触发 Reduce 任务，你可以在驱动程序（driver program）通过调用下面的方法来把 reduce 任务数设置为 0。</p>
<p>job.setNumreduceTasks(0)</p>
<p>设置完之后，Hadoop 作业在执行的时候就只有 map 阶段，而不会发生 reduce 了。</p>
</blockquote>
<h3 id="参考资料">参考资料</h3>
<p>https://dataelement.top/2021/01/04/MapReduce-in-Hadoop/#map-reduce%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90</p>
<p>https://blog.csdn.net/qq_42246689/article/details/84590215?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-8.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-8.no_search_link</p>
<p>https://blog.csdn.net/qq_45287265/article/details/107781030?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link</p>
<p>https://blog.csdn.net/Betty_betty_betty/article/details/103727691</p>
<p>https://www.hadoopdoc.com/mapreduce/mapreduce-only-map</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>环形缓冲区</title>
    <url>/2021/09/03/Hadoop_%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<h3 id="概念">概念</h3>
<p>环形缓冲区是指数据<strong>被Map处理之后</strong>会先放入内存，内存中的这片区域就是环形缓冲区。</p>
<p>环形缓冲区其实是一个简单的buffer，即一个byte类型的数组，默认大小是100M。</p>
<p>当环形缓冲区达到容量的80%时，产生溢写（spill），数据从内存溢出到磁盘上。</p>
<blockquote>
<p>阈值太小经常溢写导致IO操作影响性能，阈值太大影响内存并阻塞map的写操作。</p>
</blockquote>
<a id="more"></a>
<h3 id="原理">原理</h3>
<p>环形缓冲区其实是一个数组，数组中存放着key和value的数据，以及关于key和value的元数据信息（包括kv数据的索引）。</p>
<p><img src="/2021/09/03/Hadoop_%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/image-20210903143711067.png" alt="image-20210903143711067" style="zoom: 50%;"></p>
<p>key/value的元数据存储的格式是int类型，每个key/value对应一个元数据，元数据由4个int组成：</p>
<ul>
<li>第一个int存放value的起始位置</li>
<li>第二个int存放key的起始位置</li>
<li>第三个int存放partition</li>
<li>第四个int存放value的长度。</li>
</ul>
<p><img src="/2021/09/03/Hadoop_%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA/image-20210903143743711.png" alt="image-20210903143743711" style="zoom:50%;"></p>
<p>key/value数据和元数据在环形缓冲区中的存储是由equator（赤道）分隔的，key/value按照索引递增的方向存储，元数据则按照索引递减的方向存储，将数组抽象为一个环形结构之后，以equator为界，key/value顺时针存储，元数据逆时针存储。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/xiaoxi_hahaha/article/details/110923860（环形缓冲区）</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive SQL</title>
    <url>/2021/09/25/Hive_HiveSQL/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 27%">
<col style="width: 72%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HiveSQL转MR（普通）</td>
<td>普通的任务直接用fetch的方式直接读取数据，不需要转MR。</td>
</tr>
<tr class="even">
<td>HiveSQL转MR（Join）</td>
<td>Map：生成键值对，以JOIN ON条件中的列作为Key，以JOIN之后所关心的列作为Value，在Value中还会包含表的 Tag 信息，用于标明此Value对应于哪个表。<br>Shuffle：将键值对发送至不同的Reducer中。<br>Reduce：Reducer通过 Tag 来识别不同的表中的数据，根据Key值进行Join操作。</td>
</tr>
<tr class="odd">
<td>HiveSQL转MR（Group By）</td>
<td>Map：生成键值对，以GROUP BY条件中的列作为Key，以聚集函数涉及的字段作为Value。<br>Shuffle：将键值对发送至不同的Reducer中。<br>Reduce：根据SELECT子句的列以及聚集函数进行Reduce。</td>
</tr>
<tr class="even">
<td>HiveSQL转MR（Distinct）</td>
<td>相当于没有聚集函数的GROUP BY，操作相同，只是键值对中的value可为空。</td>
</tr>
<tr class="odd">
<td>Hive SQL与Spark SQL</td>
<td>1、Hive SQL底层是MR，Spark SQL底层是RDD的计算。本质上两者的区别变成了MR和Spark的区别（内存、算子、容错）。<br><br>2、对于Hive本身来说，它包括metastore（元数据），就是schema的管理，比如有哪些表，哪些字段，什么数据类型，有没有索引等。而Spark只是一个计算引擎，没有元数据管理工具。<br><br>3、hive有hive on mapreduce和hive on spark。hive on spark 和Spark SQL并没有特别明显的性能优化（毕竟计算引擎都是Spark）。<br><br>4、hive on mapreduce：适合处理离线非实时数据，基于磁盘的处理使得性能上较为稳定。<br>Spark SQL：实时性要求或者速度要求较高的场所，基于内存的处理可能会出现数据倾斜造成反压等问题，导致内存溢出等错误。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="参考资料">参考资料</h3>
<p>https://zhuanlan.zhihu.com/p/87545980 （Hive架构）</p>
<p>https://zhuanlan.zhihu.com/p/127138025 （SQL转MR）</p>
<p>https://www.zhihu.com/question/36053025 （Spark SQL和Hive使用场景）</p>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive存储文件类型</title>
    <url>/2021/10/03/Hive_%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TEXTFILE</td>
<td><strong>默认格式</strong>，建表时不指定默认为这个格式，导入数据时会直接把数据文件拷贝到hdfs上不进行处理。</td>
</tr>
<tr class="even">
<td>SEQUENCEFILE</td>
<td></td>
</tr>
<tr class="odd">
<td>RCFILE</td>
<td></td>
</tr>
<tr class="even">
<td>ORCFILE</td>
<td></td>
</tr>
<tr class="odd">
<td>Parquet</td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="textfile">TEXTFILE</h3>
<p>每一行都是一条记录，每行都以换行符（）结尾。</p>
<p>默认格式，数据不做压缩，磁盘开销大，数据解析开销大。</p>
<p>可结合Gzip、Bzip2使用(系统自动检查，执行查询时自动解压)，但使用这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。</p>
<p>缺点：</p>
<p>1、磁盘开销大</p>
<p>2、解析不方便，如JSON/Xml，比二进制格式解析更消耗资源</p>
<p>3、不具备类型和模式，如数值或者日期类型的数据，无法使用mr排序，需要转换为有模式的二进制文件。</p>
<h3 id="sequencefile">SequenceFile</h3>
<h4 id="概述">概述</h4>
<p>SequenceFile是Hadoop用来存储二进制形式的&lt;Key,Value&gt;对而设计的一种平面文件(Flat File)。它将数据以&lt;Key,Value&gt;的形式序列化到文件中。Hive中的SequenceFile与Hadoop API中的MapFile 是互相兼容的。并且Hive 中的SequenceFile 继承自Hadoop API 的SequenceFile，不过它的key为空，使用value 存放实际的值， 这样是为了避免MR 在运行map 阶段的排序过程。</p>
<p>可以把SequenceFile当做是一个容器，把所有的文件打包到SequenceFile类中可以高效的对小文件进行存储和处理。SequenceFile文件并不按照其存储的Key进行排序存储。</p>
<p>SequenceFile文件使用Hadoop 标准的Writable 接口实现序列化和反序列化。其中的Key和Value可以是任意类型Writable或者是自定义Writable。</p>
<h4 id="存储结构">存储结构</h4>
<p>存储结构上，SequenceFile主要由一个Header后跟多条Record组成。</p>
<p>Header主要包含了Key ClassName，Value ClassName，存储压缩算法，用户自定义元数据等信息，此外还包含了一些同步标识，用于快速定位到记录的边界。</p>
<p>每条Record以键值对的方式进行存储，用来表示它的字符数组可以一次解析成：记录的长度、Key的长度、Key值和Value值，并且Value值的结构取决于该记录是否被压缩。</p>
<p>SequenceFIle的内部格式取决于是否启用压缩，如果是压缩，则又可以分为记录压缩和块压缩。记录压缩压缩率低，一般使用块压缩。</p>
<p>无压缩类型：如果没有启用压缩(默认设置)那么每个Record就由它的记录长度(字节数)、键的长度，键和值组成。长度字段为4字节。</p>
<p>记录压缩类型：记录压缩格式与无压缩格式基本相同，不同的是值字节是用定义在头部的编码器来压缩。注意：键是不压缩的。下图为记录压缩：</p>
<p><img src="/2021/10/03/Hive_%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/image-20211003201055725.png" alt="image-20211003201055725" style="zoom:67%;"></p>
<p>块压缩类型：块压缩一次压缩多个记录，因此它比记录压缩更紧凑，而且一般优先选择。当记录的字节数达到最小大小，才会添加到块。该最小值由io.seqfile.compress.blocksize中的属性定义。默认值是1000000字节。格式为记录数、键长度、键、值长度、值。下图为块压缩：</p>
<p><img src="/2021/10/03/Hive_%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/image-20211003203325562.png" alt="image-20211003203325562" style="zoom:67%;"></p>
<p>优点：</p>
<p>1、可切分，可压缩。</p>
<p>2、难度低，因为是Hadoop框架提供的API，所以业务侧修改比较简单。</p>
<p>缺点：</p>
<p>1、不支持append操作，序列化后存储的kv数据不是按照key的某个顺序存储的。</p>
<p>2、需要合并文件，且合并后不方便查看。</p>
<h3 id="rcfile">RCFile</h3>
<h4 id="概述-1">概述</h4>
<p>RCFile全称Record Columnar File，列式记录文件，是一种类似于SequenceFile的键值对（Key/Value Pairs）数据文件。但其实它是Facebook提出的行列存储相结合的RCFile文件存储格式。</p>
<h4 id="存储结构-1">存储结构</h4>
<p>它将数据按行分块（HDFS Block），保证同一行在一个数据块上，避免读一行数据需要读取多个HDFS Block。若干行共同构成一个Row Group，一个块上可能存在多个Row Group。然后，每个Row Group的数据按列存储，有利于数据压缩和快速的列存取。</p>
<p>一个Row Group包括三个部分。</p>
<p>第一部分是Row Group头部的同步标识，主要用于分隔HDFS块中的两个连续Row Group；</p>
<p>第二部分是Row Group的元数据头部，用于存储Row Group单元的信息，包括Row Group中的记录数、每个列的字节数、列中每个域（域的概念？）的字节数；</p>
<p>第三部分是表格数据段，即实际的列存储数据。在该部分中，同一列的所有域顺序存储。从图可以看出，首先存储了列A的所有域，然后存储列B的所有域等。</p>
<p><img src="/2021/10/03/Hive_%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/image-20211003205451080.png" alt="image-20211003205451080" style="zoom:50%;"></p>
<h4 id="注意">注意</h4>
<p>1、RCFile是在Hadoop HDFS之上的存储结构，表是水平划分的，分为多个Row Group，每个Row Group再被垂直划分，以便<strong>每列单独存储</strong>。</p>
<p>2、RCFile支持<strong>弹性的</strong>Row Group大小，Row Group大小需要权衡数据压缩性能和查询性能两方面。</p>
<p>3、每个Row Group中，元数据头部和表格数据段（每个列被独立压缩）分别进行压缩和解压。压缩算法使用的是重量级的<strong>Gzip压缩算法</strong>，是为了获得较好的压缩比。解压算法使用的是被称为<strong>Lazy解压</strong>（decompression）技术来在查询执行时避免不必要的列解压，即当处理一个Row Group时，RCFile只需要解压使用到的列，因此相对较高的Gzip解压开销可以减少。</p>
<p>优点：</p>
<p>RCFile具备相当于行存储的<strong>数据加载速度</strong>和负载适应能力，在读数据时可以在扫描表格时<strong>避免不必要的列读取</strong>，它比其他结构拥有更好的性能，使用列维度的压缩能够有效提升存储空间利用率。</p>
<h4 id="索引机制">索引机制</h4>
<p>元数据MetaData中columnValueLen/columnUncompressedValueLen字段保存着每个列的总长度，Column_x_row_y_value_plain_length字段保存着每个列中对应这个Row Group中每一行的数据长度。</p>
<p>如果只需要第n列的数据，可以根据ColumnValueLen/ColumnUncompressedValueLen字段跳过前面n-1列的数据。</p>
<h4 id="rcfile的sync机制与hdfs切片的关系">RCFile的Sync机制（与HDFS切片的关系）</h4>
<p>切片，指的是MR程序允许指定某个阈值作为切片，来一次性地读取该阈值大小的文件来作为一个块进行处理。</p>
<p>Hadoop MapReduce在提交Job之前会将这个大的文本文件根据“切片”大小（假设为128M）进行“切片”，每一个MapTask处理这个文件的一个“切片”（这里不考虑处理多个切片的情况），也就是这个文件的一部分数据。文本文件是按行进行存储的，那么MapTask从某个“切片”的起始处读取文件数据时，如何定位一行记录的起始位置呢？</p>
<p>毕竟“切片”是按照字节大小直接切分的，很有可能正好将某行记录“切断”。这时就需要有这样的一个“sync”，相当于一个标志位的作用，让我们可以识别一行记录的起始位置，对于普通的文本文件而言，这个“sync”就是换行符。所以，MapTask从某个“切片”的起始处读取数据时，首先会“过滤”数据，直到遇到一个换行符，然后才开始读取数据；如果读取某行数据结束之后，发现“文件游标”超过该“切片”的范围，则读取结束。</p>
<p>RCFile同样也有这样的一个“sync”，对于文本文件而言，是每行文本一个“sync”；RCFile是以Record为单位进行存储的，但是并没有每个Record使用一个“sync”，而是两个“sync”之间有一个间隔限制SYNC_INTERVAL（SYNC_INTERVAL = 100 * （4 + 16））。每次开始输出下一个Record的数据之前，都会计算当前文件的输出位置相对于上个“sync”的偏移量，如果超过SYNC_INTERVAL就输出一个“sync”作为RCFile的Record间隔。</p>
<h4 id="数据读取和lazy解压mr读取文件">数据读取和Lazy解压（MR读取文件）</h4>
<p>在MapReduce框架中，Mapper将顺序处理HDFS块中的每个Row Group。当处理一个Row Group时，RCFile无需全部读取行组的全部内容到内存。相反，它仅仅读元数据头部和给定查询需要的列。因此，它可以跳过不必要的列以获得列存储的I/O优势。</p>
<p>例如，表tbl(c1, c2, c3, c4)有4个列，做一次查询“SELECT c1 FROM tbl WHERE c4 = 1”，<strong>对每个Row Group，RCFile仅仅读取c1和c4列的内容</strong>。在元数据头部和需要的列数据加载到内存中后，它们需要解压。元数据头部总会解压并在内存中维护直到RCFile处理下一个行组。然而，RCFile不会解压所有加载的列，相反，它使用一种Lazy解压技术。</p>
<p>Lazy解压意味着只有那些被真正用到的列才会在内存中解压。如果一个WHERE条件不能被Row Group中的所有记录满足，那么RCFile将不会解压WHERE条件中不满足的列。例如，在上述查询中，所有行组中的列c4都解压了。然而，对于一个行组，<strong>如果列c4中没有值为1的域，那么就无需解压列c1</strong>。</p>
<h4 id="弹性的行组大小">弹性的行组大小</h4>
<p>I/O性能是RCFile关注的重点，因此RCFile需要行组够大并且大小可变。行组大小和下面几个因素相关。</p>
<p>1、行组大的话，数据压缩效率会比行组小时更有效。根据对Facebook日常应用的观察，当行组大小达到一个阈值后，增加行组大小并不能进一步增加Gzip算法下的压缩比。</p>
<p>2、行组变大能够提升数据压缩效率并减少存储量。因此，如果对缩减存储空间方面有强烈需求，则不建议选择使用小行组。需要注意的是，当行组的大小超过4MB，数据的压缩比将趋于一致。</p>
<p>3、尽管行组变大有助于减少表格的存储规模，但是可能会损害数据的读性能，因为这样减少了Lazy解压带来的性能提升。而且行组变大会占用更多的内存，这会影响并发执行的其他MapReduce作业。考虑到存储空间和查询效率两个方面，Facebook选择4MB作为默认的行组大小，当然也允许用户自行选择参数进行配置。</p>
<h3 id="参考资料">参考资料</h3>
<p>综合总结：</p>
<p>https://www.cnblogs.com/sunpengblog/p/11912958.html#%E4%B8%80%E3%80%81TEXTFILE</p>
<p>sequencefile：</p>
<p>https://www.cnblogs.com/bigdatafly/articles/5037776.html</p>
<p>https://www.aboutyun.com/thread-19639-1-1.html</p>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Comparable和Comparator</title>
    <url>/2021/08/01/Java_ComparableAndComparator/</url>
    <content><![CDATA[<p>Java中Comparable和Comparator两个<strong>接口</strong>的比较。</p>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 45%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Comparable</th>
<th>Comparator</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作用</td>
<td>可以让实现它的类的对象进行比较大小</td>
<td>在类对象的外部制定排序规则，然后作为排序策略参数传递给某些类的对象的构造函数，实现比较大小</td>
</tr>
<tr class="even">
<td>位置</td>
<td>java.lang 包</td>
<td>java.util 包</td>
</tr>
<tr class="odd">
<td>接口中的方法</td>
<td>只有一个方法 compareTo()</td>
<td>JDK 8 以前只有两个方法compare()和equals()，8以后增加多个方法</td>
</tr>
<tr class="even">
<td>使用</td>
<td>public class Test implements Comparable{} 并重写其中的compareTo()方法</td>
<td>数组工具类和集合工具类中提供的工具方法sort方法都给出了含有Comparator接口的重载方法。</td>
</tr>
<tr class="odd">
<td>排序规则</td>
<td>compareTo 方法的返回值有三种情况：e1.compareTo(e2) &gt; 0 即 e1 &gt; e2<br>e1.compareTo(e2) = 0 即 e1 = e2<br>e1.compareTo(e2) &lt; 0 即 e1 &lt; e2</td>
<td>compare函数返回正数就交换传入参数的位置，否则（负数或0）就不交换两者的位置。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="comparable">Comparable</h3>
<p>使用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//名字与价格</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(String name, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当向 TreeSet 中添加 BookBean 时，会调用这个方法进行排序</span></span><br><span class="line"><span class="comment">     * e1.compareTo(e2) &gt; 0 即 e1 &gt; e2</span></span><br><span class="line"><span class="comment">     * e1.compareTo(e2) = 0 即 e1 = e2</span></span><br><span class="line"><span class="comment">     * e1.compareTo(e2) &lt; 0 即 e1 &lt; e2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> another</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object another)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (another <span class="keyword">instanceof</span> Solution) &#123;</span><br><span class="line">            Solution anotherBook = (Solution) another;</span><br><span class="line">            <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比如这里按照书价排序</span></span><br><span class="line">            result = getCount() - anotherBook.getCount();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//或者按照 String 的比较顺序</span></span><br><span class="line">            <span class="comment">//result = getName().compareTo(anotherBook.getName());</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;   <span class="comment">//当书价一致时，再对比书名。 保证所有属性比较一遍</span></span><br><span class="line">                result = getName().compareTo(anotherBook.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一样就返回 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Solution)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Solution bean = (Solution) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getCount() != bean.getCount()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> getName().equals(bean.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 hashCode 的计算方法</span></span><br><span class="line"><span class="comment">     * 根据所有属性进行 迭代计算，避免重复</span></span><br><span class="line"><span class="comment">     * 计算 hashCode 时 计算因子 31 见得很多，是一个质数，不能再被除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用 String 的 hashCode(), 唯一表示一个字符串内容</span></span><br><span class="line">        <span class="keyword">int</span> result = getName().hashCode();</span><br><span class="line">        <span class="comment">//乘以 31, 再加上 count</span></span><br><span class="line">        result = <span class="number">31</span> * result + getCount();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BookBean&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, count=&quot;</span> + count +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="comparator">Comparator</h3>
<p>compare函数返回正数就交换传入参数的位置，否则（负数或0）就不交换两者的位置。</p>
<p>因此，对于compare(Object o1, Object o2)来说，如果写成 return o1 - o2 则为升序，反之为降序。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Character&gt; letters = <span class="keyword">new</span> ArrayList&lt;&gt;(str.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">//将英文字母先排序好</span></span><br><span class="line"><span class="comment">//此处的意思是，o1 - o2如果是负数，则o1&lt;o2，不交换两者的位置，小的数o1依旧排在前面，所以这样是升序</span></span><br><span class="line"><span class="comment">//也是默认的</span></span><br><span class="line">letters.sort(<span class="keyword">new</span> Comparator&lt;Character&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Character o1, Character o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Character.toLowerCase(o1) - Character.toLowerCase(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处的意思是，o2 - o1如果是负数，则o2&lt;o1，不交换两者的位置，小的数o2依旧排在后面，所以这样是降序</span></span><br><span class="line"><span class="comment">//o2 - o1如果是正数，则o2&gt;o1，交换两者的位置，大的数o2旧排在前面，所以这样是降序</span></span><br><span class="line">letters.sort(<span class="keyword">new</span> Comparator&lt;Character&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Character o1, Character o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Character.toLowerCase(o2) - Character.toLowerCase(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>数组工具类和集合工具类中提供的工具方法sort方法都给出了含有Comparator接口的重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(T[],Comparator&lt;? <span class="keyword">super</span> T&gt; c);</span><br><span class="line">Collections.sort(List&lt;T&gt; list,Comparator&lt;? <span class="keyword">super</span> T&gt; c);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java FullGC</title>
    <url>/2021/09/18/Java_FullGC/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Full GC排查</td>
<td>1、查看GC日志<br>2、jstat命令查看实时GC，判断老年代占用空间<br>3、通过jmap命令获取dump文件<br>4、通过JVisualVM分析对象的引用链的方式来定位具体频繁创建对象的地方</td>
</tr>
<tr class="even">
<td>常见FullGC情况</td>
<td>1、System.gc()方法的调用 <br>2、老年代空间不足<br>3、方法区空间不足<br>4、CMS GC时出现promotion failed和concurrent mode failure<br>5、堆中分配很大的对象（代码中频繁地去分配大对象）</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="背景">背景</h3>
<p>GC就是Java的垃圾回收机制，通常来说，GC主要针对的是堆(java heap)区。</p>
<p>Java heap是分代的（年轻代和老年代），分代就是为了优化性能，如果不分代，那就会导致所有对象揉在一块，那样GC就会对堆区域进行全扫描。因此，分代可以大大提升GC性能。</p>
<p>分代的原理就是根据堆中对象的存活周期进行分代，年轻代中，每次垃圾回收都有大批对象死去，只有少量存活，而老年代中存放的对象存活率高。</p>
<p>Full GC：无官方定义，通常意义上而言指的是一次特殊GC的行为描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等。</p>
<p>但是实际情况中，我们主要看的是gc.log日志，其中也会发现在部分gc日志头中也有Full GC字眼，此处表示含义是在这次GC的全过程中，都是STW的状态，也就是说在这次GC的全过程中所有用户线程都是处于暂停的状态。</p>
<h3 id="full-gc排查">Full GC排查</h3>
<p>1、查看GC日志</p>
<p><img src="/2021/09/18/Java_FullGC/image-20210918110533578.png" alt="image-20210918110533578" style="zoom: 80%;"></p>
<p>2、jstat命令查看实时GC</p>
<p>使用jstat -gcutil 5280 1000查看实时GC情况，年老代采用的是CMS收集器，发现触发Full GC的原因是年老代占用空间达到指定阈值70%（-XX:CMSInitiatingOccupancyFraction=70）。</p>
<p>3、通过jmap命令获取dump文件，通过jvisualvm分析对象的引用链</p>
<p>通过jmap -dump:format=b,file=temp.dump 5280 dump文件，然后下载到本地通过jvisualvm分析对象的引用链的方式来定位具体频繁创建对象的地方，dump文件下载下来有5G多，整个导入过程都花了10多分钟。想查看所占空间较多对象的引用链，直接OOM了，dump对象太大了。这时候就换了种思路，查看占用空间比较大的一系列对象，看能不能找出什么端倪。占用空间最大的几类对象如下图：</p>
<p><img src="/2021/09/18/Java_FullGC/image-20210918111100815.png"></p>
<blockquote>
<p>java dump heap 是分配给实例类和数组对象运行数据区，所有java线程在运行期间共享heap中的数据。Java heap dump相当于java应用在运行的时候在某个时间点上打了个快照(snapshot)。</p>
<p>Dump文件是进程的内存镜像，可以把程序的执行状态保存在dump文件中。</p>
<p>jmap命令(Java Memory Map)是其中之一。主要用于打印指定Java进程(或核心文件、远程调试服务器)的共享对象内存映射或堆内存细节。jmap命令可以获得运行中的jvm的堆的快照。</p>
<p>JVisualVM是JDK自带的JVM性能检测工具，路径在%JAVA_HOME%/bin下面。</p>
</blockquote>
<h3 id="常见fullgc情况">常见FullGC情况</h3>
<p>1、System.gc()方法的调用</p>
<p>2、老年代空间不足</p>
<p>3、方法区空间不足</p>
<p>4、CMS GC时出现promotion failed和concurrent mode failure</p>
<p>5、堆中分配很大的对象（代码中频繁地去分配大对象）</p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/weixin_39309402/article/details/104756815</p>
<p>https://www.cnblogs.com/w-y-c-m/p/9919717.html</p>
<p>https://zhuanlan.zhihu.com/p/119401318</p>
<p>https://zhuanlan.zhihu.com/p/66492995</p>
<p>https://blog.csdn.net/tianya3530/article/details/88309852</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java原理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java位运算</title>
    <url>/2021/04/12/Java_%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h3 id="位运算">位运算</h3>
<p>计算机里面任何数据本质上是用二进制（0 1）来保存的数字。位运算就是直接对二进制类型的数据进行计算。</p>
<a id="more"></a>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&amp;</td>
<td>与</td>
<td>两位都为1，结果为1</td>
</tr>
<tr class="even">
<td>|</td>
<td>或</td>
<td>有一位为1，结果为1</td>
</tr>
<tr class="odd">
<td>~</td>
<td>非</td>
<td>~0 = 1， ~1 = 0</td>
</tr>
<tr class="even">
<td>^</td>
<td>异或</td>
<td>两位不相同，结果为1</td>
</tr>
<tr class="odd">
<td>&lt;&lt;</td>
<td>左移</td>
<td>二进制位全部左移，高位丢弃，低位补0</td>
</tr>
<tr class="even">
<td>&gt;&gt;</td>
<td>右移</td>
<td>二进制位全部右移，无符号数高位补零，有符号数补符号位或零（根据编译器）</td>
</tr>
</tbody>
</table>
<h3 id="常用位操作">常用位操作</h3>
<ul>
<li><p>判断奇偶</p>
<p>(x &amp; 1) == 1 等价 (x % 2 == 1)</p>
<p>(x &amp; 1) == 0 等价 (x % 2 == 0)</p></li>
<li><p>除以二</p>
<p>x &gt;&gt; 1 等价 x / 2</p></li>
<li><p>把最低位的二进制1去掉</p>
<p>x &amp;= (x - 1)</p></li>
<li><p>得到最低位的1</p>
<p>x &amp; -x</p>
<blockquote>
<p>-x的运算是，所有位置取反，然后+1</p>
<p>保留二进制下最后出现的1的位置，其余位置置0</p>
<p>https://www.cnblogs.com/yzxag/p/12668034.html</p>
</blockquote></li>
<li><p>得到0</p>
<p>x &amp; ~x == 0</p></li>
</ul>
<h3 id="指定位置的位运算">指定位置的位运算</h3>
<p>https://leetcode-cn.com/problems/power-of-two/solution/5chong-jie-fa-ni-ying-gai-bei-xia-de-wei-6x9m/</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2021/09/05/Java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 24%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>缓存一致性问题</td>
<td>各个CPU<strong>核中的缓存数据不一致</strong>导致计算结果不正确的问题。</td>
</tr>
<tr class="even">
<td>Java内存模型（JMM）</td>
<td>是Java 定义的<strong>一套协议</strong>，用来屏蔽各种硬件和操作系统的内存访问差异，让Java 程序在各种平台都能有数据一致性的运行效果，解决缓存一致性的问题。</td>
</tr>
<tr class="odd">
<td>JMM协议的内容</td>
<td>1、所有的变量都存储在主内存中，每个线程还有自己的工作内存。<br><br>2、线程的工作内存中保存了该线程使用到的变量（主内存的拷贝），线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。<br><br>3、不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。</td>
</tr>
<tr class="even">
<td>Volatile的作用</td>
<td>Java语言通过 volatile 修饰变量实现内存可见性，它强制修改后的变量写入主存，避免前后指令的CPU重排序，并及时让其他核中的相应缓存行失效，volatile是利用MESI达到符合预期的效果。</td>
</tr>
<tr class="odd">
<td>可见性</td>
<td>可见性是指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改后的值。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="背景">背景</h3>
<h4 id="冯诺依曼体系">冯诺依曼体系</h4>
<p><img src="/2021/09/05/Java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20210905103704864.png" alt="image-20210905103704864" style="zoom: 45%;"></p>
<p>冯洛伊曼体系结构定义了最基本的计算机组成模块，核心的就是由运算器和控制器组成的中央处理器（Central Process Unit，CPU）。</p>
<h4 id="多核及缓存的出现">多核及缓存的出现</h4>
<p><strong>多核</strong></p>
<p>单核CPU 能够容纳的晶体管数量增长后，会造成芯片能源消耗太大，以及发热量太高的问题，从而导致摩尔定律失效。</p>
<blockquote>
<p>摩尔定律：集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。</p>
</blockquote>
<p>针对这样的问题，解决方案不再是增加单核CPU上的晶体管数量，而是采用多个核心的方案，即单个处理器多个运算核心，对外像是只有一个核心在工作一样。</p>
<p><strong>缓存</strong></p>
<p>另一个问题是，冯洛伊曼体系存在缺陷，即CPU 运算器的运算速度远比内存读写速度快，所以CPU 大部分时间都在等待数据从内存中读取或是将数据写入内存。</p>
<p>针对这样的问题，解决方案是在CPU 和主存之间加了一层<strong>读写速度尽可能接近CPU 运行速度的高速缓存</strong>来做数据缓冲。</p>
<p>这样缓存提前从主存获取数据，CPU 不再从主存取数据，而是从缓存取数据。这样就缓解由于主存速度太慢导致的CPU 饥饿的问题。同时CPU 内还有寄存器，一些计算的中间结果临时放在寄存器内。</p>
<blockquote>
<p>缓存能够缓解CPU饥饿（等待数据读取或写入数据时空闲）的前提：</p>
<p>1、时间局部性原理：如果一个主存数据正在被访问，那么在近期它被再次访问的概率非常大。即程序80%的时间在运行20% 的代码，所以缓存本质上只要把20%的常用数据和指令放进来就可以了。</p>
<p>2、空间局部性原理：CPU使用到某块内存区域数据，这块内存区域后面临近的数据很大概率立即会被使用到。程序经常用的数组、集合（本质也是数组）经常会顺序访问（内存地址连续或邻近）。</p>
<p>正因为有了这两个前提条件，所以提前将数据缓存到高速缓存中，就能加快CPU读取数据的速度，这是和直接从内存读取数据的区别。</p>
</blockquote>
<p><strong>多核与缓存</strong></p>
<p>多核心CPU架构为：</p>
<p><img src="/2021/09/05/Java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20210905105237295.png" alt="image-20210905105237295" style="zoom:50%;"></p>
<p>其中，现代操作系统一般会有多级缓存（Cache Line），一般有L1、L2，甚至有L3，下图是的电脑缓存信息，一共4核，三级缓存，L1 缓存（在CPU核心内）这里没有显示出来，这里L2 缓存后面括号标识了是每个核都有L2 缓存，而L3 缓存没有标识，是因为L3 缓存是4个核共享的缓存：</p>
<p><img src="/2021/09/05/Java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20210905105450365.png" alt="image-20210905105450365" style="zoom:50%;"></p>
<h4 id="缓存一致性问题">缓存一致性问题</h4>
<p>数据在主存、缓存、CPU寄存器之间的流转过程，以 i = i + 2; 为例</p>
<p>1、当线程执行到这条语句时，会先从主存中读取i 的值。</p>
<p>2、然后<strong>复制一份</strong>到缓存中。</p>
<p>3、CPU 读取缓存数据（取数指令），进行 i + 2 操作（中间数据放寄存器）。</p>
<p>4、然后把结果写入缓存。</p>
<p>5、最后将缓存中i最新的值刷新到主存当中（写回主存时间不确定）。</p>
<p>在多线程、多核环境下运行：</p>
<p><img src="/2021/09/05/Java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20210905105949502.png" alt="image-20210905105949502" style="zoom: 67%;"></p>
<p>1、有A、B二个线程，在二个不同的CPU 上运行，每个线程运行的CPU 都有自己的缓存，i是共享变量。</p>
<p>2、初始值是0，A 线程从内存读取i 的值存入缓存，B 线程此时也读取i 的值存入自己CPU的缓存。</p>
<p>3、A 线程对i 进行+1操作，i变成了1，B线程缓存中的变量 i 还是0，B线程也对i 进行+1操作。</p>
<p>4、最后A、B线程先后将缓存数据写回内存共享区，预期的结果应该是2，因为发生了二次+1操作，但是实际是1。</p>
<p>这就是多CPU下的缓存一致性问题，本质上就是各个CPU<strong>核中的缓存数据不一致</strong>。</p>
<blockquote>
<p>多CPU的缓存一致性问题，和多线程共享变量安全问题不相同。</p>
<p>单核CPU 的多线程也会出现上面的线程不安全的问题，只是产生原因不是多核CPU缓存不一致的问题导致，而是CPU调度线程切换，<strong>多线程局部变量不同</strong>步引起的。</p>
</blockquote>
<h4 id="解决方案">解决方案</h4>
<p>1、早期的CPU设计中，CPU必须通过总线来访问主存中的数据，因此对总线加锁的话，其他CPU 访问主存就被阻塞了，这样防止了对共享变量的竞争。但是锁总线对CPU的性能损耗非常大，多核CPU 并行的优势就消失了。</p>
<p>2、缓存一致性协议。协议的类型很多（MSI、MESI、MOSI、Synapse、Firefly），最常见的就是Intel （英特尔）的MESI 协议。缓存一致性协议主要规范了CPU 读写主存、管理缓存数据的一系列规范。</p>
<h3 id="java内存模型">Java内存模型</h3>
<h4 id="缓存一致性协议">缓存一致性协议</h4>
<p>缓存一致性协议主要定义了CPU 读写主存、管理缓存数据的一系列规范。协议的类型很多（MSI、MESI、MOSI、Synapse、Firefly），最常见的就是Intel （英特尔）的MESI 协议。</p>
<p>缓存一致性协议（MESI协议）的核心思想：</p>
<p>1、定义了缓存中的<strong>数据状态</strong>只有四种，MESI 是四种状态的首字母。</p>
<p>缓存中数据都是以缓存行（Cache Line）为单位存储；MESI 各个状态描述如下表所示：</p>
<p><img src="/2021/09/05/Java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20210905171913612.png" alt="image-20210905171913612" style="zoom: 67%;"></p>
<p>2、当CPU写数据时，如果写的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU<strong>将该变量的缓存行置为无效状态</strong>。</p>
<p>3、当CPU读取共享变量时，发现自己缓存的该变量的缓存行是无效的，那么它就会从内存中<strong>重新读取</strong>。</p>
<h4 id="volatile的作用">Volatile的作用</h4>
<p>Java语言通过 volatile 修饰变量实现内存可见性，这需要借助MESI协议。</p>
<p>但是有的CPU只有单核、或者不支持MESI，则如何实现内存可见呢？可以是通过锁总线的方式，而不是MESI协议。</p>
<p>因此本质上，volatile屏蔽了硬件的差异，不关心底层操作系统、硬件CPU 是如何实现内存可见性的，是在Java层面实现的关键字。</p>
<p>虚拟机实现volatile的方式是写入了一条lock 前缀的汇编指令，lock 前缀的汇编指令会<strong>强制变量写入主存</strong>，也可避免前后指令的CPU重排序，并<strong>及时让其他核中的相应缓存行失效</strong>，volatile是利用MESI达到符合预期的效果。</p>
<h4 id="java内存模型-1">Java内存模型</h4>
<h5 id="jmm概念">JMM概念</h5>
<p>Java内存模型（ Java Memory Model，JMM）是Java 定义的<strong>一套协议</strong>，用来屏蔽各种硬件和操作系统的内存访问差异，让Java 程序在各种平台都能有数据一致性的运行效果。</p>
<p>JMM协议的内容是：</p>
<p>1、所有的变量都存储在主内存中，每个线程还有自己的工作内存。</p>
<p>2、线程的工作内存中保存了该线程使用到的变量（主内存的拷贝），线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。</p>
<p>3、不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。</p>
<h5 id="为什么需要jmm">为什么需要JMM</h5>
<p>CPU 有X86（复杂指令集）、ARM（精简指令集）等体系架构，版本类型也有很多种。</p>
<p>CPU 可能通过锁总线、MESI 协议实现多核心缓存的一致性。</p>
<p>因为有硬件的差异以及编译器和处理器的指令重排优化的存在，所以Java 需要一种协议来规避硬件平台的差异，保障同一段代码在所有平台运行效果一致（主要是解决缓存一致性问题），这个协议叫做Java 内存模型（Java Memory Model）</p>
<h5 id="jmm与真实内存架构">JMM与真实内存架构</h5>
<p><img src="/2021/09/05/Java_%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20210905173955587.png" alt="image-20210905173955587" style="zoom:67%;"></p>
<table>
<thead>
<tr class="header">
<th>JMM<br>(Java内存模型，JVM定义)</th>
<th>真实内存</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>线程私有的本地内存线程栈</td>
<td>CPU 寄存器、缓存和主存</td>
</tr>
<tr class="even">
<td>堆内存</td>
<td>CPU 寄存器、缓存和主存</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="jmm-内存模型规范">JMM 内存模型规范</h5>
<p>1、初始变量首先存储在主内存中；</p>
<p>2、线程操作变量需要从主内存拷贝到线程本地内存中；</p>
<p>3、线程的本地工作内存是一个抽象概念，包括了缓存、寄存器、store buffer(CPU内的缓存区域)等。</p>
<p>一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了八种操作（单一操作都是原子的）来完成。</p>
<blockquote>
<p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p>
<p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量解除锁定，解除锁定后的变量才可以被其他线程锁定。</p>
<p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。</p>
<p>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
<p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p>
<p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
<p>store（有的指令是save/存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</p>
<p>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p>
</blockquote>
<p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>
<p>1、如果要把一个变量从主内存中复制到工作内存，需要顺序执行read 和load 操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store 和write 操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行，也就是操作不是原子的，一组操作可以中断。</p>
<p>2、不允许read和load、store和write操作之一单独出现，必须成对出现。</p>
<p>3、不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</p>
<p>4、不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</p>
<p>5、一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。</p>
<p>6、如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。</p>
<p>7、如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</p>
<p>8、对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</p>
<h5 id="并发编程的三个特性">并发编程的三个特性</h5>
<p>可见性：</p>
<p>可见性是指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改后的值。</p>
<p>原子性：</p>
<p>原子性指的一个操作或一组操作要么全部执行，要么全部不执行。</p>
<p>有序性：</p>
<p>有序性是指程序执行的顺序按照代码的先后顺序执行。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://mp.weixin.qq.com/s/kpOXHhVLFa0_LxjQBhrNvg</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java原理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java可重入锁</title>
    <url>/2021/09/15/Java_%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
    <content><![CDATA[<p>可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。</p>
<p>Java中synchronized关键字和ReentrantLock都是可重入的锁。</p>
<p>如果锁不可重入，则当有如下情况时会产生死锁：</p>
<a id="more"></a>
<p>1、递归调用</p>
<p>自己调用自己时，因为自身已经获得了这个对象的锁，如果不能再加锁的话，就会导致线程一直在等待自己释放锁，就会产生死锁。</p>
<p>2、此线程调用同一对象其它synchronized或者有同步锁函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，如果synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁，导致死锁发生。</p>
<p>为什么说java中的reentrantlock的效率要比synchronise的效率高？</p>
<p>synchronized和lock在阻塞线程时都需要上下文切换，但是lock锁有优化策略，减少了线程被阻塞的几率。早期的synchronized是一把重量级锁，没有优化机制，可以说只要有线程竞争，竞争失败的线程一定会被阻塞，而reentrantlock对于那些竞争失败的线程，并不会直接阻塞，而是会尝试重新获得锁（自旋锁），如果这时候加锁成功，则线程就无需阻塞，相当于做了一定的优化。直到 jdk1.6 之后，两种锁的性能已经相差无几，甚至 Synchronized 的自动释放锁会更好用。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/papamilk/article/details/80836268</p>
<p>https://www.zhihu.com/question/53444947</p>
<p>https://zhuanlan.zhihu.com/p/336248650</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java原理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基本数据类型</title>
    <url>/2021/09/23/Java_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<table style="width:100%;">
<colgroup>
<col style="width: 3%">
<col style="width: 29%">
<col style="width: 24%">
<col style="width: 23%">
<col style="width: 16%">
<col style="width: 2%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>占位</th>
<th>最大值</th>
<th>最小值</th>
<th>默认值</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>byte</td>
<td>8 bit<br>1 byte</td>
<td>127（<span class="math inline">\(2^7-1\)</span>）</td>
<td>-128（<span class="math inline">\(-2^7\)</span>）</td>
<td>0</td>
<td>有</td>
</tr>
<tr class="even">
<td>short</td>
<td>16 bit<br>2 byte</td>
<td>32767（<span class="math inline">\(2^{15} - 1\)</span>）</td>
<td>-32768（<span class="math inline">\(-2^{15}\)</span>）</td>
<td>0</td>
<td>有</td>
</tr>
<tr class="odd">
<td>int</td>
<td>32 bit<br>4 byte</td>
<td>2,147,483,647（<span class="math inline">\(2^{31} - 1\)</span>）</td>
<td>-2,147,483,648（<span class="math inline">\(-2^{31}\)</span>）</td>
<td>0</td>
<td>有</td>
</tr>
<tr class="even">
<td>long</td>
<td>64 bit<br>8 byte</td>
<td>9,223,372,036,<br>854,775,807（<span class="math inline">\(2^{63} -1\)</span>）</td>
<td>-9,223,372,036,<br>854,775,808（<span class="math inline">\(-2^{63}\)</span>）</td>
<td>0</td>
<td>有</td>
</tr>
<tr class="odd">
<td>float</td>
<td>32 bit<br>4 byte</td>
<td></td>
<td></td>
<td>0.0f</td>
<td>有</td>
</tr>
<tr class="even">
<td>double</td>
<td>64 bit<br>8 byte</td>
<td></td>
<td></td>
<td>0.0d</td>
<td>有</td>
</tr>
<tr class="odd">
<td>char</td>
<td>16 bit<br>2 byte</td>
<td>（65535）</td>
<td>（0）</td>
<td>需要初始化，<br>否则编译错误。</td>
<td>无</td>
</tr>
<tr class="even">
<td>boolean</td>
<td>规范情况下<br>单独使用：4 byte<br>boolean数组：1 byte</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>无</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="参考资料">参考资料</h3>
<p>https://zhuanlan.zhihu.com/p/138648453 (boolean)</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程编程题</title>
    <url>/2021/04/18/Java_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
    <content><![CDATA[<p>交替打印奇偶数、十个线程实现1~100求和</p>
<a id="more"></a>
<h3 id="交替打印奇偶数">交替打印奇偶数</h3>
<h4 id="仅通过synchronized关键字实现">仅通过synchronized关键字实现</h4>
<p>创建两个线程，一个线程负责打印奇数，另一个线程打印偶数，两个线程竞争同一个对象锁，每次打印一个数字后释放锁，然后另一个线程拿到锁打印下一个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOddEven1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">						<span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;偶数线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">						<span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;奇数线程&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="synchronized关键字配合wait和notify方法">synchronized关键字配合wait和notify方法</h4>
<p>无需判断数字是否是奇偶数，两个线程通过等待唤醒机制，交替打印数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOddEven2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> printer(), <span class="string">&quot;偶数线程，&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> printer(), <span class="string">&quot;奇数线程，&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">					<span class="comment">// 打印数字，并立即释放锁</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印:&quot;</span> + count++);</span><br><span class="line">					object.notify();</span><br><span class="line">					<span class="comment">// 此处判断，是为了打印完了100个数字后，程序能够正常结束，否则程序将一直等待下去，耗费系统资源。</span></span><br><span class="line">					<span class="keyword">if</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							object.wait();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十个线程实现1100求和">十个线程实现1~100求和</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程都有一个startnum，0，10，20...90</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> startnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有线程共用一个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch latch; <span class="comment">//同步器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程初始化自己的startnum</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        startnum = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个线程不能同时执行这个加法（但是其实同时也无所谓？）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;    <span class="comment">// public static synchronized void add(int num)</span></span><br><span class="line">        sum = sum + num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//重写这个run方法执行累加操作</span></span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            tmp = tmp + (startnum + i); <span class="comment">//从startnum开始做加法，比如第二组：0 + （11+0） +（11+1）+（11+2）+...+(11+9) = 11 + 12 + 13 + ... + 20</span></span><br><span class="line">        &#125;</span><br><span class="line">        add(tmp); <span class="comment">//把结果加到总和中</span></span><br><span class="line"></span><br><span class="line">        latch.countDown(); <span class="comment">//递减计数器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程数量</span></span><br><span class="line">        <span class="keyword">int</span> tc = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//创建计数器</span></span><br><span class="line">        latch = <span class="keyword">new</span> CountDownLatch(tc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建线程数组</span></span><br><span class="line">        Thread[] threadArray = <span class="keyword">new</span> Thread[tc];</span><br><span class="line">        <span class="comment">//创建线程并运行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tc; i++)&#123;</span><br><span class="line">            threadArray[i] = <span class="keyword">new</span> ThreadTest(i*<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">            threadArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">//等待所有线程递减 CountDownLatch</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1 + 2 + 3 + ... + 100 = &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环打印abc">循环打印ABC</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.javatest.theardTest.MultiThreadAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编写一个程序，启动三个线程，三个线程的ID分别是A，B，C；，每个线程将自己的ID值在屏幕上打印5遍，打印顺序是ABCABC...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABCABCABC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ABCABCABC abcabcabc = <span class="keyword">new</span> ABCABCABC();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                abcabcabc.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                abcabcabc.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                abcabcabc.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/x541211190/article/details/109402864（交替打印奇偶数）</p>
<p>//https://blog.csdn.net/jy_z11121/article/details/84490436?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs （十个线程实现1~100求和）</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中类型相互转换</title>
    <url>/2021/04/01/Java_%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="char转int">char转int</h4>
<p>在Java中用2个字节，即16位，来表示一个char。</p>
<a id="more"></a>
<ul>
<li><p>当char为数字时</p>
<p>即'0'、'1'、'2'、'3'...、'9'时，则直接减去'0'可以得到对应的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> nine = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="string">&#x27;9&#x27;</span> - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//num即得到9</span></span><br></pre></td></tr></table></figure></li>
<li><p>当char为其他字符时</p>
<p>使用强制类型转换即可获得该字符表示的ASCII 编码。</p>
<p>字符<strong>0-9</strong>的ASCII码：48-57；</p>
<p>大写字母<strong>A-Z</strong>的ASCII码为：65-90；</p>
<p>小写字母<strong>a-z</strong>的ASCII码为：97-122；</p>
<p><strong>空字符</strong>的ASCII码为0；</p>
<p><strong>换行符</strong>的ASCII码为10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> tmp = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)tmp; <span class="comment">//num此时为&#x27;a&#x27;的ASCII 编码97</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="int转char">int转char</h4>
<ul>
<li><p>当int为两位以上的数字时，使用强制类型转换将变成该数字代表的ASCII码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">97</span>;</span><br><span class="line"><span class="keyword">char</span> ca = (<span class="keyword">char</span>)num; <span class="comment">//ca此时就代表了小写字母&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>当int为0到9的数字时，利用ASCII码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">char</span> ca = (<span class="keyword">char</span>)(num+<span class="number">48</span>) <span class="comment">//ca此时就代表了数字&#x27;9&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>先将int转为String，再转成char，可以将数字拆开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">4596</span>;</span><br><span class="line">String str = String.valueOf(num);</span><br><span class="line"><span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">	System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5 9 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="char转string">char转String</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = String.valueOf(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//char数组转String</span></span><br><span class="line"><span class="keyword">char</span>[] s=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">String st=String.valueOf(s);</span><br></pre></td></tr></table></figure>
<h4 id="string转char">String转char</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] array = str.toCharArray();</span><br></pre></td></tr></table></figure>
<h4 id="string转int">String转int</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;6666&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num = Integer.valueOf(str);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当str非数字时报出运行时异常</span></span><br><span class="line"><span class="comment">java.lang.NumberFormatException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stirng数组转int数组，利用Java 8中的stream方法</span></span><br><span class="line">String[] strings = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] array = Arrays.stream(strings).mapToInt(Integer::parseInt).toArray();</span><br></pre></td></tr></table></figure>
<h4 id="int转string">int转String</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">6666</span>;</span><br><span class="line">String str = String.valueOf(num);</span><br></pre></td></tr></table></figure>
<h4 id="string转arraylistinteger">String[]转ArrayList&lt;Integer&gt;</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//String数组先转int[]</span></span><br><span class="line"><span class="keyword">int</span>[] arr = Arrays.stream(strings).mapToInt(Integer::parseInt).toArray();</span><br><span class="line"><span class="comment">//int[]转ArrayList&lt;Integer&gt;</span></span><br><span class="line">ArrayList&lt;Integer&gt; collect = (ArrayList&lt;Integer&gt;) Arrays.stream(arr).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java从编译到执行</title>
    <url>/2021/09/01/Java_%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Java跨平台</td>
<td>通过JVM实现，JVM本身与平台有关。</td>
</tr>
<tr class="even">
<td>Java从编译到执行</td>
<td>编译：源码编译为.class文件<br>加载：将编译后的.class文件加载到 JVM 中<br>解释：把字节码转换成操作系统可识别的执行指令<br>执行：调用系统的硬件执行最终的程序指令</td>
</tr>
<tr class="odd">
<td>Java/C++速度比较</td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="java跨平台">Java跨平台</h3>
<p>Java跨平台通过Java虚拟机（JVM）实现。Java源代码会被编译为.class文件，JVM负责把.class字节码文件解释成各个操作系统所能够识别的指令并执行，JVM本身是和操作系统有关的，因此通过JVM实现跨平台执行。</p>
<h3 id="java从编译到执行">Java从编译到执行</h3>
<p>Java源码到执行的过程，从JVM的角度看可以总结为四个步骤：编译-&gt;加载-&gt;解释-&gt;执行。</p>
<h4 id="编译">编译</h4>
<p>将源码编译成JVM可以解释的class文件。</p>
<p>Java源代码文件经过 语法分析、语义分析、注解处理，最后生成.class字节码文件。</p>
<h4 id="加载">加载</h4>
<p>将编译后的class文件加载到JVM中。</p>
<p>加载又可以细分步骤为：加载-&gt;连接-&gt;初始化。</p>
<ul>
<li>加载：把.class文件加载至JVM。查找并加载类的二进制数据，在JVM堆中创建一个java.lang.Class类的对象，并将类相关的信息存储在JVM方法区中。
<ul>
<li>加载时机：为了节省内存开销，不会一次性把所有类都加载至JVM，而是等到有需要的时候才进行加载。（比如new和反射等等）</li>
<li>加载发生：.class文件通过类加载器加载到JVM，为了防止内存中出现多个同样的字节码，使用双亲委派机制加载类。</li>
<li>加载规则：JDK中的本地方法一般由根加载器（Bootstrap Loader）加载，JDK中内部实现的扩展类一般由扩展类加载器加载，而程序中的类文件则由系统类加载器加载。</li>
</ul></li>
<li>连接：对.class的信息进行验证，为类的静态变量分配内存空间并对其赋默认值。连接里又可以细化为：验证、准备、解析。
<ul>
<li>验证：验证类是否符合Java规范和JVM规范</li>
<li>准备：为类的静态变量分配内存，初始化为系统的初始值</li>
<li>解析：将符号引用转为直接引用的过程。</li>
</ul></li>
<li>初始化：为类的静态变量赋值为正确的初始值。收集.class的静态变量、静态代码块、静态方法到clinit()方法，然后从上往下执行。如果实例化对象，则会调用方法对实例变量进行初始化，并执行相应的构造方法。</li>
</ul>
<blockquote>
<p>初始化具体过程：</p>
<p>将一个类中所有被static关键字标识的代码统一执行一遍，如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值。</p>
<p>如果执行的是static代码块，那么在初始化阶段，JVM就会执行static代码块中定义的所有操作。</p>
<p>所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就是<clinit>方法，即类/接口初始化方法。该方法的作用就是初始化变量，使用用户指定的值覆盖之前在准备阶段里设定的初始值。任何invoke之类的字节码都无法调用<clinit>方法，因为该方法只能在类加载的过程中由JVM调用。</clinit></clinit></p>
<p>如果父类还没有被初始化，那么优先对父类初始化，但在<clinit>方法内部不会显示调用父类的<clinit>方法，由JVM负责保证一个类的<clinit>方法执行之前，它的父类<clinit>方法已经被执行。</clinit></clinit></clinit></clinit></p>
</blockquote>
<h4 id="解释">解释</h4>
<p>解释，就是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器（JIT）两种解释的方式。</p>
<p>在解释时会对代码进行分析，查看是否为「热点代码」（某个方法或代码块的运行特别频繁），如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度。</p>
<p>使用热点探测来检测是否为热点代码。热点探测一般有两种方式：计数器和抽样。HotSpot使用计数器的方式进行探测，为每个方法准备方法调用计数器和回边计数器，当计数器超过阈值时就会触发JIT编译，JIT将热点方法的指令码保存起来，下次执行的时候就无需进行重复解释，直接执行缓存的机器指令。</p>
<h4 id="执行">执行</h4>
<p>调用系统的硬件执行最终的程序指令。</p>
<h3 id="javac速度比较">Java/C++速度比较</h3>
<p>1、Java是解释性语言，java程序在运行时类加载器从类路经中加载相关的类，然后java虚拟机读取该类文件的字节，执行相应操作。而C++编译的时候将程序编译成本地机器码。一般来说java程序执行速度要比C++慢10-30倍。即使采用just-in-time compiling （读取类文件字节后，编译成本地机器码）技术，速度也要比C++慢好多。</p>
<p>2、在程序运行过程中，java虚拟机要检测数组是否越界，在C++中则不检测。</p>
<p>l java中所有的对象都创建在堆中，没有对象被创建在stack中，而C++有的对象和变量是创建在stack中的</p>
<p>l java在运行过程中检测对象的引用是否为空，如果引用指向都空指针，且执行某个方法时会抛出空指针异常</p>
<p>l java运行时对类型检测，如果类型不正确会抛出ClassCastException异常。</p>
<p>l java的垃圾回收机制较C++由程序员管理内存效率更低。</p>
<p>l java中的原始数据类型在每个操作系统平台长度都是相同，而C++这些数据类型长度是随操作系统的不同而不同，所以java在不同操作系统上执行时有个转化过程。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://mp.weixin.qq.com/s?__biz=MzU4NzA3MTc5Mg==&amp;mid=2247484557&amp;idx=1&amp;sn=6fb103a2a322effc564fbb04c3b93a6c&amp;chksm=fdf0ecd2ca8765c4eacc22e54b4bc57888555efee99f1c7e57ee611e07d220b35b2aa658a4ca&amp;token=830702193&amp;lang=zh_CN&amp;scene=21#wechat_redirect</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java原理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合操作</title>
    <url>/2021/04/11/Java_%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="java集合操作">Java集合操作</h3>
<p>遍历集合、Map类型数据排序</p>
<a id="more"></a>
<h3 id="遍历集合">遍历集合</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map.Entry遍历</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : tempMap.entrySet()) &#123;</span><br><span class="line">   String key = entry.getKey().toString();</span><br><span class="line">   String value = entry.getValue().toString();</span><br><span class="line">   System.out.println(<span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot; value=&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//keySet()遍历</span></span><br><span class="line">  <span class="keyword">for</span> (Object o : tempMap.keySet()) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;key=&quot;</span> + o + <span class="string">&quot; value=&quot;</span> + tempMap.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map类型数据排序">Map类型数据排序</h3>
<p>注意TreeSet、TreeMap本身的Key就是按照字典序进行排序的。</p>
<h4 id="完整方法">完整方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapKeySort</span><span class="params">(HashMap&lt;Integer, String&gt; hm)</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//定义一个list装载key、value</span></span><br><span class="line">        List&lt;Map.Entry&lt;Integer, String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;Integer, String&gt;&gt;(hm.entrySet());</span><br><span class="line">        </span><br><span class="line">     	<span class="comment">//对list进行排序，自定义排序规则</span></span><br><span class="line">     	list.sort(<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Integer, String&gt; o1, Map.Entry&lt;Integer, String&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getKey() &lt; o2.getKey() ? <span class="number">1</span> : ((o1.getKey() == o2.getKey()) ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     </span><br><span class="line">     	<span class="comment">/*打印结果查看</span></span><br><span class="line"><span class="comment">        for (Map.Entry&lt;Integer, String&gt; mapping : list) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(mapping.getKey() + &quot;:&quot; + mapping.getValue());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后把这个List返回即可</span></span><br></pre></td></tr></table></figure>
<h4 id="简单方法">简单方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取key</span></span><br><span class="line">Object[] key_arr = hashmap.keySet().toArray();   </span><br><span class="line"><span class="comment">//对key排序</span></span><br><span class="line">Arrays.sort(key_arr);   </span><br><span class="line"><span class="comment">//通过key获取value</span></span><br><span class="line"><span class="keyword">for</span>(Object key : key_arr) &#123;   </span><br><span class="line">    Object value = hashmap.get(key);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="arraylist中remove">ArrayList中Remove</h3>
<p>泛型类的类型必须为引用类型，而不能为基础类型。所以传int的时候，会被当做下标值，传Integer的时候，会被视为泛型类。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remove(1) 　　&#x2F;&#x2F;是删除索引为1的元素</span><br><span class="line">remove(new Integer(1))　　&#x2F;&#x2F;则删除元素1</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka经典三问：数据有序、丢失、重复</title>
    <url>/2021/09/15/Kafka_%E6%9C%89%E5%BA%8F%E4%B8%A2%E5%A4%B1%E9%87%8D%E5%A4%8D/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>保证数据有序</td>
<td>1、发送端：不能异步发送。<br>2、Broker端：只能有一个分区，高可用时要同步复制。<br>3、接收端：不能并行消费。</td>
</tr>
<tr class="even">
<td>数据是否丢失</td>
<td>1、发送端：partition向producer发送ack，ack=0不能保证broker一定落盘，ack=1 follower可能丢失。<br>2、Borker：先写缓存再刷盘，宕机丢失。<br>3、接收端：消费者at-most-once语义先提交offset，再消费数据，重启后只能从下一个offset处消费。</td>
</tr>
<tr class="odd">
<td>数据是否重复</td>
<td>Exactly Once语义，Broker端会对&lt; Producer ID, Partition, SeqNumber&gt;做缓存，相同主键只持久化一次。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL实现ACID</title>
    <url>/2021/09/13/MySQL_ACID%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 3%">
<col style="width: 48%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>缩写</th>
<th>解释</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>原子性：事务不可分割，操作要么全执行，要么全不执行</td>
<td>undo log：保存了事务发生之前的数据的一个版本，用于回滚。<br>当事务执行失败或调用了rollback，就会导致事务需要回滚。</td>
</tr>
<tr class="even">
<td>D</td>
<td>持久性：保证事务提交后不会因为宕机等原因导致数据丢失</td>
<td>redo log：当做<strong>数据修改</strong>的时候，不仅在内存中操作，还会在<strong>redo log中记录</strong>这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。<br>redo log是物理日志，内容基于磁盘的Page。<br>当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中。</td>
</tr>
<tr class="odd">
<td>I</td>
<td>隔离性：多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</td>
<td>InnoDB默认的隔离级别是可重复读RR，RR的实现主要为：<br>写操作：锁机制（包含next-key lock）<br>读操作：MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）</td>
</tr>
<tr class="even">
<td>C</td>
<td>一致性：事务执行前后，数据处于一种合法的状态。</td>
<td>数据库层面：数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。<br>应用层面：通过代码判断逻辑是否正确，然后决定回滚还是提交数据。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="参考资料">参考资料</h3>
<p>https://www.cnblogs.com/kismetv/p/10331633.html</p>
<p>https://www.cnblogs.com/rjzheng/p/10841031.html</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL InnoDB数据存储结构</title>
    <url>/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="数据库的存储结构页">数据库的存储结构：页</h3>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220330201455929.png" alt="image-20220330201455929" style="zoom:67%;"></p>
<h4 id="磁盘与内存交互的基本单位">磁盘与内存交互的基本单位</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220330201529222.png" alt="image-20220330201529222" style="zoom:67%;"></p>
<h4 id="索引的叶子节点">索引的叶子节点</h4>
<p>B+树的叶子节点也是以页的方式进行存储：</p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220330201651534.png" alt="image-20220330201651534" style="zoom:80%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220330201834369.png" alt="image-20220330201834369" style="zoom:67%;"></p>
<h4 id="页的大小">页的大小</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220330202324897.png" alt="image-20220330202324897" style="zoom:67%;"></p>
<h4 id="页的上层结构">页的上层结构</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220330202909418.png" alt="image-20220330202909418" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220330203001934.png" alt="image-20220330203001934" style="zoom:67%;"></p>
<p>表空间可以落地到操作系统中具体的一个文件上了。</p>
<h3 id="页的内部结构">页的内部结构</h3>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331101959874.png" alt="image-20220331101959874" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331102113042.png" alt="image-20220331102113042" style="zoom:67%;"></p>
<h4 id="file-header文件头部和-file-trailer文件尾部">File Header（文件头部）和 File Trailer（文件尾部）</h4>
<h5 id="文件头部">文件头部</h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331103643971.png" alt="image-20220331103643971" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331103715031.png" alt="image-20220331103715031" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331103800114.png" alt="image-20220331103800114" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331103857126.png" alt="image-20220331103857126" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331103924381.png" alt="image-20220331103924381" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331104008024.png" alt="image-20220331104008024" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331103451933.png" alt="image-20220331103451933" style="zoom:67%;"></p>
<h5 id="文件尾部">文件尾部</h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331103545816.png" alt="image-20220331103545816" style="zoom:67%;"></p>
<h4 id="user-records用户记录最大最小记录free-space空闲空间">User Records（用户记录）、最大最小记录、Free Space（空闲空间）</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331190255249.png" alt="image-20220331190255249" style="zoom:67%;"></p>
<h5 id="空闲空间">空闲空间</h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331190201358.png" alt="image-20220331190201358" style="zoom:67%;"></p>
<h5 id="用户记录">用户记录</h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331194059907.png" alt="image-20220331194059907" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331190521089.png" alt="image-20220331190521089" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331190544474.png" alt="image-20220331190544474" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331190655455.png" alt="image-20220331190655455" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331191022889.png" alt="image-20220331191022889" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331191223149.png" alt="image-20220331191223149" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331191344682.png" alt="image-20220331191344682" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331191608973.png" alt="image-20220331191608973" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331191717847.png" alt="image-20220331191717847" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331192432327.png" alt="image-20220331192432327" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331192603915.png" alt="image-20220331192603915" style="zoom:67%;"></p>
<p>删除一条记录，底层发生的变化：</p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331192911104.png" alt="image-20220331192911104" style="zoom:67%;"></p>
<p>​ <img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331193037689.png" alt="image-20220331193037689" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331193930717.png" alt="image-20220331193930717" style="zoom:67%;"></p>
<p>添加一条记录，底层发生的变化：</p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331193737787.png" alt="image-20220331193737787" style="zoom:67%;"></p>
<p>直接复用原先被删除记录的空间。</p>
<h5 id="最大最小记录">最大最小记录</h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331191946180.png" alt="image-20220331191946180" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331192205546.png" alt="image-20220331192205546" style="zoom:67%;"></p>
<p>最大最小记录的heap_no属性分别为0和1，表示最大最小记录在本页中前两个位置。</p>
<h4 id="page-directory页目录page-header页面头部">Page Directory（页目录）、Page Header（页面头部）</h4>
<h5 id="页目录">页目录</h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331194500416.png" alt="image-20220331194500416" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331195012000.png" alt="image-20220331195012000" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331195638911.png" alt="image-20220331195638911" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331195507847.png" alt="image-20220331195507847" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331195942356.png" alt="image-20220331195942356" style="zoom:67%;"></p>
<p>页目录结构下如何查找记录：</p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331200514900.png" alt="image-20220331200514900" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331200628989.png" alt="image-20220331200628989" style="zoom:67%;"></p>
<h5 id="页面头部">页面头部</h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331201201657.png" alt="image-20220331201201657" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220331201054849.png" alt="image-20220331201054849" style="zoom:67%;"></p>
<h3 id="b树的查找">B+树的查找</h3>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402194227574.png" alt="image-20220402194227574" style="zoom:67%;"></p>
<h3 id="innodb行格式">InnoDB行格式</h3>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402194308822.png" alt="image-20220402194308822" style="zoom:67%;"></p>
<h4 id="compact">Compact</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402194427160.png" alt="image-20220402194427160" style="zoom:67%;"></p>
<h5 id="变长字段长度列表"><strong>变长字段长度列表</strong></h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402195308017.png" alt="image-20220402195308017" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402195556631.png" alt="image-20220402195556631" style="zoom:67%;"></p>
<h5 id="null值列表"><strong>NULL值列表</strong></h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402195957984.png" alt="image-20220402195957984" style="zoom:67%;"></p>
<p>​ <img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402200037809.png" alt="image-20220402200037809" style="zoom:67%;"></p>
<h5 id="记录的真实数据"><strong>记录的真实数据</strong></h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402200917986.png" alt="image-20220402200917986" style="zoom:67%;"></p>
<h5 id="ibd文件下的真实排列"><strong>ibd文件下的真实排列</strong></h5>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402222030416.png" alt="image-20220402222030416" style="zoom:80%;"></p>
<h4 id="行溢出">行溢出</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404102424914.png" alt="image-20220404102424914" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404102330325.png" alt="image-20220404102330325" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404101153461.png" alt="image-20220404101153461" style="zoom:67%;"></p>
<h4 id="dynamic默认和compressed">Dynamic（默认）和Compressed</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404101241326.png" alt="image-20220404101241326" style="zoom:67%;"></p>
<p>也就是Dynamic（默认）和Compressed格式下，所有的行数据都存放在溢出页上面，而其他格式的行数据会有一部分前缀数据存储在行中。</p>
<h4 id="redundant">Redundant</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404101643820.png" alt="image-20220404101643820" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404101706864.png" alt="image-20220404101706864" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404102140974.png" alt="image-20220404102140974" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404102236508.png" alt="image-20220404102236508" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404102529969.png" alt="image-20220404102529969" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404102637586.png" alt="image-20220404102637586" style="zoom:67%;"></p>
<h4 id="指定行格式">指定行格式</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220402194741993.png" alt="image-20220402194741993" style="zoom:67%;"></p>
<h3 id="页的上层结构区段与碎片区">页的上层结构：区、段与碎片区</h3>
<h4 id="区">区</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404105003148.png" alt="image-20220404105003148" style="zoom:67%;"></p>
<p>从内存中单独读取一个页（1ms/页）：</p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404105709553.png" alt="image-20220404105709553" style="zoom:67%;"></p>
<p>随机I/O（10ms/页）：</p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404105436914.png" alt="image-20220404105436914" style="zoom:67%;"></p>
<p>顺序I/O（0.4ms/页）：</p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404105600300.png" alt="image-20220404105600300" style="zoom:67%;"></p>
<h4 id="段">段</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404110410601.png" alt="image-20220404110410601" style="zoom:67%;"></p>
<p>主要是为了让叶子节点和非叶子节点各自都能连续的存储。</p>
<h4 id="碎片区">碎片区</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404110730333.png" alt="image-20220404110730333" style="zoom:67%;"></p>
<p>碎片区不属于任何一个段，是比段更上层的概念。</p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404111136077.png" alt="image-20220404111136077" style="zoom:67%;"></p>
<h4 id="区的分类">区的分类</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404111613061.png" alt="image-20220404111613061" style="zoom:67%;"></p>
<h4 id="表空间">表空间</h4>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404111909682.png" alt="image-20220404111909682" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404112152138.png" alt="image-20220404112152138" style="zoom:67%;"></p>
<p>注意，MySQL 8.0中frm和ibd文件合并起来存储，所以ibd文件占用7个页面共112K大小。</p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404112639010.png" alt="image-20220404112639010" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404112844010.png" alt="image-20220404112844010" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404113147502.png" alt="image-20220404113147502" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404113340457.png" alt="image-20220404113340457" style="zoom: 67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404113340457.png" alt="image-20220404113340457" style="zoom:67%;"></p>
<p><img src="/2022/03/30/MySQL_InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20220404113512699.png" alt="image-20220404113512699" style="zoom:67%;"></p>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL多版本并发控制机制（MVCC）</title>
    <url>/2022/03/29/MySQL_MVCC/</url>
    <content><![CDATA[<table>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制。</p>
<p>这项技术使得在InnoDB的事务隔离级别下执行<strong>一致性读操作</strong>有了保证。</p>
<p>换言之，就是为了<strong>查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值</strong>，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<h3 id="快照读当前读">快照读/当前读</h3>
<p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁， 非阻塞并发读。</p>
<p>而这个读指的就是快照读, 而非当前读。</p>
<p>当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<h4 id="快照读">快照读</h4>
<p>即读取的是快照数据。这是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>
<p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
<p>不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM player WHERE ...</span><br></pre></td></tr></table></figure>
<h4 id="当前读">当前读</h4>
<p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<p>加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁</span><br><span class="line"></span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line"></span><br><span class="line">INSERT INTO student values ... # 排他锁</span><br><span class="line"></span><br><span class="line">DELETE FROM student WHERE ... # 排他锁</span><br><span class="line"></span><br><span class="line">UPDATE student SET ... # 排他锁</span><br></pre></td></tr></table></figure>
<h3 id="mvcc的组成">MVCC的组成</h3>
<p>在MySQL中，可重复读（RR）是默认的隔离级别。</p>
<p>在SQL标准中，该隔离级别下能解决脏读和不可重复读的问题，但是不能解决幻读问题。</p>
<p>MySQL则在RR级别下，通过MVCC+Next-Key Lock解决幻读问题。</p>
<p>MVCC最主要的实现方式就是依靠<strong>隐藏列、回滚日志undo log和快照视图ReadView</strong>实现的。</p>
<h4 id="隐藏列">隐藏列</h4>
<p>对于使用InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p>
<ul>
<li><strong>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id 赋值给trx_id 隐藏列。</strong></li>
<li><strong>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</strong></li>
</ul>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330103056288.png" alt="image-20220330103056288" style="zoom:67%;"></p>
<blockquote>
<p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p>
</blockquote>
<h4 id="undo-log">undo log</h4>
<p>假设之后两个事务id分别为10 、20 的事务对这条记录进行UPDATE 操作。</p>
<p>每次对记录进行改动，都会<strong>记录一条undo日志</strong>，每条undo日志也都有一个<strong>roll_pointer</strong> 属性（ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表。</p>
<p>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer 属性连接成一个链表，我们把这个链表称之为<strong>版本链</strong>，版本链的头节点就是当前记录最新的值。</p>
<p>每个版本中还包含生成该版本时对应的事务id 。</p>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330103347203.png" alt="image-20220330103347203" style="zoom: 50%;"></p>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330103406120.png" alt="image-20220330103406120" style="zoom:67%;"></p>
<h4 id="readview">ReadView</h4>
<p>快照视图，即当前事务的一个快照。</p>
<p>使用READ UNCOMMITTED 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录 的最新版本就好了。使用SERIALIZABLE 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p>
<p>使用READ COMMITTED 和REPEATABLE READ 隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是<strong>需要判断一下版本链中的哪个版本是当前事务可见的</strong>，这是ReadView要解决的主要问题。</p>
<p>由于MVCC是为了解决读-写冲突的，因此ReadView只会在SELECT操作时生成。</p>
<p>READ COMMITTED ：每次读取数据前都生成一个ReadView。</p>
<p>REPEATABLE READ ：只会在第一次执行查询语句时生成一个ReadView ，之后的查询就不会重复生成了。</p>
<h5 id="结构">结构</h5>
<p>ReadView中主要包含4个比较重要的内容，分别如下： 1. <strong>creator_trx_id ，创建这个 Read View 的事务 ID。</strong>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。 2. <strong>trx_ids</strong> ，表示在生成ReadView时当前系统中<strong>活跃的（活跃指的是未提交的）读写事务</strong>的事务id列表。 3. <strong>up_limit_id</strong> ，活跃的事务中<strong>最小的事务</strong> ID。 4. <strong>low_limit_id</strong> ，表示生成ReadView时系统中<strong>应该分配给下一个事务的id 值</strong>。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p>
<blockquote>
<p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p>
</blockquote>
<h5 id="规则">规则</h5>
<p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p>
<ul>
<li><p>如果被访问版本的<strong>trx_id</strong>属性值与ReadView中的<strong>creator_trx_id</strong> 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</p></li>
<li><p>如果被访问版本的<strong>trx_id</strong>属性值小于ReadView中的<strong>up_limit_id</strong> 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</p></li>
<li><p>如果被访问版本的<strong>trx_id</strong>属性值大于或等于ReadView中的<strong>low_limit_id</strong> 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p></li>
<li><p>如果被访问版本的<strong>trx_id</strong>属性值在ReadView的up_limit_id 和low_limit_id <strong>之间</strong>，那就需要判断一下<strong>trx_id</strong>属性值是不是在<strong>trx_ids</strong> 列表中。</p>
<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。（事务提交并不是顺序的，不同id的事务提交顺序可能不同）</li>
</ul></li>
</ul>
<h3 id="mvcc具体过程">MVCC具体过程</h3>
<p>当查询一条记录的时候，系统如何通过MVCC找到它： 1. 首先获取事务自己的版本号，也就是事务 ID； 2. 获取 ReadView； 3. 查询得到的数据，然后与 ReadView 中的事务版本号进行比较； 4. 如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照； 5. 最后返回符合规则的数据。</p>
<p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。此时同样的查询语句都会重新获取一次 ReadView，这时如果 ReadView 不同，就可能产生不可重复读或者幻读的情况。</p>
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 ReadView。</p>
<h4 id="rc下的案例">RC下的案例</h4>
<p>READ COMMITTED，每次读取数据前都生成一个ReadView。</p>
<p>现在有两个事务id 分别为10 、20 的事务在执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name&#x3D;&quot;李四&quot; WHERE id&#x3D;1;</span><br><span class="line">UPDATE student SET name&#x3D;&quot;王五&quot; WHERE id&#x3D;1;</span><br><span class="line"></span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>此刻，表student 中id 为1 的记录得到的版本链表如下所示：</p>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330152427561.png" alt="image-20220330152427561" style="zoom:67%;"></p>
<p>假设现在有一个使用READ COMMITTED 隔离级别的事务开始执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 10、20未提交</span><br><span class="line">SELECT * FROM student WHERE id &#x3D; 1; # 得到的列name的值为&#39;张三&#39;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330152814882.png" alt="image-20220330152814882" style="zoom:67%;"></p>
<p>把事务id 为10 的事务提交一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE student SET name&#x3D;&quot;李四&quot; WHERE id&#x3D;1;</span><br><span class="line">UPDATE student SET name&#x3D;&quot;王五&quot; WHERE id&#x3D;1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p>再到事务id 为20 的事务中更新一下表student 中id 为1 的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name&#x3D;&quot;钱七&quot; WHERE id&#x3D;1;</span><br><span class="line">UPDATE student SET name&#x3D;&quot;宋八&quot; WHERE id&#x3D;1;</span><br></pre></td></tr></table></figure>
<p>此刻，表student中id 为1 的记录的版本链就长这样：</p>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330152900294.png" alt="image-20220330152900294" style="zoom:67%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 10、20均未提交</span><br><span class="line">SELECT * FROM student WHERE id &#x3D; 1; # 得到的列name的值为&#39;张三&#39;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 10提交，Transaction 20未提交</span><br><span class="line">SELECT * FROM student WHERE id &#x3D; 1; # 得到的列name的值为&#39;王五&#39;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330153109803.png" alt="image-20220330153109803" style="zoom:67%;"></p>
<h4 id="rr下的案例">RR下的案例</h4>
<p>使用REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView ，之后的查询就不会重复生成了。</p>
<p>同样是RC下的场景，SELECT1过程完全相同，SELECT2不生成新的ReadView，因此读取到的数据是相同的，不会产生不可重复读的问题。</p>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330153358057.png" alt="image-20220330153358057" style="zoom:67%;"></p>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330153427722.png" alt="image-20220330153427722" style="zoom:67%;"></p>
<h3 id="mvcc解决幻读问题">MVCC解决幻读问题</h3>
<h4 id="一般场景">一般场景</h4>
<p>一般场景下，MVCC可以直接解决幻读的问题。</p>
<p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下：</p>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330153841553.png" alt="image-20220330153841553" style="zoom: 33%;"></p>
<p>假设现在有事务 A 和事务 B <strong>并发执行</strong>， 事务 A 的事务 id 为 20 ， 事务 B 的事务 id 为 30 。</p>
<p>事务 A 开始第一次查询数据，查询的 SQL 语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student where id &gt;&#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：</p>
<p>trx_ids=[20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20 。</p>
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into student(id,name) values(2,&#39;李四&#39;);</span><br><span class="line">insert into student(id,name) values(3,&#39;王五&#39;);</span><br></pre></td></tr></table></figure>
<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330160907514.png" alt="image-20220330160907514" style="zoom: 67%;"></p>
<p>接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。</p>
<p>此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。 1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。</p>
<p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，<strong>这个值处于 up_limit_id 和 low_limit_id 之间</strong>，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p>
<p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p>
<p>最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象。</p>
<h4 id="mvccnext-key-lock">MVCC+Next-Key Lock</h4>
<p>在一些特殊场景下，单纯采用MVCC仍然可能会出现幻读，例如如下场景：</p>
<p><img src="/2022/03/29/MySQL_MVCC/image-20220330161431987.png" alt="image-20220330161431987" style="zoom: 67%;"></p>
<p>其过程为：</p>
<p>1.a事务先select，b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意操作），</p>
<p>2.a事务再select出来的结果在MVCC下还和第一次select一样，</p>
<p>3.接着a事务不加条件地update，这个update会作用在所有行上（包括b事务新加的），</p>
<p>4.a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了.</p>
<p>上面这样，事务2提交之后，事务1再次执行update，因为这个是当前读，他会读取最新的数据，包括别的事务已经提交的。</p>
<p>因此，这条记录<strong>隐藏列中的trx_id 会被修正为事务1的事务id</strong>。</p>
<p>此时的隔离级别是RR，事务1只会在第一次查询的时候生成ReadView，在第三次查询进行比较的时候，就会发现事务2插入的这条记录最新的版本是事务1修改的，因此可以被事务1看到。</p>
<p>所以就会导致此时前后读取的数据不一致，出现幻读。</p>
<p>Next-Key Lock：行锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p>
<p>因此，这里的解决方案实际上就是将update之前的快照读，最开始的select语句，更改为当前读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE class_id&#x3D;1 FOR UPDATE;</span><br></pre></td></tr></table></figure>
<p>这样，就对class_id在 (负无穷，1] 之间的记录加上了Next-Key Lock，使得事务2不能对这个区间内的数据进行修改，从而解决幻读问题。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://www.cnblogs.com/xuwc/p/13873293.html （MVCC解决幻读）</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL读写分离与主从复制</title>
    <url>/2021/09/10/MySQL_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读写分离</td>
<td>将数据库分为主库和从库，主库只写数据，多个从库只读取数据。<br>缓解因写入操作时间过长而影响数据库查询效率的问题。</td>
</tr>
<tr class="even">
<td>读写分离分机配置</td>
<td>1、程序代码内部实现：insert主库，select从库<br>2、中间代理服务器自动判断转发：MySQL Proxy连接池</td>
</tr>
<tr class="odd">
<td>主从同步延迟</td>
<td>1、二次读取，从库读不到就去读主库<br>2、写数据之后，立刻到来的读操作指定为访问主库<br>3、关键业务读写都由主库承担，非关键业务读写分离</td>
</tr>
<tr class="even">
<td>主从复制</td>
<td>将主库写入、变更的数据同步到从库上。<br>使得从库提供和主库一致的数据。</td>
</tr>
<tr class="odd">
<td>MySQL支持的复制类型</td>
<td>1、基于语句，直接复制SQL命令。<br>2、基于行，直接复制数据。<br>3、混合方式，先语句后行。</td>
</tr>
<tr class="even">
<td>主从复制过程</td>
<td>binlog复制并重放语句。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="基本概念">基本概念</h3>
<h4 id="读写分离">读写分离</h4>
<p><strong>概念</strong></p>
<p>将数据库分为主库和从库，主库只写数据，多个从库只读取数据。</p>
<p><strong>原因</strong></p>
<p>因为数据库的“写”操作是比较耗时的（写10000条数据到oracle可能要3分钟）。</p>
<p>但是数据库的“读”操作相对较快（从oracle读10000条数据可能只要5秒钟）。</p>
<p>所以读写分离解决的是，数据库的写入影响查询效率的问题，把访问的压力从主库转移到从库。</p>
<p>读写分离相对分表分库而言是比较简单的，但是它只能分担访问的压力，分担不了存储的压力，也就是你的数据库表的数据逐渐增多，但是面对一张表海量的数据，查询还是很慢的，所以如果业务发展的快数据暴增，到一定时间还是得分库分表。即当读写分离都无法解决查询效率低的问题时，需要改用分库分表的操作。</p>
<h4 id="主从复制">主从复制</h4>
<p><strong>概念</strong></p>
<p>将主库写入、变更的数据同步到从库上。</p>
<p><strong>原因</strong></p>
<p>使得从库提供和主库一致的数据。</p>
<h3 id="读写分离-1">读写分离</h3>
<h4 id="分机配置">分机配置</h4>
<p>分配机制，也就是制定写操作是去主库写，读操作是去从库读的方案。</p>
<p>1、基于程序代码内部实现</p>
<p>在代码中根据select 、insert进行路由分类，这类方法也是目前生产环境下应用最广泛的。</p>
<p>实现很简单，就是抽出一个中间层，让这个中间层来实现读写分离和数据库连接。讲白点就是搞个provider封装了save,select等通常数据库操作，内部save操作的dataSource是主库的，select操作的dataSource是从库的。</p>
<p>优点：就是实现简单，并且可以根据业务定制化变化，随心所欲。性能较好，因为程序在代码中实现，不需要增加额外的硬件开支。</p>
<p>缺点：就是是如果哪个数据库宕机了，发生主从切换了之后，就得修改配置重启。并且如果你的系统很大，一个业务可能包含多个子系统，一个子系统是java写的一个子系统用go写的，这样的话得分别为不同语言实现一套中间层，重复开发。需要开发人员来实现，运维人员无从下手。</p>
<p>2、基于中间代理层实现</p>
<p>代理一般介于应用服务器和数据库服务器之间，代理数据库服务器接收到应用服务器的请求后根据判断后转发到后端数据库。代理数据库服务器的代表性程序有：Mysql Proxy，Atlas等。</p>
<p>MySQL Proxy实际上是在客户端请求与MySQL服务器之间建立了一个连接池。所有客户端请求都是发向MySQL Proxy，然后经由MySQL Proxy进行相应的分析，判断出是读操作还是写操作，分发至对应的MySQL服务器上。对于多节点Slave集群，也可以起做到负载均衡的效果。</p>
<p>优点：因为是通过sql协议的所以可以兼容不同的语言不需要单独写一套，并且有中间件来实现主从切换，业务服务器不需要关心这点。</p>
<p>缺点：如果数据库中间件出现故障则导致所有服务都不可用。并且多了一个系统就等于多了一个瓶颈，所以对中间件的性能要求也高，所有的数据库操作都要经过它。中间件实现很复杂，难度比代码封装高很多。</p>
<h4 id="问题及解决方案">问题及解决方案</h4>
<p><strong>问题：主从同步延迟</strong></p>
<p>主库有数据写入之后，同时也写入在binlog(二进制日志文件)中，从库是通过binlog文件来同步数据的，这期间会有一定时间的延迟，可能是1秒，如果同时有大量数据写入的话，时间可能更长。</p>
<p>对于实时性要求较高的场景下，主从同步延迟可能会造成较大的影响。比如有一个付款操作，你付款了，主库是已经写入数据，但是查询是到从库查，从库里还没有你的付款记录，所以页面上查询的时候你还没付款。</p>
<p><strong>解决方案：</strong></p>
<p>1、二次读取</p>
<p>二次读取的意思就是读从库没读到之后再去主库读一下，只要通过对数据库访问的API进行封装就能实现这个功能。很简单，并且和业务之间没有耦合。但是有个问题，如果有很多二次读取相当于压力还是回到了主库身上，等于读写分离白分了。而且如有人恶意攻击，就一直访问没有的数据，那主库就可能爆了。</p>
<p>2、写数据之后，立刻到来的读操作指定为访问主库</p>
<p>也就是写操作之后，立刻到来的读操作指定访问主库，经过一定时间后的读操作访问从库。这就等于写死了，和业务强耦合了。</p>
<p>3、关键业务读写都由主库承担，非关键业务读写分离</p>
<p>类似付钱的这种业务，读写都到主库，避免延迟的问题，但是例如改个头像啊，个人签名这种比较不重要的就读写分离，查询都去从库查，毕竟延迟一下影响也不大。</p>
<h3 id="主从复制-1">主从复制</h3>
<h4 id="mysql支持的复制类型">MySQL支持的复制类型</h4>
<p>1） 基于语句的复制。在服务器上执行sql语句，在从服务器上执行同样的语句，MySQL默认采用基于语句的复制，执行效率高。</p>
<p>2） 基于行的复制。把改变的内容复制过去，而不是把命令在从服务器上执行一遍。</p>
<p>3） 混合类型的复制。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。</p>
<h4 id="复制过程">复制过程</h4>
<p>①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。</p>
<p>②salve从库连接master主库，Master有多少个slave就会创建多少个binlog dump线程。</p>
<p>③当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容复制到slave节点。</p>
<p>④slave中的I/O线程接收到 binlog 内容后，将内容写入到本地的 relay-log（中继日志，通常会位于os缓存中，所以中继日志的开销很小）。</p>
<p>⑤SQL线程读取I/O线程写入的relay-log，并重放其中的SQL语句更新slave数据，使其与master中的数据一致。</p>
<p><img src="/2021/09/10/MySQL_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/image-20210911214924821.png" alt="image-20210911214924821" style="zoom: 67%;"></p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/u013421629/article/details/78793966</p>
<p>https://juejin.cn/post/6844903828588855309</p>
<p>http://article.docway.net/details?id=6045c3864da5fa50e1500786</p>
<p>https://juejin.cn/post/6844903475101302797#heading-15</p>
<p>https://segmentfault.com/a/1190000023775512</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务</title>
    <url>/2022/03/17/MySQL_%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="事务">事务</h3>
<p>事务，是满足ACID特性的一系列操作。使数据从一种状态变换到另一种状态。</p>
<h3 id="事务的acid特性">事务的ACID特性</h3>
<table>
<thead>
<tr class="header">
<th>特性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原子性（A）</td>
<td>事务是不可分割的，其中的操作要么全部执行成功，要么全部失败回滚。</td>
</tr>
<tr class="even">
<td>一致性（C）</td>
<td>事务执行前后，数据从一个合法状态变换到另外一个合法状态。<br>合法状态，指的是满足预定义的约束条件的状态。（如账户不能为负数）</td>
</tr>
<tr class="odd">
<td>隔离性（I）</td>
<td>并发执行的各个事务之间不能相互干扰。</td>
</tr>
<tr class="even">
<td>持久性（D）</td>
<td>事务一旦被提交，它对数据库中数据的改变就是永久性的。<br>接下来的其他操作和数据库故障不应该对其有任何影响。</td>
</tr>
</tbody>
</table>
<h3 id="事务的状态">事务的状态</h3>
<p><img src="/2022/03/17/MySQL_%E4%BA%8B%E5%8A%A1/image-20220317194457099.png" alt="image-20220317194457099" style="zoom:50%;"></p>
<ul>
<li>活动的（active） 事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。</li>
<li>部分提交的（partially committed） 当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</li>
<li>失败的（failed） 当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</li>
<li>中止的（aborted） 如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个<strong>撤销的过程称之为回滚</strong>。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</li>
<li>提交的（committed） 当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，就可以说该事务处在了提交的状态。</li>
</ul>
<p>因此，事务最终的状态只可能是提交的（committed，所有操作全部执行成功，以COMMIT语句结尾）或中止的（aborted，出现失败并回滚，以ROLLBACK语句结尾，不包括检查点）</p>
<h3 id="使用事务">使用事务</h3>
<h4 id="显式事务">显式事务</h4>
<p>1、执行START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">#或者</span><br><span class="line">mysql&gt; START TRANSACTION;</span><br></pre></td></tr></table></figure>
<p>START TRANSACTION 语句相较于BEGIN 特别之处在于，后边能跟随几个修饰符：</p>
<ul>
<li>READ ONLY ：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</li>
<li>READ WRITE ：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</li>
<li>WITH CONSISTENT SNAPSHOT ：启动一致性读。</li>
</ul>
<p>2、一系列事务中的操作（主要是DML，不含DDL）</p>
<p>3、<strong>提交事务 或 中止事务（即回滚事务）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line"></span><br><span class="line">#回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line"></span><br><span class="line">#将事务回滚到某个保存点。（这里事务并未结束）</span><br><span class="line">mysql&gt; ROLLBACK TO [SAVEPOINT]</span><br></pre></td></tr></table></figure>
<p>两个完整的事务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user(name varchar(20), PRIMARY KEY (name)) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#39;张三&#39;;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#39;李四&#39;;</span><br><span class="line">INSERT INTO user SELECT &#39;李四&#39;;#此时事务处于失败状态</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
<h4 id="隐式事务">隐式事务</h4>
<p>MySQL中有一个系统变量autocommit ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;autocommit&#39;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit | ON |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>当这里开启时，就会进行自动提交，每执行一条单独的语句都会当成一个独立的事务进行提交。</p>
<p>如果我们想关闭这种自动提交的功能，可以使用下边两种方法之一：</p>
<ul>
<li><p>显式的的使用START TRANSACTION 或者BEGIN 语句开启一个事务。这样在本次事务提交或者回 滚前会暂时关闭掉自动提交的功能。</p></li>
<li><p>把系统变量autocommit 的值设置为OFF ，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET autocommit &#x3D; OFF;</span><br><span class="line">#或</span><br><span class="line">SET autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。 当设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 STARTTRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。</p>
<h4 id="隐式提交数据的情况">隐式提交数据的情况</h4>
<ul>
<li><p>数据定义语言（Data definition language，缩写为：<strong>DDL</strong>）</p></li>
<li><p>隐式使用或修改mysql数据库中的表</p></li>
<li><p>事务控制或关于锁定的语句 ① 当我们在一个事务<strong>还没提交或者回滚时就又使用</strong>START TRANSACTION 或者BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。 ② 当前的autocommit 系统变量的值为OFF ，我们手动把它调为ON 时，也会隐式的提交前边语句所属的事务。</p>
<p>③ 使用LOCK TABLES 、UNLOCK TABLES 等关于锁定的语句也会隐式的提交前边语句所属的事务。</p></li>
<li><p>加载数据的语句。</p></li>
<li><p>关于MySQL主从复制的一些语句。</p></li>
</ul>
<h3 id="事务的分类">事务的分类</h3>
<ul>
<li><p>扁平事务（Flat Transactions）</p>
<p>通过BEGIN开启，通过COMMIT或ROLLBACK结束。</p></li>
<li><p>带有保存点的扁平事务（Flat Transactions with Savepoints）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user(name varchar(255), balance DECIMAL(10,2)) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user (name,balance) VALUES(&#39;张三&#39;,1000);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE user setbalance &#x3D; balance - 100 WHERE NAME &#x3D; &#39;张三&#39;;</span><br><span class="line">UPDATE user setbalance &#x3D; balance - 100 WHERE NAME &#x3D; &#39;张三&#39;;</span><br><span class="line">SAVEPOINT s1;</span><br><span class="line"></span><br><span class="line">UPDATE user setbalance &#x3D; balance + 10 WHERE NAME &#x3D; &#39;张三&#39;;</span><br><span class="line">ROLLBACK TO s1;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li>
<li><p>链事务（Chained Transactions）</p>
<p>带有保存点的事务，当系统发生崩溃时，所有的保存点都会消失，这意味着进行恢复时，事务需要从开始处重新执行。</p>
<p>链式事务，当提交一个事务的时候，释放不需要的数据对象，将必要的上下文隐式地传给下一个需要开始的事务。前一个事务的提交和后一个事务的开始合并为一个原子操作。下一个事务将看到上一个事务的结果，就好像在上一个事务中进行一样。</p>
<p>与保存点事务不同的是：</p>
<p>1、保存点事务能够回滚到任意的保存点，而链事务只能回滚到最近的当前事务。</p>
<p>2、链事务执行COMMIT后释放所有的锁，保存点事务不会释放。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user(name varchar(255), PRIMARY KEY (name)) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">SET @@completion_type &#x3D; 1;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user VALUES(&#39;张三&#39;);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">INSERT INTO user VALUES(&#39;李四&#39;);</span><br><span class="line">INSERT INTO user VALUES(&#39;李四&#39;);</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user; #只能查到张三</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@completion_type &#x3D; 0; #默认情况，用COMMIT提交事务后，下一个事务需要用START TRANSACTION或BEGIN开启。</span><br><span class="line"></span><br><span class="line">SET @@completion_type &#x3D; 1; #用COMMIT提交事务后，相当于执行了COMMIT AND CHAIN，开启了一个链事务，即提交事务后会开启一个相同隔离级别的事务。</span><br><span class="line"></span><br><span class="line">SET @@completion_type &#x3D; 1;#用COMMIT提交事务后，相当于执行了COMMIT AND RELEASE，断开与服务器连接。</span><br></pre></td></tr></table></figure></li>
<li><p>嵌套事务（Nested Transactions）</p></li>
<li><p>分布式事务（Distributed Transactions）</p></li>
</ul>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务日志</title>
    <url>/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>是什么</td>
<td></td>
</tr>
<tr class="even">
<td>目的</td>
<td></td>
</tr>
<tr class="odd">
<td>流程</td>
<td></td>
</tr>
<tr class="even">
<td>刷盘机制</td>
<td></td>
</tr>
<tr class="odd">
<td>redo log buffer存储</td>
<td></td>
</tr>
<tr class="even">
<td>redo log file存储</td>
<td></td>
</tr>
<tr class="odd">
<td>优点</td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="redo日志">redo日志</h3>
<p>redo日志是存储引擎层（Innodb）生成的日志，记录物理级别上页的修改操作，例如“页号xxx，偏移量yyy，写入了zzz数据”。</p>
<p>以防止脏页还未来得及刷入磁盘时数据库宕机导致数据丢失的问题，可以通过redo log进行数据恢复。</p>
<h4 id="目的">目的</h4>
<p>前提知识：</p>
<p>MySQL在更新数据的过程中，需要将磁盘上的页读取到内存中的Buffer Pool之后，再做修改。缓冲池Buffer Pool中被修改过后的脏页会以一定的频率刷入磁盘（checkpoint机制）。</p>
<p>刷盘不是每次更新数据就触发的，而是master线程隔一段时间去处理的。</p>
<blockquote>
<p>避免小的修改就要进行刷盘，刷盘需要访问磁盘，每次修改都访问磁盘会影响性能。</p>
<p>在特定的时刻，比如内存不足或空闲时再进行刷盘。</p>
</blockquote>
<p>所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>解决方案：</p>
<p>为了解决这样的问题，采用WAL（write-ahead logging）技术。先把对磁盘的修改写入日志（redo log），只有日志写入成功时才算事务是提交成功的。</p>
<p>当发生宕机，脏页还未来得及刷入磁盘时，可以通过redo log进行数据恢复。</p>
<h4 id="优点作用">优点（作用）</h4>
<ul>
<li>解决了脏页没有来得及刷入磁盘导致数据丢失的问题，保证了事务的持久性（D）。</li>
<li>redo日志是顺序写入磁盘的，速度快，且占用空间较小。（顺序写入磁盘比脏页随机刷盘快，因此可以降低脏页刷盘频率）</li>
<li>在事务执行的过程中，redo log不断地产生。（binlog是事务提交时才一次性产生的）</li>
</ul>
<h4 id="组成">组成</h4>
<ul>
<li>重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。</li>
<li>重做日志文件 (redo log file) ，保存在硬盘中，是持久的。</li>
</ul>
<h4 id="流程">流程</h4>
<figure>
<img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319203930683.png" alt="image-20220319203930683"><figcaption aria-hidden="true">image-20220319203930683</figcaption>
</figure>
<p>以一个更新事务为例，redo log的过程为：</p>
<p>第1步：先将原始数据从磁盘中读入内存中来，<strong>修改数据的内存拷贝</strong>。</p>
<p>第2步：生成一条重做日志并<strong>写入redo log buffer</strong>，记录的是数据被修改后的值。</p>
<p>第3步：将redo log buffer中的内容按照不同的刷盘策略<strong>刷新</strong>到 redo log file，对 redo log file采用<strong>追加写</strong>的方式。</p>
<p>第4步：提交事务，定期将内存中修改的数据刷新到磁盘中。</p>
<h4 id="redo-log刷盘">redo log刷盘</h4>
<p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以一定的频率刷入到真正的redo log file 中。</p>
<p>此外，redo log buffer刷盘到redo log file的过程也不是直接刷到磁盘中去，只是刷入到文件系统缓存（page cache，这个不属于MySQL管理）中去，这是现代操作系统为了提高文件写入效率做的一个优化，真正的写入会交给系统自己来决定（比如page cache足够大了）。</p>
<p>那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p>
<p>因此，MySQL中通过<code>innodb_flush_log_at_trx_commit</code> 参数，控制这两个刷新过程的时机，即刷盘策略。</p>
<p>总之，就是控制redo log从redo log buffer（MySQL管理的内存）到page cache（操作系统管理的内存）再到redo log file（磁盘）的过程。</p>
<figure>
<img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319204343772.png" alt="image-20220319204343772"><figcaption aria-hidden="true">image-20220319204343772</figcaption>
</figure>
<p>同时注意到，InnoDB存储引擎存在一个后台线程master thread，每隔1s就会将redo log buffer中的内容写入到page cache并刷盘到redo log file中。也就是说，一个没有提交的事务的redo log，也可能会刷盘，因为事务执行过程中会源源不断产生redo log。</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319205438182.png" alt="image-20220319205438182" style="zoom:67%;"></p>
<p><code>innodb_flush_log_at_trx_commit</code> 参数的刷盘策略为：</p>
<ul>
<li><p>设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次redo log的刷盘）</p>
<p>当MySQL宕机时，即出现1s的redo log丢失。</p></li>
<li><p>设置为1 ：表示每次事务提交时都将进行刷盘操作，从redo log buffer一直到redo log file（ 默认值），成功后事务才算提交成功。</p>
<p>只要事务提交成功，redo log就不会出现任何丢失，因为已经落盘。效率最差。</p></li>
<li><p>设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache。由os自己决定什么时候同步到磁盘文件。</p>
<p>事务提交成功时，redo log全部进入page cache。当MySQL宕机时，不会出现数据丢失，但os宕机时，会出现1s数据丢失。效率最高。</p></li>
</ul>
<h4 id="redo-log到redo-log-buffer">redo log到redo log buffer</h4>
<h5 id="具体存储过程">具体存储过程</h5>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个Mini-Transaction（mtr）组成，每一个mtr 又可以包含若干条redo日志。</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319212926282.png" alt="image-20220319212926282" style="zoom:67%;"></p>
<blockquote>
<p>MySQL把对底层数据页的一次原子访问的过程称之为一个Mini-Transaction，比如像某个索引对应的B+树中插入一条记录的过程就是mtr。一个mtr可能包含多个redo日志，比如B+树中插入一条记录时可能会涉及到数据的移动等，这就产生了多个redo日志。</p>
<p>在进行数据恢复时，一个mtr包含的多个redo日志作为一个不可分割的整体。</p>
</blockquote>
<p>向redo log buffer中写入redo log的过程是顺序的，也就是先往前面的block body中写，当该block中的空闲空间用完了之后再往下一个block中写，</p>
<p>InnoDB提供了一个称为buf_free的全局变量，指明后续写入的redo log应该从log buffer中的哪个位置开始写。</p>
<figure>
<img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319213709411.png" alt="image-20220319213709411"><figcaption aria-hidden="true">image-20220319213709411</figcaption>
</figure>
<p>每个mtr都会产生一组redo日志，这些日志的存储必须是相邻的。</p>
<p>例如有两个事务，每个事务分别有两个mtr：</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319213854973.png" alt="image-20220319213854973" style="zoom:67%;"></p>
<p>不同的事务可能是并发执行的，所以T1 、T2 之间的mtr 可能是交替执行的，因此在redo log buffer中可能是交替存储的：</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319213949141.png" alt="image-20220319213949141" style="zoom:80%;"></p>
<h5 id="redo-log-buffer的结构">redo log buffer的结构</h5>
<p>这个buffer由redo log block组成，每个block的结构为：</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319214311619.png" alt="image-20220319214311619" style="zoom:80%;"></p>
<blockquote>
<p>为什么每个block是512B？</p>
<p>机械磁盘的默认扇区大小就是512B。MySQL按照每个block的大小写入数据，每次刚好写入一个扇区的大小，保证了写入的原子性。如果MySQL将block的大小定义为超过512B，一次写入数据超过512B，就有可能导致多个扇区中有些扇区成功，有些扇区失败，这样MySQL一次写入的操作就不是原子性的。</p>
</blockquote>
<p>log block body存储了真正的redo log，其余位置都是存储的一些管理信息。</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319215001258.png" alt="image-20220319215001258" style="zoom: 50%;"></p>
<h4 id="redo-log-buffer到redo-log-file">redo log buffer到redo log file</h4>
<h5 id="具体存储过程-1">具体存储过程</h5>
<p>redo log file是以日志文件组的形式组织的，包括了多个redo日志文件，每个文件的大小相同。这些文件以ib_logfile[数字]命名，数字从0,1,2...。总共的redo日志文件大小其实就是： innodb_log_file_size × innodb_log_files_in_group 。</p>
<p>当redo log从redo log buffer或者page cache中刷入redo log file时，先从ib_logfile0开始写入，依次往后类推，写到最后一个文件时再从头开始写入。</p>
<p>整个日志文件组中还含有两个重要的属性：</p>
<ul>
<li>write pos：当前记录的位置，边写边往后移动</li>
<li>checkpoint：当前要清除的位置，边写边往后移动</li>
</ul>
<p>每次redo log被刷入redo log file时，write pos向后移动。</p>
<p>当MySQL使用redo log file进行数据恢复时，或者内存中脏页已经被刷到磁盘中时，checkpoint向后移动。</p>
<p>从write pos到checkpoint的位置表示空闲区域，可以继续写入redo log。</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319220102374.png" alt="image-20220319220102374" style="zoom: 67%;"></p>
<h5 id="redo-log-file的结构">redo log file的结构</h5>
<p>实际上就是首尾相接的多个redo log file组成，日志循环写入。</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220319215959254.png" alt="image-20220319215959254" style="zoom:67%;"></p>
<h3 id="undo日志">undo日志</h3>
<p>undo日志是存储引擎层（Innodb）生成的日志，记录了逻辑操作的日志，即SQL语句。</p>
<p>例如INSERT数据时，undo log会记录一个与之相反的DELETE操作。</p>
<p>主要用于事务的回滚以及一致性非锁定读（MVCC，读取旧版本数据）。</p>
<h4 id="目的-1">目的</h4>
<p>事务执行到一半会出现一些情况，比如：</p>
<ul>
<li>事务执行过程中可能遇到各种错误，比如服务器本身的错误， 操作系统错误，甚至是突然断电导致的错误。</li>
<li>程序员可以在事务执行过程中手动输入ROLLBACK 语句结束当前事务的执行。</li>
</ul>
<p>出现这些情况时，需要把数据改回原先的样子，此过程称之为回滚。</p>
<p>SELECT操作不涉及数据的更改，因此没有undo log。此外，undo log会产生redo log，因为undo log也需要持久性的保护。</p>
<h4 id="优点作用-1">优点（作用）</h4>
<ul>
<li><p>回滚数据</p>
<p>undo log是逻辑日志，只会将数据库逻辑地（在SQL上）恢复到原来的样子，所有修改都被逻辑地取消了，但是数据结构和物理页可能和原来不同。</p>
<p>原因是数据库是多并发的，有多个事务同时操作一个物理页，假如回滚某个事物则不能简单地将一个页还原，因为这会影响到其他事务。（比如INSERT操作就对应一个DELETE操作即可）</p></li>
<li><p>MVCC</p>
<p>多版本并发控制协议，当用户读取一条已经被锁定（正在被修改）的记录时，可以通过undo log读取之前的版本信息实现非锁定读。</p></li>
</ul>
<h4 id="组成-1">组成</h4>
<p>InnoDB对undo log的管理采用段的方式，也就是回滚段（rollback segment） 。每个回滚段记录了1024 个undo log segment ，而在每个undo log segment段中进行undo页的申请，在undo页中真正写入undo log。</p>
<p>在InnoDB1.1版本之前（不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为1024 。从1.1版本开始InnoDB支持最大128个rollback segment ，故其支持同时在线的事务限制提高到了128*1024 。</p>
<p>undo页的重用：</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220321150453318.png" alt="image-20220321150453318" style="zoom:50%;"></p>
<p>回滚段与事物之间的关系：</p>
<ol type="1">
<li>每个事务只会使用一个回滚段（undo log segment ），一个回滚段在同一时刻可能会服务于多个事务。</li>
<li>当一个事务开始的时候，会指定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</li>
<li>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</li>
<li>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</li>
<li>当事务提交时，InnoDB存储引擎会做以下两件事情： 将undo log放入列表中，以供之后的purge操作 判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li>
</ol>
<p>回滚段中的数据分类：</p>
<ul>
<li><p>未提交的回滚数据(uncommitted undo information)</p>
<p>事务还没有提交，事务中的更新操作还在往回滚段对应的页写入数据。</p></li>
<li><p>已经提交但未过期的回滚数据(committed undo information)</p>
<p>事务已经提交，但是可能有其他事务需要获取记录对应的早期版本，因此不能马上删除undo log及其对应的页。</p>
<p>事务提交后，将对应的页放入一个链表中，由purge线程负责判定是否删除。</p></li>
<li><p>事务已经提交并过期的数据(expired undo information)</p>
<p>事务已经提交，且数据保存时间已经超过undo retention指定的时间，没有其他事物需要使用这个版本的数据。则当回滚段中的数据满了之后就优先覆盖掉这部分的数据。</p></li>
</ul>
<p>undo log的分类：</p>
<ul>
<li><p>insert undo log</p>
<p>INSERT操作，只对事务本身可见，对其他事务是不可见的（原本不存在这些数据，是事务隔离性的要求）。因此这一类undo log在事务提交后就可以删除。</p></li>
<li><p>update undo log</p>
<p>DELETE和UPDATE操作，其他事务可能需要看到之前版本的数据，因此这些undo log在事务提交后不能立刻删除，要放入链表中等待purge线程判断。</p></li>
</ul>
<h3 id="流程-1">流程</h3>
<p>简要生成流程：</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220321154626169.png" alt="image-20220321154626169" style="zoom: 50%;"></p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220321154820659.png" alt="image-20220321154820659" style="zoom:67%;"></p>
<p>本质上就是在修改数据前，先记录到undo log，然后修改数据，然后记录redo log。假设修改数据中出错了，则可以根据undo log进行恢复。</p>
<p>详细生成流程：</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220321155126650.png" alt="image-20220321155126650" style="zoom: 50%;"></p>
<p>每次修改数据时，会把老的记录写入新生成的undo log。当前记录中的回滚指针指向新生成的undo log，新生成的undo log中回滚指针指向老旧的undo log。</p>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220321160953880.png" alt="image-20220321160953880" style="zoom:67%;"></p>
<p>回滚过程：</p>
<p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样： 1. 通过undo no=3的日志把id=2的数据删除（删除新增主键的记录）</p>
<ol start="2" type="1">
<li><p>通过undo no=2的日志把id=1的数据的deletemark还原成0（数据不删除）</p></li>
<li><p>通过undo no=1的日志把id=1的数据的name还原成Tom</p></li>
<li><p>通过undo no=0的日志把id=1的数据删除（移除insert的操作）</p></li>
</ol>
<blockquote>
<p><img src="/2022/03/19/MySQL_%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/image-20220321161544572.png" alt="image-20220321161544572" style="zoom:67%;"></p>
</blockquote>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务隔离级别</title>
    <url>/2022/03/18/MySQL_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>MySQL是一个客户端／服务器架构（C/S）的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话（ Session ）。</p>
<p>每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。</p>
<h3 id="事务的并发性问题">事务的并发性问题</h3>
<p>当有多个事务同时对服务器中的数据进行访问或修改时，可能会产生如下四种问题。</p>
<h4 id="脏写-dirty-write">脏写（ Dirty Write ）</h4>
<p>事务Session A 修改了另一个未提交事务Session B 修改过的数据。（同时，事务A commit之后不生效）</p>
<p><img src="/2022/03/18/MySQL_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20220318200140026.png" alt="image-20220318200140026" style="zoom: 80%;"></p>
<p>A修改了数据，但是由于B回滚了，所以最终的数据是原始数据，而非事务A提交的数据。</p>
<h4 id="脏读-dirty-read">脏读（ Dirty Read ）</h4>
<p>Session A 读取了已经被 Session B 更新但还没有被提交的字段。</p>
<p>之后若 Session B 回滚，Session A 读取的内容就是临时且无效的。</p>
<p><img src="/2022/03/18/MySQL_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20220318200358640.png" alt="image-20220318200358640" style="zoom: 80%;"></p>
<p>简单来说就是可以读到脏数据。所谓的脏数据实际上指的是事务对缓冲池中的行记录的修改，并且还没有被提交的数据。</p>
<h4 id="不可重复读-non-repeatable-read">不可重复读（ Non-Repeatable Read ）</h4>
<p>Session A 读取了一个字段，然后 Session B 更新了该字段。 之后Session A 内的其他语句再次读取同一个字段， 值就不同了。那就意味着发生了不可重复读。</p>
<p><img src="/2022/03/18/MySQL_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20220318200548491.png" alt="image-20220318200548491" style="zoom:80%;"></p>
<p>这里Session B是隐式事务，语句结束后立刻提交，则每次Session B提交后，Session A中的语句都能读到不同的值。</p>
<h4 id="幻读-phantom">幻读（ Phantom ）</h4>
<p>Session A 从一个表中读取了一个字段, 然后 Session B 在该表中插入了一些新的行。 之后, 如果 Session A 再次读取同一个表, 就会多出几行。那就意味着发生了幻读。</p>
<p><img src="/2022/03/18/MySQL_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20220318200823509.png" alt="image-20220318200823509" style="zoom:80%;"></p>
<p>Session B中提交了一个隐式事务，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为幻影记录。</p>
<p>注意到，幻读强调的是读取到了之前没有读取过的数据，也就是数据增多的情况才称之为幻读。如果原来读取的数据无法读取到，即数据减少的情况，则归类为不可重复读。</p>
<h3 id="sql标准的隔离级别">SQL标准的隔离级别</h3>
<p>所谓隔离级别，就是并发性和数据一致性的权衡。在不同的隔离级别下，并发事务可以产生不同严重程度的问题。</p>
<p>不论是哪种隔离级别，都不允许脏写的情况发生，因为会导致已提交的数据不生效。</p>
<p><img src="/2022/03/18/MySQL_%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20220318201628017.png" alt="image-20220318201628017" style="zoom: 50%;"></p>
<p>注意，这类实现方式是标准SQL的实现方式，需要频繁进行加锁和释放锁的操作：</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 40%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>隔离级别</th>
<th>说明</th>
<th>具体实现（SQL标准的实现）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>READ UNCOMMITTED<br>读未提交</td>
<td>所有事务都可以看到其他未提交事务的执行结果。<br>不能避免脏读、不可重复读、幻读。</td>
<td>解决脏写（丢失修改的写覆盖问题），未提交读实现为：<br><br>1.事务对当前被读取的数据不加锁。（不加锁是性能提升的位置）<br><br>2.事务开始更新一行数据时，必须先对其加<strong>行级共享锁</strong>（这个锁使得别的事务不可以更改数据，但可以读数据），直到事务结束才释放。</td>
</tr>
<tr class="even">
<td>READ COMMITTED<br>读已提交</td>
<td>一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统（Oracle）的默认隔离级别（但不是MySQL默认的）。<br>可以避免脏读，但不可重复读、幻读问题仍然存在。</td>
<td>解决脏读，读已提交实现为：<br><br>1.事务对当前被读取的数据加<strong>行级共享锁</strong>（多个事务只能读，不能修改），一旦读完该行，立即释放该共享锁。（注意是<strong>读完立即释放</strong>，这样在两次读取时，可能有其他事务修改数据，从而产生不可重复读）<br><br>2.事务在更新某行数据时，必须对其加上<strong>行级排他锁</strong>（不能读也不能改），直到事务结束才释放。（注意是<strong>事务结束才释放</strong>，这样在事务A两次读取的中间，事务B可能加上了行级排他锁修改数据，从而产生不可重复读。为什么解决了脏读，因为事务B没有提交之前它加上了行级排他锁，事务A不能够读取此时未提交的数据，只能读取原始数据，直到事务B提交。）</td>
</tr>
<tr class="odd">
<td>REPEATABLE READ <br>可重复读</td>
<td>事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。<br>可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的<strong>默认隔离级别</strong>。</td>
<td>解决不可重复读，可重复读实现为：<br><br>1.事务在读取数据时，必须先对其加<strong>行级共享锁</strong>，直到事务结束才释放（注意是<strong>事务结束才释放</strong>，因此事务B不能够修改数据，注意这里是SQL标准的实现，在MySQL中事务B是可以修改数据的）<br><br>2.事务A在更新数据时，必须先对其加行级排他锁，直到事务结束才释放（注意是事务结束才释放）</td>
</tr>
<tr class="even">
<td>SERIALIZABLE <br>可串行化</td>
<td>事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。<br>所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</td>
<td>解决所有并发问题，可串行化实现为：<br><br>1.事务在读取数据时，必须先对其加<strong>表级共享锁</strong> ，直到事务结束才释放；<br><br>2.事务在更新数据时，必须先对其加<strong>表级排他锁</strong> ，直到事务结束才释放。</td>
</tr>
</tbody>
</table>
<h3 id="mysql设置隔离级别">MySQL设置隔离级别</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看隔离级别，MySQL 5.7.20的版本及之后：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;transaction_isolation&#39;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line"></span><br><span class="line"># 修改隔离级别</span><br><span class="line">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION &#x3D; &#39;隔离级别&#39;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ-UNCOMMITTED</span><br><span class="line">&gt; READ-COMMITTED</span><br><span class="line">&gt; REPEATABLE-READ</span><br><span class="line">&gt; SERIALIZABLE</span><br><span class="line"></span><br><span class="line"># 使用GLOBAL 关键字（在全局范围影响）：当前已经存在的会话无效，只对执行完该语句之后产生的会话起作用。服务器重启后失效。</span><br><span class="line"># 使用SESSION 关键字（在会话范围影响）：对当前会话的所有后续的事务有效。如果在事务之间执行，则对后续的事务有效。该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>InnoDB事务隔离级别实现：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>隔离级别</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>READ UNCOMMITTED<br>读未提交</td>
<td>1.事务对当前被读取的数据不加锁，都是当前读 。<br><br>2.事务开始更新一行数据时，必须先对其加<strong>行级共享锁</strong>（这个锁使得别的事务不可以更改数据，但可以读数据），直到事务结束才释放。</td>
</tr>
<tr class="even">
<td>READ COMMITTED<br>读已提交</td>
<td>1.事务对当前被读取的数据不加锁，且是快照读。<br><strong>每个</strong>语句开始执行时，获得ReadView，可见性判断是基于语句级别的ReadView。<br><br>2.事务在更新某行数据时，必须对其加上<strong>行级排他锁</strong>（不能读也不能改），直到事务结束才释放。<br>不需要GAP LOCK，只使用记录锁。并且事务只持有被UPDATE/DELETE记录的写锁（可重复读需要保留全部写锁直到事务结束，而读已提交只保留真正更改的）。</td>
</tr>
<tr class="odd">
<td>REPEATABLE READ <br>可重复读</td>
<td>1.事务对当前被读取的数据不加锁，且是快照读。<br>事务在<strong>开始时</strong>创建一个ReadView，当读一条记录时，会遍历版本链表，通过当前事务的ReadView判断可见性，找到第一个对当前事务可见的版本，读这个版本。<br><br>2.事务在更新某行数据时，必须对其加上<strong>行级排他锁</strong>（不能读也不能改），直到事务结束才释放。<br>MySQL在可重复读级别下解决了幻读问题，因此这里的锁包括GAP LOCK。</td>
</tr>
<tr class="even">
<td>SERIALIZABLE <br>可串行化</td>
<td>1.事务在读取数据时，必须先对其加<strong>表级共享锁</strong> ，直到事务结束才释放；<br><br>2.事务在更新数据时，必须先对其加<strong>表级排他锁</strong> ，直到事务结束才释放。</td>
</tr>
</tbody>
</table>
<h3 id="参考资料">参考资料</h3>
<p>MySQL 是如何实现四大隔离级别的？ - 郭华的回答 - 知乎 https://www.zhihu.com/question/263820564/answer/289269082 （RC和RR的区别）</p>
<p>https://segmentfault.com/a/1190000025156465</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 性能分析：系统性能参数</title>
    <url>/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_01%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="数据库服务器的优化步骤">数据库服务器的优化步骤</h3>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_01%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0/image-20220424152838731.png" alt="image-20220424152838731"><figcaption aria-hidden="true">image-20220424152838731</figcaption>
</figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_01%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0/image-20220424153021823.png" alt="image-20220424153021823" style="zoom:67%;"></p>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_01%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0/image-20220424153123746.png" alt="image-20220424153123746" style="zoom:67%;"></p>
<h3 id="查看系统性能参数">查看系统性能参数</h3>
<p>在MySQL中，可以使用SHOW STATUS 语句查询一些MySQL数据库服务器的性能参数、执行频率。</p>
<p>SHOW STATUS语句语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW [GLOBAL|SESSION] STATUS LIKE &#39;参数&#39;;</span><br></pre></td></tr></table></figure>
<p>一些常用的性能参数如下：</p>
<p>•　Connections：连接MySQL服务器的次数。</p>
<p>•　Uptime：MySQL服务器的上线时间。</p>
<p>•　Slow_queries：慢查询的次数。</p>
<p>•　Innodb_rows_read：Select查询返回的行数</p>
<p>•　Innodb_rows_inserted：执行INSERT操作插入的行数</p>
<p>•　Innodb_rows_updated：执行UPDATE操作更新的行数</p>
<p>•　Innodb_rows_deleted：执行DELETE操作删除的行数</p>
<p>•　Com_select：查询操作的次数。</p>
<p>•　Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</p>
<p>•　Com_update：更新操作的次数。</p>
<p>•　Com_delete：删除操作的次数。</p>
<h3 id="统计sql的查询成本">统计SQL的查询成本</h3>
<p>SQL的查询成本指的是需要查询多少个数据页才能查询到符合条件的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT student_id, class_id, NAME, create_time FROM student_info</span><br><span class="line">WHERE id BETWEEN 900001 AND 900100;</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW STATUS LIKE &#39;last_query_cost&#39;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Last_query_cost | 21.134453 |</span><br><span class="line">+-----------------+-----------+</span><br></pre></td></tr></table></figure>
<p>可以看到需要查找22个页面才能获取完整数据。</p>
<p>数据页的数量是原先的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。<strong>虽然页数量（last_query_cost）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。</strong></p>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_01%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0/image-20220424154133541.png" alt="image-20220424154133541" style="zoom:67%;"></p>
<p>经常使用的数据放在缓冲池中，同时通过批量读取减少查询时间。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 性能分析：慢查询日志与Profile</title>
    <url>/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="慢查询日志">慢查询日志</h3>
<h4 id="开启慢查询日志">开启慢查询日志</h4>
<ol type="1">
<li>开启slow_query_log</li>
</ol>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql &gt; set global slow_query_log&#x3D;&#39;ON&#39;;</span><br></pre></td></tr></table></figure> 然后再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424161722259.png" alt="image-20220424161722259" style="zoom:67%;"></p>
<p>能看到这时慢查询分析已经开启，同时文件保存在 /var/lib/mysql/atguigu02-slow.log 文件中。</p>
<ol start="2" type="1">
<li>修改long_query_time阈值</li>
</ol>
<p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql &gt; show variables like &#39;%long_query_time%&#39;;</span><br></pre></td></tr></table></figure> <img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424161811720.png" alt="image-20220424161811720" style="zoom:67%;"></p>
<p>这里如果想把时间缩短，比如设置为 1 秒，可以这样设置：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置global的方式对当前session的long_query_time是无效的。对新连接的客户端有效。</span><br><span class="line">mysql &gt; set global long_query_time &#x3D; 1;</span><br><span class="line"></span><br><span class="line">#因此需要继续执行</span><br><span class="line">mysql&gt; set long_query_time&#x3D;1;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424162312370.png" alt="image-20220424162312370" style="zoom:67%;"></p>
<h4 id="查看慢查询数目">查看慢查询数目</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#39;%Slow_queries%&#39;;</span><br><span class="line">show status like &#39;slow_queries&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424162118281.png" alt="image-20220424162118281" style="zoom: 80%;"></p>
<h4 id="慢查询日志分析工具mysqldumpslow">慢查询日志分析工具：mysqldumpslow</h4>
<p>MySQL提供了日志分析工具mysqldumpslow 。查看mysqldumpslow的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424163338975.png" alt="image-20220424163338975" style="zoom:67%;"></p>
<p>常用参数如下：</p>
<ul>
<li><p>a: 不将数字抽象成N，字符串抽象成S</p></li>
<li><p>s: 是表示按照何种方式排序： c: 访问次数 l: 锁定时间 r: 返回记录 t: <strong>查询时间</strong> al:平均锁定时间 ar:平均返回记录数 at:平均查询时间 （默认方式） ac:平均查询次数</p></li>
<li><p>t: 即为返回前面多少条的数据；</p></li>
<li><p>g: 后边搭配一个正则匹配模式，大小写不敏感的；</p></li>
</ul>
<p>按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# mysqldumpslow -s t -t 5 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu01-slow.log</span><br><span class="line"></span><br><span class="line">Reading mysql slow query log from &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu01-slow.log</span><br><span class="line"></span><br><span class="line">Count: 1 Time&#x3D;2.39s (2s) Lock&#x3D;0.00s (0s) Rows&#x3D;13.0 (13), root[root]@localhost</span><br><span class="line">SELECT * FROM student WHERE name &#x3D; &#39;S&#39;</span><br><span class="line"></span><br><span class="line">Count: 1 Time&#x3D;2.09s (2s) Lock&#x3D;0.00s (0s) Rows&#x3D;2.0 (2), root[root]@localhost</span><br><span class="line">SELECT * FROM student WHERE stuno &#x3D; N</span><br><span class="line"></span><br><span class="line">Died at &#x2F;usr&#x2F;bin&#x2F;mysqldumpslow line 162, &lt;&gt; chunk 2.</span><br></pre></td></tr></table></figure>
<p>其他命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"></span><br><span class="line">#得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"></span><br><span class="line">#得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"></span><br><span class="line">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log | more</span><br></pre></td></tr></table></figure>
<h4 id="关闭慢查询日志">关闭慢查询日志</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：通过配置文件永久性修改，设置为OFF或者注释掉或者删除掉</span><br><span class="line">slow_query_log&#x3D;OFF</span><br><span class="line"></span><br><span class="line">#方式二：在会话窗口中设置</span><br><span class="line">SET GLOBAL slow_query_log&#x3D;off;</span><br></pre></td></tr></table></figure>
<p>重启MySQL服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
<h4 id="删除慢查询日志">删除慢查询日志</h4>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424164242445.png" alt="image-20220424164242445" style="zoom:67%;"></p>
<p>注意使用slow表示仅重置慢查询日志。</p>
<h3 id="profile">Profile</h3>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424164456815.png" alt="image-20220424164456815" style="zoom:67%;"></p>
<p>查询Profile的开启状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql &gt; show variables like &#39;profiling&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424164611847.png" alt="image-20220424164611847" style="zoom:67%;"></p>
<p>设置 profiling='ON’ 来开启 show profile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql &gt; set profiling &#x3D; &#39;ON&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424164645677.png" alt="image-20220424164645677" style="zoom:67%;"></p>
<p>查看当前会话都有哪些query的profiles，使用下面这条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql &gt; show profiles;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424164749090.png" alt="image-20220424164749090" style="zoom:67%;"></p>
<p>查看执行查询语句的开销：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424164842271.png" alt="image-20220424164842271" style="zoom:67%;"></p>
<p>show profile的常用查询参数： ① ALL：显示所有的开销信息。 ② BLOCK IO：显示块IO开销。 ③ CONTEXT SWITCHES：上下文切换开 销。 ④ CPU：显示CPU开销信息。 ⑤ IPC：显示发送和接收开销信息。 ⑥ MEMORY：显示内存开销信 息。 ⑦ PAGE FAULTS：显示页面错误开销信息。 ⑧ SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。 ⑨ SWAPS：显示交换次数开销信息。</p>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_02%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%B8%8Eprofile/image-20220424164957909.png" alt="image-20220424164957909" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 性能分析：Trace和Sys Schema视图</title>
    <url>/2022/04/26/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_04trace%E5%92%8Csys_schema/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="分析优化器执行计划trace">分析优化器执行计划：Trace</h3>
<p><img src="/2022/04/26/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_04trace%E5%92%8Csys_schema/image-20220426193549303.png" alt="image-20220426193549303" style="zoom:67%;"></p>
<p>测试：执行如下SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student where id &lt; 10;</span><br></pre></td></tr></table></figure>
<p>最后， 查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line"><span class="comment">//第1部分：查询语句</span></span><br><span class="line">QUERY: select * from student where id &lt; 10</span><br><span class="line"><span class="comment">//第2部分：QUERY字段对应语句的跟踪信息</span></span><br><span class="line">TRACE: &#123;</span><br><span class="line">    &quot;steps&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;join_preparation&quot;</span>: &#123;</span><br><span class="line">                <span class="comment">//预备工作&quot;select#&quot;: 1,</span></span><br><span class="line">                <span class="attr">&quot;steps&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;expanded_query&quot;</span>: <span class="string">&quot;/* select#1 */ select `student`.`id` AS</span></span><br><span class="line"><span class="string">`id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS</span></span><br><span class="line"><span class="string">`age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]<span class="comment">/*steps*/</span></span><br><span class="line">            &#125;<span class="comment">/*join_preparation*/</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;join_optimization&quot;</span>: &#123;</span><br><span class="line">                <span class="comment">//进行优化&quot;select#&quot;: 1,</span></span><br><span class="line">                <span class="attr">&quot;steps&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;condition_processing&quot;</span>: &#123;</span><br><span class="line">                            <span class="comment">//条件处理&quot;condition&quot;: &quot;WHERE&quot;,</span></span><br><span class="line">                            <span class="attr">&quot;original_condition&quot;</span>: <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span>,</span><br><span class="line">                            <span class="attr">&quot;steps&quot;</span>: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="attr">&quot;transformation&quot;</span>: <span class="string">&quot;equality_propagation&quot;</span>,</span><br><span class="line">                                    <span class="attr">&quot;resulting_condition&quot;</span>: <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="attr">&quot;transformation&quot;</span>: <span class="string">&quot;constant_propagation&quot;</span>,</span><br><span class="line">                                    <span class="attr">&quot;resulting_condition&quot;</span>: <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="attr">&quot;transformation&quot;</span>: <span class="string">&quot;trivial_condition_removal&quot;</span>,</span><br><span class="line">                                    <span class="attr">&quot;resulting_condition&quot;</span>: <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]<span class="comment">/*steps*/</span></span><br><span class="line">                        &#125;<span class="comment">/*condition_processing*/</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;substitute_generated_columns&quot;</span>: &#123;</span><br><span class="line">                            <span class="comment">//替换生成的列</span></span><br><span class="line">                        &#125;<span class="comment">/*substitute_generated_columns*/</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;table_dependencies&quot;</span>: [</span><br><span class="line">                            <span class="comment">//表的依赖关系&#123;</span></span><br><span class="line">                                <span class="string">&quot;table&quot;</span>: <span class="string">&quot;`student`&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;row_may_be_null&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                                <span class="string">&quot;map_bit&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                                <span class="string">&quot;depends_on_map_bits&quot;</span>: [</span><br><span class="line">                                    </span><br><span class="line">                                ]<span class="comment">/*depends_on_map_bits*/</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]<span class="comment">/*table_dependencies*/</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;ref_optimizer_key_uses&quot;</span>: [</span><br><span class="line">                            <span class="comment">//使用键</span></span><br><span class="line">                        ]<span class="comment">/*ref_optimizer_key_uses*/</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;rows_estimation&quot;</span>: [</span><br><span class="line">                            <span class="comment">//行判断&#123;</span></span><br><span class="line">                                <span class="string">&quot;table&quot;</span>: <span class="string">&quot;`student`&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;range_analysis&quot;</span>: &#123;</span><br><span class="line">                                    <span class="attr">&quot;table_scan&quot;</span>: &#123;</span><br><span class="line">                                        <span class="attr">&quot;rows&quot;</span>: <span class="number">3973767</span>,</span><br><span class="line">                                        <span class="attr">&quot;cost&quot;</span>: <span class="number">408558</span></span><br><span class="line">                                    &#125;<span class="comment">/*table_scan*/</span>,</span><br><span class="line">                                    <span class="comment">//扫描表&quot;potential_range_indexes&quot;: [</span></span><br><span class="line">                                        <span class="comment">//潜在的范围索引&#123;</span></span><br><span class="line">                                            <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;PRIMARY&quot;</span>,</span><br><span class="line">                                            <span class="attr">&quot;usable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                                            <span class="attr">&quot;key_parts&quot;</span>: [</span><br><span class="line">                                                <span class="string">&quot;id&quot;</span></span><br><span class="line">                                            ]<span class="comment">/*key_parts*/</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                    ]<span class="comment">/*potential_range_indexes*/</span>,</span><br><span class="line">                                    <span class="attr">&quot;setup_range_conditions&quot;</span>: [</span><br><span class="line">                                        <span class="comment">//设置范围条件</span></span><br><span class="line">                                    ]<span class="comment">/*setup_range_conditions*/</span>,</span><br><span class="line">                                    <span class="attr">&quot;group_index_range&quot;</span>: &#123;</span><br><span class="line">                                        <span class="attr">&quot;chosen&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                                        <span class="attr">&quot;cause&quot;</span>: <span class="string">&quot;not_group_by_or_distinct&quot;</span></span><br><span class="line">                                    &#125;<span class="comment">/*group_index_range*/</span>,</span><br><span class="line">                                    <span class="attr">&quot;skip_scan_range&quot;</span>: &#123;</span><br><span class="line">                                        <span class="attr">&quot;potential_skip_scan_indexes&quot;</span>: [</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;PRIMARY&quot;</span>,</span><br><span class="line">                                                <span class="attr">&quot;usable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">                                                <span class="attr">&quot;cause&quot;</span>: <span class="string">&quot;query_references_nonkey_column&quot;</span></span><br><span class="line">                                            &#125;</span><br><span class="line">                                        ]<span class="comment">/*potential_skip_scan_indexes*/</span></span><br><span class="line">                                    &#125;<span class="comment">/*skip_scan_range*/</span>,</span><br><span class="line">                                    <span class="attr">&quot;analyzing_range_alternatives&quot;</span>: &#123;</span><br><span class="line">                                        <span class="comment">//分析范围选项&quot;range_scan_alternatives&quot;: [</span></span><br><span class="line">                                            &#123;</span><br><span class="line">                                                &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                                                &quot;ranges&quot;: [</span><br><span class="line">                                                    <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">                                                ]/*ranges*/,</span><br><span class="line">                                                &quot;index_dives_for_eq_ranges&quot;: true,</span><br><span class="line">                                                &quot;rowid_ordered&quot;: true,</span><br><span class="line">                                                &quot;using_mrr&quot;: false,</span><br><span class="line">                                                &quot;index_only&quot;: false,</span><br><span class="line">                                                &quot;rows&quot;: 9,</span><br><span class="line">                                                &quot;cost&quot;: 1.91986,</span><br><span class="line">                                                &quot;chosen&quot;: true</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        ]/*range_scan_alternatives*/,</span><br><span class="line">                                        &quot;analyzing_roworder_intersect&quot;: &#123;</span><br><span class="line">                                            &quot;usable&quot;: false,</span><br><span class="line">                                            &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">                                        &#125;/*analyzing_roworder_intersect*/</span><br><span class="line">                                    &#125;/*analyzing_range_alternatives*/,</span><br><span class="line">                                    &quot;chosen_range_access_summary&quot;: &#123;</span><br><span class="line">                                        <span class="comment">//选择范围访问摘要&quot;range_access_plan&quot;: &#123;</span></span><br><span class="line">                                            &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                                            &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                                            &quot;rows&quot;: 9,</span><br><span class="line">                                            &quot;ranges&quot;: [</span><br><span class="line">                                                <span class="string">&quot;id &lt; 10&quot;</span></span><br><span class="line">                                            ]/*ranges*/</span><br><span class="line">                                        &#125;/*range_access_plan*/,</span><br><span class="line">                                        &quot;rows_for_plan&quot;: 9,</span><br><span class="line">                                        &quot;cost_for_plan&quot;: 1.91986,</span><br><span class="line">                                        &quot;chosen&quot;: true</span><br><span class="line">                                    &#125;/*chosen_range_access_summary*/</span><br><span class="line">                                &#125;/*range_analysis*/</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]/*rows_estimation*/</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;considered_execution_plans&quot;</span>: [</span><br><span class="line">                            <span class="comment">//考虑执行计划&#123;</span></span><br><span class="line">                                <span class="string">&quot;plan_prefix&quot;</span>: [</span><br><span class="line">                                    </span><br><span class="line">                                ]<span class="comment">/*plan_prefix*/</span>,</span><br><span class="line">                                <span class="string">&quot;table&quot;</span>: <span class="string">&quot;`student`&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;best_access_path&quot;</span>: &#123;</span><br><span class="line">                                    <span class="comment">//最佳访问路径&quot;considered_access_paths&quot;: [</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                            &quot;rows_to_scan&quot;: 9,</span><br><span class="line">                                            &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                                            &quot;range_details&quot;: &#123;</span><br><span class="line">                                                &quot;used_index&quot;: &quot;PRIMARY&quot;</span><br><span class="line">                                            &#125;/*range_details*/,</span><br><span class="line">                                            &quot;resulting_rows&quot;: 9,</span><br><span class="line">                                            &quot;cost&quot;: 2.81986,</span><br><span class="line">                                            &quot;chosen&quot;: true</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    ]/*considered_access_paths*/</span><br><span class="line">                                &#125;/*best_access_path*/,</span><br><span class="line">                                &quot;condition_filtering_pct&quot;: 100,</span><br><span class="line">                                <span class="comment">//行过滤百分比&quot;rows_for_plan&quot;: 9,</span></span><br><span class="line">                                &quot;cost_for_plan&quot;: 2.81986,</span><br><span class="line">                                &quot;chosen&quot;: true</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]/*considered_execution_plans*/</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;attaching_conditions_to_tables&quot;</span>: &#123;</span><br><span class="line">                            <span class="comment">//将条件附加到表上&quot;original_condition&quot;: &quot;(`student`.`id` &lt; 10)&quot;,</span></span><br><span class="line">                            <span class="attr">&quot;attached_conditions_computation&quot;</span>: [</span><br><span class="line">                                </span><br><span class="line">                            ]<span class="comment">/*attached_conditions_computation*/</span>,</span><br><span class="line">                            <span class="attr">&quot;attached_conditions_summary&quot;</span>: [</span><br><span class="line">                                <span class="comment">//附加条件概要&#123;</span></span><br><span class="line">                                    <span class="string">&quot;table&quot;</span>: <span class="string">&quot;`student`&quot;</span>,</span><br><span class="line">                                    <span class="string">&quot;attached&quot;</span>: <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]<span class="comment">/*attached_conditions_summary*/</span></span><br><span class="line">                        &#125;<span class="comment">/*attaching_conditions_to_tables*/</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;finalizing_table_conditions&quot;</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">&quot;table&quot;</span>: <span class="string">&quot;`student`&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;original_table_condition&quot;</span>: <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span>,</span><br><span class="line">                                <span class="attr">&quot;final_table_condition &quot;</span>: <span class="string">&quot;(`student`.`id` &lt; 10)&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]<span class="comment">/*finalizing_table_conditions*/</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;refine_plan&quot;</span>: [</span><br><span class="line">                            <span class="comment">//精简计划&#123;</span></span><br><span class="line">                                <span class="string">&quot;table&quot;</span>: <span class="string">&quot;`student`&quot;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]<span class="comment">/*refine_plan*/</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]/*steps*/</span><br><span class="line">            &#125;/*join_optimization*/</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;join_execution&quot;</span>: &#123;</span><br><span class="line">                <span class="comment">//执行&quot;select#&quot;: 1,</span></span><br><span class="line">                <span class="attr">&quot;steps&quot;</span>: [</span><br><span class="line">                    </span><br><span class="line">                ]<span class="comment">/*steps*/</span></span><br><span class="line">            &#125;<span class="comment">/*join_execution*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]/*steps*/</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第3部分：跟踪信息过长时，被截断的跟踪信息的字节数。</span></span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0 //丢失的超出最大容量的字节</span><br><span class="line"><span class="comment">//第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在</span></span><br><span class="line">调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。</span><br><span class="line">INSUFFICIENT_PRIVILEGES: 0 //缺失权限</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="mysql监控分析视图sys-schema">MySQL监控分析视图：Sys Schema</h3>
<p><img src="/2022/04/26/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_04trace%E5%92%8Csys_schema/image-20220426194758083.png" alt="image-20220426194758083" style="zoom:67%;"></p>
<h4 id="sys-schema视图摘要">Sys schema视图摘要</h4>
<ol type="1">
<li>主机相关：以host_summary开头，主要汇总了IO延迟的信息。</li>
<li>Innodb相关：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。</li>
<li>I/o相关：以io开头，汇总了等待I/O、I/O使用量情况。</li>
<li>内存使用情况：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li>
<li>连接与会话信息：processlist和session相关视图，总结了会话相关信息。</li>
<li>表相关：以schema_table开头的视图，展示了表的统计信息。</li>
<li>索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li>
<li>语句相关：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li>
<li>用户相关：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。</li>
<li>等待事件相关信息：以wait开头，展示等待事件的延迟情况。</li>
</ol>
<h4 id="sys-schema视图使用场景">Sys schema视图使用场景</h4>
<p>索引情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1. 查询冗余索引</span><br><span class="line">select * from sys.schema_redundant_indexes;</span><br><span class="line">#2. 查询未使用过的索引</span><br><span class="line">select * from sys.schema_unused_indexes;</span><br><span class="line">#3. 查询索引的使用情况</span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line">from sys.schema_index_statistics where table_schema&#x3D;&#39;dbname&#39; ;</span><br></pre></td></tr></table></figure>
<p>表相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 查询表的访问量</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from</span><br><span class="line">sys.schema_table_statistics group by table_schema,table_name order by io desc;</span><br><span class="line"># 2. 查询占用bufferpool较多的表</span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10;</span><br><span class="line"># 3. 查看表的全表扫描情况</span><br><span class="line">select * from sys.statements_with_full_table_scans where db&#x3D;&#39;dbname&#39;;</span><br></pre></td></tr></table></figure>
<p>语句相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1. 监控SQL执行的频率</span><br><span class="line">select db,exec_count,query from sys.statement_analysis order by exec_count desc;</span><br><span class="line">#2. 监控使用了排序的SQL</span><br><span class="line">select db,exec_count,first_seen,last_seen,query from sys.statements_with_sorting limit 1;</span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL</span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0</span><br><span class="line">order by (tmp_tables+tmp_disk_tables) desc;</span><br></pre></td></tr></table></figure>
<p>IO相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1. 查看消耗磁盘IO的文件</span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br></pre></td></tr></table></figure>
<p>Innodb 相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1. 行锁阻塞情况</span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL慢查询优化与Explain</title>
    <url>/2021/09/27/MySQL_%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8EExplain/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>慢查询物理原因</td>
<td>出现大量磁盘随机IO时，大部分时间都被浪费在寻址而非传输数据。<br>解决方案为建立索引，减少随机IO。</td>
</tr>
<tr class="even">
<td>慢查询索引原因</td>
<td>1、索引分区度低。<br>2、索引创建太多。<br>3、常用字段/排序字段没有创建索引。</td>
</tr>
<tr class="odd">
<td>慢查询SQL原因</td>
<td>1、对索引进行运算、使用函数、模糊匹配、隐式转换等。<br>2、联合索引不包含前面的索引，根据最左匹配原则会导致索引失效。</td>
</tr>
<tr class="even">
<td>SQL优化</td>
<td>1、使用join代替子查询。<br>2、使用覆盖索引，减少回表。<br>3、where将过滤数据多的条件放在前面。<br>4、使用联合索引，而不是建立多个索引。</td>
</tr>
<tr class="odd">
<td>Explain排查</td>
<td>使用Explain关键字查看SQL语句的执行信息。<br>type、key、extra字段观察是否使用了索引，是否进行的是全表扫描。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="sql的执行过程">SQL的执行过程</h3>
<p><img src="/2021/09/27/MySQL_%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8EExplain/image-20210927111125432.png" alt="image-20210927111125432" style="zoom: 67%;"></p>
<ol type="1">
<li>客户端发送一条SQL语句给服务端，服务端的连接器先进行账号/密码、权限等环节<strong>验证</strong>，有异常直接拒绝请求。</li>
<li>服务端查询<strong>缓存</strong>，如果SQL语句命中了缓存，则返回缓存中的结果，否则继续处理。</li>
<li>服务端对SQL语句进行词法解析、<strong>语法解析</strong>、预处理来检查SQL语句的合法性。</li>
<li>服务端通过优化器对之前生成的解析树进行<strong>优化</strong>处理，生成最优的<strong>物理执行计划</strong>。</li>
<li>将生成的物理执行计划调用<strong>存储引擎</strong>的相关接口，进行数据查询和处理。（存储引擎就包括redo log、undo logo等日志）</li>
<li>处理完成后将结果返回客户端。</li>
</ol>
<h3 id="sql物理执行原理">SQL物理执行原理</h3>
<p>InnoDB存储引擎(Storage Engine)是MySQL默认存储引擎。</p>
<p>它是面向行存储的，数据都是存储在磁盘的数据页中，数据页里面按照固定的行格式存储着每一行数据。行数据又分为多种格式，默认的Compact格式为：</p>
<p><img src="/2021/09/27/MySQL_%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8EExplain/image-20210927111445383.png" alt="image-20210927111445383" style="zoom:50%;"></p>
<p>同时，在SQL执行的过程中会根据局部性原理采取磁盘预读机制：</p>
<p>当计算机访问一个数据时，不仅会加载当前数据所在的数据页，还会将当前数据页相邻的数据页一同加载到内存，磁盘预读的长度一般为页的整倍数，从而有效降低磁盘IO的次数。</p>
<p><img src="/2021/09/27/MySQL_%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8EExplain/image-20210927111644942.png" alt="image-20210927111644942" style="zoom: 50%;"></p>
<p>将数据从磁盘读取到内存中进行处理时，需要经过的若干磁盘物理结构大致为：</p>
<p><img src="/2021/09/27/MySQL_%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8EExplain/image-20210927111849133.png" alt="image-20210927111849133" style="zoom: 50%;"></p>
<ul>
<li>扇区：是硬盘的读写的基本单位，通常情况下每个扇区的大小是 512B</li>
<li>磁盘块：文件系统读写数据的最小单位，相邻的扇区组合在一起形成一个块，一般是4KB</li>
<li>页：是内存的最小存储单位，页的大小通常为磁盘块大小的 2^n 倍</li>
<li>InnoDB页面的默认大小是16KB，是数倍个操作系统的页</li>
</ul>
<p>从磁盘读取数据的物理过程是：</p>
<ul>
<li>寻道：磁头移动定位到指定磁道</li>
<li>旋转：等待指定扇区从磁头下旋转经过</li>
<li>数据传输：数据在磁盘与内存之间的实际传输</li>
</ul>
<p>MySQL的数据是一行行存储在磁盘上的，并且这些数据并非物理连续地存储，这样的话要查找数据就无法避免随机在磁盘上读取和写入数据。</p>
<p>对于MySQL来说，当出现大量磁盘随机IO时，大部分时间都被浪费到寻道上，磁盘不停地转动，但无法传输很多的数据。</p>
<p>因此，慢查询的一个很大的原因就是太多的随机IO，导致读取数据的性能降低。</p>
<h3 id="索引">索引</h3>
<p>索引，本质上就是用某种数据结构将数据组织起来，便于快速地查找数据。</p>
<p>可以实现增删改查的数据结构非常多，包括：哈希表、二叉搜索树、AVL、红黑树、B树、B+树等，这些都是可以作为索引的候选数据结构。</p>
<p>结合MySQL的实际情况：</p>
<ul>
<li><p>磁盘和内存交互</p></li>
<li><p>随机磁盘IO</p></li>
<li><p>排序和范围查找</p></li>
<li><p>增删改的复杂度等</p></li>
</ul>
<p>综合考量之下B+树脱颖而出。</p>
<p>B+树作为多路平衡查找树，对于范围查找和排序都可以很好地支持，并且更加矮胖（原因是非叶子节点不存储数据），访问数据时的平均磁盘IO次数取决于树的高度，因此B+树可以让磁盘的查找次数更少。</p>
<p>在InnoDB中B+树的高度一般都在2<sub>4层，并且<strong>根节点常驻内存中</strong>，也就是说查找某值的行记录时最多只需要1</sub>3次磁盘I/O操作。</p>
<h4 id="聚集索引">聚集索引</h4>
<p>聚集索引的叶子节点存放的就是数据本身，可以理解为叶子节点就存储了一行数据。</p>
<p>每个使用Innodb作为数据库引擎的数据表<strong>都会</strong>有聚集索引。</p>
<p>假设我们有student表，将id作为主键索引，那么聚集索引的B+树结构，如图：</p>
<p><img src="/2021/09/27/MySQL_%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8EExplain/image-20210929094534075.png" alt="image-20210929094534075" style="zoom:50%;"></p>
<p>聚集索引的结构：</p>
<ul>
<li>非叶子节点不存数据（不存储完整的一行数据），只有主键和相关指针。</li>
<li>叶子节点包含主键、行数据、指针。</li>
<li>叶子节点之间由双向指针串联形成有序双向链表，叶子节点内部也是有序的。</li>
</ul>
<p>聚集索引按照如下规则创建：</p>
<ul>
<li>有主键时InnoDB利用主键来生成。</li>
<li>没有主键，InnoDB会选择一个非空的唯一索引来创建。</li>
<li>没有主键，没有非NULL的唯一索引时，InnoDB会隐式创建一个自增的列来创建。</li>
</ul>
<p>查找过程：</p>
<p>假如我们要查找id=10的数据，大致过程如下：</p>
<ul>
<li>索引的根结点在内存中，10&gt;9 因此找到P3指针</li>
<li>P3指向的数据并没有在内存中，因此产生1次磁盘IO读取磁盘块3到内存</li>
<li>在内存中对磁盘块3进行二分查找，找到ID=9的全部值</li>
</ul>
<h4 id="非聚集索引">非聚集索引</h4>
<p>非聚集索引的叶子节点中存放的是二级索引值和主键键值，非叶子节点和叶子节点都没有存储整行数据值。</p>
<p>假设我们有student表，将name作为二级索引，那么非聚集索引的B+树结构，如图：</p>
<p><img src="/2021/09/27/MySQL_%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8EExplain/image-20210929094956533.png" alt="image-20210929094956533" style="zoom:50%;"></p>
<p>非聚集索引的结构：</p>
<ul>
<li>叶子节点存储的是主键，没有存储数据行</li>
</ul>
<p>查找过程：</p>
<p>假如我们要查找name=Tom的记录的所有值，大致过程如下：</p>
<ul>
<li>从非聚集索引开始，根节点在内存中，按照name的字典序找到P3指针</li>
<li>P3指针所指向的磁盘块不在内存中，产生1次磁盘IO加载到内存</li>
<li>在内存中对磁盘块3的数据进行搜索，获得name=tom的记录的主键值为4</li>
<li>根据主键值4从聚集索引的根节点中获得P2指针</li>
<li>P2指针所指向的磁盘块不在内存中，产生第2次磁盘IO加载到内存</li>
<li>将上一步获得的数据，在内存中进行二分查找获得全部行数据</li>
</ul>
<p>该查询就包含了一次回表过程，因此性能比主键查询慢了一倍，因此尽量使用主键查询，一次完事。</p>
<p>总的过程即划分为两步：</p>
<ul>
<li><p>通过非聚集索引的叶子节点来确定数据行对应的主键</p></li>
<li><p>通过相应的主键值在聚集索引中查询到对应的行记录</p></li>
</ul>
<p>通过非聚集索引找到主键值，再根据主键值从聚集索引找对于行数据的过程称为<strong>回表查询</strong>。</p>
<p>换句话说：select * from student where name = 'Bob' 将产生回表查询，因为在name索引的叶子节点没有其他值，只能从聚集索引获得。</p>
<h4 id="覆盖索引">覆盖索引</h4>
<p>如果查找的字段在非聚集索引就可以完成，就可以避免一次回表过程，这种称为：覆盖索引，所以select * 并不是好习惯，需要什么拿什么就好。</p>
<h3 id="慢sql">慢SQL</h3>
<h4 id="原因">原因</h4>
<ul>
<li><p>数据库表索引设置不合理</p></li>
<li><p>SQL语句有问题，需要优化</p></li>
</ul>
<p>把设置原则和优化反过来说，就是普遍上慢SQL出现的原因。实际上可能慢SQL还包括单表记录太多（分库分表）和没有索引等情况。</p>
<h4 id="索引设置原则">索引设置原则</h4>
<ul>
<li>索引区分度低</li>
</ul>
<p>假如表中有1000w记录，其中有status字段表示状态，可能90%的数据status=1，可以不将status作为索引，因为其对数据记录区分度很低。</p>
<ul>
<li>切忌过多创建索引</li>
</ul>
<p>每个索引都需要占用磁盘空间，修改表数据时会对索引进行更新，索引越多，更新越复杂。</p>
<blockquote>
<p>因为每添加一个索引，.ibd文件中就需要多维护一个B+Tree索引树，如果某一个table中存在10个索引，那么就需要维护10棵B+Tree，写入效率会降低，并且会浪费磁盘空间。</p>
</blockquote>
<ul>
<li>常用查询字段建索引</li>
</ul>
<p>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度，属于热门字段，为其建立索引非常必要。</p>
<ul>
<li>常排序/分组/去重字段建索引</li>
</ul>
<p>对于需要经常使用ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段建立索引，可以有效借助B+树的特性来加速执行。</p>
<ul>
<li>主键和外键建索引</li>
</ul>
<p>主键可以用来创建聚集索引，外键也是唯一的且常用于表关联的字段，也需要建索引来提高性能。</p>
<h4 id="sql优化">SQL优化</h4>
<p>如果数据库表的索引设置比较合理，SQL语句书写不当会造成索引失效，甚至造成全表扫描，迅速拉低性能。</p>
<p><strong>索引失效</strong></p>
<ul>
<li>对索引使用函数</li>
</ul>
<blockquote>
<p>select id from std upper(name) = 'JIM';</p>
</blockquote>
<ul>
<li>对索引进行运算</li>
</ul>
<blockquote>
<p>select id from std where id+1=10;</p>
</blockquote>
<ul>
<li>对索引使用&lt;&gt; 、not in 、not exist、!=</li>
</ul>
<blockquote>
<p>select id from std where name != 'jim';</p>
</blockquote>
<ul>
<li>对索引进行前导模糊查询</li>
</ul>
<blockquote>
<p>select id from std name like '%jim';</p>
</blockquote>
<ul>
<li>隐式转换会导致不走索引</li>
</ul>
<blockquote>
<p>比如：字符串类型索引字段不加引号，select id from std name = 100;保持变量类型与字段类型一致</p>
</blockquote>
<ul>
<li>非索引字段的or连接</li>
</ul>
<blockquote>
<p>并不是所有的or都会使索引失效，如果or连接的所有字段都设置了索引，是会走索引的，一旦有一个字段没有索引，就会走全表扫描。</p>
</blockquote>
<ul>
<li>联合索引仅包含复合索引非前置列</li>
</ul>
<blockquote>
<p>联合索引包含key1，key2，key3三列，但SQL语句没有key1，根据联合索引的最左匹配原则，不会走联合索引。 select name from table where key2=1 and key3=2;</p>
</blockquote>
<p><strong>SQL优化</strong></p>
<ul>
<li>使用连接（join）代替子查询（select * from (select * from...)）</li>
</ul>
<blockquote>
<p>对于数据库来说，在绝大部分情况下，连接会比子查询更快，使用连接的方式，MySQL优化器一般可以生成更佳的执行计划，更高效地处理查询 而子查询往往需要运行重复的查询，子查询生成的<strong>临时表上也没有索引</strong>， 因此效率会更低。</p>
</blockquote>
<ul>
<li>LIMIT偏移量过大的优化</li>
</ul>
<blockquote>
<p>禁止分页查询偏移量过大，如limit 100000,10</p>
</blockquote>
<ul>
<li><p>使用覆盖索引</p>
<blockquote>
<p>减少select * 借助覆盖索引，减少回表查询次数。</p>
</blockquote></li>
<li><p>多表关联查询时，小表在前，大表在后</p></li>
</ul>
<blockquote>
<p>在MySQL中，执行from后的表关联查询（join）是从左往右执行的，第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。</p>
<p>目前这个已经优化过了，是自动的。</p>
</blockquote>
<ul>
<li>调整Where字句中的连接顺序</li>
</ul>
<blockquote>
<p>MySQL采用从左往右的顺序解析where子句，可以<strong>将过滤数据多的条件放在前面</strong>，最快速度缩小结果集。</p>
</blockquote>
<ul>
<li>使用小范围事务，而非大范围事务</li>
<li>遵循最左匹配原则</li>
<li>使用联合索引，而非建立多个单独索引</li>
</ul>
<h4 id="explain排查慢sql">Explain排查慢SQL</h4>
<p>在分析慢SQL之前需要通过MySQL进行相关设置：</p>
<ul>
<li><p>开启慢SQL日志。</p></li>
<li><p>设置慢SQL的执行时间阈值。</p></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">开启：SET GLOBAL slow_query_log = 1;</span><br><span class="line">开启状态：SHOW VARIABLES LIKE &#x27;%slow_query_log%&#x27;;</span><br><span class="line">设置阈值：SET GLOBAL long_query_time=3;</span><br><span class="line">查看阈值：SHOW GLOBAL VARIABLES LIKE &#x27;long_query_time%&#x27;; </span><br></pre></td></tr></table></figure>
<p>使用Explain命令查看SQL语句的执行信息，MySQL解释了它将如何处理该语句，包括表的加载顺序、sql 的查询类型、可能用到哪些索引，哪些索引又被实际使用、表与表之间的引用关系、一个表中有多少行被优化器查询等等。</p>
<p>Explain 执行计划包含字段信息如下：分别是 id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra 12个字段。</p>
<p><img src="/2021/09/27/MySQL_%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8EExplain/image-20210929113151381.png"></p>
<p>每个字段的大致内容如下，更详细的解释见参考资料：</p>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 82%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>id</td>
<td>表示查询中执行select子句或者操作表的顺序，id的值越大，代表优先级越高，越先执行。</td>
</tr>
<tr class="even">
<td>select_type</td>
<td>表示 select 查询的类型，主要是用于区分各种复杂的查询，例如：普通查询、联合查询、子查询等。</td>
</tr>
<tr class="odd">
<td>table</td>
<td>查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表，例如DERIVED、 &lt;union1,4&gt;等。</td>
</tr>
<tr class="even">
<td>partitions</td>
<td>查询时匹配到的分区信息，对于非分区表值为NULL，当查询的是分区表时，partitions显示分区表命中的分区情况。</td>
</tr>
<tr class="odd">
<td><strong>type</strong></td>
<td>type：查询使用了何种类型，它在 SQL优化中是一个非常重要的指标，以下性能从好到坏依次是：system（只有一条记录） &gt; const &gt; eq_ref （查询命中主键或唯一索引）&gt; ref &gt; ref_or_null &gt; index_merge（使用多个索引） &gt; unique_subquery &gt; index_subquery &gt; range &gt; index（遍历叶子节点读全表） &gt; ALL（从硬盘中读取）</td>
</tr>
<tr class="even">
<td>possible_keys</td>
<td>表示在MySQL中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，但这个索引并不定一会是最终查询数据时所被用到的索引。</td>
</tr>
<tr class="odd">
<td><strong>key</strong></td>
<td>key是查询中实际使用到的索引，若没有使用索引，显示为NULL。</td>
</tr>
<tr class="even">
<td>key_len</td>
<td>表示查询用到的索引长度（字节数），原则上长度越短越好。</td>
</tr>
<tr class="odd">
<td>ref</td>
<td>表示常量等值查询、关联查询或查询条件使用了表达式、函数。</td>
</tr>
<tr class="even">
<td>rows</td>
<td>以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。</td>
</tr>
<tr class="odd">
<td>filtered</td>
<td>一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。</td>
</tr>
<tr class="even">
<td><strong>Extra</strong></td>
<td>显示一些额外信息。Using index（覆盖索引）、Using where（通过where条件过滤数据）、Using temporary（结果需要使用临时表来存储）、Using filesort（ORDER BY的字段没有索引，需要优化）、Using join buffer（连接缓冲区来存储中间结果）等。</td>
</tr>
</tbody>
</table>
<h3 id="参考资料">参考资料</h3>
<p>https://mp.weixin.qq.com/s/5BmveQZ1_VqgMcCtU1oIyA</p>
<p>https://mp.weixin.qq.com/s/xf4VRBFLhhIAGGZPhbRetQ</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL日志</title>
    <url>/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>日志是MySQL数据库的重要组成部分，记录着数据库运行期间各种状态信息。</p>
<table>
<colgroup>
<col style="width: 4%">
<col style="width: 31%">
<col style="width: 31%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>binlog</th>
<th>redo log</th>
<th>undo log</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>记录内容</td>
<td>用于<strong>记录数据库执行的写入性操作</strong>(不包括查询)信息，以二进制的形式保存在磁盘中。</td>
<td>记录事务<strong>对数据页做了哪些修改</strong>。</td>
<td>保存了事务发生之前的<strong>数据的一个版本</strong>，可以用于回滚。其实本质上，老旧的记录就形成了undo log。</td>
</tr>
<tr class="even">
<td>日志类型</td>
<td>逻辑日志</td>
<td>物理日志</td>
<td>逻辑日志</td>
</tr>
<tr class="odd">
<td>使用场景</td>
<td><strong>主从复制</strong>和<strong>数据恢复</strong>。主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端重放binlog从而达到主从数据一致。数据恢复：通过使用MySQL binlog工具来恢复数据。</td>
<td>redo log <strong>防止DB出现故障造成数据的丢失</strong>。当出现故障导致脏页还未来得及保存进磁盘时，通过redo log进行重做，从而达到事务的持久性这一特性。</td>
<td>多版本并发控制协议<strong>MVCC中的快照读</strong>，通过undo log形成记录的多个版本，能执行快照读时能够判断读取的是哪个版本的记录。</td>
</tr>
</tbody>
</table>
<p><strong>redo log 和 bin log 区别</strong></p>
<p>作用不同：redo log是保证事务的持久性的，binlog主要用于主从复制。</p>
<p>内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</p>
<p>产生时机不同：事务开始之后就产生redo log，事务提交的时候产生bin log。</p>
<p>释放时机不同：当对应事务的脏页写入到磁盘之后，redo log可以被移除，超过一定时间后，binlog被删除。</p>
<p>恢复效率：基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog。</p>
<p>先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<a id="more"></a>
<h4 id="binlog">binlog</h4>
<ul>
<li><p><strong>概念</strong></p>
<p>binlog属于逻辑日志，用于<strong>记录数据库执行的写入性操作</strong>(不包括查询)信息，以二进制的形式保存在磁盘中。binlog是MySQL的逻辑日志，并且由Server层进行记录，使用任何存储引擎的MySQL数据库都会记录binlog日志。</p>
<blockquote>
<p>逻辑日志：可以简单理解为记录的就是sql语句。但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</p>
<p>物理日志：因为MySQL数据最终是保存在数据页中的，物理日志记录的就是数据页变更，即数据本身的值。</p>
</blockquote></li>
<li><p><strong>使用场景</strong></p>
<p>binlog的主要使用场景有两个，分别是<strong>主从复制</strong>和<strong>数据恢复</strong>。</p>
<p>主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端重放binlog从而达到主从数据一致。</p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/3.png" style="zoom:50%;"></p>
<p>数据恢复：通过使用MySQL binlog工具来恢复数据。</p></li>
<li><p><strong>产生时机</strong></p>
<p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p></li>
<li><p><strong>释放时机</strong></p>
<p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p></li>
<li><p>binlog记录方式</p>
<p>binlog是通过追加的方式进行写入的，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p></li>
</ul>
<h4 id="redo-log">redo log</h4>
<ul>
<li><p><strong>概念</strong></p>
<p>redo log属于物理日志，记录事务<strong>对数据页做了哪些修改</strong>。</p>
<blockquote>
<p>InnoDB的修改数据的基本流程</p>
<p>当我们想要修改DB上某一行数据的时候，InnoDB是把数据从磁盘读取到内存的缓冲池上进行修改。</p>
<p>这个时候数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为<strong>脏页</strong>。</p>
<p>InnoDB对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，这样会产生海量的IO操作，严重影响InnoDB的处理性能。</p>
<p>既然脏页与磁盘中的数据存在差异，那么如果在这期间DB出现故障就会造成数据的丢失。为了解决这个问题，redo log就应运而生了。</p>
</blockquote>
<p>redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。</p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/1.png" style="zoom:67%;"></p>
<p>mysql每执行一条DML语句，先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file。这种先写日志，再写磁盘的技术就是MySQL里经常说到的WAL(Write-Ahead Logging) 技术。</p></li>
<li><p><strong>使用场景</strong></p>
<p>redo log <strong>防止DB出现故障造成数据的丢失</strong>。当出现故障导致脏页还未来得及保存进磁盘时，通过redo log进行重做，从而达到事务的持久性这一特性。</p></li>
<li><p><strong>产生时机</strong></p>
<p>事务开始之后就产生redo log。</p></li>
<li><p><strong>释放时机</strong></p>
<p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p></li>
<li><p><strong>redo log记录方式</strong></p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/0.png" style="zoom:50%;"></p>
<p>redo log实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此redo log实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。</p>
<p>checkpoint所做的事就是把脏页给刷新回磁盘。所以，当DB重启恢复时，只需要恢复checkpoint之后的数据。这样就能大大缩短恢复时间。</p>
<p>check point到write pos之间是redo log待落盘的数据页更改记录。</p>
<p>write pos到check point之间的部分是redo log空着的部分，用于记录新的记录。</p>
<p>当write pos追上check point时，会先推动check point向前移动，空出位置再记录新的日志。</p></li>
<li><p><strong>redo log写入磁盘的时机</strong>（buffer到file的时机）</p>
<p>MySQL支持三种将redo log buffer写入redo log file的时机，可以通过innodb_flush_log_at_trx_commit参数配置，各参数值含义如下：</p>
<p>0（延迟写）</p>
<p>事务提交时不会将redo log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到redo log file中。也就是说<strong>设置为0时是(大约)每秒刷新写入到磁盘中的</strong>，当系统崩溃，会丢失1秒钟的数据。</p>
<p>1（实时写，实时刷）</p>
<p>事务每次提交都会将redo log buffer中的日志写入os buffer并调用fsync()刷到redo log file中。这种方式即使系统崩溃也不会丢失任何数据，但是因为<strong>每次提交都写入磁盘</strong>，IO的性能较差。</p>
<p>2（实时写，延迟刷）</p>
<p>每次<strong>提交都仅写入</strong>到os buffer，然后是<strong>每秒调用</strong>fsync()将os buffer中的日志写入到redo log file。</p></li>
</ul>
<h4 id="undo-log">undo log</h4>
<ul>
<li><p>概念</p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/2.png" style="zoom: 67%;"></p>
<p>undo log属于逻辑日志，保存了事务发生之前的<strong>数据的一个版本</strong>，可以用于回滚。其实本质上，老旧的记录就形成了undo log。</p></li>
<li><p>使用场景</p>
<p>多版本并发控制协议MVCC中，通过undo log形成记录的多个版本，能执行快照读时能够判断读取的是哪个版本的记录。</p></li>
<li><p>产生时机</p>
<p>不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表。</p></li>
<li><p>释放时机</p>
<p>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo log上的旧版本，决定是否可以清理undo log的日志空间。</p></li>
</ul>
<h4 id="参考资料">参考资料</h4>
<p>https://cloud.tencent.com/developer/article/1679325</p>
<p>https://www.cnblogs.com/wy123/p/8365234.html</p>
<p>https://zhuanlan.zhihu.com/p/35355751</p>
<p>https://www.cnblogs.com/xuwc/p/13873611.html</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引索引失效的情况</title>
    <url>/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="简介">简介</h3>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426203247043.png" alt="image-20220426203247043" style="zoom:67%;"></p>
<h3 id="最左匹配原则">最左匹配原则</h3>
<p>在有联合索引的情况下，索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426211526989.png" alt="image-20220426211526989" style="zoom:67%;"></p>
<h3 id="主键插入顺序">主键插入顺序</h3>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426211741818.png" alt="image-20220426211741818" style="zoom:67%;"></p>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426211858864.png" alt="image-20220426211858864" style="zoom: 50%;"></p>
<p>新插入的数据把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中，意味着产生性能损耗。</p>
<p>所以如果想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。</p>
<p>因此建议让主键具有AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是手动插入 。</p>
<p>注意，这可能仅针对于非核心业务的表有效，在一些特殊的业务场景下不能让主键自增。</p>
<h3 id="计算函数类型转换自动或手动导致索引失效">计算、函数、类型转换(自动或手动)导致索引失效</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#函数</span><br><span class="line"></span><br><span class="line">#索引生效，因为是现根据索引找，然后再判断</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#39;abc%&#39;;</span><br><span class="line">#索引失效，因为要一个一个取出来计算</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) &#x3D; &#39;abc&#39;;</span><br><span class="line"></span><br><span class="line">#索引失效</span><br><span class="line">EXPLAIN SELECT id, stuno, name FROM student WHERE SUBSTRING(name, 1,3)&#x3D;&#39;abc&#39;;</span><br><span class="line">#索引生效</span><br><span class="line">EXPLAIN SELECT id, stuno, NAME FROM student WHERE NAME LIKE &#39;abc%&#39;;</span><br><span class="line"></span><br><span class="line">#计算</span><br><span class="line"></span><br><span class="line">#索引失效，因为发生了计算</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 &#x3D; 900001;</span><br><span class="line">#索引生效，因为是等值匹配，且表达同一个意思</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno &#x3D; 900000;</span><br><span class="line"></span><br><span class="line">#类型转换</span><br><span class="line"></span><br><span class="line"># 未使用到索引，name&#x3D;123发生类型转换，索引失效。</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name&#x3D;123;</span><br><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name&#x3D;&#39;123&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="范围条件右边的列索引失效">范围条件右边的列索引失效</h3>
<p>当使用联合索引时，从遇到范围查询条件开始索引就会失效，因此涉及到范围查询的字段在创建索引时的应当放在最后。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_age_name_classid on student(age,name,classid);</span><br><span class="line"></span><br><span class="line">#联合索引只能使用到age</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age&#x3D;30 AND student.classId&gt;20 AND student.name &#x3D; &#39;abc&#39; ;</span><br><span class="line">#联合索引可以用age、name</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age&#x3D;30 AND student.name &#x3D; &#39;abc&#39; AND student.classId&gt;20 ;</span><br></pre></td></tr></table></figure>
<h3 id="不等于-或者索引失效">不等于(!= 或者&lt;&gt;)索引失效</h3>
<p>注意，这里指的是索引可能会失效的情况。</p>
<p>例如存在覆盖索引时，select的字段刚好能够完全被覆盖时，即使有!= 或者&lt;&gt;，依然会使用到索引，这是由于在索引内进行查找能够免去回表的操作，比起直接遍历整张表性能要好，因此选择使用索引。</p>
<p>当没有发生覆盖索引时，可能直接遍历全表比使用索引的效率要更高，因此可能会发生索引失效。</p>
<h3 id="is-null可以使用索引is-not-null无法使用索引">is null可以使用索引，is not null无法使用索引</h3>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426223124033.png" alt="image-20220426223124033" style="zoom:67%;"></p>
<h3 id="like以通配符开头索引失效">like以通配符%开头索引失效</h3>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426223434251.png" alt="image-20220426223434251" style="zoom:67%;"></p>
<p>当出现覆盖索引的情况时，由于避免了回表的操作，因此可以使用索引。</p>
<h3 id="or-前后存在非索引的列索引失效">OR 前后存在非索引的列，索引失效</h3>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426223540475.png" alt="image-20220426223540475" style="zoom:67%;"></p>
<p>当OR前后的条件都是索引列时，EXPLAIN结果中type字段的值就是index_merge，表示多个索引都被使用到了。</p>
<h3 id="数据库和表的字符集不统一">数据库和表的字符集不统一</h3>
<p>MySQL统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。</p>
<h3 id="小结">小结</h3>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426224045075.png" alt="image-20220426224045075" style="zoom:67%;"></p>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426224107517.png" alt="image-20220426224107517" style="zoom:67%;"></p>
<p><img src="/2022/04/26/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_01%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220426224244906.png" alt="image-20220426224244906" style="zoom:67%;"></p>
<p>1、即区分度更高的字段作为单列索引。</p>
<p>2、先经过区分度高的字段过滤后，剩余的数据更少。</p>
<p>3、即选择满足更多过滤条件字段的联合索引。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 关联查询优化</title>
    <url>/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>外连接</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="外连接与内连接">外连接与内连接</h3>
<p>内连接：只会取两表关联条件匹配的到的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from 表名  inner join  关联表  on 两表关联条件 (内连接)</span><br></pre></td></tr></table></figure>
<p>外连接：如果两表关联条件匹配不到的数据，也会取到关联条件列展示为NULL。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from 表名 left join 关联表 on 两表条件  (左外连接)</span><br><span class="line">select * from 表名 right join 关联表 on 两表条件 (右外连接)</span><br></pre></td></tr></table></figure>
<p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表的处理结果返回给用户。</p>
<p>在使用inner join时，on和where的条件位置没有区别。</p>
<p>在使用left jion时，on和where条件的区别如下：</p>
<ul>
<li><p>on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。</p></li>
<li><p>where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p></li>
</ul>
<p>因此，对于left join，不管on后面跟什么条件，左表的数据全部查出来，因此要想过滤需把条件放到where后面。</p>
<p>对于inner join，满足on后面的条件表的数据才能查出，可以起到过滤作用，也可以把条件放到where后面。</p>
<p>外连接转内连接的情况：</p>
<p>由上可知，当LEFT JOIN中的WHERE过滤条件中出现被驱动表的过滤条件时，最终结果都不会含有带NULL的数据，这些数据都会被过滤掉，因此外连接在真正的SQL语句中被转成内连接执行。</p>
<blockquote>
<p>https://stackoverflow.com/questions/3256304/left-join-turns-into-inner-join</p>
</blockquote>
<h3 id="join语句底层原理">JOIN语句底层原理</h3>
<h4 id="simple-nested-loop-join">Simple Nested-Loop Join</h4>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427212025478.png" alt="image-20220427212025478" style="zoom:67%;"></p>
<p>可以从读取记录数中看出，当A越小时总的读取记录数越小，因此小表作为驱动表更合理。</p>
<blockquote>
<p>什么叫作“小表”？ 在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</p>
</blockquote>
<h4 id="index-nested-loop-join">Index Nested-Loop Join</h4>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427213056423.png" alt="image-20220427213056423" style="zoom:67%;"></p>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427213208843.png" alt="image-20220427213208843" style="zoom:67%;"></p>
<p>读取记录数由于走索引不需要进行全表扫描，因此是A乘上匹配到的B的数量。</p>
<p>比较次数取决于索引中B+树的高度。</p>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427214332596.png" alt="image-20220427214332596" style="zoom:67%;"></p>
<p>案例：在这个流程里： 1. 对驱动表t1做了全表扫描，这个过程需要扫描100行； 2. 而对于每一行R，根据a字段去表t2查找，走的是树搜索过程。由于构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描100行； 3. 所以，整个执行流程，总扫描行数是200。</p>
<h4 id="block-nested-loop-join">Block Nested-Loop Join</h4>
<p>主要是降低了被驱动表反复加载到内存又被清除掉的IO次数。</p>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427213457099.png" alt="image-20220427213457099" style="zoom:67%;"></p>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427213905404.png" alt="image-20220427213905404" style="zoom:67%;"></p>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427214015400.png" alt="image-20220427214015400" style="zoom:67%;"></p>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427215046829.png" alt="image-20220427215046829" style="zoom:67%;"></p>
<figure>
<img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427214218398.png" alt="image-20220427214218398"><figcaption aria-hidden="true">image-20220427214218398</figcaption>
</figure>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427215938514.png" alt="image-20220427215938514" style="zoom:67%;"></p>
<h4 id="hash-join">Hash Join</h4>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427220438176.png" alt="image-20220427220438176" style="zoom:67%;"></p>
<p><img src="/2022/04/27/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_02%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220427220636034.png" alt="image-20220427220636034" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_03%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="覆盖索引">覆盖索引</h3>
<p>索引包含了满足查询结果的数据就叫做覆盖索引。</p>
<p>简单说就是， 索引列+主键 包含 SELECT 到 FROM之间查询的列。</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_03%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220430152703914.png" alt="image-20220430152703914" style="zoom:67%;"></p>
<h3 id="索引条件下推">索引条件下推</h3>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_03%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220430155434275.png" alt="image-20220430155434275" style="zoom:67%;"></p>
<p>ICP的使用条件</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_03%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220430155809739.png" alt="image-20220430155809739" style="zoom:67%;"></p>
<p>简单来说，ICP仅用于二级索引，因为二级索引才有回表的操作，ICP的目的就是利用索引去过滤一些数据，没有回表操作比如聚簇索引和覆盖索引等情况下则无法使用ICP。</p>
<p>案例</p>
<p>如果在（zipcode, lastname, firstname)上建立了索引</p>
<figure>
<img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_03%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220430160043856.png" alt="image-20220430160043856"><figcaption aria-hidden="true">image-20220430160043856</figcaption>
</figure>
<p>此时，该查询语句只能使用到zipcode索引，lastname此时不能用于查找数据，因为出现了模糊匹配开头的索引失效情况，然而此时却可以利用lastname做数据的过滤。</p>
<p>将数据在联合索引中根据zipcode查询出来后，使用lastname先过滤数据，然后再进行回表操作取出全部数据，再根据address过滤数据，这就是索引条件下推（ICP）。</p>
<p>ICP的打开和关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#关闭</span><br><span class="line">SET optimizer_switch&#x3D;&quot;index_condition_pushdown&#x3D;off&quot;</span><br><span class="line"></span><br><span class="line">#打开</span><br><span class="line">SET optimizer_switch&#x3D;&quot;index_condition_pushdown&#x3D;on&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据</category>
        <category>海量数据</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 其他查询优化</title>
    <url>/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="子查询优化">子查询优化</h3>
<p>结论：</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428200827281.png" alt="image-20220428200827281" style="zoom:67%;"></p>
<p>分析：</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428200855334.png" alt="image-20220428200855334" style="zoom:67%;"></p>
<h3 id="排序优化">排序优化</h3>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428201320388.png" alt="image-20220428201320388" style="zoom:67%;"></p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428204552767.png" alt="image-20220428204552767" style="zoom:67%;"></p>
<p>ORDER BY加索引不加LIMIT关键字，索引失效</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428202222737.png" alt="image-20220428202222737" style="zoom:67%;"></p>
<p>ORDER BY加索引，当数据量较大时，因为存在回表操作，可能不会使用索引，直接将数据加载到内存中开销更小。</p>
<p>当加上LIMIT关键字后，只需要少量的回表操作，开销较低时，就会使用索引。</p>
<p>ORDER BY字段时，需要注意字段上索引的顺序。联合索引本身是按照字段进行升序构建的。</p>
<p>一个升序一个降序无法使用索引：</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428202742795.png" alt="image-20220428202742795" style="zoom:67%;"></p>
<p>两个都是降序，反而可以倒着遍历，因为叶子节点内是双向链表：</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428202708125.png" alt="image-20220428202708125" style="zoom:67%;"></p>
<p>过滤和索引的关系：</p>
<p>当存在联合索引(age, class_id, name)：</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428203912939.png" alt="image-20220428203912939" style="zoom:67%;"></p>
<p>上面两句都只用到age索引，因为过滤完数据之后剩余的数据量太小，可以直接加载进内存排序而无需再利用索引进行多次回表操作。</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428203940526.png" alt="image-20220428203940526" style="zoom:67%;"></p>
<p>上面一句没用到索引，下面一句全部用上，因为上面没有LIMIT限制，数据量太多，下面经过LIMIT限制后直接通过索引找到排序之后的前若干个数据，开销相对较小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE age &#x3D; 30 AND stuno &lt;101000 ORDER BY NAME;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428205716954.png" alt="image-20220428205716954" style="zoom:67%;"></p>
<p>存在联合索引时的一些案例小结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#INDEX a_b_c(a,b,c)</span><br><span class="line"></span><br><span class="line">#order by 能使用索引最左前缀</span><br><span class="line">- ORDER BY a</span><br><span class="line">- ORDER BY a,b</span><br><span class="line">- ORDER BY a,b,c</span><br><span class="line">- ORDER BY a DESC,b DESC,c DESC</span><br><span class="line"></span><br><span class="line">#如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引</span><br><span class="line">- WHERE a &#x3D; const ORDER BY b,c</span><br><span class="line">- WHERE a &#x3D; const AND b &#x3D; const ORDER BY c</span><br><span class="line">- WHERE a &#x3D; const ORDER BY b,c</span><br><span class="line">- WHERE a &#x3D; const AND b &gt; const ORDER BY b,c</span><br><span class="line"></span><br><span class="line">#不能使用索引进行排序</span><br><span class="line">- ORDER BY a ASC,b DESC,c DESC &#x2F;* 排序不一致 *&#x2F;</span><br><span class="line">- WHERE g &#x3D; const ORDER BY b,c &#x2F;*丢失a索引*&#x2F;</span><br><span class="line">- WHERE a &#x3D; const ORDER BY c &#x2F;*丢失b索引*&#x2F;</span><br><span class="line">- WHERE a &#x3D; const ORDER BY a,d &#x2F;*d不是索引的一部分*&#x2F;</span><br><span class="line">- WHERE a in (...) ORDER BY b,c &#x2F;*对于排序来说，多个相等条件也是范围查询*&#x2F;</span><br></pre></td></tr></table></figure>
<p>FileSort</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428211758197.png" alt="image-20220428211758197" style="zoom:67%;"></p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428211057753.png" alt="image-20220428211057753" style="zoom:67%;"></p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428211525659.png" alt="image-20220428211525659" style="zoom:67%;"></p>
<h3 id="group-by优化">GROUP BY优化</h3>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428214500160.png" alt="image-20220428214500160" style="zoom:67%;"></p>
<h3 id="分页查询优化">分页查询优化</h3>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428214700864.png" alt="image-20220428214700864" style="zoom:67%;"></p>
<p>方案一：主键自增时</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428214734210.png" alt="image-20220428214734210" style="zoom:67%;"></p>
<p>方案二：在索引上完成排序（*）</p>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220428214810730.png" alt="image-20220428214810730" style="zoom:67%;"></p>
<h3 id="exists与in">EXISTS与IN</h3>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220430173812901.png" alt="image-20220430173812901" style="zoom:67%;"></p>
<h3 id="count与count字段">COUNT(*)与COUNT(字段)</h3>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220430174255769.png" alt="image-20220430174255769" style="zoom:67%;"></p>
<h3 id="select">SELECT(*)</h3>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220430174503101.png" alt="image-20220430174503101" style="zoom:67%;"></p>
<h3 id="limit-1">LIMIT 1</h3>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220430174636287.png" alt="image-20220430174636287" style="zoom:67%;"></p>
<h3 id="多使用commit">多使用COMMIT</h3>
<p><img src="/2022/04/28/MySQL_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96_04%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/image-20220430174721925.png" alt="image-20220430174721925" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引的数据结构</title>
    <url>/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>索引</td>
<td>便于存储引擎快速查找数据的数据结构。</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="简介">简介</h3>
<p>索引（Index）是便于存储引擎快速查找数据的数据结构。</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220417153701853.png" alt="image-20220417153701853" style="zoom:67%;"></p>
<p>即不同存储引擎下，索引对应的数据结构可能是不同的。</p>
<p>索引的优点</p>
<p>（1）通过降低数据库的IO成本，<strong>提高数据检索的效率</strong>。（最主要）</p>
<p>（2）通过创建<strong>唯一索引</strong>，可以保证数据库表中每一行数据的唯一性。</p>
<p>（3）可以<strong>加速表和表之间的连接</strong>。即，对于有依赖关系的子表和父表联合查询时，通过外键可以提高查询速度。</p>
<p>（4）在使用分组（group by）和排序子句（order by）进行数据查询时，可以显著<strong>减少查询中分组和排序的时间</strong>，降低了CPU的消耗。</p>
<p>索引的缺点</p>
<p>（1）<strong>创建索引和维护索引要耗费时间</strong>，并且随着数据量的增加，所耗费的时间也会增加。</p>
<p>（2）索引需要<strong>占磁盘空间</strong>。除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</p>
<p>（3）虽然索引大大提高了查询速度，同时却会<strong>降低更新表的速度</strong>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p>
<blockquote>
<p>一种可行的方案是当存在大量增删改查操作时，先删除索引，操作完数据后再创建索引，因为创建索引的时间比维护索引的时间要小。</p>
</blockquote>
<h3 id="innodb中的索引">InnoDB中的索引</h3>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220418152151998.png" alt="image-20220418152151998" style="zoom:67%;"></p>
<p>数据页中的存储内容可以分为<strong>目录项</strong>和<strong>普通记录</strong>。</p>
<p>目录项记录和普通的用户记录的<strong>不同点</strong>：</p>
<ul>
<li><p>目录项记录的record_type（数据页中一条记录中记录头信息中的一个字段）值是1，而普通用户记录的record_type 值是0。</p></li>
<li><p>目录项记录只有主键值和页号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。</p></li>
</ul>
<blockquote>
<p>记录头信息（是用户记录中的一个字段，也就是数据页中一条记录中记录头信息中的一个字段）里还有一个叫min_rec_mask 的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask 值为1 ，其他别的记录的min_rec_mask 值都是0 。</p>
</blockquote>
<p>目录项记录和普通的用户记录的<strong>相同点</strong>：</p>
<ul>
<li>两者用的是一样的数据页，都会为主键值生成Page Directory （页目录），从而在按照主键值进行查找时可以使用<strong>二分法</strong>来加快查询速度。</li>
</ul>
<blockquote>
<p>根据索引值查找记录的过程大致分为两步：</p>
<p>1.先到存储目录项记录的页，根据二分法在目录项中快速查询。</p>
<p>2.根据录项记录的页寻找到叶子节点的数据页，根据二分法快速定位数据。</p>
</blockquote>
<p>现在以查找主键为20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol type="1">
<li>先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</li>
<li>再到存储用户记录的页9中根据二分法快速定位到主键值为20 的用户记录。</li>
</ol>
<p>数据页之间通过双向链表连接，数据页中的记录通过单向链表连接。</p>
<p>InnoDB下索引的数据结构对应B+树。假设一个数据页中，能够存放n条数据，能够存放m个目录项，通常m多于n。</p>
<p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放n条记录。</p>
<p>如果B+树有2层，最多能存放<span class="math inline">\(m×n=mn\)</span>条记录。</p>
<p>如果B+树有3层，最多能存放<span class="math inline">\(m×m×n= m^2n\)</span> ，当<span class="math inline">\(m=1000,n=100\)</span>时已经达到1,0000,0000 条记录。</p>
<p>如果B+树有4层，最多能存放<span class="math inline">\(m×m×n= m^3n\)</span> 条记录。</p>
<p>因此一般情况下，所用到的B+树都不会超过4层，通过索引值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory （页目录），所以在页面内也可以通过二分法实现快速定位记录。</p>
<h3 id="innodb索引的分类">InnoDB索引的分类</h3>
<p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。</p>
<p>非聚簇索引称为二级索引或者辅助索引，联合索引是非聚簇索引的一种。</p>
<h4 id="聚簇索引">聚簇索引</h4>
<p>就是用主键作为目录项构成的索引，将数据组织成B+树的结构，叶子节点存放完整的记录项。</p>
<p>一张表只能存在一个聚簇索引，如果没有显示指定主键，则采用隐藏列中的隐式主键构建索引（实际上就是一个自增id）。</p>
<p>这也是为什么InnoDB引擎下一张表只会产生一个文件.ibd，这其中包含了索引和数据。</p>
<p>特点： 1. 使用<strong>主键值的大小进行记录和页的排序</strong>，这包括三个方面的含义：</p>
<ul>
<li><p>页内的记录是按照主键的大小顺序排成一个<strong>单向链表</strong>。</p></li>
<li><p>各个存放<strong>用户记录</strong>的页也是根据页中用户记录的主键大小顺序<strong>排成一个双向链表</strong>。</p></li>
<li><p>存放<strong>目录项记录</strong>的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序<strong>排成一个双向链表</strong>。</p></li>
</ul>
<ol start="2" type="1">
<li>B+树的<strong>叶子节点存储的是完整的用户记录</strong>。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</li>
</ol>
<p>优点：</p>
<ul>
<li><p>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据<strong>比非聚簇索引更快（不用回表）。</strong></p></li>
<li><p>聚簇索引对于主键的<strong>排序查找和范围查找</strong>速度非常快</p></li>
<li><p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<strong>节省了大量的io操作</strong>。</p></li>
</ul>
<p>缺点：</p>
<ul>
<li><p>插入速度严重依赖于插入顺序，<strong>按照主键的顺序插入是最快的方式</strong>，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键</p></li>
<li><p>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般<strong>定义主键为不可更新</strong></p></li>
</ul>
<h4 id="非聚簇索引">非聚簇索引</h4>
<p>就是用非主键字段作为目录项构成的索引，将数据组织成B+树的结构，叶子节点存放该非主键字段和对应的主键字段。</p>
<p>在查询时，先通过该字段查找到主键，然后再通过聚簇索引中的主键查找到详细数据<strong>（称为回表）</strong>。</p>
<p>一张表可以存在多个非聚簇索引。</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419195357758.png" alt="image-20220419195357758" style="zoom:67%;"></p>
<h4 id="联合索引">联合索引</h4>
<p>非聚簇索引的一种特殊情况。是使用多个字段构建的索引。</p>
<p>在构建B+树时按照多个字段的先后顺序对目录项和数据项进行排序。</p>
<p>注意其叶子节点依然存放的是主键值。</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419194201263.png" alt="image-20220419194201263" style="zoom:67%;"></p>
<h3 id="innodb的b树索引的注意事项">InnoDB的B+树索引的注意事项</h3>
<ul>
<li><p>根页面的位置固定（B+树是自上而下创建的）</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419205328506.png" alt="image-20220419205328506" style="zoom:67%;"></p></li>
<li><p>非聚簇索引中目录项包含索引字段、主键值、页号以保证每个目录项的唯一性</p>
<p>因为索引字段可能存在重复值，这样就会导致添加索引项时的困惑。因此需要使用主键值保证唯一性，当索引字段重复时即可用主键判断。</p></li>
<li><p>一个数据页中最少存储2条数据记录（才能使树分叉）</p></li>
</ul>
<h3 id="myisam中的索引">MyISAM中的索引</h3>
<p>MyISAM引擎使用B+Tree 作为索引结构，叶子节点的data域存放的是数据记录的地址。</p>
<p>即索引和数据是分开存储的（数据不需要排序）。</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419205833946.png" alt="image-20220419205833946" style="zoom:67%;"></p>
<p>其中聚簇索引和非聚簇索引的结构没有任何区别，只是要求建立的索引字段是否唯一的区别。</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419205618656.png" alt="image-20220419205618656" style="zoom:67%;"></p>
<h4 id="myisam中的索引与innodb的区别">MyISAM中的索引与InnoDB的区别</h4>
<p>① 在InnoDB存储引擎中，只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM 中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。</p>
<p>② InnoDB的<strong>数据文件本身就是索引文件</strong>，而MyISAM索引文件和数据文件是分离的，<strong>索引文件仅保存数据记录的地址</strong>。</p>
<p>③ InnoDB的非聚簇索引叶子节点存储相应记录主键的值，而MyISAM索引叶子节点记录的是地址。换句话说，InnoDB的所有非聚簇索引都引用主键作为叶子节点。</p>
<p>④ MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p>
<p>⑤ <strong>InnoDB要求表必须有主键（ MyISAM可以没有）</strong>。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419210246714.png" alt="image-20220419210246714" style="zoom:50%;"></p>
<h3 id="索引的代价">索引的代价</h3>
<ul>
<li><p>空间上的代价</p>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的<strong>每一个节点都是一个数据页</strong>，一个页默认会 占用16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p></li>
<li><p>时间上的代价</p>
<p>每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。</p>
<p>而且，B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。</p>
<p>增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位， 页面分裂、页面回收等操作来维护好节点和记录的排序。</p>
<p>如果建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会降低性能。</p></li>
</ul>
<h3 id="mysql索引数据结构选择">MySQL索引数据结构选择</h3>
<p>主要就是根据索引对应的数据结构是否能降低磁盘IO次数来考虑索引的数据结构。</p>
<h4 id="hash索引">Hash索引</h4>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419221003001.png" alt="image-20220419221003001" style="zoom:67%;"></p>
<p>Hash索引的适用场景：</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419221149671.png" alt="image-20220419221149671" style="zoom:67%;"></p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419221319048.png" alt="image-20220419221319048" style="zoom:67%;"></p>
<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220419221219754.png" alt="image-20220419221219754" style="zoom:67%;"></p>
<h4 id="b树">B树</h4>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420201319776.png" alt="image-20220420201319776" style="zoom:67%;"></p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420201357155.png" alt="image-20220420201357155" style="zoom:67%;"></p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420201238123.png" alt="image-20220420201238123" style="zoom:67%;"></p>
<p>在 B 树的搜索过程中，比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。</p>
<p>而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。</p>
<p>B 树相比于平衡二叉树来说磁盘 I/O 操作要少，在数据查询中比平衡二叉树效率要高。所以只要树的高度足够低，IO次数足够少，就可以提高查询性能。</p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420201617314.png" alt="image-20220420201617314" style="zoom:67%;"></p>
<h4 id="b树-1">B+树</h4>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420202423794.png" alt="image-20220420202423794" style="zoom:67%;"></p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420202737383.png" alt="image-20220420202737383" style="zoom:67%;"><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420203045666.png" alt="image-20220420203045666"></p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420203118360.png" alt="image-20220420203118360" style="zoom:67%;"></p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420203217642.png" alt="image-20220420203217642" style="zoom:67%;"></p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420203330828.png" alt="image-20220420203330828" style="zoom:67%;"></p>
<p><img src="/2022/04/17/MySQL_%E7%B4%A2%E5%BC%95_01%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220420203409225.png" alt="image-20220420203409225" style="zoom:67%;"></p>
<p>索引需要手动指定吗？</p>
<p>如果是NDB或MEMORY存储引擎，可以手动指定是Hash索引还是B+树索引。其他存储引擎无需手动指定。</p>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引的分类与创建</title>
    <url>/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="索引的分类">索引的分类</h3>
<h4 id="按照功能划分">按照功能划分</h4>
<p>从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</p>
<p><img src="/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/image-20220420212210772.png" alt="image-20220420212210772" style="zoom:67%;"></p>
<p><img src="/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/image-20220420212318954.png" alt="image-20220420212318954" style="zoom:67%;"></p>
<p>因为数据存储在文件中只能按照一种顺序进行存储，因此最多只能有一个主键索引，数据文件按照主键来进行组织。</p>
<p><img src="/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/image-20220420213141724.png" alt="image-20220420213141724" style="zoom:67%;"></p>
<p><img src="/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/image-20220420213235627.png" alt="image-20220420213235627" style="zoom:67%;"></p>
<h4 id="按照物理实现方式划分">按照物理实现方式划分</h4>
<p>聚簇索引和非聚簇索引。</p>
<h4 id="按照作用字段个数进行划分">按照作用字段个数进行划分</h4>
<p>按照作用字段个数进行划分，分成单列索引和联合索引。</p>
<p><img src="/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/image-20220420212754947.png" alt="image-20220420212754947" style="zoom:67%;"></p>
<p><img src="/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/image-20220420212834657.png" alt="image-20220420212834657" style="zoom:67%;"></p>
<h4 id="数据库引擎支持的索引">数据库引擎支持的索引</h4>
<p><img src="/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/image-20220420213321502.png" alt="image-20220420213321502" style="zoom:67%;"></p>
<h3 id="索引的创建">索引的创建</h3>
<h4 id="创建表时创建">创建表时创建</h4>
<h5 id="隐式创建">隐式创建</h5>
<p>在添加主键约束、唯一性约束、外键约束时，索引会被自动创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept(</span><br><span class="line">dept_id INT PRIMARY KEY AUTO_INCREMENT, #主键约束，创建主键索引</span><br><span class="line">dept_name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">emp_id INT PRIMARY KEY AUTO_INCREMENT, #主键约束，创建主键索引</span><br><span class="line">emp_name VARCHAR(20) UNIQUE, #唯一性约束，创建唯一性索引</span><br><span class="line">dept_id INT,</span><br><span class="line">CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id) #外键约束，创建外键索引</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="显式创建">显式创建</h5>
<p>显式创建索引的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |</span><br><span class="line">DESC]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>UNIQUE 、FULLTEXT 和SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；</p></li>
<li><p>INDEX 与KEY 为同义词，两者的作用相同，用来指定创建索引；</p></li>
<li><p>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</p></li>
<li><p>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</p></li>
<li><p>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</p></li>
<li><p>ASC 或DESC 指定升序或者降序的索引值存储。</p></li>
</ul>
<h5 id="普通索引">普通索引</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE book(</span><br><span class="line">    book_id INT ,</span><br><span class="line">    book_name VARCHAR(100),</span><br><span class="line">    authors VARCHAR(100),</span><br><span class="line">    info VARCHAR(100) ,</span><br><span class="line">    comment VARCHAR(100),</span><br><span class="line">    year_publication YEAR,</span><br><span class="line">    INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="唯一索引">唯一索引</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test1(</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    name varchar(30) NOT NULL,</span><br><span class="line">    UNIQUE INDEX uk_idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>该语句执行完毕之后，可以在MySQL客户端中使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM test1 \G</span><br></pre></td></tr></table></figure>
<h5 id="主键索引">主键索引</h5>
<p>设定为主键后数据库会自动建立索引，innodb为聚簇索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">    id INT(10) UNSIGNED AUTO_INCREMENT ,</span><br><span class="line">    student_no VARCHAR(200),</span><br><span class="line">    student_name VARCHAR(200),</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>删除主键索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">drop PRIMARY KEY ;</span><br></pre></td></tr></table></figure>
<p>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引。</p>
<h5 id="联合索引">联合索引</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test3(</span><br><span class="line">    id INT(11) NOT NULL,</span><br><span class="line">    name CHAR(30) NOT NULL,</span><br><span class="line">    age INT(11) NOT NULL,</span><br><span class="line">    info VARCHAR(255),</span><br><span class="line">    INDEX multi_idx(id,name,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="全文索引">全文索引</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</span><br><span class="line">CREATE TABLE &#96;papers&#96; (</span><br><span class="line">    &#96;id&#96; int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;title&#96; varchar(200) DEFAULT NULL,</span><br><span class="line">    &#96;content&#96; text,</span><br><span class="line">    PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">    FULLTEXT KEY &#96;title&#96; (&#96;title&#96;,&#96;content&#96;)</span><br><span class="line">) ENGINE&#x3D;MyISAM DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"># 不同于like方式的的查询：</span><br><span class="line">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;</span><br><span class="line"></span><br><span class="line"># 全文索引用match+against方式查询：</span><br><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</span><br><span class="line"></span><br><span class="line"># 全文索引比 like + % 快 N 倍，但是可能存在精度问题；</span><br><span class="line"># 如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</span><br></pre></td></tr></table></figure>
<h5 id="空间索引">空间索引</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 空间索引创建中，要求空间类型的字段必须为非空。</span><br><span class="line">CREATE TABLE test5(</span><br><span class="line">    geo GEOMETRY NOT NULL,</span><br><span class="line">    SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">) ENGINE&#x3D;MyISAM;</span><br></pre></td></tr></table></figure>
<h4 id="创建表后创建">创建表后创建</h4>
<p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p>
<ul>
<li><p>使用ALTER TABLE语句创建索引 ALTER TABLE语句创建索引的基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name </span><br><span class="line">ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) </span><br><span class="line">[ASC | DESC]</span><br></pre></td></tr></table></figure></li>
<li><p>使用CREATE INDEX创建索引 CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span><br><span class="line">ON table_name (col_name[length],...) </span><br><span class="line">[ASC | DESC]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="索引的删除">索引的删除</h3>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。</p>
<p>如果组成索引的所有列都被删除，则整个索引将被删除。</p>
<ul>
<li><p>使用ALTER TABLE删除索引 ALTER TABLE删除索引的基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure></li>
<li><p>使用DROP INDEX语句删除索引 DROP INDEX删除索引的基本语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/image-20220421211245537.png" alt="image-20220421211245537" style="zoom:67%;"></p></li>
</ul>
<p><img src="/2022/04/20/MySQL_%E7%B4%A2%E5%BC%95_02%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%9B%E5%BB%BA/image-20220421211343477.png" alt="image-20220421211343477" style="zoom:67%;"></p>
<h3 id="mysql-8.0新特性">MySQL 8.0新特性</h3>
<h4 id="降序索引">降序索引</h4>
<p>MySQL 8.0之前，DESC是无法起作用的，所有的索引依然按照升序排列。</p>
<p>MySQL 8.0之后，支持DESC降序排列索引。</p>
<p>降序索引只对查询中<strong>特定的排序顺序</strong>（例如ORDER BY column DESC）有效，如果使用不当，反而查询效率更低。</p>
<h4 id="隐藏索引">隐藏索引</h4>
<p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。</p>
<p>从MySQL 8.x开始支持隐藏索引（invisible indexes） ，<strong>将待删除的索引设置为隐藏索引后，普通查询和查询优化器都不再使用这个索引进行数据的查找</strong>（即使使用force index（强制使用索引），优化器也不会使用该索引）。</p>
<p>确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。</p>
<p>注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
<p><strong>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建表时直接创建：在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现</span><br><span class="line">CREATE TABLE tablename(</span><br><span class="line">    propname1 type1[CONSTRAINT1],</span><br><span class="line">    propname2 type2[CONSTRAINT2],</span><br><span class="line">    ……</span><br><span class="line">    propnamen typen,</span><br><span class="line">    INDEX [indexname](propname1 [(length)]) INVISIBLE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 在已经存在的表上创建</span><br><span class="line">CREATE INDEX indexname</span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br><span class="line"></span><br><span class="line">ALTER TABLE tablename</span><br><span class="line">ADD INDEX indexname (propname [(length)]) INVISIBLE;</span><br><span class="line"></span><br><span class="line"># 切换索引可见状态</span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br><span class="line"></span><br><span class="line"># 使隐藏索引对查询优化器可见</span><br><span class="line">#在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关（use_invisible_indexes）来打开某个设置，使隐藏索引对查询优化器可见。</span><br><span class="line">#如果use_invisible_indexes设置为off(默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。</span><br><span class="line"></span><br><span class="line">#在MySQL命令行执行如下命令查看查询优化器的开关设置。</span><br><span class="line">mysql&gt; select @@optimizer_switch \G</span><br><span class="line">#在输出的结果信息中找到如下属性配置，此属性配置值为off，说明隐藏索引默认对查询优化器不可见</span><br><span class="line">use_invisible_indexes&#x3D;off</span><br><span class="line"># 使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令</span><br><span class="line">mysql&gt; set session optimizer_switch&#x3D;&quot;use_invisible_indexes&#x3D;on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引的分类与创建</title>
    <url>/2022/04/22/MySQL_%E7%B4%A2%E5%BC%95_03%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h3 id="适合使用索引的情况">适合使用索引的情况</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>字段的值有唯一性的限制</td>
<td>此时应该添加唯一性约束或唯一索引，二者取其一即可。<br>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。<br>不要认为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</td>
</tr>
<tr class="even">
<td>频繁作为 WHERE 查询条件的字段</td>
<td>创建普通索引就可以大幅提升数据查询的效率。</td>
</tr>
<tr class="odd">
<td>经常 GROUP BY 和 ORDER BY 的列</td>
<td>注意，SQL执行的时候是先执行GROUP BY后执行ORDER BY。因此，添加索引时注意顺序。<br>可以先添加由GROUP BY字段在前，ORDER BY字段在后的<strong>联合索引</strong>，能大幅提升查询性能。</td>
</tr>
<tr class="even">
<td>UPDATE、DELETE 的 WHERE 条件列</td>
<td>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。<br>原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<br>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为<strong>非索引字段更新不需要对索引进行维护</strong>。</td>
</tr>
<tr class="odd">
<td>DISTINCT 字段需要创建索引</td>
<td>数据已经排序，去重的时候会很方便，因为相同的数据会聚集在一起。</td>
</tr>
<tr class="even">
<td>多表 JOIN 连接操作时，对on以及where之后的字段创建索引</td>
<td>对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，过滤数据更高效。<br>对ON后用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。因为不一致的话会使用函数进行隐式转换，索引上使用函数会导致索引失效。</td>
</tr>
<tr class="odd">
<td>使用列的类型小的创建索引</td>
<td>有TINYINT就不要用INT，占据空间更小。</td>
</tr>
<tr class="even">
<td>使用字符串前缀创建索引</td>
<td>select count(distinct left(列名, 索引长度))/count(*)<br>计算区分度，选择一定的前缀创建索引即可。既保持高效查询，又避免占据太多空间，同时一个页上放的数据也更多。<br>Alibaba指南：在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。长度为 20 的索引，区分度会高达90% 以上。</td>
</tr>
<tr class="odd">
<td>区分度高(散列性高)的列适合作为索引</td>
<td><img src="/2022/04/22/MySQL_%E7%B4%A2%E5%BC%95_03%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5/image-20220424142336597.png" alt="image-20220424142336597"></td>
</tr>
<tr class="even">
<td>使用最频繁的列放到联合索引的左侧</td>
<td>这样也可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率。</td>
</tr>
<tr class="odd">
<td>在多个字段都要创建索引的情况下，联合索引优于单值索引</td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="不适合使用索引的情况">不适合使用索引的情况</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>在WHERE、GROUP BY、ORDER BY中使用不到的字段，不要设置索引</td>
<td>不作为查询条件的字段设置索引没有意义，浪费空间</td>
</tr>
<tr class="even">
<td>数据量小的表最好不要使用索引</td>
<td>在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。发挥不出索引的效果。</td>
</tr>
<tr class="odd">
<td>有大量重复数据的列上不要建立索引</td>
<td>当数据重复度大，比如高于 10% 的时候，也不需要对这个字段使用索引。<br>索引的意义就在于快速定位数据，重复的数据太多就无法定位。<br>但是相反，如果是查询大量重复数据上不重复的那些值，可以在该字段上建立索引。</td>
</tr>
<tr class="even">
<td>避免对经常更新的表创建过多的索引</td>
<td>经常更新的字段和经常更新的表，更新时维护索引需要花费时间。</td>
</tr>
<tr class="odd">
<td>不建议用无序的值作为索引</td>
<td>这里指的是AUTO INCREAMENT的字段作为索引时，在插入数据时较为方便，不需要调整B+树中的结构。<br>如果是无序的字段，在插入新的数据时可能会发生页面分裂等情况。</td>
</tr>
<tr class="even">
<td>删除不再使用或者很少使用的索引</td>
<td></td>
</tr>
<tr class="odd">
<td>不要定义冗余或重复的索引</td>
<td>冗余：联合索引下，index(a,b,c)其实已经包括了index(a)，index(a,b)以及index(a,b,c)。<br>重复：主键、唯一性约束上都已经自动添加索引，不需要再次创建。</td>
</tr>
</tbody>
</table>
<h3 id="限制索引的数目">限制索引的数目</h3>
<p><img src="/2022/04/22/MySQL_%E7%B4%A2%E5%BC%95_03%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5/image-20220424142514540.png" alt="image-20220424142514540" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>常用SQL</title>
    <url>/2021/04/17/SQL_SQL/</url>
    <content><![CDATA[<p>SQL 是用于访问和处理数据库的标准的计算机语言。</p>
<a id="more"></a>
<h3 id="函数">函数</h3>
<h4 id="lfet-join函数">LFET JOIN函数</h4>
<p>on和where的区别：</p>
<p>where 是在两个表join完成后，再附上where条件。</p>
<p>而 and 则是在表连接前过滤A表或B表里面哪些记录符合连接条件。它会保留左表的全部记录。</p>
<h4 id="limit-offset函数">LIMIT OFFSET函数</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#选择排名第二高的工资</span><br><span class="line">select</span><br><span class="line">ifnull(</span><br><span class="line">(</span><br><span class="line">    select distinct Salary from Employee order by Salary desc limit 1 offset 1</span><br><span class="line">)</span><br><span class="line">,</span><br><span class="line">null</span><br><span class="line">)</span><br><span class="line">as SecondHighestSalary</span><br></pre></td></tr></table></figure>
<h4 id="窗口函数">窗口函数</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每个部门里面工资前三高的员工</span><br><span class="line">select d.name as department, a.name as employee, a.salary as salary</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    #利用排名函数 dense_rank() 获得分区下的排名</span><br><span class="line">    select *, dense_rank() over( partition by departmentid order by salary desc) as t</span><br><span class="line">    from Employee</span><br><span class="line">)</span><br><span class="line">as a </span><br><span class="line">inner join department as d # 用部门id连接</span><br><span class="line">on a.DepartmentId &#x3D; d.Id </span><br><span class="line">where t &lt;&#x3D; 3 #选择排名高的</span><br></pre></td></tr></table></figure>
<h4 id="case-when">CASE WHEN</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="type">Date</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">Result</span> <span class="keyword">when</span> <span class="string">&#x27;胜&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;胜&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">Result</span> <span class="keyword">when</span> <span class="string">&#x27;负&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;负&#x27;</span></span><br><span class="line"><span class="keyword">from</span> test</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="type">date</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    STUDENT_NAME,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> score <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">&#x27;及格&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">&#x27;优秀&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;缺席考试&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;异常&#x27;</span> <span class="keyword">END</span>) <span class="keyword">AS</span> REMARK</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL窗口函数</title>
    <url>/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p>窗口指的是记录的集合。窗口函数也就是在满足某种条件的记录集合上执行的特殊函数。</p>
<a id="more"></a>
<h4 id="基本用法">基本用法</h4>
<blockquote>
<p>函数名 OVER (子句)</p>
</blockquote>
<p>函数名部分即表示窗口函数。</p>
<p>over关键字用来指定函数执行的窗口范围，若后面括号中什么都不写，则窗口函数基于所有行进行计算；如果不为空，则支持以下4中语法来设置窗口：</p>
<ul>
<li><p><code>PARTITION BY</code> 子句：窗口按照哪些字段进行分组，窗口函数在不同的分组上分别执行；</p></li>
<li><p><code>ORDER BY</code>子句：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号；</p></li>
<li><p><code>FRAME</code>子句：FRAME是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用</p></li>
<li><p>window_name：给窗口指定一个别名。如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">rank</span> ( ) <span class="keyword">over</span> w1 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee <span class="keyword">window</span> w1 <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> )</span><br><span class="line">    </span><br><span class="line"># <span class="keyword">from</span> <span class="keyword">table</span>后面加了一个关键字<span class="keyword">WINDOW</span>，后面跟了一个子句，这样在<span class="keyword">select</span>中就可以使用这个w1作为窗口了。</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="窗口函数">窗口函数</h4>
<p>窗口函数，在某些记录的集合上执行的函数。</p>
<h5 id="序号函数">序号函数</h5>
<p>row_number()/rank()/dense_rank()</p>
<p>作用：显示分区中的当前行号（排名是需要通过<code>ORDER BY</code>子句实现的）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,</span><br><span class="line">   <span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> ranking,</span><br><span class="line">   <span class="built_in">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> dese_rank,</span><br><span class="line">   <span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> row_num</span><br><span class="line"><span class="keyword">from</span> 班级;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/0.png" style="zoom:67%;"></p>
<ul>
<li><p>rank函数：如果有并列名次的行，会占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，4。</p></li>
<li><p>dense_rank函数：如果有并列名次的行，不占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，2。</p></li>
<li><p>row_number函数：不考虑并列名次的情况。比如前3名是并列的名次，排名是正常的1，2，3，4。</p></li>
</ul>
<h5 id="分布函数">分布函数</h5>
<p>percent_rank()/cume_dist()</p>
<p>percent_rank()</p>
<p>用途：和之前的RANK()函数相关，每行按照公式进行计算：(rank - 1) / (rows - 1)</p>
<p>其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数该函数可以用来计算分位数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">percent_rank</span> ( ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ),</span><br><span class="line">    Company,</span><br><span class="line">    Salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Company <span class="operator">=</span> <span class="string">&#x27;Microsoft&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/1.png" style="zoom:67%;"></p>
<p>cume_dist()</p>
<p>用途：分组内小于等于当前rank值的行数/分组内总行数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">cume_dist</span> ( ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ),</span><br><span class="line">    Company,</span><br><span class="line">    Salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Company <span class="operator">=</span> <span class="string">&#x27;Microsoft&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/2.png" style="zoom:67%;"></p>
<h5 id="聚合函数">聚合函数</h5>
<p>sum/avg/max/min/count</p>
<p>用途：在窗口中每条记录动态应用聚合函数(sum/avg/max/min/count)，可以动态计算在指定的窗口内的各种聚合函数值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">avg</span>( Salary ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ),</span><br><span class="line">    Company,</span><br><span class="line">    Salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Company <span class="operator">=</span> <span class="string">&#x27;Microsoft&#x27;</span></span><br></pre></td></tr></table></figure>
<p>按照分组的每一行，求累计的平均值。根据over子句分组之后，挨个行进行select，并执行over前面的函数，因为over子句已经把记录变成了符合条件的一些行集，所以select的方式就改变了。</p>
<p><img src="/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/3.png" style="zoom:67%;"></p>
<h4 id="参考资料">参考资料</h4>
<p>https://leetcode-cn.com/problems/department-top-three-salaries/solution/tu-jie-sqlmian-shi-ti-jing-dian-topnwen-ti-by-houz/</p>
<p>https://www.jianshu.com/p/e5c5bfb1e28b</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>BasicVSR 论文阅读</title>
    <url>/2021/01/28/SR_Basicvsr/</url>
    <content><![CDATA[<p>《BasicVSR：The Search for Essential Components in Video Super-Resolution and Beyond》</p>
<h3 id="背景">背景</h3>
<p>相比图像超分任务，视频超分网络会设计更多模块，因为它多了一个时空维度。因此复杂的设计结构在视频超分网络中是常见的。本文重新分析了视频超分网络中的四大模块（对齐、聚合、传播和上采样）的作用，以及它们的优缺点。提出了一个视频超分框架baseline，即BasicVSR，并在Reds和Vimeo数据集上训练，验证了该框架的有效性。</p>
<p>另外，本文扩展BasicVSR框架，设计了信息重新填充机制和成对传播策略，促进信息聚合，即IconVSR网络。</p>
<a id="more"></a>
<h3 id="方法">方法</h3>
<p>该部分首先分析了视频超分网络中四大模块中不同选择的作用，并在每个模块中选择最好的组件构成BasicVSR网络，该网络可以作为设计其他视频超分网络的骨架backbone。然后，作者在backbone的基础上引入了两种新的组件信息重新填充机制和成对传播策略，略微提升了参数量和运行时间，并提高了网络性能。</p>
<h4 id="传播模块">传播模块</h4>
<p>本质上，传播模块定义了各个输入帧究竟是如何在网络中进行传播的，当前各个帧的传播方式主要有如下几种：</p>
<ul>
<li><p>Local</p>
<p>局部传播使用一个滑动窗口中的LR图像作为输入，然后利用这些局部信息完成重建任务。这是最常见的方式，也是TDAN、EDVR等方法的输入方式，例如一次性输入相邻的7帧，并选择重建第4帧，其他的作为参考帧。因此，网络能够访问的信息限制在这些局部相邻帧中。缺少远距离帧不可避免地限制了网络的表达能力。</p>
<p><img src="/2021/01/28/SR_Basicvsr/0.png" style="zoom:67%;"></p>
<p>如图所示，作者将测试集分成K个segments在BasicVSR网络中进行测试，可以看到当每个segments内的帧数越多的时候，其恢复的PSNR值越低，说明了帧的数量对网络有影响。</p>
<p>对于非recurrent形式的网络，滑动窗口内的帧数越多则会导致网络的参数量和占用显存都会大规模增加，这是一个主要的缺陷。</p></li>
<li><p>Unidirectional Propagation</p>
<p>单向传播形式，即如RLSP、RSDN等普通recurrent网络的形式，每次输入一帧和相邻帧，并利用重建的相邻帧及其中间产物来完成当前参考帧的重建过程。</p>
<p><img src="/2021/01/28/SR_Basicvsr/1.png" style="zoom:67%;"></p>
<p>然而，单向传播的方式会涉及到隐状态，即前一帧的中间产物的处理问题。本质上隐状态代表了前一帧或前n帧的特征，因此当输入的帧数越靠前时，隐状态含有的信息越少，对参考帧的重建效果越差，如上图所示。</p></li>
<li><p>Bidirectional Propagation</p>
<p>双向传播形式解决上述两种问题，本质上就是网络同时利用前一帧和后一帧的隐状态，来完成当前参考帧的重建。前一帧的隐状态包含当前参考帧之前的所有信息，后一帧的隐状态包含当前参考帧之后的所有信息，这相当于可以利用前后所有帧的信息。</p></li>
</ul>
<h4 id="对齐模块">对齐模块</h4>
<ul>
<li><p>无对齐</p>
<p>不对齐的特征或图像会影响聚合的效果，并最终导致性能降低。直接串联不对齐的特征以进行恢复，相邻帧的特征将不会与输入图像的特征在空间上对齐。由于卷积之类的局部操作具有相对较小的感受野，在相应位置集合信息时无法有效地利用相邻帧的信息，此时会导致较低的效率。</p></li>
<li><p>基于图像的对齐</p>
<p>基于图像的对齐使用光流估计相邻帧到参考帧的光流变化，然后利用光流的信息将相邻帧变形对齐到参考帧上。该过程是直接在图像上进行的，而非特征图上进行的。并且大部分的工作通常需要利用其他预训练的光流估计网络。</p></li>
<li><p>基于特征的对齐</p>
<p>基于特征的对齐最流行的方法是使用可变形卷积。然而本文使用的方式是基于光流的特征对齐，即先估计光流，然后根据光流将中间结果，即隐状态进行对齐，然后将对齐过后的特征和当前参考帧一起输入残差块进行重建。</p></li>
</ul>
<h4 id="聚合与上采样">聚合与上采样</h4>
<p>文章对聚合方式没有进行过多探讨，只采用最基础的聚合方式，即拼接特征图并输入多个卷积作为聚合模块。</p>
<p>上采样模块采用最经典有效的方式Pixel-shuffle。</p>
<h4 id="basicvsr">BasicVSR</h4>
<p><img src="/2021/01/28/SR_Basicvsr/2.png" style="zoom: 50%;"></p>
<p>本文提出的Backbone即BasicVSR，采用了上述探讨的最基础的几个模块。对齐模块采用基于光流的特征对齐，对齐的对象是隐状态和光流图。传播模块采用的是双向传播模式，当前参考帧需要利用前后一帧的隐状态。聚合模块是直接拼接，上采样模块则为Pixel-shuffle。</p>
<h4 id="iconvsr">IconVSR</h4>
<p>在BasicVSR的基础上引入了两种新的组件信息重新填充机制和成对传播策略来提升网络的性能。</p>
<ul>
<li><p>Information-Refill</p>
<p>信息重新填充机制是为了解决在图像边界和有遮挡区域的不精确对齐的问题。不精确对齐会导致误差的不断积加，特别是在网络中采用长距离传播的时候。为了解决特征不精确对齐带来的不利影响，本文提出了一个信息重新填充机制，以做特征修正。</p>
<p><img src="/2021/01/28/SR_Basicvsr/3.png" style="zoom:67%;"></p>
<p>如上图所示，E为特征提取模块，C为卷积单元。需要事先设定一些关键帧<span class="math inline">\(I_{key}\)</span>，当关键帧作为参考帧进行输入时，对齐的特征需要和前后帧的特征进行拼接，对当前的特征图进行修正，防止错误累加，最后才将对齐后的特征和参考帧一起输入重建模块。</p></li>
<li><p>Coupled Propagation</p>
<p>成对传播策略将后向传播的特征，即后向传播的隐状态，也作为正向传播模块的输入。而不是像BasicVSR中的那样，直接在U处融合前后两个传播分支的输出。</p>
<p><img src="/2021/01/28/SR_Basicvsr/4.png" style="zoom:67%;"></p>
<p>通过成对传播，前向传播分支从过去和将来的帧中接收信息，从而导致更高质量的特征，获得更好的输出。</p></li>
</ul>
<h3 id="实验结果">实验结果</h3>
<h4 id="与sota进行对比">与SOTA进行对比</h4>
<p><img src="/2021/01/28/SR_Basicvsr/5.png" style="zoom: 50%;"></p>
<p><img src="/2021/01/28/SR_Basicvsr/6.png" style="zoom: 50%;"></p>
<h4 id="信息重新填充机制和成对传播策略消融实验">信息重新填充机制和成对传播策略消融实验</h4>
<p><img src="/2021/01/28/SR_Basicvsr/7.png" style="zoom: 50%;"></p>
<h4 id="信息重新填充机制中的关键帧数量">信息重新填充机制中的关键帧数量</h4>
<p><img src="/2021/01/28/SR_Basicvsr/8.png" style="zoom: 50%;"></p>
<h3 id="总结">总结</h3>
<p>本文中提出的BasicVSR和IconVSR，利用recurrent的机制进行超分辨率。BasicVSR主要利用了双向传播机制，使得长距离信息能够得到利用，IconVSR在此基础上直接在前向传播分支中利用后向传播的特征，直接在特征维度上利用长距离信息。</p>
<p>同时注意到，双向传播机制的短板非常明显，无论是BasicVSR还是IconVSR都需要将所有视频帧全部输入到网络中之后才能够进行超分辨率，这是相比于滑动窗口最大的缺陷，这导致了基于双向传播的方法无法做到实时超分。并且，这需要保存大量的中间结果，即隐状态，这在训练时可能会导致大规模的显存占用情况存在。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>VSR</category>
      </categories>
      <tags>
        <tag>VSR</tag>
      </tags>
  </entry>
  <entry>
    <title>DSFN 论文阅读</title>
    <url>/2021/02/09/SR_DSFN/</url>
    <content><![CDATA[<p>《Dual-Stream Fusion Network for Spatiotemporal Video Super-Resolution》 WACV 2021</p>
<h3 id="背景">背景</h3>
<p>时空视频超分辨率，即在时间维度上提升帧率，在空间维度上提升分辨率。本文认为，直接级联已有空间和时间超分辨率的方法（没有另外设计）来实现时空上采样，改变它们的顺序能够使得结果具有互补性。 因此，本文提出了一种双流融合网络，以自适应地融合两个时空上采样流产生的中间结果，其中第一个流应用空间超分辨率，然后是时间超分辨率，而第二个流则先使用空间超分辨率再进行时间超分辨率。</p>
<a id="more"></a>
<h3 id="方法">方法</h3>
<p><img src="/2021/02/09/SR_DSFN/0.png" style="zoom:50%;"></p>
<h4 id="框架的组件">框架的组件</h4>
<ul>
<li><p><span class="math inline">\(M_S\)</span></p>
<p>空间超分辨率网络。本文使用的是单幅图像的超分辨率网络ESPCN、SAN。</p></li>
<li><p><span class="math inline">\(M_T\)</span></p>
<p>时间超分辨率网络。即插帧网络，本文使用SuperSloMo、DAIN。</p></li>
<li><p><span class="math inline">\(F\)</span></p>
<p>融合网络，负责将不同分支产生的结果进行融合。具体采用采用了U-Net，它包含五个具有跳跃连接的对称下采样和上采样卷积层。</p></li>
<li><p><span class="math inline">\(R\)</span></p>
<p>调整网络，增强细节。具体为三个残差块。</p></li>
</ul>
<h4 id="框架的执行">框架的执行</h4>
<p>整个网络的流程具体来说就是将时空超分辨率分为两个分支，一个是先超分再插帧，另一个是先插帧再超分，然后通过融合网络融合两个分支的结果，最后通过调整网络进行细节调整。</p>
<p>空间超分辨率网络接收单个输入帧，并进行超分，输出对应一帧的超分结果；时间超分辨率网络接收前后两帧，并预测中间帧的结果。</p>
<p>先超分再插帧的过程可以表示为：</p>
<p><img src="/2021/02/09/SR_DSFN/1.png" style="zoom:67%;"></p>
<p>先插帧再超分的过程可以表示为：</p>
<p><img src="/2021/02/09/SR_DSFN/2.png" style="zoom:67%;"></p>
<p>本文认为，这两个数据流在时空上采样方面表现出互补的结果，其中先超分再插帧在运动较小的区域产生更精细的细节，而先插帧再超分在运动较大的区域提供更好的重建。</p>
<p>将双分支预测得到的结果进行融合，融合的策略就是给两个分支的结果分别预测一个Mask，并将Mask和预测结果进行element-wise的乘法后相加，整个过程可以表示为：</p>
<p><img src="/2021/02/09/SR_DSFN/3.png" style="zoom:67%;"></p>
<p>注意到，两个Mask之间，假如给予约束 Mask1 + Mask2 = 1，则总的预测结果变成了两个分支结果的线性插值，否则总的预测结果是两个分支结果的线性组合。</p>
<p>最终，通过一个三个残差块的调整网络增强细节信息。</p>
<p><img src="/2021/02/09/SR_DSFN/4.png" style="zoom:67%;"></p>
<h4 id="损失函数">损失函数</h4>
<p>损失函数主要分为两个部分：重建损失、辅助损失。</p>
<p><img src="/2021/02/09/SR_DSFN/5.png" style="zoom:77%;"></p>
<ul>
<li><p>重建损失</p>
<p>各个中间预测结果和GT的L1距离，作为重建损失。</p>
<p><img src="/2021/02/09/SR_DSFN/6.png" style="zoom:67%;"></p></li>
<li><p>辅助损失</p>
<p>主要是先超分再插帧的超分部分，以及先插帧再超分的插帧部分，对中间结果计算L1损失。</p>
<p><img src="/2021/02/09/SR_DSFN/7.png" style="zoom: 60%;"></p></li>
</ul>
<h3 id="实验结果">实验结果</h3>
<p>batch size设置为24，使用优化器RAdam，学习率开始时设置为<span class="math inline">\(5e-5\)</span>。时间和空间超分辨率均为2x。使用数据集Vimeo-90K、UCF101、FISR dataset。训练过程，首先单独训练超分网络和插帧网络，然后冻结参数把它们和融合网络及调整网络拼接在一起训练，最终联合训练所有模块。</p>
<h4 id="时空超分的互补结果">时空超分的互补结果</h4>
<p><img src="/2021/02/09/SR_DSFN/8.png"></p>
<p>文章认为先超分再插帧在小动作区域有更好的细节，先插帧再超分能够在大动作区域有更好的重建效果。如图所示应该是1、3行表示小动作区域，先超分再插帧的效果更好，Error Map有更少的像素点有值；而2、4行则表示大动作区域，先插帧再超分的Error Map有更少的像素点有值。</p>
<h4 id="不同融合策略的比较">不同融合策略的比较</h4>
<p><img src="/2021/02/09/SR_DSFN/9.png" style="zoom:67%;"></p>
<p>One-mask表示Mask1 + Mask2 = 1，总的预测结果变成了两个分支结果的线性插值，Two-mask则表示总的预测结果是两个分支结果的线性组合，可以看出Two-mask更有优势。</p>
<h4 id="选择不同上采样网络">选择不同上采样网络</h4>
<p><img src="/2021/02/09/SR_DSFN/10.png" style="zoom: 67%;"></p>
<p>越新的方法作为backbone效果则越好。</p>
<h4 id="与sota结果相比">与SOTA结果相比</h4>
<p><img src="/2021/02/09/SR_DSFN/11.png" style="zoom:67%;"></p>
<p>并没有和最新的网络结果相比，例如Zooming Slow-Mo。</p>
<h3 id="结论">结论</h3>
<p>本文提出了一种融合双分支结果的网络来进行时空超分辨率。然而，该网络并不是end-to-end训练的，借用已有的网络进行多阶段训练，并且正文没有给出参数量和计算量，可能代价也比较高。其次，重建完全由中间和最终输出帧的像素级重建损失来指导，把超分和插帧的过程都看成是独立的过程，各个中间结果之间没有加上时序的联系，这必然导致了性能的降低。因此，在时空超分中如何有效地利用时序信息进行更好的重建值得进行探索。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>STVSR</category>
      </categories>
      <tags>
        <tag>STVSR</tag>
      </tags>
  </entry>
  <entry>
    <title>DualSR 论文阅读</title>
    <url>/2021/02/05/SR_DualSR/</url>
    <content><![CDATA[<p>《DualSR: Zero-Shot Dual Learning for Real-World Super-Resolution》 WACV 2021</p>
<h3 id="背景">背景</h3>
<p>许多基于深度学习的SR方法在庞大数据集上学习复杂的LR-HR上采样关系。但是，这些经过预训练的SR方法通常在直接从相机捕获的图像上表现差很多。它们接受了干净，无噪声，合成的LR图像进行训练，而真实LR图像的退化过程与理想条件不同。现实情况下，每个摄像机的采集参数，例如传感器的点扩展功能（PSF），也不同。即使是同一台摄像机拍摄的图像，也会因光线条件、景深以及抖动而产生的模糊等而有所不同。这些条件使得训练一个在所有不同图像退化条件下都能表现良好的CNN变得很困难。</p>
<a id="more"></a>
<p>许多盲SR方法在超分之前都会估算退化过程。 盲超分的SOTA使用深度学习来学习图像特定的下采样器（降级模型参数），上采样器使用该下采样器对输入的LR图像进行超分辨。 但是，从单个输入图像估计合适的下采样器很复杂。 尤其是在存在噪声或其他采集伪像的情况下，这些方法通常无法估算出良好的降级参数。 错误的降级会严重降低上采样器的效率，并降低SR性能。</p>
<p>受诸如CycleGAN 和 DualGAN 等最新无监督方法的启发，论文引入了Zero-Shot DualSR，一种双路径架构，用于在现实世界中的LR图像上实现超分辨率，并且是一种无监督的方案。</p>
<h3 id="方法">方法</h3>
<p><img src="/2021/02/05/SR_DualSR/0.png" style="zoom: 50%;"></p>
<h4 id="框架的组件">框架的组件</h4>
<ul>
<li><p><span class="math inline">\(G_{UP}\)</span></p>
<p>上采样器。与ZSSR类似，采用了简单的8层全卷积网络，并采用了ReLU激活。在输入和输出之间存在一个全局的残差连接。将LR图像放大到输出大小，然后才将其送入网络。</p></li>
<li><p><span class="math inline">\(G_{DN}\)</span> &amp; <span class="math inline">\(D_{DN}\)</span></p>
<p>下采样器和判别器。使用KernelGAN中的生成器和判别器。</p>
<p>生成器是一个深层线性网络（没有任何激活）。小的感受野强迫使网络仅使用LR图像的局部特征（例如边缘），而不是依赖于高级全局特征。 因此，生成器<span class="math inline">\(G_{DN}\)</span>学习能够生成图像的kernel，该图像在patch分布上与输入LR图像相似。</p>
<p><img src="/2021/02/05/SR_DualSR/1.png" style="zoom:55%;"></p>
<p>判别器是一个全卷积的PatchGAN，其感受野为7x7。</p>
<p><img src="/2021/02/05/SR_DualSR/2.png" style="zoom:60%;"></p></li>
</ul>
<h4 id="框架的执行">框架的执行</h4>
<p>在前向循环中，首先应用上采样器以生成2x的上采样图像。，然后应用下采样器并将上采样的图像转换回1x。</p>
<p>同样，在后向循环中，首先由<span class="math inline">\(G_{DN}\)</span>生成1/2x的图像，然后<span class="math inline">\(G_{UP}\)</span>将图像上采样回到原始比例。</p>
<h4 id="损失函数">损失函数</h4>
<p>损失函数主要分为三部分：对抗损失、循环一致性损失、掩码插值损失。</p>
<p><img src="/2021/02/05/SR_DualSR/3.png" style="zoom: 67%;"></p>
<ul>
<li><p>对抗损失</p>
<p>对于下采样器<span class="math inline">\(G_{DN}\)</span>，希望其能够生成和真实LR相同的图像，判别器尽可能认为它是真实的LR（标签为1），损失如下（正则化项<span class="math inline">\(R\)</span>具体见KernelGAN论文）：</p>
<p><img src="/2021/02/05/SR_DualSR/4.png" style="zoom:60%;"></p>
<p>对于判别器<span class="math inline">\(D_{DN}\)</span>,希望其能够判别哪些是真实的LR，即让真实的LR被判别为1，合成的LR被判别为0：</p>
<p><img src="/2021/02/05/SR_DualSR/5.png" style="zoom:60%;"></p></li>
<li><p>循环一致性损失</p>
<p>确保<span class="math inline">\(G_{UP}\)</span>和<span class="math inline">\(G_{DN}\)</span>可以还原由另一个执行的操作。</p>
<p><img src="/2021/02/05/SR_DualSR/6.png" style="zoom:60%;"></p></li>
<li><p>掩码插值损失</p>
<p>Bicubic上采样能够能够正确地对低频部分进行上采样，但是无法重构高频细节。对所有像素使用Bicubic能够产生无伪影但模糊的结果。因此，论文仅对图像低频部分应用插值损失。首先对Bicubic上采样的图像应用Sobel算子，它主要用作边缘检测，是一种离散性差分算子，用来计算图像亮度函数的灰度近似值。应用Sobel算子能够产生mask，该mask在低频区域的像素值较高，在图像的高频区域的像素值较低。</p>
<p><img src="/2021/02/05/SR_DualSR/7.png" style="zoom:60%;"></p>
<p>然后应用掩码插值损失使得<span class="math inline">\(G_{UP}\)</span>的结果和Bicubic上采样的结果仅在低频部分是相近的。</p>
<p><img src="/2021/02/05/SR_DualSR/8.png" style="zoom:60%;"></p></li>
</ul>
<h3 id="实验结果">实验结果</h3>
<p>训练使用的 patch size 为 64 x 64 以及 128 x 128。训练和测试时不使用任何数据增强（图像变换）。因为训练时间很少，所以可以用暴力搜索方法来获得<span class="math inline">\(\lambda_{cycle}=5,\lambda_{inter}=2\)</span>。</p>
<p>在RTX 2080 Ti GPU上，论文的方法平均训练+推理时间为233秒。 对于KernelGAN + ZSSR 的组合，运行时间为281秒，对于BlindSR，则为370秒。 像SAN这样的有监督深度学习SR方法具有很长的训练时间，并且图像大小显着影响其推理时间。对于SAN +，在DIV2KRK基准上测试每张图片平均需要298秒。</p>
<h4 id="合成的真实lr数据集">合成的真实LR数据集</h4>
<p><img src="/2021/02/05/SR_DualSR/9.png" style="zoom: 45%;"></p>
<h4 id="realsr数据集">RealSR数据集</h4>
<p>该数据集通过调整焦距获得不同尺度图像，但作者认为不同尺度间没有完全对齐，因此只放出视觉效果。</p>
<p><img src="/2021/02/05/SR_DualSR/10.png" style="zoom:40%;"></p>
<h4 id="掩码插值损失">掩码插值损失</h4>
<p><img src="/2021/02/05/SR_DualSR/11.png" style="zoom:50%;"></p>
<h3 id="结论">结论</h3>
<p>本文提出提出了DualSR，一个轻量级的dual架构，它学习每个图像特定的LR-HR关系。它由下采样器和上采样器组成，在训练中使用循环一致性损失来相互改进。此外，论文提出了掩码插值损失，消除了图像低频区域的伪影，而不会导致边缘过于平滑。</p>
<p>该方法是Zero-Shot的，无需HR图像进行监督，但本质上就是用了Bicubic上采样的低频部分来进行监督。之前的文章DynaVSR是用了元学习的思想，在测试时同样使用了类似循环一致性的方法，但在训练时为了更好的效果仍然使用了HR的图像。因此，可以思考如何将Zero-Shot的思想（目前来看还是想办法在Bicubic上采样的结果做文章），应用到VSR上，来达到完全无监督的效果。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>SISR</category>
      </categories>
      <tags>
        <tag>SISR</tag>
        <tag>RealSR</tag>
      </tags>
  </entry>
  <entry>
    <title>OR-Net 论文阅读</title>
    <url>/2021/02/16/SR_ORNet/</url>
    <content><![CDATA[<p>《Learning Omni-frequency Region-adaptive Representations for Real Image Super-Resolution》 2021</p>
<h3 id="背景">背景</h3>
<p>Real World数据包含不同的、复杂的退化方式，例如模糊、噪声和降采样，因此导致传统深度学习方法在真实数据集上表现不好。</p>
<p>RealSR和DRealSR不仅提出了两个真实数据集，还提出了两种真实超分方法 laplacian pyramid based kernel prediction network (LP-KPN) 和 component divide-and- conquer (CDC)。然而，它们都是在像素水平上进行重建（区域、边缘和角落），没有利用到频率信息。</p>
<a id="more"></a>
<p>图像的频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间上的梯度。图像的主要成分是低频信息，它形成了图像的基本灰度等级，对图像结构的决定作用较小；中频信息决定了图像的基本结构，形成了图像的主要边缘结构；高频信息形成了图像的边缘和细节，是在中频信息上对图像内容的进一步强化。</p>
<p><img src="/2021/02/16/SR_ORNet/0.png" style="zoom: 50%;"></p>
<p>作者观察到，对于图a可以看出，LR的退化在各个频率上都存在。对于图b可以看出，在不同区域中的不同频率组件内，真实LR的退化也是不同的。</p>
<p>因此，本文作者提出ORNet，在图像的不同频率上增强相应的频率因子，最终通过区域自适应频率聚合模块，结合动态卷积和空间注意力机制，针对HR图像的不同位置，有选择性地重建不同的频率分量。</p>
<h3 id="方法">方法</h3>
<p><img src="/2021/02/16/SR_ORNet/1.png" style="zoom: 67%;"></p>
<h4 id="框架的组件">框架的组件</h4>
<ul>
<li><p>Frequency Decomposition (FD) Module</p>
<p>对图像进行频率分离，可以在传统的信号处理方法中采用小波变换或离散余弦变换来实现。然而，由于数学运算的确定性和任务无关性，这种转换不可避免地为low-level恢复任务丢弃了一些关键、详细的信息。为了在模拟小波变换的同时避免关键信息丢失，作者提出通过可学习的隐空间下采样，来分解混合特征表示。类似的操作可以参考OctConv。</p>
<p>具体来说，作者首先利用步长较大的卷积层(如stride= 2)对特征表示进行下采样，提取粗特征，即低频分量。然后，从原始特征(下采样前)中减去这些相对低频的分量，以获得其余相对高频的特征表示。</p></li>
<li><p>Frequency Enhancement Unit (FEU)</p>
<p>该单元对不同频率的信息进行增强。如b种所示结构，将CA的结果和普通卷积的结果相拼接，并加入dense connection。目的是有助于各分支在不同阶段选择性融合相应的频率分量，从而提高各分支在不同频域的表示能力。</p></li>
<li><p>Region-adaptive Frequency Aggregation (RFA) Module</p>
<p>该模块对不同频率组件进行自适应聚合。</p>
<p><img src="/2021/02/16/SR_ORNet/4.png" style="zoom:50%;"></p>
<p>即预测多个动态卷积核，并设置一个可学习的权重向量，将多个卷积核组合在一起形成动态卷积核，通过它生成attention map并与原来的特征图做乘法。</p></li>
</ul>
<h4 id="框架的执行">框架的执行</h4>
<p>首先将输入图像进行频率分离。用大步长卷积提取低频特征，并不断减去低频特征获得高频特征。</p>
<p><img src="/2021/02/16/SR_ORNet/2.png" style="zoom: 67%;"></p>
<p>上箭头表示双线性插值上采样，下箭头表示带步长卷积进行下采样。</p>
<p>接着，通过FEU来增强不同频率的表示，以弥补低/中/高频信息的丢失，并将低频信息与不同高频信息相结合。</p>
<p><img src="/2021/02/16/SR_ORNet/3.png" style="zoom: 60%;"></p>
<p>真实LR图像中不同区域的频率信息丢失是不同的。因此，有必要对不同区域的全频分量进行自适应聚合，以恢复更真实、纹理细节更丰富的HR图像。通过作者提出的RFA模块，使用动态卷积核的方式生成attention map来组合多个频率下的组件，最终通过pixel shuffle提高分辨率。</p>
<p><img src="/2021/02/16/SR_ORNet/5.png" style="zoom:60%;"></p>
<h3 id="实验结果">实验结果</h3>
<p>是一种有监督方法，使用DRealSR进行训练，动态核的数量设置为5个，使用L1损失优化网络。</p>
<h4 id="不同频率的可视化">不同频率的可视化</h4>
<p><img src="/2021/02/16/SR_ORNet/6.png" style="zoom: 67%;"></p>
<p>对于FD模块，首先在图6(a)中对三个频率尺度的特征进行可视化，可以看到高频分支的特征包含更多的细节和纹理信息。然后根据图6(b)中的小波变换对低/中/高频特征进行分析。从左到右，频率范围从1增加到6中，低频特征的能量几乎完全集中在低频域，高频特征和中频特征的能量集中在相对更高的频率域。</p>
<h4 id="不同频率数量的比较">不同频率数量的比较</h4>
<p><img src="/2021/02/16/SR_ORNet/7.png" style="zoom:50%;"></p>
<p>提高频率分割的数量一定程度上能够提高效果。</p>
<h4 id="消融实验">消融实验</h4>
<p><img src="/2021/02/16/SR_ORNet/8.png" style="zoom: 50%;"></p>
<h4 id="与sota相比较">与SOTA相比较</h4>
<p><img src="/2021/02/16/SR_ORNet/9.png" style="zoom: 50%;"></p>
<p>其他方法除了CDC外均没有在DRealSR上训练，因此除了CDC外本质上无法证明该方法的有效性。</p>
<h3 id="结论">结论</h3>
<p>作者提出一种全频域自适应网络(OR-Net)来实现真实图像超分辨率。比较有贡献的地方在于分析了真实图像与图像频率的关系，以及频率在网络中的影响。然而现在RealSR大部分流行的方式是无监督学习（或unpaired的方式），而该文是完全的有监督学习。</p>
<p>有文章显示基于卷积的频率分离操作在PSNR和SSIM上稍高于基于小波变换的方法，但在视觉感知上（LPIPS指标）会稍差。对图像进行不同频率分离的方式会导致最终的重建效果有所不同。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>SISR</category>
      </categories>
      <tags>
        <tag>SISR</tag>
        <tag>RealSR</tag>
      </tags>
  </entry>
  <entry>
    <title>TPSTVSR 论文阅读</title>
    <url>/2021/02/26/SR_TPSTVSR/</url>
    <content><![CDATA[<p>《Space-Time Video Super-Resolution Using Temporal Profiles》 ACMMM 2020</p>
<h3 id="背景">背景</h3>
<p>在时空超分辨率中，直接将VFI（插帧）和VSR（超分）串联，不能充分利用视频的时空相关性，是一种次优做法。此外，在计算效率低的同时，也容易引入累积误差。Zooming Slow-Mo提出一种one-stage的做法，使用可变形的ConvLSTM来隐式对齐帧，这样可能会错过长依赖的时间上下文，因为当更多的帧融合时，需要设计更复杂的帧对齐规则。因此，本文提出利用 Temporal Profile (TP)来解决时空超分辨率问题。</p>
<a id="more"></a>
<p>视频帧在一个Patch上，可以转换为如下水平（vertical）TPs 和垂直（horizontal）TPs：</p>
<p><img src="/2021/02/26/SR_TPSTVSR/0.png" style="zoom: 50%;"></p>
<p>基于TP的时空超分辨率有以下几个好处：</p>
<p>（1）STVSR可以有效地建模为基于学习的恢复任务，聚焦于TPs的特定二维结构。</p>
<p>（2）TPs既包含空间维度又包含时间维度，可以更好地利用时空相关性。</p>
<p>（3）与现有的多帧对齐方法相比，TPs能够更灵活地融合长依赖的时间上下文信息。</p>
<h3 id="方法">方法</h3>
<p>首先将低帧率和低分辨率的视频转换成TPs，然后将其送入Temporal Profile超分辨率模块（TPSRM）提高帧率，然后将TPs转换为视频域，发送给特征洗牌模块（FSM）生成具有目标空间分辨率的视频，最后通过调整模块（RM）去除伪影，增强细节。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/1.png" style="zoom: 80%;"></p>
<ul>
<li><p>Temporal-Profile Super-Resolution Module</p>
<p>首先将输入视频帧 W x H x T 转换为垂直Temporal Profile T x H x W（转换为水平TP无太大区别），即在垂直方向上将视频帧切割成W个。然后输入TPSRM，将TP分辨率提高为 （2T-1）x 2H x W。TPSRM采用IMDN模型，用L1损失函数做监督，ground truth由高帧率高分辨率视频转换成TP得到。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/8.png" style="zoom:60%;"></p></li>
<li><p>Feature Shuffling Module</p>
<p>该模块的目的是提高空间分辨率。经过TPSRM后，帧率提升为原来的两倍，H提高为原来的两倍，而W不变，FSM的目的就是将H再次提高两倍，W直接提高四倍。注意到其中Feature Shuffling阶段会将通道数（也就是帧率）减半，来将W提升2倍，在后面的模块需要将空间分辨率和通道数同时提升。CSR同样使用IMDN模块。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/2.png" style="zoom: 67%;"></p></li>
<li><p>Refining Module</p>
<p>该模块目的是消除伪影和增强细节，采用U-Net结构。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/3.png" style="zoom: 67%;"></p></li>
</ul>
<p>损失函数采用 L1、SSIM、VGG和Cycle Consistency四种损失函数。采用循环一致性损失来保证重构视频与输入的时空一致性，同时可以避免过度增强。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/4.png" style="zoom:67%;"></p>
<p><img src="/2021/02/26/SR_TPSTVSR/5.png" style="zoom:67%;"></p>
<p><img src="/2021/02/26/SR_TPSTVSR/6.png" style="zoom:67%;"></p>
<p><img src="/2021/02/26/SR_TPSTVSR/7.png" style="zoom: 67%;"></p>
<h3 id="实验结果">实验结果</h3>
<p>使用Vimeo90K数据集进行训练，进行空间4倍超分，时间2倍超分，batch size设置为1，学习率每2个epoch下降0.2，在一张1080Ti GPU上进行训练。</p>
<h4 id="与sota对比">与SOTA对比</h4>
<p><img src="/2021/02/26/SR_TPSTVSR/9.png" style="zoom:80%;"></p>
<h4 id="参数量与运行时间">参数量与运行时间</h4>
<p><img src="/2021/02/26/SR_TPSTVSR/10.png" style="zoom:80%;"></p>
<h4 id="不同损失函数比较">不同损失函数比较</h4>
<p><img src="/2021/02/26/SR_TPSTVSR/11.png" style="zoom:67%;"></p>
<h4 id="真实场景老电影恢复">真实场景：老电影恢复</h4>
<p>由于相机设备的分辨率有限，老电影往往会出现严重的时空退化。另外，在不同的压缩程度下保存也会影响观感。因此时空超分有应用场景。从网络上直接下载老电影，并和Zooming Slow-Mo进行对比，两者同样在Vimeo90K上训练。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/12.png" style="zoom: 67%;"></p>
<h3 id="结论">结论</h3>
<p>本文从Temporal Profile的角度进行时空超分辨率，与Zooming Slow-Mo相比降低了参数量和运行时间。该网络利用的是滑动窗口的原理，当帧数过多时会造成显存大量占用的问题。此外，当一个移动的物体在视频中突然出现或消失时，由于快速的移动，TPs很难捕捉到全局信息，融合水平和垂直的TPs可能是一种解决方案。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/13.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>STVSR</category>
      </categories>
      <tags>
        <tag>STVSR</tag>
      </tags>
  </entry>
  <entry>
    <title>TriNAS 论文阅读</title>
    <url>/2021/01/29/SR_TriNAS/</url>
    <content><![CDATA[<p>《Trilevel Neural Architecture Search for Efficient Single Image Super-Resolution》</p>
<h3 id="背景">背景</h3>
<p>传统的基于深度学习的超分辨率方法通常会在三层神经结构设计上选择以下变化：网络级优化、单元（cell）级优化以及内核（kernel）级优化。为一个深层SR模型人工执行这些优化需要较高的代价。并且，人工设计的架构往往不是最优的，对于真实超分辨率来说，可能在计算上效率低下。因此，论文提出了一种用于高效单图像超分辨率（SR）的三级神经架构搜索（TriNAS）方法。</p>
<a id="more"></a>
<p>论文首先在三个级别（即网络级别，单元级别和内核级别（卷积内核））定义离散搜索空间。提出了基于树模型的搜索框架来替代网格型的搜索框架，减少节点之间的依赖性。</p>
<p>然后，与之前利用softmax进行连续松弛策略的NAS方法不同，论文利用排序的sparsestmax来使得三级搜索架构稀疏地起作用。因此，论文的NAS优化可以逐渐收敛到对超网起主要作用的神经架构。</p>
<p>此外，论文提出的方法可以在单个阶段中同时进行搜索和训练，与传统的NAS算法相比，这大大减少了搜索和训练时间。</p>
<p>在基准数据集上进行的实验表明，论文的的NAS算法所提供的SR模型在参数数量和FLOPS方面具有显着减轻的优势，其PSNR值可与当前的SOTA相媲美。</p>
<h3 id="方法">方法</h3>
<h4 id="搜索空间定义">搜索空间定义</h4>
<p><img src="/2021/01/29/SR_TriNAS/2.png" style="zoom: 60%;"></p>
<p>为了在模型容量和模型大小之间达到适当的平衡，同时保证最小的精度损失，论文提出在内核级、单元级和网络级结构上进行搜索，以得到高效的SR网络结构。</p>
<ul>
<li><p>网络级</p>
<p>论文遵循AGD和SRResNet来定义网络级搜索空间。他们的超网结构使大多数计算都在低分辨率特征空间中进行，从而提高了计算效率。</p>
<p>网络级架构搜索主要通过搜索五个残差块和两个上采样块。将Residual-in-Residual（RiR）模块中的dense block替换为包含可搜索单元级运算符和内核级运算的五个连续层。</p>
<p>为了进行高效的上采样模块设计，论文替换了两个最初设计的上采样模块。取代的是一个PixelShuffel块，其中包含一个卷积层以及一个PixelShuffel层，以达到上采样的目的。由于PixelShuffle块固定在网络的尾部，因此在网络级搜索空间中添加了两个常规卷积层。最终，论文仅关注堆叠的五个RiR块和两个用于网络路径搜索的标准卷积层。</p>
<p><img src="/2021/01/29/SR_TriNAS/0.png" style="zoom:80%;"></p>
<p>为了对网络级搜索空间建模，采用上图所示的AutoDeep-Lab网格状结构似乎是可行的解决方案。 但是，网格建模旨在遍历网络块的所有顺序路径。 每个节点表示这个位置的feature map，每个路径都从第一个节点开始，并沿着一组箭头到达最终的目标节点。 显然，所有路径共享大多数节点和箭头。 这种冗余共享导致路径，单元和内核之间的极端依赖，因为路径在层次上包括它们。 尽管这样的共享策略可以节省大量训练内存，但它极大地限制了搜索空间。 此外，紧密的结合可能会损害每条路径的贡献以及对某些冗余路径的修剪的学习。</p>
<p><img src="/2021/01/29/SR_TriNAS/1.png" style="zoom: 67%;"></p>
<p>论文提出了一种用于网络级路径搜索建模的树结构，来克服冗余共享的缺点。 如上图所示，树建模旨在遍历所有树结构路径。 在这里，每个节点仅连接到其父节点和子节点，因此，依赖性非常宽松。 但是，必须在训练时维护这样的关联，以降低内存消耗。 放宽不同路径的相关性可以实现灵活的网络级搜索空间。 对路径的较低依赖性可能会由于单元和内核之间的分层连接而导致它们之间可靠的关联，从而使它们的搜索空间更为通用。 此外，引入的树模型可以更好地解开路径之间的纠缠关系，从而能够对冗余路径进行修剪。</p></li>
<li><p>单元级</p>
<p>在单元级，论文搜索五个RiR块，每个块包含五个个可搜索的单元，即总共25个可搜索的单元。每个单元会选择如下操作符：</p>
<p>Conv 1×1；Residual Block (2 layers of Conv 3×3 + skip-connection)；Conv 3×3；Depthwise Block (Conv 1×1 + Depthwise Conv3×3 + Conv 1×1).</p></li>
<li><p>内核级</p>
<p>对于内核级搜索，论文遵循super-kernel框架对该搜索空间进行建模。 对于每个卷积内核，先设置一个具有完整通道的超级内核。 为了修剪超级内核的通道数，需要一组可搜索的扩展比<span class="math inline">\(\phi=[\frac{1}{3},\frac{1}{2},\frac{4}{5},\frac{5}{6},1]\)</span>。并且设置参数<span class="math inline">\(\gamma_i\)</span>控制选择第<span class="math inline">\(i\)</span>个扩展比的概率。</p></li>
</ul>
<h4 id="连续松弛策略">连续松弛策略</h4>
<p>为了使得NAS是可微的，关键思想是将离散的搜索空间的显式选择放宽为搜索空间中所有相关候选对象的的隐式选择。连续松弛使我们能够以完全可微的方式选择对超网贡献最大的候选者，然后就可以通过反向传播的方式优化整个超网，以实现高效的架构。流行的连续松弛策略之一是应用softmax来实现所有候选网络操作的混合。但是，softmax无法产生稀疏的分布，因此，它无法反映主导操作，这对于有效的结构设计而言至关重要。因此，使用softmax可以防止超级网络收敛到主要的候选架构。</p>
<p>为了解决这个问题，论文提出了sparsestmax，它在连续松弛过程中产生了良好的稀疏性，并且可以寻求具有优势的候选架构，同时具有诸如softmax之类的凸性和可微性。</p>
<p>具体来说，为了实现离散网络级搜索空间的连续松弛，论文使用一组连续组合权值来聚合所有的网络路径，构成一个超网络。网络级架构搜索的树模型中每个特征图（即节点）都可以用作其对应路径的输出，然后可以将输出送到上采样层以获得超分结果。 论文根据提出的树模型对来自相关网络路径的所有特征图定义了一组权重<span class="math inline">\(\beta\)</span>，因此，超网的输出是所有中间特征图的加权组合。</p>
<p>传统的连续松弛做法就是对所有的<span class="math inline">\(\beta\)</span>应用softmax函数来判断每个路径对总的网络的贡献。然而，softmax通常产生非零参数，即平滑变化的参数。因此，候选路径的贡献是相对均匀的，这防止超网络收敛到一个主要的候选结构。因此，利用sparsetmax来产生稀疏的分布，其中<span class="math inline">\(q\)</span>表示具有约束的单纯形：</p>
<p><img src="/2021/01/29/SR_TriNAS/3.png" style="zoom: 80%;"></p>
<p>sparsestmax的基本思想是将输入向量<span class="math inline">\(\beta\)</span>的欧几里德投影投射到概率单纯形上。该投射可能会触及单纯形边界，在这种情况下，sparsestmax会产生稀疏分布。为了获得更好的稀疏度，sparsestmax还引入了一个圆环约束，该圆环约束可以通过将单纯形外接圆的半径从零线性增加到某个阈值来逐步产生稀疏性。</p>
<p>前文提到的树模型搜索架构有助于对路径进行剪枝，然而直接使用sparsestmax可能会在节点上产生无序的非零组合权重（极端情况是它们全部分布在奇/偶数节点上）。 在这种情况下，除非排序稀疏度，否则无法很好地修剪路径。 换句话说，只要非零组合权重沿路径下降，以便所有零权重都出现在路径的尾部，就可以执行网络级修剪，直接删除尾部即可。因此，论文提出利用排序的sparsetmax方法。 对每个路径<span class="math inline">\(p_i\)</span>内的权重<span class="math inline">\(\beta_i\)</span>施加排序约束。 直观上，这有助于使得浅层的输出feature maps对超网趋于相同的贡献度。排序的sparsetmax可以表示为：</p>
<p><img src="/2021/01/29/SR_TriNAS/4.png" style="zoom: 77%;"></p>
<p>上述讨论了网络级的连续松弛策略，即使用了排序的sparsetmax方法。对于单元级的连续松弛策略，同样给每个单元的输出定义权重<span class="math inline">\(\alpha\)</span>，并采用非排序的sparsetmax的方式进行连续松弛。对于内核级的连续松弛策略，则采用gumbel-softmax方法。</p>
<h4 id="代理任务和优化">代理任务和优化</h4>
<p>对于本文的三级NAS任务，论文不是从头训练模型，而是通过知识蒸馏方法，从而利用预先训练的最先进的图像超分辨率模型的知识。将预训练的ESRGAN模型作为teacher model，搜索阶段的代理任务是通过最小化模型输出与教师模型输出之间的知识精馏距离来搜索模型G。此外，图像SR任务偏向于更有效率的模型，因此在目标函数中加入模型效率项。</p>
<p>由于架构搜索的参数的数量远远小于网络模型的参数的数量，因此在单个训练集上对它们进行联合优化容易出现过拟合。具体来说，将数据集分为训练集和验证集，分别在这两组数据上优化网络参数和架构搜索参数。</p>
<h4 id="算法流程">算法流程</h4>
<p><img src="/2021/01/29/SR_TriNAS/7.png"></p>
<h3 id="实验结果">实验结果</h3>
<h4 id="与sota进行对比">与SOTA进行对比</h4>
<p><img src="/2021/01/29/SR_TriNAS/5.png" style="zoom: 50%;"></p>
<h4 id="softmax与sparsetmax对比">softmax与sparsetmax对比</h4>
<p><img src="/2021/01/29/SR_TriNAS/6.png" style="zoom: 67%;"></p>
<h3 id="结论">结论</h3>
<p>本文介绍了用于单图像超分辨率任务的Trilevel NAS方法，主要是将排序的sparsetmax激活用于树模型的网络架构搜索中。树模型能够使得节点之间降低依赖性，提供灵活的搜索空间，并能够更好地进行剪枝优化；sparsetmax激活在连续松弛过程中产生了良好的稀疏性，使得超网能够收敛到一个主要的候选结构上；排序的sparsetmax同样能够更好地进行模型剪枝。</p>
<p>论文中提到的sparsetmax仅使用在了网络级和单元级架构搜索，可以同样利用排序的sparsetmax去进一步地优化内核级的搜索空间，来产生更高效的超分模型，以达到高PSNR和高感知质量的效果。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>SISR</category>
      </categories>
      <tags>
        <tag>SISR</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark SQL执行原理</title>
    <url>/2021/09/25/Spark_SparkSQL%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<table style="width:100%;">
<colgroup>
<col style="width: 19%">
<col style="width: 40%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
<th>产物</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Parser<br>解析器</td>
<td>将sql语句利用Antlr4进行词法和语法的解析。</td>
<td>语法树和Unresolved LogicalPlan。<br>仅仅是一种数据结构，不包含任何数据信息，例如不知道数据源，数据类型，不同的列来自哪张表等。</td>
</tr>
<tr class="even">
<td>Analyzer<br>分析器</td>
<td>进行规则解析。</td>
<td>Analyzed Logical Plan。<br>将表解析为具体的字段，确定数据来源，确定聚合函数等。</td>
</tr>
<tr class="odd">
<td>Optimizer<br>优化器</td>
<td>优化逻辑计划。</td>
<td>Optimized Logical Plan。<br>谓词下推 + 列剪枝 + 常量替换 + 常量累加。</td>
</tr>
<tr class="even">
<td>Planner<br>计划器</td>
<td>生成多个物理计划，根据代价模型选择最优。</td>
<td>Physical Plan。 <br>解析出数据源从JDBC读取，文件路径，数据类型等。</td>
</tr>
<tr class="odd">
<td>Code Generation<br>代码生成</td>
<td>将 SQL 翻译成一系列的关系代数算子或表达式。<br>然后依赖这些关系代数算子逐条处理输入数据并产生结果。</td>
<td>Code &amp; DAG<br>在Driver端生成可执行代码和DAG有向无环图。</td>
</tr>
<tr class="even">
<td>Execution<br>执行器</td>
<td>执行代码。</td>
<td>计算结果。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="参考资料">参考资料</h3>
<p>https://zhuanlan.zhihu.com/p/127138025 （Hive转MR）</p>
<p>https://blog.csdn.net/qq_30031221/article/details/109222355 （Spark底层执行原理）</p>
<p>https://www.cnblogs.com/weiyiming007/p/11313226.html</p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 案例</title>
    <url>/2021/04/19/Spark_%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>一些样例代码。</p>
<a id="more"></a>
<h3 id="wordcount">WordCount</h3>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCounts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Spark Context</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取文件并计算词频</span></span><br><span class="line">    <span class="keyword">val</span> source: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;hdfs://node01:8020/dataset/wordcount.txt&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = source.flatMap &#123; line =&gt; line.split(<span class="string">&quot; &quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> wordsTuple: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map &#123; word =&gt; (word, <span class="number">1</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> wordsCount: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordsTuple.reduceByKey &#123; (x, y) =&gt; x + y &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查看执行结果</span></span><br><span class="line">    println(wordsCount.collect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    String line = value.toString();</span><br><span class="line">    String[] split = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String word : split) &#123;</span><br><span class="line">    	context.write(<span class="keyword">new</span> Text(word),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义我们的reduce逻辑</span></span><br><span class="line"><span class="comment">* 所有的key都是我们的单词，所有的values都是我们单词出现的次数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> values</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">    	count += value.get();</span><br><span class="line">    &#125;</span><br><span class="line">    context.write(key,<span class="keyword">new</span> LongWritable(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobMain</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Job job = Job.getInstance(<span class="keyword">super</span>.getConf(),</span><br><span class="line">	JobMain.class.getSimpleName());</span><br><span class="line">	<span class="comment">//打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span></span><br><span class="line">	job.setJarByClass(JobMain.class);</span><br><span class="line">    <span class="comment">//第一步：读取输入文件解析成key，value对</span></span><br><span class="line">    job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">    TextInputFormat.addInputPath(job,<span class="keyword">new</span></span><br><span class="line">    Path(<span class="string">&quot;hdfs://192.168.52.250:8020/wordcount&quot;</span>));</span><br><span class="line">    <span class="comment">//第二步：设置我们的mapper类</span></span><br><span class="line">    job.setMapperClass(WordCountMapper.class);</span><br><span class="line">    <span class="comment">//设置我们map阶段完成之后的输出类型</span></span><br><span class="line">    job.setMapOutputKeyClass(Text.class);</span><br><span class="line">    job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//第三步，第四步，第五步，第六步，省略</span></span><br><span class="line">    <span class="comment">//第七步：设置我们的reduce类</span></span><br><span class="line">    job.setReducerClass(WordCountReducer.class);</span><br><span class="line">    <span class="comment">//设置我们reduce阶段完成之后的输出类型</span></span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//第八步：设置输出类以及输出路径</span></span><br><span class="line">    job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">    TextOutputFormat.setOutputPath(job,<span class="keyword">new</span> Path(<span class="string">&quot;hdfs://192.168.52.250:8020/wordcount_out&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> b = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> b?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 程序main函数的入口类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">	Tool tool = <span class="keyword">new</span> JobMain();</span><br><span class="line">	<span class="keyword">int</span> run = ToolRunner.run(configuration, tool, args);</span><br><span class="line">	System.exit(run);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark调优</title>
    <url>/2021/09/24/Spark_%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p>开发调优</p>
<table>
<colgroup>
<col style="width: 36%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1、避免创建重复的RDD</td>
<td>避免进行多次重复计算来创建同一个RDD增加计算开销。</td>
</tr>
<tr class="even">
<td>2、尽可能复用同一个RDD</td>
<td>例如有一个RDD的数据格式是key-value类型的。<br>另一个是单value类型的。<br>这两个RDD的value数据是完全一样的。<br>那么此时我们可以只使用key-value类型的那个RDD，<br>因为其中已经包含了另一个的数据。</td>
</tr>
<tr class="odd">
<td>3、对多次使用的RDD进行持久化</td>
<td>重复出现的RDD会被重复计算<br>rdd.persist(StorageLevel.MEMORY_AND_DISK_SER)</td>
</tr>
<tr class="even">
<td>4、尽量避免使用shuffle类算子</td>
<td>尽可能避免使用reduceByKey、join、distinct、repartition等会进行shuffle的算子。<br>尽量使用map类的非shuffle算子。<br>如将join转换成Broadcast+map。</td>
</tr>
<tr class="odd">
<td>5、使用map-side预聚合的shuffle算子</td>
<td>reduceByKey和aggregateByKey算子都会对每个节点本地的相同key进行预聚合。<br>groupByKey算子是不会进行预聚合的，全量的数据会在集群的各个节点之间分发和传输。</td>
</tr>
<tr class="even">
<td>6、使用高性能的算子</td>
<td>使用mapPartitions替代普通map。<br>使用foreachPartitions替代foreach。<br>使用filter之后进行coalesce操作。<br>使用repartitionAndSortWithinPartitions替代repartition与sort类操作。</td>
</tr>
<tr class="odd">
<td>7、广播大变量</td>
<td>这样每个Executor只有一个副本，而不是每个Executor中的每个Task都有一个副本。</td>
</tr>
<tr class="even">
<td>8、使用Kryo优化序列化性能</td>
<td>Kryo序列化类库的性能比Java序列化类库的性能要高很多。</td>
</tr>
<tr class="odd">
<td>9、优化数据结构</td>
<td>使用字符串替代对象，使用原始类型（比如Int、Long）替代字符串，使用数组替代集合类型。<br>尽可能地减少内存占用，降低GC频率，提升性能。</td>
</tr>
</tbody>
</table>
<p>数据倾斜调优</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数据倾斜发生的现象</td>
<td>1、绝大多数task执行得都非常快，但个别task执行极慢。<br>2、原本能够正常执行的Spark作业，某天突然报出内存溢出异常。（数据太大资源不足）</td>
</tr>
<tr class="even">
<td>数据倾斜排查</td>
<td>1、yarn-client模式提交，本地直接看log，在log中找到当前运行到了第几个stage。<br>2、yarn-cluster模式提交，通过Spark Web UI来查看当前运行到了第几个stage。<br>3、两种模式下都可以在Spark Web UI上查看当前stage各个task分配的数据量，从而进一步确定是不是task分配的数据不均匀导致了数据倾斜。<br>4、确定数据倾斜发生在哪个stage后，根据stage划分原理，推算出发生倾斜的那个stage对应代码中的哪一部分，这部分代码中肯定会有一个shuffle类算子。</td>
</tr>
<tr class="odd">
<td>查看Key的分布情况</td>
<td>1、Spark SQL：group by、join语句导致数据倾斜，直接从源表中查看。<br>2、Spark RDD：shuffle算子，加入查看key分布的代码，比如RDD.countByKey()，然后用collect/take到客户端打印一下。</td>
</tr>
<tr class="even">
<td>数据倾斜解决方案</td>
<td>1、使用Hive ETL预处理数据。<br>2、过滤少数导致倾斜的key。（null值）<br>3、提高shuffle操作的并行度。<br>4、两阶段聚合（随机前缀局部聚合+全局聚合），仅适用于reduceByKey等聚合操作，不适用于join连接操作。<br>5、将reduce join转为map join。（大表join小表的场景）<br>6、采样找出有数据倾斜的key，拆出来，有数据倾斜的表加随机前缀，无倾斜的表做数据膨胀保证能被join上（大表join大表的场景，表1有数据倾斜，表2没有）<br></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>资源调优</p>
<p>对Spark运行过程中各个使用资源的地方，通过调节各种参数，来优化资源使用的效率，从而提升Spark作业的执行性能。</p>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 68%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>num-executors</td>
<td>设置Spark作业总共要用多少个Executor进程来执行。（50-100）<br>默认情况下一台机器启动一个Executor进程。</td>
</tr>
<tr class="even">
<td>executor-memory</td>
<td>设置每个Executor进程的内存。（4G-8G）</td>
</tr>
<tr class="odd">
<td>executor-cores</td>
<td>每个Executor进程的CPU core数量。（2-4个）<br>这个参数决定了每个Executor进程并行执行task线程的能力。<br>因为每个CPU core同一时间只能执行一个task线程。</td>
</tr>
<tr class="even">
<td>driver-memory</td>
<td>Driver进程的内存。</td>
</tr>
<tr class="odd">
<td>spark.default.parallelism</td>
<td>设置每个stage的默认task数量。（500-1000个）<br>默认是一个HDFS block对应一个task。</td>
</tr>
<tr class="even">
<td>spark.storage.memoryFraction</td>
<td>设置RDD持久化数据在Executor内存中能占的比例，默认是0.6。<br>也就是说，默认Executor 60%的内存，可以用来保存持久化的RDD数据。</td>
</tr>
<tr class="odd">
<td>spark.shuffle.memoryFraction</td>
<td>该参数用于设置shuffle过程中一个task拉取到上个stage的task的输出后，进行聚合操作时能够使用的Executor内存的比例，默认是0.2。<br>也就是说，Executor默认只有20%的内存用来进行该操作。<br>多余的数据就会溢写到磁盘文件中去，此时就会极大地降低性能。</td>
</tr>
</tbody>
</table>
<p>shuffle调优</p>
<table>
<colgroup>
<col style="width: 39%">
<col style="width: 60%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>spark.shuffle.file.buffer</td>
<td>设置shuffle write task在溢写到磁盘文件前的缓冲区大小。</td>
</tr>
<tr class="even">
<td>spark.reducer.maxSizeInFlight</td>
<td>设置shuffle read task的buffer缓冲大小，而这个buffer缓冲决定了每次能够拉取多少数据。</td>
</tr>
<tr class="odd">
<td>spark.shuffle.io.maxRetries</td>
<td>Reducer如果因为网络异常导致拉取失败，是会自动进行重试的。<br>该参数就代表了可以重试的最大次数，默认3次。</td>
</tr>
<tr class="even">
<td>spark.shuffle.io.retryWait</td>
<td>该参数代表了每次重试拉取数据的等待间隔，默认是5s。</td>
</tr>
<tr class="odd">
<td>spark.shuffle.memoryFraction</td>
<td>Executor内存中，分配给shuffle read task进行聚合操作的内存比例，默认是20%。</td>
</tr>
<tr class="even">
<td>spark.shuffle.manager</td>
<td>该参数用于设置ShuffleManager的类型。Spark 1.5以后，有三个可选项：hash、sort和tungsten-sort。<br>tungsten-sort与sort类似，但是使用了tungsten计划中的堆外内存管理机制，内存使用效率更高。</td>
</tr>
<tr class="odd">
<td>spark.shuffle.sort.bypassMergeThreshold</td>
<td>使用bypass sort-base shuffle的shuffle read task的阈值。（默认是200）</td>
</tr>
<tr class="even">
<td>spark.shuffle.consolidateFiles</td>
<td>如果使用HashShuffleManager，该参数有效。<br>如果设置为true，那么就会开启consolidate机制，会大幅度合并shuffle write的输出文件。<br>对于shuffle read task数量特别多的情况下，这种方法可以极大地减少磁盘IO开销，提升性能。</td>
</tr>
</tbody>
</table>
<h3 id="参考资料">参考资料</h3>
<p>https://mp.weixin.qq.com/s/1OZZc3rshA-sSAlsQYGF2Q</p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark闭包、累加器和广播变量</title>
    <url>/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="总结">总结</h3>
<ul>
<li><p>闭包</p>
<p>闭包<strong>就是一个携带了外部作用域的函数</strong>，当它需要被分发到各个节点上执行的时候，需要外部作用域所在的对象是可序列化的。</p>
<p>使用这种外部变量的形式，会造成每个Task中都存在一个该变量的副本。</p></li>
</ul>
<a id="more"></a>
<ul>
<li><p>广播变量</p>
<p>广播变量是一种变量，广播变量允许开发者将一个 <code>Read-Only</code> 的变量<strong>缓存到集群中每个节点中</strong>，而不是传递给每一个 Task 一个副本，每个Executor中只会存在一个副本。</p>
<ul>
<li><p>解决了外部变量在每个Task中都存在副本的问题，每个Executor只会存在一份广播变量的副本，节省空间。</p></li>
<li><p>在Driver端可以修改广播变量的值，<strong>在Executor端无法修改广播变量的值。</strong></p></li>
<li><p>广播变量只能在Driver端定义，不能在Executor端定义。</p></li>
<li><p>不能将RDD广播，因为RDD是不存储数据的。可以将RDD的结果广播出去。</p></li>
</ul></li>
<li><p>累加器</p>
<p>累加器是一个<strong>支持添加操作的分布式变量</strong>，可以在分布式环境下保持一致性。</p>
<ul>
<li>累加器在Driver端定义赋初始值，累加器只能在Driver端读取最后的值，在Excutor端更新。</li>
<li>在Driver端可以修改广播变量的值，<strong>在Executor端可以修改累加器的值。</strong></li>
</ul></li>
</ul>
<h3 id="闭包">闭包</h3>
<p>如果一个函数<strong>携带了外部的作用域</strong>，这种<strong>函数称为闭包</strong>。</p>
<p>在Scala中，函数是一个对象，继承自FunctionN。</p>
<h4 id="问题引出">问题引出</h4>
<p>在spark中实现统计List(1,2,3)的和。如果使用下面的代码，程序打印的结果不是6，而是0。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">      <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> rdd = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">      <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">      <span class="comment">//warn: don&#x27;t do this</span></span><br><span class="line">      rdd.foreach(x =&gt; counter += x)</span><br><span class="line">      println(<span class="string">&quot;Counter value: &quot;</span>+counter) <span class="comment">//打印结果为0</span></span><br><span class="line"></span><br><span class="line">      sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题分析： counter是在foreach函数外部定义的，也就是在driver程序中定义，而foreach函数是属于rdd对象的，rdd函数的执行位置是各个worker节点（或者说worker进程），main函数是在driver节点上（或者说driver进程上）执行的。所以当counter变量在driver中定义，被在rdd中使用的时候，出现了变量的跨域问题，也就是闭包问题。</p>
<p>问题解释： 对于上面程序中的counter变量，由于在main函数和在rdd对象中foreach函数是属于不同作用域的，所以，传进foreach中的counter是一个副本，初始值都为0。foreach中叠加的是counter的副本，不管副本如何变化，都不会影响到main函数中的counter，所以最终打印出来的counter为0。</p>
<h4 id="解决方案">解决方案</h4>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>())</span><br><span class="line">    <span class="keyword">val</span> newRDD = sc.textFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    newRDD.map(data =&gt; &#123;</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      println(data.toString)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在RDD的函数中调用了在函数外部定义的对象，这些对象需要通过网络从driver所在节点传给其他的worker节点，所以<strong>要求这些类是可序列化的</strong>，比如在Java或者Scala中实现Serializable类。Worker节点接收到程序之后，在Spark资源管理器的指挥下运行RDD程序。不同Worker节点之间的运行操作是并行的。</p>
<p><img src="/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/0.png" style="zoom:67%;"></p>
<p>除了用外部定义的对象来实现类似的功能，Spark还另外提供了两种机制，分别是<strong>Broadcast</strong>和<strong>Accumulator</strong>。</p>
<p>相比于外部变量的方式，在一定场景下使用Broadcast比较有优势，因为所广播的数据在每一个Worker节点上面只存一个副本，而在Spark算子中使用到的外部变量会在每一个用到它的Task中保存一个副本，即使这些task在同一个节点上面。所以当数据量比较大的时候，建议使用广播而不是外部变量。</p>
<h3 id="广播变量">广播变量</h3>
<p>广播变量是一种变量，广播变量允许开发者将一个 <code>Read-Only</code> 的变量缓存到集群中每个节点中, 而不是传递给每一个 Task 一个副本，每个Executor中只会存在一个副本。</p>
<p>变量一旦被定义为一个广播变量，那么这个变量只能读，不能修改。</p>
<p><img src="/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/2.png" style="zoom:50%;"></p>
<h4 id="广播变量的使用">广播变量的使用</h4>
<h5 id="创建广播变量">创建广播变量</h5>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> b = sc.broadcast(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>如果 Log 级别为 DEBUG 的时候, 会打印如下信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEBUG BlockManager: Put block broadcast_0 locally took  430 ms</span><br><span class="line">DEBUG BlockManager: Putting block broadcast_0 without replication took  431 ms</span><br><span class="line">DEBUG BlockManager: Told master about block broadcast_0_piece0</span><br><span class="line">DEBUG BlockManager: Put block broadcast_0_piece0 locally took  4 ms</span><br><span class="line">DEBUG BlockManager: Putting block broadcast_0_piece0 without replication took  4 ms</span><br></pre></td></tr></table></figure>
<h5 id="使用-value-获取数据">使用 <code>value</code> 获取数据</h5>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">b.value</span><br></pre></td></tr></table></figure>
<p>获取数据的时候会打印如下信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEBUG BlockManager: Getting local block broadcast_0</span><br><span class="line">DEBUG BlockManager: Level for block broadcast_0 is StorageLevel(disk, memory, deserialized, 1 replicas)</span><br></pre></td></tr></table></figure>
<p>使用 <code>value</code> 方法的注意点</p>
<p>方法签名 <code>value: T</code></p>
<p>在destroy之前才能使用value：在 <code>value</code> 方法内部会确保使用获取数据的时候, 变量必须是可用状态, 所以必须在变量被 <code>destroy</code> 之前使用 <code>value</code> 方法, 如果使用 <code>value</code> 时变量已经失效, 则会报出以下错误：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.apache.spark.SparkException: Attempted to use Broadcast(0) after it was destroyed (destroy at &lt;console&gt;:27)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.assertValid(Broadcast.scala:144)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.value(Broadcast.scala:69)</span><br><span class="line">  ... 48 elided</span><br></pre></td></tr></table></figure>
<h5 id="使用-unpersist-删除数据">使用 <code>unpersist</code> 删除数据</h5>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">b.unpersist</span><br></pre></td></tr></table></figure>
<h5 id="使用-destroy-销毁变量">使用 <code>destroy</code> 销毁变量,</h5>
<p>释放内存空间</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">b.destroy</span><br></pre></td></tr></table></figure>
<p>销毁以后, 会打印如下信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEBUG BlockManager: Removing broadcast 0</span><br><span class="line">DEBUG BlockManager: Removing block broadcast_0_piece0</span><br><span class="line">DEBUG BlockManager: Told master about block broadcast_0_piece0</span><br><span class="line">DEBUG BlockManager: Removing block broadcast_0</span><br></pre></td></tr></table></figure>
<p>使用 <code>destroy</code> 方法的注意点</p>
<p>方法签名 <code>destroy(): Unit</code></p>
<p>不要多次删除广播变量：<code>destroy</code> 方法会移除广播变量, 彻底销毁掉, 但是如果你试图多次 <code>destroy</code> 广播变量, 则会报出以下错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.apache.spark.SparkException: Attempted to use Broadcast(0) after it was destroyed (destroy at &lt;console&gt;:27)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.assertValid(Broadcast.scala:144)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.destroy(Broadcast.scala:107)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.destroy(Broadcast.scala:98)</span><br><span class="line">  ... 48 elided</span><br></pre></td></tr></table></figure>
<h4 id="广播变量的使用场景">广播变量的使用场景</h4>
<p>正常情况下使用 Task 拉取数据的时候, 会将数据拷贝到 Executor 中多次, 但是使用广播变量的时候只会复制一份数据到 Executor 中, 所以在两种情况下特别适合使用广播变量</p>
<ul>
<li>一个 Executor 中有多个 Task 的时候</li>
<li>一个变量比较大的时候</li>
<li>大RDD和小RDD执行join操作时。当一个 RDD 很大并且还需要和另外一个 RDD 执行 <code>join</code> 的时候, 可以将较小的 RDD 广播出去, 然后使用大的 RDD 在算子 <code>map</code> 中直接 <code>join</code>, 从而实现在 Map 端 <code>join</code>。</li>
</ul>
<h3 id="累加器">累加器</h3>
<h4 id="通用累加器">通用累加器</h4>
<p>Accumulators(累加器) 是一个只支持 added(添加) 的分布式变量, 可以在分布式环境下保持一致性, 并且能够做到高效的并发。</p>
<p><img src="/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/1.png" style="zoom:50%;"></p>
<ul>
<li><p>Accumulator 是支持并发并行的, 在任何地方都可以通过 add 来修改数值, 无论是 Driver 还是 Executor</p></li>
<li><p>只能在 Driver 中才能调用 value 来获取数值</p></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;ip_ana&quot;</span>).setMaster(<span class="string">&quot;local[6]&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> counter = sc.longAccumulator(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line"></span><br><span class="line">sc.parallelize(<span class="type">Seq</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">  .foreach(counter.add(_))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果: 15</span></span><br><span class="line">println(counter.value)</span><br></pre></td></tr></table></figure>
<ul>
<li>累加器能保证在 Spark 任务出现问题被重启的时候不会出现重复计算</li>
<li>累加器只有在 Action 执行的时候才会被触发</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;ip_ana&quot;</span>).setMaster(<span class="string">&quot;local[6]&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> counter = sc.longAccumulator(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line"></span><br><span class="line">sc.parallelize(<span class="type">Seq</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">  .map(counter.add(_)) <span class="comment">// 这个地方不是 Action, 而是一个 Transformation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果是 0</span></span><br><span class="line">println(counter.value)</span><br></pre></td></tr></table></figure>
<h4 id="自定义累加器">自定义累加器</h4>
<p>可以通过自定义累加器来实现更多类型的累加器, 累加器的作用远远不只是累加, 比如可以实现一个累加器, 用于向里面添加一些运行信息。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承AccumulatorV2这个类，传入String类型，返回Set[String]类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, <span class="type">Set</span>[<span class="type">String</span>]] </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个可变长度的Set，即 mutable.Set[String]  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> infos: mutable.<span class="type">Set</span>[<span class="type">String</span>] = mutable.<span class="type">Set</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断累加器对象是否为空，这里就是判断这个Set是否为空</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">    infos.isEmpty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回一个拷贝的累加器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, <span class="type">Set</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> newAccumulator = <span class="keyword">new</span> <span class="type">InfoAccumulator</span>()</span><br><span class="line">    infos.synchronized &#123; <span class="comment">//使用synchronized关键字保证线程安全</span></span><br><span class="line">      newAccumulator.infos ++= infos <span class="comment">//把一个Set添加到另一个Set中使用++=</span></span><br><span class="line">    &#125;</span><br><span class="line">    newAccumulator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清空累加器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    infos.clear()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//往累加器中添加元素</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(v: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    infos += v</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//累加器在进行累加的时候，可能每个分布式节点都有一个实例</span></span><br><span class="line">  <span class="comment">//在最后的Driver中进行合并，通过调用这个merge方法把所有的实例内容合并起来，</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, <span class="type">Set</span>[<span class="type">String</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    infos ++= other.value <span class="comment">//这里的value就是下面这个方法返回的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//提供给外部累加结果，注意返回一个不可变的类型，防止外部进行修改</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Set</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    infos.toSet</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulator2</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;ip_ana&quot;</span>).setMaster(<span class="string">&quot;local[6]&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> infoAccumulator = <span class="keyword">new</span> <span class="type">InfoAccumulator</span>()</span><br><span class="line">  sc.register(infoAccumulator, <span class="string">&quot;infos&quot;</span>)</span><br><span class="line"></span><br><span class="line">  sc.parallelize(<span class="type">Seq</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>))</span><br><span class="line">    .foreach(item =&gt; infoAccumulator.add(item))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行结果: Set(3, 1, 2)</span></span><br><span class="line">  println(infoAccumulator.value)</span><br><span class="line"></span><br><span class="line">  sc.stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://knifefly.cn/2018/05/21/%E7%90%86%E8%A7%A3spark%E9%97%AD%E5%8C%85/（闭包）</p>
<p>https://blog.csdn.net/weixin_43854618/article/details/105680445（累加器）</p>
<p>https://www.cnblogs.com/qingyunzong/p/8890483.html#_label1（广播变量和累加器）</p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>CAP定理</title>
    <url>/2021/09/15/%E5%88%86%E5%B8%83%E5%BC%8F_CAP%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th></th>
<th>Consistency<br>一致性</th>
<th>Availability<br>可用性</th>
<th>Partition tolerance<br>分区容错性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>概念</td>
<td>所有节点在同一时间的数据完全一致。</td>
<td>集群整体一直能够响应客户端的读写请求。</td>
<td>节点之间无法通信或节点故障时，<br>集群仍然可以对外提供服务。</td>
</tr>
</tbody>
</table>
<table style="width:100%;">
<colgroup>
<col style="width: 17%">
<col style="width: 41%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>满足特性</th>
<th>描述</th>
<th>案例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CP without A：无可用性</td>
<td>集群为了提供满足一致性的数据<br>需要暂时停止集群中的某些节点的服务完成数据同步。<br>一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，<br>等待所有数据全部一致了之后再让用户访问系统。</td>
<td>分布式数据库，<br>如Redis、HBase等。</td>
</tr>
<tr class="even">
<td>AP wihtout C：无一致性</td>
<td>集群为了一直能够提供服务<br>当某些节点更新数据后，不能立刻同步给所有节点。<br>每个节点只能用本地数据提供服务，<br>而这样会导致全局数据的不一致性。</td>
<td>抢购商品时显示存在库存，<br>但实际上会下单失败，<br>原因就是节点间的数据无法保持一致。</td>
</tr>
<tr class="odd">
<td>CA without P：无分区容错性</td>
<td>集群为了提供一致性数据和一直提供服务<br>就不能够进行分区。<br>这样就无法形成一个分布式系统。</td>
<td>MySQL等单机的数据库服务。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="概述">概述</h3>
<p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个特性。</p>
<p>Consistency、Availability、Partition tolerance。</p>
<p>它们的第一个字母分别是 C、A、P。Eric Brewer 说，分布式系统中这三个特性不可能同时做到，最多只能同时满足其中的两个。这个结论就叫做 CAP 定理。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/hong10086/article/details/88627210</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性哈希算法</title>
    <url>/2021/09/10/%E5%88%86%E5%B8%83%E5%BC%8F_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 18%">
<col style="width: 81%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>一致性哈希算法</td>
<td>一致性哈希算法就是将哈希缓存的除数改为<span class="math inline">\(2^{32}\)</span>，将映射空间看成一个hash环，把服务器和缓存数据看作是上面的每个点。<br>缓存数据会分配到沿顺时针方向遇到的第一个服务器上。</td>
</tr>
<tr class="even">
<td>优点</td>
<td>服务器的数量如果发生改变，并不是所有缓存都会失效，而是<strong>只有部分缓存会失效</strong>。</td>
</tr>
<tr class="odd">
<td>hash环偏斜</td>
<td>服务器可能会不均匀地被映射到hash环上。<br>大量缓存数据可能会被映射到同一个服务器上。</td>
</tr>
<tr class="even">
<td>虚拟节点</td>
<td>实际节点虚拟复制而来的节点，其实就是在hash环上再设置多个服务器的映射。<br>解决hash环偏斜导致缓存数据分配不均的问题。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="基础">基础</h3>
<p>一致性哈希算法在1997年由麻省理工学院提出，是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系（哈希过程）。</p>
<h3 id="背景">背景</h3>
<p>有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为0号、1号、2号，现在，有3万张图片需要缓存，我们希望这些图片被均匀的缓存到这3台服务器上，以便它们能够分摊缓存的压力。</p>
<p>没有任何规律的将3万张图片平均的缓存在3台服务器上，需要访问某个缓存项时，则需要遍历3台缓存服务器，时长不可接受。</p>
<p>另一种做法是对缓存项的键进行哈希，将hash后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上。下次访问某张图片时就不再需要遍历所有的服务器了。</p>
<blockquote>
<p>hash（图片名称）% N</p>
<p>因为图片的名称是不重复的，所以，当我们对同一个图片名称做相同的哈希计算时，得出的结果应该是不变的，如果我们有3台服务器，使用哈希后的结果对3求余，那么余数一定是0、1或者2，正好与我们之前的服务器编号相同，如果求余的结果为0， 我们就把当前图片名称对应的图片缓存在0号服务器上。</p>
</blockquote>
<p><img src="/2021/09/10/%E5%88%86%E5%B8%83%E5%BC%8F_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/image-20210911093838711.png" alt="image-20210911093838711" style="zoom:33%;"></p>
<p>如果3台缓存服务器已经不能满足我们的缓存需求，增加或减少服务器数量后，取余的数量不再是3，除数不变的情况下余数不再相同，所有缓存的位置都要发生改变。</p>
<p>换句话说，当服务器数量发生改变时（增加服务器提高性能或因为故障减少服务器），所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，由于大量缓存在同一时间失效，造成了<strong>缓存的雪崩</strong>。</p>
<h3 id="一致性哈希">一致性哈希</h3>
<p>一致性哈希算法就是将哈希缓存的除数改为<span class="math inline">\(2^{32}\)</span>，将映射空间看成一个hash环，把服务器和缓存数据看作是上面的每个点。缓存数据会分配到沿顺时针方向遇到的第一个服务器上。</p>
<p>这样即使有服务器增加或减少，只会有部分的缓存数据会失效，其余的缓存数据仍然起作用，避免缓存雪崩导致的服务崩溃。</p>
<h4 id="过程">过程</h4>
<p><img src="/2021/09/10/%E5%88%86%E5%B8%83%E5%BC%8F_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/image-20210911095342719.png" alt="image-20210911095342719" style="zoom:50%;"></p>
<p>三台服务器有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模：</p>
<p>hash（服务器A的IP地址）% <span class="math inline">\(2^{32}\)</span></p>
<p>通过上述公式算出的结果一定是一个0到<span class="math inline">\(2^{32}-1\)</span>之间的一个整数，我们就用算出的这个整数，代表服务器。同理，服务器B与服务器C也可以通过相同的方法映射。</p>
<p>利用同样的方法将图片进行映射：</p>
<p>hash（图片名称） % <span class="math inline">\(2^{32}\)</span></p>
<p>然后将图片缓存到沿顺时针方向遇到的第一个服务器上。</p>
<p><img src="/2021/09/10/%E5%88%86%E5%B8%83%E5%BC%8F_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/image-20210911095316323.png" alt="image-20210911095316323" style="zoom:50%;"></p>
<p>由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一张图片必定会被缓存到固定的服务器上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器上，直接去对应的服务器查找对应的图片即可。</p>
<h4 id="优点">优点</h4>
<p>如果使用之前的hash算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了，而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是<strong>只有部分缓存会失效</strong>，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。</p>
<p><img src="/2021/09/10/%E5%88%86%E5%B8%83%E5%BC%8F_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/image-20210911095522730.png" alt="image-20210911095522730" style="zoom:50%;"></p>
<p>例如此时服务器B失效，只有图片3的缓存失效，其余图片的缓存仍然维持在原有的服务器上。</p>
<h4 id="hash环的偏斜">hash环的偏斜</h4>
<p>实际情况下，服务器可能会不均匀地被映射到hash环上，也就是集中地映射到部分位置：</p>
<p><img src="/2021/09/10/%E5%88%86%E5%B8%83%E5%BC%8F_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/image-20210911095815909.png" alt="image-20210911095815909" style="zoom:50%;"></p>
<p>那么被缓存的对象很有可能大部分集中缓存在某一台服务器上：</p>
<p><img src="/2021/09/10/%E5%88%86%E5%B8%83%E5%BC%8F_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/image-20210911095857352.png" alt="image-20210911095857352" style="zoom:50%;"></p>
<p>例如上图几乎大部分图片都被缓存到服务器A上，导致的情况是：</p>
<p>1、三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均匀。</p>
<p>2、如果此时缓存了大量数据的服务器出现故障，那么失效缓存的数量也将达到最大值，在极端情况下，仍然有可能引起缓存雪崩和系统崩溃。</p>
<h4 id="虚拟节点">虚拟节点</h4>
<p>为了解决hash环偏斜导致的缓存不均衡地分布在各服务器的问题，引入虚拟节点的概念。</p>
<p>虚拟节点就是实际节点虚拟复制而来的节点，其实就是在hash环上再设置多个服务器的映射，保证服务器均匀地分布在hash环上，解决缓存分布不均衡的问题。</p>
<p><img src="/2021/09/10/%E5%88%86%E5%B8%83%E5%BC%8F_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/image-20210911101520105.png" alt="image-20210911101520105" style="zoom: 50%;"></p>
<h3 id="参考资料">参考资料</h3>
<p>https://www.zsythink.net/archives/1182</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2021/07/29/%E5%A4%A7%E6%95%B0%E6%8D%AEZookeeper%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>Zookeeper（分布式协调服务）帮助Hadoop解决的问题</p>
<a id="more"></a>
<p>主要是为了实现高可用机制</p>
<p>首先所有的NN在启动的时候会竞争写一个zookeeper上的临时节点，所有的standby nn向这个节点注册一个观察器，当这个节点出现异常或挂掉时，起在zookeeper上创建的临时节点也会被删除，standy的nn节点检测到该节点发生变化时，会重新发起竞争，直到产生一个Active节点。</p>
<p>写入高可用。 集群中的写入操作都是先通知Leader，Leader再通知Follower写入，实际上当超过一半的机器写入成功后，就认为写入成功了，所以就算有些机器宕机，写入也是成功的。</p>
<p>读取高可用。 zookeeperk客户端读取数据时，可以读取集群中的任何一个机器。所以部分机器的宕机并不影响读取。 zookeeper服务器必须是奇数台，因为zookeeper有选举制度，角色有：领导者、跟随者、观察者，选举的目的是保证集群中数据的一致性。</p>
<p>https://blog.csdn.net/eric_sunah/article/details/46610167</p>
<p>https://www.jianshu.com/p/87976ec5f45f</p>
<p>kafka</p>
<p>分布式的发布-订阅消息系统。</p>
<p>Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡 和水平扩展。</p>
<p>一个分区可以有多个副本，这些副本保存在不同的broker上。每个分区的副本中都会有一个作为 Leader。当一个broker失败时，Leader在这台broker上的分区都会变得不可用，kafka会自动移除 Leader，再其他副本中选一个作为新的Leader。</p>
<p>消息同步：先写入到leader中，follower再同步。Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW（即offset）并且向Producer发送ACK。</p>
<p>数据库与数据仓库的区别</p>
<p>数据库是面向事务型，用户较为关心操作的响应时间。数据仓库是面向分析型的，一般针对历史数据进行分析，允许一定的冗余存在便于挖掘数据。</p>
<p>HIVE SQL与SQL的区别</p>
<p>HIVE就是利用SQL语句在HDFS上执行map reduce操作。</p>
<p>4.Hive不支持将数据插入现有的表或分区中 Hive仅支持覆盖重写整个表。 insert overwrite 表 （重写覆盖）</p>
<p>Hive不支持等值连接：</p>
<p>SQL中内关联可以这样写： select * from a , b where a.key = b.key Hive中应该这样写： select * from a join b on a.key = b.key</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2021/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AEZookeeper/</url>
    <content><![CDATA[<p>Zookeeper（分布式协调服务）帮助Hadoop解决的问题</p>
<a id="more"></a>
<p>主要是为了实现高可用机制</p>
<p>首先所有的NN在启动的时候会竞争写一个zookeeper上的临时节点，所有的standby nn向这个节点注册一个观察器，当这个节点出现异常或挂掉时，起在zookeeper上创建的临时节点也会被删除，standy的nn节点检测到该节点发生变化时，会重新发起竞争，直到产生一个Active节点。</p>
<p>写入高可用。 集群中的写入操作都是先通知Leader，Leader再通知Follower写入，实际上当超过一半的机器写入成功后，就认为写入成功了，所以就算有些机器宕机，写入也是成功的。</p>
<p>读取高可用。 zookeeperk客户端读取数据时，可以读取集群中的任何一个机器。所以部分机器的宕机并不影响读取。 zookeeper服务器必须是奇数台，因为zookeeper有选举制度，角色有：领导者、跟随者、观察者，选举的目的是保证集群中数据的一致性。</p>
<p>https://blog.csdn.net/eric_sunah/article/details/46610167</p>
<p>https://www.jianshu.com/p/87976ec5f45f</p>
<p>kafka</p>
<p>分布式的发布-订阅消息系统。</p>
<p>Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡 和水平扩展。</p>
<p>一个分区可以有多个副本，这些副本保存在不同的broker上。每个分区的副本中都会有一个作为 Leader。当一个broker失败时，Leader在这台broker上的分区都会变得不可用，kafka会自动移除 Leader，再其他副本中选一个作为新的Leader。</p>
<p>消息同步：先写入到leader中，follower再同步。Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW（即offset）并且向Producer发送ACK。</p>
<p>数据库与数据仓库的区别</p>
<p>数据库是面向事务型，用户较为关心操作的响应时间。数据仓库是面向分析型的，一般针对历史数据进行分析，允许一定的冗余存在便于挖掘数据。</p>
<p>HIVE SQL与SQL的区别</p>
<p>HIVE就是利用SQL语句在HDFS上执行map reduce操作。</p>
<p>4.Hive不支持将数据插入现有的表或分区中 Hive仅支持覆盖重写整个表。 insert overwrite 表 （重写覆盖）</p>
<p>Hive不支持等值连接：</p>
<p>SQL中内关联可以这样写： select * from a , b where a.key = b.key Hive中应该这样写： select * from a join b on a.key = b.key</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>行列存储的比较</title>
    <url>/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E8%A1%8C%E5%88%97%E5%AD%98%E5%82%A8%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 10%">
<col style="width: 44%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>行存储（OLTP）</td>
<td>同一行所属的多个字段被保存在一起，<br>当修改或插入一行数据时IO开销较低。</td>
<td>获取特定列时本质上还是扫描了所有行，<br>再把特定列取出，存在不必要的IO开销。</td>
</tr>
<tr class="even">
<td>列存储（OLAP）</td>
<td>1、同一列的数据被保存在一起，能够满足<br>快速读取特定列的需求。（OLAP常用）<br>选取列时降低IO开销，随机读变顺序读。<br>2、列式存储容易实现数据压缩。</td>
<td>1、插入、删除数据不方便。<br>2、被选择出来的列要重新组装。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="行列存储的原理">行列存储的原理</h3>
<p>数据在存储系统中的基本单位为页，页中的数据是连续存储的。</p>
<p>页也是进行数据读取时候基本单位，一次读取就是一次IO操作。</p>
<p>例如一个数据表为：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E8%A1%8C%E5%88%97%E5%AD%98%E5%82%A8%E6%AF%94%E8%BE%83/image-20210926145033057.png" alt="image-20210926145033057" style="zoom:67%;"></p>
<p>一个数据页用一个4x4的单元格表示：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E8%A1%8C%E5%88%97%E5%AD%98%E5%82%A8%E6%AF%94%E8%BE%83/image-20210926145129243.png" alt="image-20210926145129243" style="zoom:67%;"></p>
<p>按行存储为：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E8%A1%8C%E5%88%97%E5%AD%98%E5%82%A8%E6%AF%94%E8%BE%83/image-20210926145202849.png" alt="image-20210926145202849" style="zoom: 67%;"></p>
<p>按列存储为：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E8%A1%8C%E5%88%97%E5%AD%98%E5%82%A8%E6%AF%94%E8%BE%83/image-20210926145242775.png" alt="image-20210926145242775" style="zoom:67%;"></p>
<p>当执行OLTP查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,city <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">004</span></span><br></pre></td></tr></table></figure>
<p>以行方式查询（在有适当的索引情况下)，那么，执行一次以上查询，只需要扫描一次Page 1就可以了。</p>
<p>以列方式查询，需要投其扫描Page 1和Page 2共2次，分别取得id，city的单行值。</p>
<p>因此，在OLTP这种以查询一行数据为主的场景下，适合采用行方式进行存储。</p>
<p>当执行OLAP查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(id) <span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure>
<p>对于行存储，这个查询需要两次IO将全部数据放入内存后，进行页间数据的跳读（类随机读取，因为id被city隔开了)。</p>
<p>对于列存储，只需要一次IO将Page 1放入内存后进行连续读取，如果id还有多页的话，也是进行的物理连续读取。</p>
<p>在进行OLAP操作时候，不仅是减小了IO次数，而且把随机读取变为了连续读取。</p>
<h3 id="列式存储数据压缩">列式存储数据压缩</h3>
<p>因为列式存储将同一列的数据存储在一起，所以使用压缩算法可以减少存储占用的磁盘空间。</p>
<p>压缩算法的基本原理其实很简单，它使用基于特定规则的数据表示原数据。</p>
<p>如下所示的字符串中包含连续的相同字符，就可以使用朴素的压缩算法减少字符串的长度：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E8%A1%8C%E5%88%97%E5%AD%98%E5%82%A8%E6%AF%94%E8%BE%83/image-20210926152828786.png" alt="image-20210926152828786" style="zoom:67%;"></p>
<p>黄色方块表示前面字符串的重复次数，这种简单的压缩策略可以在保证无损的情况下将字符串的长度压缩 33%，然而压缩率是由压缩算法和数据的特性共同决定的。与面向行的数据存储相比，面向列的数据存储会将相同类型的数据就近存储，这也给压缩算法的提供了更多发挥的空间。</p>
<p>压缩算法实际上是一种<strong>使用 CPU 时间换取 I/O 时间和空间</strong>的策略，但是在多数情况下，这种生意都是稳赚不赔的。压缩算法通过减少数据的大小、减少磁盘的寻道时间提高 I/O 的性能、减少数据的传输时间并提高缓冲区的命中率，节省的 I/O 时间可以轻易补偿它带来的 CPU 额外开销（IO时间远大于CPU的额外时间）。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://www.zhihu.com/question/29380943</p>
<p>https://draveness.me/whys-the-design-olap-column-oriented/</p>
<p>https://www.cnblogs.com/ajianbeyourself/p/7771682.html</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>海量数据问题</title>
    <url>/2021/04/14/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>海量数据问题，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大导致无法一次性装入内存。</p>
<a id="more"></a>
<h3 id="基础">基础</h3>
<h4 id="换算单位">换算单位</h4>
<ul>
<li>1 byte = 8 bit</li>
<li>1 KB = <span class="math inline">\(2^{10}\)</span> byte = 1024 byte ≈ <span class="math inline">\(10^3\)</span> byte</li>
<li>1 MB = <span class="math inline">\(2^{20}\)</span> byte ≈ <span class="math inline">\(10^6\)</span> byte</li>
<li>1 GB = <span class="math inline">\(2^{30}\)</span> byte ≈ <span class="math inline">\(10^9\)</span> byte</li>
<li>1 千万 = <span class="math inline">\(10^7\)</span></li>
<li>1 亿 = <span class="math inline">\(10^8\)</span></li>
</ul>
<p>1 个整数占 4 byte，1 亿个整数占 4*<span class="math inline">\(10^8\)</span> byte ≈ 400 MB。</p>
<h4 id="位图bitmap">位图(bitmap)</h4>
<p>用一个bit位来标记某个元素对应的值。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p>
<p>想知道某个元素出现过没有。如果为每个所有可能的值分配1个bit。</p>
<p>但对于海量的、取值分布很均匀的集合进行<strong>去重</strong>，Bitmap极大地压缩了所需要的内存空间。于此同时，还额外地完成了对原始数组的<strong>排序工作</strong>。</p>
<p>统计数字出现的次数。</p>
<h4 id="bloom-filter布隆过滤器">Bloom Filter(布隆过滤器)</h4>
<h4 id="trie树">trie树</h4>
<p>前缀统计，词频统计。</p>
<h4 id="外部排序">外部排序</h4>
<p>大数据的排序，去重。</p>
<p>1、首先按内存大小，将外存上的文件分成若干子文件。</p>
<p>2、依次读入内存并利用有效的内部排序对他们进行排序，并将排序后得到的有序字文件重新写入外存，通常称这些子文件为归并段。</p>
<p>3、对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件。</p>
<p>外排序的优化方法：置换选择 败者树原理，最优归并树。</p>
<h3 id="常用解决方案">常用解决方案</h3>
<p>1、分而治之/hash映射 + hash统计 + 堆/快速/归并排序； 2、Bitmap去重；</p>
<p>当分而治之（hash映射）出现数据倾斜：改变hash函数再次进行映射。</p>
<p>找数字的去重用位图，字符串去重用HashSet。</p>
<h4 id="海量数据去重">海量数据去重</h4>
<p>数字去重使用位图bitmap，字符串去重HashSet。</p>
<h4 id="n个数求前k大">N个数求前K大</h4>
<p>1、排序算法。 2、计数排序，开辟一个大数组，记录每个整数是否出现，从大到小取。（bitmap） 3、维护一个大小为k的小顶堆。</p>
<h4 id="求文件a中没有但b中有的单词">求文件A中没有但B中有的单词</h4>
<p>遍历文件A，将文件hash到n个小文件中，对B文件同样操作。然后对于每一对文件，先将一个文件存入HashSet，对另一个文件遍历判断。</p>
<h4 id="海量数据排序问题">海量数据排序问题</h4>
<p>hash到小文件中（其实直接切分成若干小文件也行），然后先在小文件排序。</p>
<p>然后合并的时候，用堆，每个小文件取一个，然后最小的拿走再加入对应文件的数字，直到结束。</p>
<p>又或者直接对多个小文件进行归并排序。</p>
<h4 id="海量数据出现次数最多数据">海量数据出现次数最多数据</h4>
<p>分而治之/hash映射（相同数据被分到一起） + HashMap统计 + 堆/快速/归并排序；</p>
<h3 id="面试题">面试题</h3>
<h4 id="字符串统计次数海量日志数据提取出某日访问百度次数最多的那个ip">字符串统计次数：海量日志数据，提取出某日访问百度次数最多的那个IP</h4>
<p><strong>算法思想：分而治之+Hash统计+排序</strong></p>
<p>IP地址最多有<span class="math inline">\(2^{32}\)</span>种取值情况，即约40亿种取值。每个ip地址是32位，因此是一个ip地址大小为4 byte。所以所有ip地址的大小为 <span class="math inline">\(40*10^8*4 byte= 16GB\)</span>， 不能完全加载到内存中处理。</p>
<p>1、按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含<span class="math inline">\(2^{22}=4*2^{20}\)</span>个IP地址，即约400万个ip地址，每个小文件大小为<span class="math inline">\(4*2^{20}*4bytes=16MB\)</span>。</p>
<p>2、对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址。</p>
<p>3、可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP。</p>
<h4 id="top-k统计最热门的10个查询串">TOP K：统计最热门的10个查询串</h4>
<p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p><strong>算法思想：hashmap+堆</strong></p>
<p>去重后300万个查询串的大小最大为<span class="math inline">\(3*10^6*255byte = 765MB\)</span>，可以放入内存当中，构建HashMap统计次数时，value为整型，因此value所占的空间大小为<span class="math inline">\(3*10^6*4byte=12MB\)</span>，因此总内存可以装载这个HashMap。</p>
<p>1、先对这批海量数据预处理，在O(N)的时间内用Hash表完成统计； 2、借助堆这个数据结构，找出Top K，时间复杂度为O(N*logK)。</p>
<h4 id="数字找不重复数字统计次数海量数据找出不重复的整数">数字找不重复/数字统计次数：海量数据找出不重复的整数</h4>
<p>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</p>
<p><strong>算法思想：bitmap位图去重/统计次数</strong></p>
<p>1、2-Bitmap，每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义，共需内存<span class="math inline">\(2^{32} * 2 bit = 2^{32} * 0.25 byte =1 GB\)</span>内存。</p>
<p>2、然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。</p>
<p>3、扫描完成后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>如果需要统计数字出现的次数，则只需要增加bitmap中每一位的bit数即可。</p>
<h4 id="找重复找出ab文件共同的url">找重复：找出a、b文件共同的url</h4>
<p>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url。</p>
<p><strong>算法思想：分而治之 + HashSet去重</strong></p>
<p>每个文件的大小约为<span class="math inline">\(50*10^8*64byte=64*5GB\)</span>，无法放入内存种。</p>
<p>1、遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件。</p>
<p>2、这样处理后，所有可能相同的url都在对应的小文件中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p>
<p>3、求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p>
<h4 id="外部排序10个文件按照query频度排序">外部排序：10个文件，按照query频度排序</h4>
<p>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求按照query的频度排序。</p>
<p><strong>算法思想：分而治之 + hash统计 + 内外排序</strong></p>
<p>1、顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件中。这样新生成的文件每个的大小大约也1G，大于1G的更换哈希函数继续进行切分。</p>
<p>2、找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用排序算法按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件。</p>
<p>3、对这10个文件进行归并排序。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://wangpengcheng.github.io/2019/12/17/hailiangshuju_problems/</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>海量数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>海量数据</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令</title>
    <url>/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>常用Linux命令：top</p>
<a id="more"></a>
<h3 id="top">Top</h3>
<p>对系统资源和进程的信息进行监控。</p>
<h4 id="统计信息区系统资源信息区">统计信息区（系统资源信息区）</h4>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/0.png"></p>
<p><strong>第一行：输出系统任务队列信息</strong></p>
<p><strong>18:46:38</strong>：系统当前时间</p>
<p><strong>up 2days 1:54</strong>：系统开机后到现在的总运行时间</p>
<p><strong>1 user</strong>：当前登录用户数</p>
<p><strong>load average: 0, 0.01, 0.05</strong>：系统负载，系统运行队列的平均利用率，可认为是可运行进程的平均数；三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值；单核CPU中load average的值=1时表示满负荷状态，多核CPU中满负载的load average值为1*CPU核数</p>
<p><strong>第二行：任务进程信息</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/5.png"></p>
<p><strong>total</strong>：系统全部进程的数量</p>
<p><strong>running</strong>：运行状态的进程数量</p>
<p><strong>sleeping</strong>：睡眠状态的进程数量</p>
<p><strong>stoped</strong>：停止状态的进程数量</p>
<p><strong>zombie</strong>：僵尸进程数量</p>
<p><strong>第三行：CPU信息</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/1.png"></p>
<p><strong>us</strong>：用户空间占用CPU百分比</p>
<p><strong>sy</strong>：内核空间占用CPU百分比</p>
<p><strong>ni</strong>：已调整优先级的用户进程的CPU百分比</p>
<p><strong>id</strong>：空闲CPU百分比，越低说明CPU使用率越高</p>
<p><strong>wa</strong>：等待IO完成的CPU百分比</p>
<p><strong>hi</strong>：处理硬件中断的占用CPU百分比</p>
<p><strong>si</strong>：处理软中断占用CPU百分比</p>
<p><strong>st</strong>：虚拟机占用CPU百分比</p>
<p><strong>第四行：物理内存信息</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/2.png"></p>
<p>以下内存单位均为MB</p>
<p><strong>total</strong>：物理内存总量</p>
<p><strong>free</strong>：空闲内存总量</p>
<p><strong>used</strong>：使用中内存总量</p>
<p><strong>buff/cacge</strong>：用于内核缓存的内存量</p>
<p><strong>第五行：交互区内存信息</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/3.png"></p>
<p><strong>total</strong>：交换区总量</p>
<p><strong>free</strong>：空闲交换区总量</p>
<p><strong>used</strong>：使用的交换区总量</p>
<p><strong>avail Mem</strong>：可用交换区总量</p>
<p>注：如果used不断在变化， 说明内核在不断进行内存和swap的数据交换，说明内存真的不够用了</p>
<p>问题：内存空间还剩多少空闲呢？</p>
<p>答案：空闲内存=空闲内存总量+缓冲内存量 +可用交换区总量</p>
<blockquote>
<p>SWAP交换空间，当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中。</p>
</blockquote>
<h4 id="进程信息区进程列表">进程信息区（进程列表）</h4>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/4.png" style="zoom: 80%;"></p>
<p><strong>PID</strong>：进程号</p>
<p><strong>USER</strong>：运行进程的用户</p>
<p><strong>PR</strong>：优先级</p>
<p><strong>NI</strong>：nice值。负值表示高优先级，正值表示低优先级</p>
<p><strong>VIRT</strong>：占用虚拟内存，单位kb。VIRT=SWAP+RES</p>
<p><strong>RES</strong>：占用真实内存，单位kb</p>
<p><strong>SHR</strong>：共享内存大小，单位kb</p>
<p><strong>S</strong>：进程状态</p>
<p><strong>%CPU</strong>：占用CPU百分比</p>
<p><strong>%MEM</strong>：占用内存百分比</p>
<p><strong>TIME+</strong>：上次启动后至今的总运行时间</p>
<p><strong>COMMAND</strong>：命令名or命令行</p>
<p><strong>进程状态</strong></p>
<p>R=运行状态</p>
<p>S=睡眠状态</p>
<p>D=不可中断的睡眠状态</p>
<p>T=跟踪/停止</p>
<p>Z=僵尸进程</p>
<h3 id="参考资料">参考资料</h3>
<p>https://cloud.tencent.com/developer/article/1640762 （Top命令）</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存技术</title>
    <url>/2021/09/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 26%">
<col style="width: 73%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>早期内存分配存在的问题</td>
<td>1、进程地址空间不隔离。<br>2、内存使用效率低。<br>3、进程运行地址不确定。</td>
</tr>
<tr class="even">
<td>虚拟内存技术</td>
<td>本质上就是增加一个中间层，利用一种间接的地址访问方法访问物理内存。</td>
</tr>
<tr class="odd">
<td>分段管理</td>
<td>采用虚拟内存技术。<br>进程的地址空间按照进程自身的逻辑关系（数据段、代码段等）划分为若干个段。<br>内存分配时以段位单位进行分配，每个段在内存中占连续空间，但各段之间可以不相邻。<br>解决问题1、3，不能解决2。</td>
</tr>
<tr class="even">
<td>分页管理</td>
<td>采用虚拟内存技术。<br>将地址空间分成许多的页，进程运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。<br>一个可执行文件(PE文件)其实就是一些编译链接好的数据和指令的集合，它也会被分成很多页，在PE文件执行的过程中，它往内存中装载的单位就是页。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="早期内存分配">早期内存分配</h3>
<p><img src="/2021/09/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20210916105514274.png" alt="image-20210916105514274" style="zoom:50%;"></p>
<p>1、一个程序想要运行，需要全都装入内存，即预先在内存上分配好它需要的所有空间。运行多个程序时，必须保证这些程序用到的内存总量要小于计算机实际物理内存的大小。</p>
<p>2、程序中访问的内存地址都是实际的物理内存地址。</p>
<p>带来的问题：</p>
<p>1、进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。</p>
<blockquote>
<p>举个例子，假设我有两个程序，一个是程序A，一个是程序B。程序A在内存中的地址<strong>假设</strong>是0x00000000<sub>0x00000099，程序B在内存中的地址<strong>假设</strong>是0x00000100</sub>x00000199。那么假设你在程序A中，本来想操作地址0x00000050，不小心<strong>手残</strong>操作了地址0x00000150，那么，不好的事情或许会发生。你影响了程序A也就罢了，你把程序B也搞了一顿。</p>
</blockquote>
<p>2、内存使用效率低。空闲的内存碎片无法得到有效利用，进程在切换（上下文切换）的时候需要将大量数据装载导出，效率低下。</p>
<blockquote>
<p>举个例子，假设你写了3个程序，其中程序A大小为10M，程序B为70M，程序C的大小为30M你的计算机的内存总共有100M。</p>
<p>这三个程序加起来有110M，显然这三个程序是无法同时存在于内存中的。</p>
</blockquote>
<p>3、进程运行地址不确定。操作系统会在可用物理内存上随机分配物理地址，导致地址不确定。</p>
<blockquote>
<p>因为我们程序每次要运行的时候，都是需要装载到内存中的，假设你在程序中<strong>写死</strong>了要操作某个地址的内存，例如你要地址0x00000010。但是问题来了，你能够保证你操作的地址0x00000010真的就是你<strong>原来</strong>想操作的那个位置吗？很可能程序第一次装载进内存的位置是0x00000000-0x00000099，而程序第二次运行的时候，这个程序装载进内存的位置变成了0x00000200-0x00000299，而你操作的0x00000010地址压根就不是属于这个程序所占有的内存。</p>
</blockquote>
<h3 id="分段">分段</h3>
<p>为了解决问题1、3，提出虚拟地址的概念。本质上就是增加一个中间层，利用一种间接的地址访问方法访问物理内存。进程中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p>
<p><img src="/2021/09/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image-20210916111126625.png" alt="image-20210916111126625" style="zoom: 50%;"></p>
<p>内存的分段管理，就是进程的地址空间按照进程自身的逻辑关系（数据段、代码段等）划分为若干个段，每个段都有一个段名，每段从0开始编址。 内存分配时以段位单位进行分配，每个段在内存中占连续空间，但各段之间可以不相邻。由于时按照逻辑功能划分，用户编程更方便，程序可读性更高。</p>
<p>案例：</p>
<p>假设有两个进程A和B。</p>
<p>进程A所需内存大小为10M，其虚拟地址空间分布在<strong>0x00000000</strong>到0x00A00000。</p>
<p>进程B所需内存为100M，其虚拟地址空间分布为<strong>0x00000000</strong>到0x06400000。</p>
<p>那么按照分段的映射方法，进程A在物理内存上映射区域为0x00100000到0x00B00000，，进程B在物理内存上映射区域为0x00C00000到0x07000000。于是进程A和进程B分别被映射到了不同的内存区间，彼此互不重叠，实现了地址隔离。从应用程序的角度看来，进程A的地址空间就是分布在0x00000000到0x00A00000，在做开发时，开发人员只需访问这段区间上的地址即可。应用程序并不关心进程A究竟被映射到物理内存的那块区域上了，所以程序的运行地址也就是相当于说是确定的了。</p>
<p>缺陷：</p>
<p>分段管理依然没有解决内存的使用效率问题。在分段的映射方法中，每次换入换出内存的都是整个程序，这样会造成大量的磁盘访问操作，导致效率低下。</p>
<p>实际上，程序的运行有局部性特点，在某个时间段内，程序只是访问程序的一小部分数据，也就是说，程序的大部分数据在一个时间段内都不会被用到。基于这种情况，人们想到了粒度更小的内存分割和映射方法，这种方法就是分页(Paging)。</p>
<h3 id="分页">分页</h3>
<p>分页的基本方法是，将地址空间分成许多的页。每页的大小由CPU决定，然后由操作系统选择页的大小。目前Inter系列的CPU支持4KB或4MB的页大小，而PC上目前都选择使用4KB。按这种选择，4GB虚拟地址空间共可以分成1048576个页，512M的物理内存可以分为131072个页。显然虚拟空间的页数要比物理空间的页数多得多。</p>
<p>在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。</p>
<p>一个可执行文件(PE文件)其实就是一些编译链接好的数据和指令的集合，它也会被分成很多页，在PE文件执行的过程中，它往内存中装载的单位就是页。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://www.cnblogs.com/myseries/p/12487211.html</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>OLTP与OLAP</title>
    <url>/2021/08/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_OLTP%E4%B8%8EOLAP/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 7%">
<col style="width: 46%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>OLTP(Online Transaction Processing)</th>
<th>OLAT(Online Analytical Processing)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>概念</td>
<td>在线事务处理，是一种数据处理的概念</td>
<td>在线分析处理，是一种数据处理的概念</td>
</tr>
<tr class="even">
<td>操作目的</td>
<td>查询、改变数据</td>
<td>分析规律、预测趋势</td>
</tr>
<tr class="odd">
<td>操作对象</td>
<td>数据库</td>
<td>数据仓库</td>
</tr>
<tr class="even">
<td>操作数据量</td>
<td>一般仅一两张表。（数据量小）<br>点查为主，返回的是记录本身或该记录的多个列。即使是范围查询，基本上也会通过limit来限制返回的记录数。</td>
<td>对多张表的数据进行count()、sum()和avg()等聚合方法<br>从大量数据中找出规律。<br>表中单条记录本身并不是查询所关心的，比较典型的特点包括有聚合类算子、涉及多表Join。</td>
</tr>
<tr class="odd">
<td>数据模型</td>
<td>实体-关系模型（ER）</td>
<td>星型或雪花</td>
</tr>
<tr class="even">
<td>数据时效</td>
<td>当前数据</td>
<td>当前以及历史</td>
</tr>
<tr class="odd">
<td>数据操作</td>
<td>DDL、DML</td>
<td>一般不支持更新和删除</td>
</tr>
<tr class="even">
<td>性能要求</td>
<td>高吞吐、低延迟</td>
<td>性能要求相对较低</td>
</tr>
<tr class="odd">
<td>业务类型</td>
<td>查询、支付、转账</td>
<td>统计报表</td>
</tr>
</tbody>
</table>
<a id="more"></a>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库分层</title>
    <url>/2021/07/11/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<h3 id="总结">总结</h3>
<p>数仓分成其实大致可以分为数据引入（数据源解耦）、数据公共（数仓）、数据应用（业务）这三层。</p>
<p>数据公共层又可以分为明细层（DWD）、公共层（DWB/DWS）、维度层（DIM）等。</p>
<p>总结下来可以大致分为：</p>
<table>
<thead>
<tr class="header">
<th>数仓分层</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数据应用层（ADS）</td>
<td>存放不同业务的指标统计数据。</td>
</tr>
<tr class="even">
<td>维度层（DIM）</td>
<td>用户资料表，配置表</td>
</tr>
<tr class="odd">
<td>服务数据层（DWS）</td>
<td>针对特定的业务主题生成宽表，用于提供后续的业务查询</td>
</tr>
<tr class="even">
<td>基础数据层（DWB/DWM）</td>
<td>对数据做轻度的聚合操作，生成一些中间表，提升公共指标的复用性</td>
</tr>
<tr class="odd">
<td>明细层（DWD）</td>
<td>减少表的关联关系，提供一定的数据质量保证</td>
</tr>
<tr class="even">
<td>数据引入层（ODS）</td>
<td>存放未经过处理的原始数据</td>
</tr>
<tr class="odd">
<td>数据源</td>
<td>存储在消息队列MQ和数据库OLTP中的数据</td>
</tr>
</tbody>
</table>
<p><img src="/2021/07/11/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82/image-20210711155449936.png" alt="image-20210711155449936" style="zoom:67%;"></p>
<a id="more"></a>
<p>将数据仓库中的数据进行分层存储，本质上是为了构建清晰的数据链路，便于规划和管理数据。</p>
<p>在阿里巴巴的数据体系中，将数据仓库分为三层，从数据源开始自下而上为：</p>
<ul>
<li>数据引入层（ODS，Operation Data Store）</li>
<li>数据公共层（CDM，Common Data Model）</li>
<li>数据应用层（ADS，Application Data Service）</li>
</ul>
<p><img src="/2021/07/11/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82/image-20210711151440351.png" alt="image-20210711151440351" style="zoom:67%;"></p>
<h3 id="数据引入层ods">数据引入层（ODS）</h3>
<p>存放未经过处理的原始数据至数据仓库系统，结构上与源系统保持一致，是数据仓库的数据准备区。</p>
<p>主要完成基础数据引入到数据仓库（阿里云的数仓工具为MaxCompute）的职责，同时记录基础数据的历史变化。</p>
<h3 id="数据公共层cdm">数据公共层（CDM）</h3>
<p>主要完成数据加工与整合，本质上是建立明细表和宽表，这些表是可复用的、面向分析和统计的。</p>
<p>在这一层内又可以划分为多层。</p>
<p><img src="/2021/07/11/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82/image-20210711152514618.png" alt="image-20210711152514618" style="zoom:67%;"></p>
<h4 id="明细层dwd">明细层（DWD ）</h4>
<p>Data Warehouse Detail</p>
<p>该层一般保持和ODS层一样的数据粒度，并且提供一定的数据质量保证。同时，为了提高数据明细层的易用性，该层会采用一些维度退化手法，将维度退化至事实表中，减少事实表和维表的关联。</p>
<p>另外，在该层也会做一部分的数据聚合，将相同主题的数据汇集到一张表中，提高数据的可用性。</p>
<h4 id="公共层dwbdws">公共层（DWB/DWS）</h4>
<p>DWB：data warehouse base 基础数据层，存储的是客观数据，一般用作中间层，可以认为是大量指标的数据层。</p>
<p>该层会在DWD层的数据基础上，对数据做<strong>轻度的聚合</strong>操作，生成一系列的中间表，提升公共指标的<strong>复用性</strong>，减少重复加工。本质上，就是对通用的核心维度进行聚合操作，算出相应的统计指标。</p>
<p>DWS：data warehouse service 服务数据层，基于DWB上的基础数据，整合汇总成分析某一个主题域的服务数据，一般是宽表。</p>
<p>DWS又称<strong>数据集市或宽表</strong>。按照业务划分，如流量、订单、用户等，生成字段比较多的宽表，用于提供后续的业务查询，OLAP分析，数据分发等。</p>
<p>一般来讲，该层的数据表会相对比较少，一张表会涵盖比较多的业务内容，由于其字段较多，因此一般也会称该层的表为宽表。</p>
<p>在实际计算中，如果直接从DWD或者ODS计算出宽表的统计指标，会存在<strong>计算量太大</strong>并且维度太少的问题，因此一般的做法是，在DWB层先计算出多个小的中间表，然后再拼接成一张DWS的宽表。由于宽和窄的界限不易界定，也可以去掉DWB这一层，只留DWS层，将所有的数据在放在DWS亦可。</p>
<h4 id="维度层dim">维度层（DIM）：</h4>
<p>Dimension。</p>
<p>基于维度建模理念思想，建立整个企业一致性维度。</p>
<p>主要包含两部分数据：</p>
<p>高基数维度数据：一般是用户资料表、商品资料表类似的<strong>资料表</strong>。数据量可能是千万级或者上亿级别。</p>
<p>低基数维度数据：一般是<strong>配置表</strong>，比如枚举值对应的中文含义，或者日期维表。数据量可能是个位数或者几千几万。</p>
<h3 id="数据应用层ads">数据应用层（ADS）</h3>
<p>存放数据产品个性化的统计指标数据。根据CDM与ODS层加工生成。本质上就是业务方需要展示的数据表。</p>
<h3 id="分层的优点">分层的优点</h3>
<ul>
<li>清晰结构 每一个数据分层都有它的作用域，在使用表的时候能更方便地定位和理解整个数据链路的构造。</li>
<li>数据追踪 简单来说，我们最终给业务呈现的是一个能直接使用业务表，但是它的来源有很多，如果有一张来源表出问题了，希望能够快速准确地定位到问题，并清楚它的危害范围。</li>
<li>减少重复开发 规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算。</li>
<li>把复杂问题简单化 将一个复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，比较简单和容易理解。而且便于维护数据的准确性，当数据出现问题之后，可以不用修复所有的数据，只需要从有问题的步骤开始修复。</li>
<li>屏蔽原始数据的异常 屏蔽业务的影响，不必改一次业务就需要重新接入数据。例如假如某一层的时间单位被修改了，则只影响这一层。</li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p>https://help.aliyun.com/document_detail/114447.html</p>
<p>https://cloud.tencent.com/developer/article/1396891</p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库与数据库</title>
    <url>/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>数据仓库，英文名称为Data Warehouse，可简写为DW或DWH，是一种用于报告和数据分析的系统，被认为是商业智慧（BI，Business Intelligence）的核心组件。 数据仓库将一个或多个数据源的数据集成到中央存储库中，将当前和历史数据存储在一起，用于创建分析报告。 存储在仓库中的数据从运行系统（例如营销或销售）上传。</p>
<a id="more"></a>
<h3 id="数据仓库与数据库">数据仓库与数据库</h3>
<p>数据库 Database (Oracle, Mysql)主要用于事务处理，数据仓库 Data Warehouse (Hive)主要用于数据分析。用途上的不同决定了这两种架构的特点不同。</p>
<p>数据库(Database)的特点是：</p>
<ul>
<li>相对复杂的表格结构，存储结构相对紧致，少冗余数据。</li>
<li>读和写都有优化。</li>
<li>相对简单的read/write query，单次作用于相对的少量数据。</li>
</ul>
<p>数据仓库(Datawarehouse)的特点是：</p>
<ul>
<li>相对简单的(Denormalized)表格结构，存储结构相对松散，多冗余数据。</li>
<li>一般只是读优化。</li>
<li>相对复杂的read query，单次作用于相对大量的数据（历史数据）。</li>
</ul>
<p>用图书表格系统举例子，可以从如下方面看出两者的区别。</p>
<h4 id="表结构">表结构</h4>
<p>如下表示数据库(Database)的表结构。这里有六张表，分别记录了作者，图书，图书种类，发行商以及他们之间的关系。可以看出每张表都相对紧致，冗余的数据较少。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/0.png" style="zoom:50%;"></p>
<p>如下表示数据仓库(Data Warehouse)的表结构。需要对原始表格进行Denormalization。数据仓库中仅剩余一张表格。</p>
<blockquote>
<p>Denormalization是一种策略，用于已经预先Normalized的数据库上以提高性能。Denormalization尝试通过增加数据的冗余副本或对数据进行分组来提高数据库的读取性能，但以牺牲一些写入性能为代价。</p>
</blockquote>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/1.png" style="zoom:50%;"></p>
<p>Denormalization可以通过对数据库中的表格执行如下的SQL语句脚本实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Denormalization Script -- </span><br><span class="line">select </span><br><span class="line">b.id,</span><br><span class="line">b.title,</span><br><span class="line">b.copyright,</span><br><span class="line">b.isbn,</span><br><span class="line">g.genre,</span><br><span class="line">a.firstname as AuthorFirstName,</span><br><span class="line">a.lastname as AuthorLastName,</span><br><span class="line">a.dateofbirth,</span><br><span class="line">a.gender,</span><br><span class="line">p.name as PublisherName</span><br><span class="line">from BOOKS b</span><br><span class="line">left join GENRE g on b.genre &#x3D; g.id</span><br><span class="line">left join AUTHOR_BOOK_MAP abm on b.id &#x3D; abm.bookid</span><br><span class="line">left join AUTHORS a on a.id &#x3D; abm.authorid</span><br><span class="line">left join PUBLISHER_BOOK_MAP pbm on b.id &#x3D; pbm.bookid</span><br><span class="line">left join PUBLISHER p on p.id &#x3D; pbm.publisherid;</span><br></pre></td></tr></table></figure>
<h4 id="存储空间">存储空间</h4>
<p>很明显，因为在Denormalization的过程中，如果数据库主表和次表不是一对一的关系，那么最终数据仓库主表或者次表一定会出现重复的数据。所以从存储空间角度讲，相比于数据库紧密的存储结构，数据仓库则存在大量冗余重复的数据。</p>
<p>数据库(Database)表单存储紧凑：</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/2.png" style="zoom: 67%;"></p>
<p>数据仓库(Datawarehouse)表单里有大量冗余：</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/3.png" style="zoom:67%;"></p>
<h4 id="读写优化">读写优化</h4>
<h5 id="基本读read操作对比">基本读(Read)操作对比</h5>
<p>如下所示的两种查询，一个是找一本书（Primary Key）的信息，另一个是找一位作者（Non-Key）所有的作品信息。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/4.png" style="zoom:67%;"></p>
<p>由于数据库需要利用表之间的关联才能找到所有需要的数据，在<strong>效率上会相对低下</strong>。相比之下数据仓库把这些关联关系转化成重复数据记录到同一张表上了，查询效率相对就会较高。数据仓库相当于牺牲了空间换取了查询效率。</p>
<p>此外，在数据库里面写这段Query的时候，<strong>需要了解表单的结构与他们之间的关系</strong>，这对于做数据报告或者数据分析非常不友好，尤其是在表单结构很复杂的时候（比如表单使用了逻辑树的储存结构）。这时候数据仓库简单明了的Denormalized表单结构就对于生成数据报告就非常有优势了。</p>
<p>并且，由于数据报告和数据分析常常涉及到大规模的查询，这些<strong>查询很可能会占用很高的CPU资源</strong>，从而可能影响到数据库的常规读写操作，因为数据库常常是Single-Instance的（接下来会提到）；这一点上数据仓库的Multi-instances的结构就不会有太多这个问题。</p>
<h5 id="大数据读read操作对比">大数据读(Read)操作对比</h5>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/5.png" style="zoom: 50%;"></p>
<p>当数据量非常大的时候，特定条件下的数据仓库的读优化所带来的优势可以全面超越数据库。大部分的数据库都是Single-instance的，而数据仓库则是Multi-instances的<strong>分布式系统</strong>。数据仓库在分配储存的节点的时候是根据PrimaryKey/PartitionKey来分配的，查询的时候不仅<strong>根据查询键的值来搜索对应节点位置</strong>，同时<strong>进行大量的并行查询</strong>，可以极大提升查询的性能。</p>
<p>但是，并不是所有的读操作，数据仓库一直都有优势。比如在如下两种情况时，数据仓库的读表现并不如数据库：</p>
<p>1、在对小量数据进行读取操作的时候，由于数据仓库要进行寻找数据所在的节点位置之类的预运算，整体效率上反倒不如数据库。</p>
<p>2、如果读取操作的目标不是主键(PrimaryKey)或者分区键(PartitionKey)，那么数据仓库的查询也需要进行全局扫描，效率上就不好说是否胜过数据库了。</p>
<p>这两点也是为什么现在即使有像Amazon Redshift这般强大的Data Warehouse应用，SQL Database仍然无法被取代的一部分主要原因。</p>
<h5 id="写write操作">写(Write)操作</h5>
<p>多数情况下，数据仓库不太会进行精确的写操作。因为冗余行数太多，有时候只是改一个很小的字段，也会修改大量的行数。而对于数据库来说，由于其紧凑的表格结构，写操作就可以非常精细有效了。比如需要修改《Java Complete》这本书的版权，从1999改到2002，数据库里面只需要该一行，而数据仓库里面需要改5行。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/6.png"></p>
<p>数据仓库的写操作都是整段(表)刷新或者整段数据插入, 这也和它做数据分析的用途有关系。由于数据仓库的整表刷新和分布式储存的特质，我们可以通过把PartitionKey设置成数据创建/更新的时间，然后记录一段时间内的历史数据。这对于数据分析以及利用数据进行决策都有重要意义。</p>
<h3 id="数据仓库与数据库结合">数据仓库与数据库结合</h3>
<p>可以通过将两者的架构结合发挥出两者的优势。</p>
<p>通常的软件架构简化一下就是用户通过API和数据库交互。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/7.png" style="zoom:55%;"></p>
<p>这里如果要直接在数据库上做数据分析，数据监控等等任务的话，会有以下几个问题：</p>
<p>1、数据分析通常涉及大量数据查询，可能会<strong>占用太多CPU</strong>从而影响软件的基本功能。</p>
<p>2、数据库的表单结构通常比较复杂，<strong>需要数据分析人员对DB结构有深入的了解</strong>。</p>
<p>3、数据库在进行<strong>大量数据查询的时候效率较低</strong>。</p>
<p>4、开放数据库访问<strong>权限</strong>（即便只是读权限），尤其是给外组人员，会有安全隐患。</p>
<p>为了解决以上四个问题，我们可以通过利用脚本，每隔一段时间把数据库里面的所有数据Denormalize到数据仓库里面，在数据仓库里面进行数据分析。根据之前提到的数据仓库的所有的特性（独立不影响业务，表结构简单，读数据速度快，相对安全），这四个问题都可以得到很好的解决。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/8.png" style="zoom: 50%;"></p>
<p>但是这里还是有一个小问题。如果有很多不同的组需要共享这个Data Warehouse，那么同样他们的脚本可能会相互影响。这里引入一下数据目录(Data Catalog)的概念来解决这个问题。</p>
<blockquote>
<p>数据目录是一种元数据管理工具，旨在帮助公司查找和管理存储在其各个系统中的大量数据（包括表、文件和数据库） 。</p>
</blockquote>
<p>通过数据目录储存元数据，然后发布出去让不同组的数据仓库都可以同步这个数据。这样，每个不同组的数据仓库都拿到了同样的Denormalized数据，但是却相互独立开了。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/9.png" style="zoom: 33%;"></p>
<h3 id="总结">总结</h3>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 45%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>数据库</th>
<th>数据仓库</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作用</td>
<td>主要用于事务处理（增删改）。</td>
<td>主要用于数据分析。</td>
</tr>
<tr class="even">
<td>表格结构</td>
<td>一个存储的主题通常由多张表格及其之间的关系（Schema）组成。</td>
<td>一个存储的主题可以由一张表格形成，它里面包含了大量冗余的数据（Denormalization增加数据的冗余副本）。</td>
</tr>
<tr class="odd">
<td>存储空间</td>
<td>表格存储紧凑。</td>
<td>表格存在冗余。</td>
</tr>
<tr class="even">
<td>基本读操作</td>
<td>1、需要利用表之间的关联才能找到所有需要的数据，在<strong>效率上会相对低下</strong>。2、需要<strong>了解表格的结构与他们之间的关系</strong>进行查询。3、Single-Instance的数据库在执行大规模查询时<strong>占用大量CPU资源</strong>。</td>
<td>1、数据仓库包含<strong>大量冗余数据</strong>，可以不用对多个表格进行关联就能查询到数据。2、Denormalized策略使得<strong>不需要理解表格之间的关系</strong>就可以进行查询。3、数据仓库通常是<strong>分布式存储</strong>的，可以通过分布式计算框架操作数据。</td>
</tr>
<tr class="odd">
<td>大规模读操作</td>
<td>基于Single-Instance的数据库在执行大规模查询时不能并行查找，效率低下。</td>
<td>基于分布式存储系统和分布式计算框架的数据仓库在面临大规模查询时可以进行并行查找，效率较高。（小量数据查询、查询目标非主键/分区键时，无法保证效率）</td>
</tr>
<tr class="even">
<td>写操作</td>
<td>更新数据时仅涉及少量的行。</td>
<td>由于数据是冗余存储的，更新数据时涉及到大量的行更新。</td>
</tr>
<tr class="odd">
<td>两者结合</td>
<td>每隔一段时间把数据库里面的所有数据Denormalize到数据仓库里面，在数据仓库里面进行数据分析。</td>
<td>不同数据仓库通过订阅数据目录中的元数据信息来获取Denormalized之后的数据。</td>
</tr>
</tbody>
</table>
<h3 id="参考资料">参考资料</h3>
<p>转载自： https://www.zhihu.com/question/20623931/answer/750367153</p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据建模</title>
    <url>/2021/08/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h3 id="基本概念">基本概念</h3>
<h4 id="事实表">事实表</h4>
<p>事实表（Fact Table）用来记录具体事件，包含了每个事件的具体要素，以及具体发生的事情。<strong>也就是每一条数据记录了发生的一件事情</strong>。例子中就通过一条事实表记录说明了某个地方（地域ID）的某人（用户ID）在某个时间（时间ID）通过某种方式（支付ID）买了某产品（产品ID）。</p>
<p><img src="/2021/08/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/image-20210803085511700.png" alt="image-20210803085511700" style="zoom:67%;"></p>
<a id="more"></a>
<h4 id="维度表">维度表</h4>
<p>维度表（Dimension Table ）是依赖事实表而存在的，没有事实表数据，维度表也就没有存在的意义。每个维度表都是对事实表中的每个列/字段进行展开描述。</p>
<p>比如事实表中的用户ID，就可以进一步展开成一张维度表，记录该用户ID实体的用户名、联系信息、地址信息、年龄、性别和注册方式等等。</p>
<p><img src="/2021/08/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/image-20210803085631465.png" alt="image-20210803085631465" style="zoom:67%;"></p>
<h4 id="事实表与维度表">事实表与维度表</h4>
<p>事实表的增删改操作相比维度表更为频繁，模型建立后，维度表中的数据保持相对稳定。商品销售行为是一直在发生的，而用户注册和产品更新不总是随时有的。再说到地域和支付方式，那就更少变化了。</p>
<p><img src="/2021/08/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/image-20210803085828180.png" alt="image-20210803085828180" style="zoom:50%;"></p>
<p>通过事实表和维度表组织起来的数仓多维数据模型（上图为星型模型），相比原本分散在数据库等各处的数据，能够有更有目的更高效的查询效率，比如可以查询汇总地域维度中某个省的商品销售情况，也可以通过时间维度分析每个季度的某类商品销售趋势。<strong>将多个维度表跟事实表进行不同程度的关联，可以展开得到各种各样的分析结果</strong>，满足商品运营等数据使用者的不同需求。</p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL面试题</title>
    <url>/2021/09/15/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>SQL中连续登录问题和在线峰值问题等。</p>
<a id="more"></a>
<h3 id="连续登录问题">连续登录问题</h3>
<h4 id="连续登录n天的用户id">连续登录n天的用户id</h4>
<p>1、因为每天用户登录次数可能不止一次，所以需要先将用户每天的登录日期去重。</p>
<p>2、再用row_number() over(partition by _ order by _)函数将用户id分组，按照登陆时间进行排序。</p>
<p>3、计算登录日期减去第二步骤得到的结果值，用户连续登陆情况下，每次相减的结果都相同。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">id   date   rank  date-rank(这个相减的结果是一个数值，无规律，这里只是举例)  </span><br><span class="line">001  06-06  1     06-05</span><br><span class="line">001  06-08  2     06-06</span><br><span class="line">001  06-09  3     06-06</span><br><span class="line">001  06-10  4     06-06</span><br><span class="line">001  06-15  5     06-10</span><br><span class="line">001  06-16  6     06-10</span><br></pre></td></tr></table></figure>
<p>4、按照id和日期分组并求和，筛选大于等于7的即为连续7天登陆的用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># id, date</span><br><span class="line"># 用户ID，用户登录时间</span><br><span class="line"></span><br><span class="line">#最后先按照id和结果列进行 group by，然后统计结果，旋转连续天数大于7的用户id</span><br><span class="line">select id,count(*) from </span><br><span class="line">(</span><br><span class="line">    #date函数仅返回日期部分，不返回时间部分，结果列表示  用户连续登陆情况下，每次相减的结果都相同</span><br><span class="line">    select *,date(date)-rank as res from </span><br><span class="line">    (</span><br><span class="line">        #按照用户分组，按照时间排序, rank是排名</span><br><span class="line">        select *,row_number() over(PARTITION by id order by date) as rank from </span><br><span class="line">        (</span><br><span class="line">            #给时间去重</span><br><span class="line">            select DISTINCT date(date) as date,id from table_test</span><br><span class="line">        ) a </span><br><span class="line">    )b</span><br><span class="line">)c </span><br><span class="line">GROUP BY id,res having count(*)&gt;&#x3D;7;</span><br></pre></td></tr></table></figure>
<p>有一张用户签到表t_user_attendence，标记每天用户是否签到（说明：该表包含所有用户所有工作日的出勤记录） ，</p>
<p>包含三个字段：日期 fdate，用户id user_id，用户当天是否签到 is_sign_in 0否1是</p>
<h4 id="截至当前连续签到的天数">截至当前连续签到的天数</h4>
<p>问题1：请计算截至当前每个用户已经连续签到的天数（输出表仅包含当天签到的所有用户，计算其连续签到天数）</p>
<p>解题方案：先找用户最近一次未签到日期，再用今天减那个日期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,datediff(CURDATE(),maxdate) <span class="keyword">as</span> fconsecutive_days</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">( </span><br><span class="line">   <span class="keyword">select</span> user_id, <span class="built_in">max</span>(fdate) <span class="keyword">as</span> maxdate</span><br><span class="line">   <span class="keyword">from</span> t_user_attendence</span><br><span class="line">   <span class="keyword">where</span> is_sign_in <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">   <span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br><span class="line">) <span class="keyword">as</span> T1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NOW()函数以'YYYY-MM-DD HH:MM:SS'返回当前的日期时间，可以直接存到DATETIME字段中。</p>
<p>CURDATE()以'YYYY-MM-DD'的格式返回今天的日期，可以直接存到DATE字段中。</p>
<p>CURTIME()以'HH:MM:SS'的格式返回当前的时间，可以直接存到TIME字段中。</p>
</blockquote>
<h4 id="最大连续天数">最大连续天数</h4>
<p>问题2：请计算每个用户历史以来最大的连续签到天数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id, <span class="built_in">max</span>(days)</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">	(</span><br><span class="line">		<span class="keyword">select</span> user_id,groupday, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> days</span><br><span class="line">		<span class="keyword">from</span> </span><br><span class="line">		(</span><br><span class="line">			<span class="keyword">select</span> </span><br><span class="line">				user_id, </span><br><span class="line">                (<span class="type">date</span>(fdate) <span class="operator">-</span> <span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>(fdate)) ) <span class="keyword">as</span> groupday</span><br><span class="line">			<span class="keyword">from</span> user_sign</span><br><span class="line">			<span class="keyword">where</span> is_sign_in <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">		)  T2</span><br><span class="line">		<span class="keyword">group</span> <span class="keyword">by</span> user_id,groupday</span><br><span class="line"></span><br><span class="line">	) T1</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br></pre></td></tr></table></figure>
<h3 id="计算用户在线峰值">计算用户在线峰值</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#(timestampe:String, uid:Int, logtype:Int)</span><br><span class="line">#时间戳 用户ID 上线下线状态(-1下线，1上线)</span><br><span class="line"></span><br><span class="line">select</span><br><span class="line">    max(max_users)</span><br><span class="line">from </span><br><span class="line">(</span><br><span class="line">    #排序后第一行到本行的和，就统计了当前时刻究竟有多少人在线</span><br><span class="line">    select</span><br><span class="line">        sum(logtype) over(order by &#96;timestampe&#96;) as max_users </span><br><span class="line">    from</span><br><span class="line">    (</span><br><span class="line">        #unix_timestamp 自&#39;1970-01-01 00:00:00&#39;的到当前时间的秒数差</span><br><span class="line">        select</span><br><span class="line">            uid,</span><br><span class="line">            unix_timestamp(timestampe) as &#96;timestampe&#96;, </span><br><span class="line">            logtype</span><br><span class="line">        from</span><br><span class="line">            mytable</span><br><span class="line">    ) as a  #将登录时间和登出时间多列成多行</span><br><span class="line">)as b</span><br></pre></td></tr></table></figure>
<h3 id="前n个阅读量最高的文章">前N个阅读量最高的文章</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#给定用户id，文章id，阅读时间</span><br><span class="line">select 文章id, count(*) as 阅读量</span><br><span class="line">from biao</span><br><span class="line">group by 文章id</span><br><span class="line">order by 阅读量 desc</span><br><span class="line">limit 5</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://www.codeleading.com/article/5399898432/ （在线峰值）</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>结构化数据、半结构化数据、非结构化数据</title>
    <url>/2021/09/12/%E6%95%B0%E6%8D%AE%E5%BA%93_%E7%BB%93%E6%9E%84%E5%8C%96%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>结构化数据</td>
<td>可以使用关系型数据库表示和存储的数据，通常表现为二维表格的形式。</td>
</tr>
<tr class="even">
<td>半结构化数据</td>
<td>通过标签或者字段对数据进行分层表示存储的数据。</td>
</tr>
<tr class="odd">
<td>非结构化数据</td>
<td>没有固定Schema或结构约束的数据。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="结构化数据">结构化数据</h3>
<p>结构化的数据是指可以使用关系型数据库表示和存储的数据，通常表现为二维表格的形式。</p>
<p>特点：数据以行为单位，一行数据表示一个实体的信息，每一行数据的字段是相同的。显然，结构化数据的可扩展性不好，比如增加一个字段就非常麻烦。</p>
<p>数据模型：实体-关系模型</p>
<figure>
<img src="/2021/09/12/%E6%95%B0%E6%8D%AE%E5%BA%93_%E7%BB%93%E6%9E%84%E5%8C%96%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/image-20210912171228151.png" alt="image-20210912171228151"><figcaption aria-hidden="true">image-20210912171228151</figcaption>
</figure>
<h3 id="半结构化数据">半结构化数据</h3>
<p>半结构化数据是指通过标签或者字段对数据进行分层表示存储的数据。</p>
<p>特点：它是结构化数据的一种形式，不符合关系型数据库数据模型。一行数据的标签或者字段是不固定的，没有严格的Schema的约束。</p>
<p>数据模型：树、图</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>A<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>13<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="非结构化数据">非结构化数据</h3>
<p>非结构化数据指的是没有固定Schema约束的数据。</p>
<p>特点：通常无法将这些数据拆分成某种结构进行存储，即直接对这类数据进行整体存储，而且一般存储为二进制的数据格式，比如图片、语音、视频等。</p>
<p>数据模型：没有</p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/liangyihuai/article/details/54864952</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库中键和范式</title>
    <url>/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="总结">总结</h3>
<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>键</td>
<td>指的是关系型数据库中一张表的某些字段</td>
</tr>
<tr class="even">
<td>超键</td>
<td>在关系表中能唯一标识一行数据的字段集</td>
</tr>
<tr class="odd">
<td>候选键</td>
<td>不含有多余字段的超键被称为候选键，同样能够唯一决定一条数据</td>
</tr>
<tr class="even">
<td>主属性</td>
<td>候选键中的字段</td>
</tr>
<tr class="odd">
<td>主键</td>
<td>用户选择的被用来唯一标识一行数据的的候选键被称为主键</td>
</tr>
<tr class="even">
<td>范式</td>
<td>关系型数据库表需要满足的一些约束条件被称为范式。</td>
</tr>
<tr class="odd">
<td>一范式</td>
<td>字段不可再分</td>
</tr>
<tr class="even">
<td>二范式</td>
<td>非主键字段全部依赖于主键（消除部份依赖）</td>
</tr>
<tr class="odd">
<td>三范式</td>
<td>非主键字段之间无依赖关系（消除传递依赖）</td>
</tr>
<tr class="even">
<td>BCNF</td>
<td>消除主属性对候选键的部分和传递依赖</td>
</tr>
<tr class="odd">
<td>四范式</td>
<td>消除一张数据表内的多个一对多的关系</td>
</tr>
<tr class="even">
<td>范式优点</td>
<td>消除冗余、异常</td>
</tr>
<tr class="odd">
<td>范式缺点</td>
<td>关联表增加查询复杂度，降低数据库查询性能</td>
</tr>
<tr class="even">
<td>反范式化</td>
<td>在数据表中增加冗余字段来提升数据库的读性能。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="键">键</h3>
<p>例如有如下字段：</p>
<p>身份证、姓名、性别、年龄</p>
<p><strong>超键</strong>(super key)：在关系中能唯一标识一行数据的字段集称为关系模式的超键。</p>
<p>身份证 唯一，所以是一个超键</p>
<p>姓名 唯一，所以是一个超键</p>
<p>（姓名，性别）唯一，所以是一个超键</p>
<p>（姓名，性别，年龄）唯一，所以是一个超键</p>
<p>即超键能够唯一决定一条数据，但可能不是最小唯一的的字段或字段集合。</p>
<p><strong>候选键</strong>(candidate key)：不含有多余字段的超键称为候选键。</p>
<p>身份证唯一，而且没有多余属性，所以是一个候选键</p>
<p>姓名唯一，而且没有多余属性，所以是一个候选键</p>
<p>即候选键是没有多余属性的超键，候选键同样能够唯一决定一条数据</p>
<p><strong>主属性</strong>：即候选键中的一个字段。</p>
<p><strong>非主属性</strong>：除了主属性外的属性。</p>
<p><strong>主键</strong>(primary key)：用户选择的被用来唯一标识一行数据的的候选键被称为主键</p>
<p>考虑输入查询方便性，可以选择身份证为主键，也可以考虑习惯选择姓名为主键。</p>
<p>即主键是选中的一个候选键。</p>
<h3 id="范式">范式</h3>
<p>范式来自英文Normal form，简称NF。</p>
<p>在关系型数据库中，关于数据表设计的<strong>基本原则、规则就称为范式</strong>。</p>
<p>可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入(insert)、删除(delete)和更新(update)操作异常。</p>
<h4 id="一范式">一范式</h4>
<p>字段不可再分。</p>
<p>反例：</p>
<table>
<thead>
<tr class="header">
<th>Contact</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Email:kkkk@ee.net,phone:222456</td>
</tr>
<tr class="even">
<td>email:kkk@fff.net phone:123455</td>
</tr>
</tbody>
</table>
<p>问题：</p>
<p>contact字段可以再分，不符合第一范式。</p>
<p>正例：</p>
<table>
<thead>
<tr class="header">
<th>Email</th>
<th>Phone</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Email:kkkk@ee.net</td>
<td>222456</td>
</tr>
<tr class="even">
<td>email:kkk@fff.net</td>
<td>123455</td>
</tr>
</tbody>
</table>
<h4 id="二范式">二范式</h4>
<p>非主键字段完全依赖于主键。（不能只依赖于主键的一部分）</p>
<p>即只要知道主键中的所有字段的值，就可以唯一确定一行数据及其字段的值。</p>
<p>反例：</p>
<p>选课关系表，主键为（学号，课程名称），可以发现这能唯一地标识一条数据</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>课程名称</th>
<th>姓名</th>
<th>年龄</th>
<th>成绩</th>
<th>学分</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>语文</td>
<td>小明</td>
<td>15</td>
<td>92</td>
<td>3</td>
</tr>
<tr class="even">
<td>02</td>
<td>数学</td>
<td>小王</td>
<td>16</td>
<td>98</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>问题：</p>
<p>不满足第二范式，因为存在如下决定关系：</p>
<p>（课程名称） → （学分）</p>
<p>（学号） → （姓名, 年龄）</p>
<p>造成问题有：</p>
<ol type="1">
<li>数据冗余：</li>
</ol>
<p>同一门课程由n个学生选修，"学分"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。</p>
<ol start="2" type="1">
<li>更新异常：</li>
</ol>
<p>若调整了某门课程的学分，数据表中所有行的"学分"值都要更新，否则会出现同一门课程学分不同的情况。</p>
<ol start="3" type="1">
<li>插入异常：</li>
</ol>
<p>假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。</p>
<ol start="4" type="1">
<li>删除异常：</li>
</ol>
<p>假设一批学生已经完成课程的选修，需要从数据库表中删除这些记录。但与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。</p>
<p>正例：</p>
<p>把选课关系表拆分为三个表：</p>
<p>学生表：</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>年龄</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>02</td>
<td>小王</td>
<td>16</td>
</tr>
</tbody>
</table>
<p>课程表：</p>
<table>
<thead>
<tr class="header">
<th>课程名称</th>
<th>学分</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数学</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>选课关系表：</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>课程名称</th>
<th>成绩</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>02</td>
<td>数学</td>
<td>98</td>
</tr>
</tbody>
</table>
<p>学生：Student(学号, 姓名, 年龄)； 课程：Course(课程名称, 学分)； 选课关系：SelectCourse(学号, 课程名称, 成绩)。</p>
<p>这样的数据库表是符合第二范式的， 消除了数据冗余、更新异常、插入异常和删除异常。</p>
<h4 id="三范式">三范式</h4>
<p>非主键字段之间无依赖关系。（没有传递依赖）</p>
<p>反例：</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>奖学金等级</th>
<th>奖学金</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>小明</td>
<td>优秀</td>
<td>1800.00</td>
</tr>
</tbody>
</table>
<p>问题：</p>
<p>主键是学号，奖学金依赖于奖学金等级，因此不满足三范式</p>
<p>正例：</p>
<p>学生表</p>
<table>
<thead>
<tr class="header">
<th>学号</th>
<th>姓名</th>
<th>等级</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>小明</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>奖学金等级表</p>
<table>
<thead>
<tr class="header">
<th>等级</th>
<th>奖学金等级</th>
<th>奖学金</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>优秀</td>
<td>1800.00</td>
</tr>
</tbody>
</table>
<h4 id="bcnf">BCNF</h4>
<p>消除主属性对候选键的部分和传递依赖</p>
<p>反例：</p>
<table>
<thead>
<tr class="header">
<th>仓库ID</th>
<th>商品ID</th>
<th>管理员ID</th>
<th>商品数量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>20130104</td>
<td>1</td>
<td>200</td>
</tr>
</tbody>
</table>
<p>主键是</p>
<p>(仓库ID, 商品ID) →(管理员ID, 数量)</p>
<p>或</p>
<p>(管理员ID, 商品ID) → (仓库ID, 数量)</p>
<p>(仓库ID, 商品ID)和(管理员ID,商品ID)都是候选键，都可以唯一决定一条数据。</p>
<p>问题：</p>
<p>但是，存在主属性对候选键的部份依赖。</p>
<p>主属性(仓库ID) → 候选键(管理员ID,商品ID)中的(管理员ID)</p>
<p>主属性(管理员ID) → 候选键(仓库ID, 商品ID)中的(仓库ID)</p>
<ol type="1">
<li>删除异常：</li>
</ol>
<p>当仓库被清空后，所有"存储物品ID"和"数量"信息被删除的同时，"仓库ID"和"管理员ID"信息也被删除了。</p>
<ol start="2" type="1">
<li>插入异常：</li>
</ol>
<p>当仓库没有存储任何物品时，无法给仓库分配管理员。</p>
<ol start="3" type="1">
<li>更新异常：</li>
</ol>
<p>如果仓库换了管理员，则表中所有行的管理员ID都要修改。</p>
<p>正例：</p>
<p>仓库管理表：</p>
<table>
<thead>
<tr class="header">
<th>仓库ID</th>
<th>商品ID</th>
<th>商品数量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>20130104</td>
<td>200</td>
</tr>
</tbody>
</table>
<p>仓库表：</p>
<table>
<thead>
<tr class="header">
<th>仓库ID</th>
<th>管理员ID</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>1</td>
</tr>
</tbody>
</table>
<h4 id="四范式">四范式</h4>
<p>消除一张数据表内的多个一对多的关系。</p>
<p>多值依赖：即属性（字段）之间的一对多关系，记为K→→A。也就是说字段K中的某个值，对应了字段A中的多个值。</p>
<p>平凡的多值依赖：全集U=K+A，字段K中的某个值可以对应于字段A中的多个值，即K→→A。此时整个表就是一组一对多关系。</p>
<p>非平凡的多值依赖：全集U=K+A+B，字段K中的某个值可以对应于字段A中的多个值，同时也可以对应于字段B中的多个值，字段A与字段B互相独立，即K→→A，K→→B。整个表存在多组一对多关系，且有：“一”部分是相同的属性集合，“多”部分是互相独立的属性集合。</p>
<p>反例：</p>
<p>建立课程、教师、教材的模型，每门课程有对应的一组教师，每门课程也有对应的一组教材，一门课程使用的教材和教师没有关系：</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503214059944.png" alt="image-20220503214059944" style="zoom:67%;"></p>
<p>课程ID，教师ID，教材ID这三列作为联合主键，没有非主属性，因此满足BCNF。</p>
<p>问题：</p>
<p>可以看出存在多值依赖，因为同一个课程对应于多个教师，同时对应多个教材。</p>
<p>存在插入异常，当添加新的英版高数教材，但是还没确定具体哪个老师来教，就无法在这个表中维护Course高数和Book英版高数教材的的关系。</p>
<p>正例：</p>
<p>把多个一对多的关系拆分。</p>
<p>课程教师表：</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503214437672.png" alt="image-20220503214437672" style="zoom:67%;"></p>
<p>课程教材表：</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503214459263.png" alt="image-20220503214459263" style="zoom:67%;"></p>
<h4 id="反范式化">反范式化</h4>
<p>反范式化就是在数据表中增加冗余字段来提升数据库的读性能。</p>
<p>反范式化的问题</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503203330428.png" alt="image-20220503203330428" style="zoom:67%;"></p>
<p>反范式化的适用场景</p>
<p>当冗余信息有价值或者能大幅度提高查询效率的时候，才会采取反范式的优化。冗余字段不需要经常性地被修改，以及冗余字段在查询的时候不可或缺。</p>
<p>在现实生活中，经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于<strong>历史快照</strong>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p>
<p>反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储<strong>历史数据，对增删改的实时性要求不强，对历史数据的分析需求强</strong>。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<h4 id="范式的优缺点">范式的优缺点</h4>
<p>优点：</p>
<p>1、降低数据冗余度，节省磁盘存储空间</p>
<p>2、防止一些插入、删除、更新异常操作。</p>
<p>缺点：</p>
<p>应用的范式等级越高，则表越多。表多会带来很多问题：</p>
<p>1、查询时要连接多个表，增加了查询的复杂度。</p>
<p>2、查询时需要连接多个表，降低了数据库查询性能。</p>
<p>而现在的情况，磁盘空间成本基本可以忽略不计，所以数据冗余所造成的问题也并不是应用数据库范式的理由。因此，并不是应用的范式越高越好，要看实际情况而定。第三范式已经很大程度上减少了数据冗余，并且减少了造成插入异常，更新异常，和删除异常了。所以大多数情况应用到第三范式已经足够，在一定情况下第二范式也是可以的。</p>
<h3 id="案例">案例</h3>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503222057892.png" alt="image-20220503222057892" style="zoom:67%;"></p>
<p>按照一范式（字段不可再分）进行改进：</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503222208460.png" alt="image-20220503222208460" style="zoom:67%;"></p>
<p>按照二范式（非主键字段全部依赖于主键）进行改进：</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503222334191.png" alt="image-20220503222334191" style="zoom:67%;"></p>
<p>将其拆分成三个表：</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503222510212.png" alt="image-20220503222510212" style="zoom:67%;"></p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503222811550.png" alt="image-20220503222811550" style="zoom:67%;"></p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503222750888.png" alt="image-20220503222750888" style="zoom:67%;"></p>
<p>按照三范式（非主键字段之间无依赖关系）进行改进：</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503223138589.png" alt="image-20220503223138589" style="zoom:67%;"></p>
<p>将其拆分为两张表：</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503222946435.png" alt="image-20220503222946435" style="zoom:67%;"></p>
<p>按照反范式化（允许冗余字段）进行改进：</p>
<p><img src="/2021/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93_%E9%94%AE%E4%B8%8E%E8%8C%83%E5%BC%8F/image-20220503223245621.png" alt="image-20220503223245621" style="zoom:67%;"></p>
<p>数量、单价、总价之间可以相互计算得出结果，存在非主键字段之间的依赖关系，但是为了数值精确和查询方便（不需要计算），因此保留这样的冗余字段。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://www.jianshu.com/p/a78faaf59e49</p>
<p>https://blog.csdn.net/xuxurui007/article/details/7738330</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 字符串</title>
    <url>/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>LeetCode中与字符串有关的题目。</p>
<a id="more"></a>
<h3 id="无重复字符的最长子串">3 无重复字符的最长子串</h3>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: s = "abcabcbb" 输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</p>
<p><strong>题解</strong></p>
<p>采用双指针方法，并用HashMap记录每个字符所在位置，当后指针碰到重复字符，前指针则移动到HashMap记录所在位置+1，则跳过这个重复字符。</p>
<p>并且注意到每次都要更新最长子串长度（防止循环结束时不更新），每次都要更新字符所在位置。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%AD%97%E7%AC%A6%E4%B8%B2/0.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明双指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; n; right++)&#123;</span><br><span class="line">			<span class="comment">//存储当前字符</span></span><br><span class="line">            <span class="keyword">char</span> tmp = s.charAt(right);</span><br><span class="line">            <span class="comment">//发现重复</span></span><br><span class="line">            <span class="keyword">if</span>(hm.containsKey(tmp))&#123;</span><br><span class="line">                left = Math.max(left, hm.get(tmp)+<span class="number">1</span>); <span class="comment">//更新左指针的位置为最靠近右边的</span></span><br><span class="line">            &#125;</span><br><span class="line">            hm.put(tmp,right);<span class="comment">//更新字符的位置</span></span><br><span class="line">            res = Math.max(res, right - left +<span class="number">1</span>);<span class="comment">//更新最长子串长度</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>无重复字符的最长子串：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-jie-suan-fa-3-wu-zhong-fu-zi-fu-de-zui-chang-z/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 数组</title>
    <url>/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>LeetCode中与数组有关的题目。</p>
<a id="more"></a>
<h3 id="缺失的第一个正数">41 缺失的第一个正数</h3>
<p><strong>题目描述</strong></p>
<p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的<strong>正整数</strong>。</p>
<p>进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,0] 输出：3</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(1)：不使用额外空间</p>
<p>原地哈希法，<strong>最小的正数是从1开始的</strong>，因此遍历数组，把每个元素存放到对应的位置，直到当前位置的数是非正数或大于数组长度的就继续处理下一个，比如1存放到数组的第一个位置（下标为0），3存放到数组的第3个位置（下标为2），如果是非正数或者大于数组的长度的值，不做处理。</p>
<p>注意，如果 nums[i] == nums[ nums[i] - 1 ]，即nums[i] 应该放在的位置上有值了，<strong>表示存在重复值</strong>，也是不做处理的，这个重复值会占据一个本来属于其他正数的位置。</p>
<p>最后再遍历一遍数组，如果nums[i] == i+1不成立，说明这个位置没有这个数，我们就直接i+1即可。图解流程见题解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( i &lt; max)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//只有[1,max]之间的数，才需要放到对应的位置numbers-1，0也不需要因为它不是正整数不是题目需要处理的范围</span></span><br><span class="line">            <span class="comment">// nums[i] == i+1 表示当前遍历到的值已经放在对应的位置</span></span><br><span class="line">            <span class="comment">// nums[i] == nums[ nums[i] - 1 ] 表示当前遍历到的值，它应该交换到的位置上已经满足条件,即存在重复值，此时继续交换则会导致无限循环下去，因此也是直接跳过</span></span><br><span class="line">            <span class="comment">//nums[i] 应该放在下标为 nums[i] - 1的位置，此时才能保证nums[i] == i+1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">1</span> || nums[i] &gt; max || nums[i] == i+<span class="number">1</span> || nums[i] == nums[ nums[i] - <span class="number">1</span> ])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            swap(nums, i, nums[i]-<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//再次遍历数组</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; max)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( nums[i] != i+<span class="number">1</span> )</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果上面都没有return，说明数字都在对应的位置上面，即[1，max]都已经归位，因此返回长度+1</span></span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="颜色分类荷兰国旗法正数负数零移动">75 颜色分类（荷兰国旗法，正数负数零移动）</h3>
<p>题目描述</p>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>示例 1：</p>
<p>输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2]</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(1)：不使用额外空间</p>
<p>第一种最简单的方法，使用单指针，设置一个全局指针，每次遇到0就和全局指针交换并递增全局指针，先排好0；然后从全局指针的位置开始出发，每次遇到1就和全局指针交换，就排好1，剩下2自动排好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//设置全局指针</span></span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换0</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, ptr, i);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换1</span></span><br><span class="line">        <span class="comment">//注意这里是从ptr开始的，而不是ptr+1开始的，因为要使得ptr++</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ptr; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                swap(nums, ptr, i);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有第二种使用三指针的方法，见题解。</p>
<h3 id="盛最多水的容器">11 盛最多水的容器</h3>
<p>题目描述</p>
<p>输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(1)：不使用额外空间</p>
<p>双指针从两边向中间移动，每次移动短板，因为短板决定了最多能盛水多少。每次移动短板，则水有可能增多、不变、减少；移动长板，则水不可能增多，只能不变或减少，因为短板才是决定因素。</p>
<p>因此，移动短板不会导致丢失面积最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line"></span><br><span class="line">            res = Math.max(res, (j-i)*Math.min(height[i],height[j]) );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])  i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>缺失的第一个正数：https://leetcode-cn.com/problems/first-missing-positive</p>
<p>https://leetcode-cn.com/problems/first-missing-positive/solution/javade-6chong-jie-fa-de-tu-wen-xiang-jie-wei-yun-s/</p>
<p>颜色分类：https://leetcode-cn.com/problems/sort-colors/solution/xue-sheng-wu-de-nu-peng-you-du-neng-kan-71kjg/</p>
<p>盛水最多的容器：https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 树</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E6%A0%91/</url>
    <content><![CDATA[<p>LeetCode中与树有关的题目。</p>
<a id="more"></a>
<h3 id="二叉树展开为链表">114 二叉树展开为链表</h3>
<p><strong>题目描述</strong></p>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><strong>题解</strong>：</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将左右子树展开</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        TreeNode tmp_right = root.right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将展开的左子树链表接到右子树链表的后面</span></span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            root = root.right;</span><br><span class="line">        root.right = tmp_right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中的最大路径和">124 二叉树中的最大路径和</h3>
<p><strong>题目描述</strong></p>
<p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E6%A0%91/0.png" style="zoom:67%;"></p>
<p>输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</p>
<p><strong>题解：</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>后续遍历得到左右子树的最大路径和，再和当前值进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE; <span class="comment">//记录全局最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后序遍历，返回左右子树的最大和，负数的就不要</span></span><br><span class="line">        <span class="keyword">int</span> max_left = Math.max(<span class="number">0</span>, dfs(root.left));</span><br><span class="line">        <span class="keyword">int</span> max_right = Math.max(<span class="number">0</span>, dfs(root.right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//和全局最大值判断</span></span><br><span class="line">        max = Math.max(max, (root.val + max_left + max_right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只能返回一条路径的最大值</span></span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(max_left, max_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证二叉搜索树">98 验证二叉搜索树</h3>
<p><strong>题目描述</strong></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>二叉搜索树的特点就是中序遍历是有序的，因此肯定是中序遍历，然后只要验证前一个节点是否小于等于当前节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历判断是否大于前一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int pre = Integer.MIN_VALUE; 不可以定义这个值！！有这个用例</span></span><br><span class="line">    TreeNode pre; <span class="comment">//前一个结点，全局的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) <span class="comment">//遍历左子树，为true表明左子树满足二叉搜索树条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val) <span class="comment">//当前节点是否大于前继节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pre = root; <span class="comment">//将前继节点记录为当前节点</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.right)) <span class="comment">//遍历右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//都满足条件，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的完全性检验">958 二叉树的完全性检验</h3>
<p>题目描述</p>
<p>验证一棵二叉树是否是完全二叉树</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>层序遍历，把一颗树的节点（包括空节点）按层序遍历排成一行，当且仅当存在两个相邻节点：前一个为null，后一个不为null时，才不是完全二叉树。</p>
<blockquote>
<pre><code>   1
  / \
 2   3
/ \   \</code></pre>
<p>4 5 6 层序遍历序列为：[1, 2, 3, 4, 5, null, 6]，其中 null 出现在了6前面，所以不合法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录前驱节点</span></span><br><span class="line">        TreeNode prev = root;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span> &amp;&amp; node != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/solution/hen-jian-dan-de-si-lu-dai-ma-hen-jian-ji-by-yuanyb/ （二叉树的完全性检验）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 动态规划</title>
    <url>/2021/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%8A%A8%E8%A7%84/</url>
    <content><![CDATA[<p>剑指Offer中关于动态规划的题目解析。</p>
<a id="more"></a>
<h3 id="跳台阶">01 跳台阶</h3>
<p><strong>题目描述</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历一次n</p>
<p>空间复杂度O(1)：只需要保存前两个值</p>
<p>动态规划的思想是，令dp[i]表示当前青蛙在第i个台阶，那么它可以由dp[i-1]级台阶跳1级，也可以由dp[i-2]级台阶跳2级，因此可得到递推式为dp[i] = dp[i-1] + dp[i-2]。最便捷的方法为可以发现dp[i]只和dp的前两个值有关，因此只需要保存前两个值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">2</span>;<span class="comment">//dp[i-1]</span></span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">1</span>;<span class="comment">//dp[i-2]</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            res = one + two;</span><br><span class="line">            two = one;</span><br><span class="line">            one = res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变态跳台阶">02 变态跳台阶</h3>
<p>题目描述</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历一次n</p>
<p>空间复杂度O(1)：只需要保存前一个值</p>
<p>dp[i]表示当前青蛙在第i个台阶，则它可以由dp[i-1]级台阶跳1级，也可以由dp[i-2]级台阶跳2级，由dp[i-3]级台阶跳3级等等。</p>
<p>则dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + ... dp[1] + dp[0]。</p>
<p>同理可得dp[i-1] = dp[i-2] + dp[i-3] + ... dp[1] + dp[0]。</p>
<p>dp[i] - dp[i-1] = dp[i-1]，则dp[i] = 2dp[i-1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++)&#123;</span><br><span class="line">             res = res*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩形覆盖">03 矩形覆盖</h3>
<p><strong>题目描述</strong></p>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>比如n=3时，2*3的矩形块有3种覆盖方法 。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历一次n</p>
<p>空间复杂度O(1)：只需要保存前两个值</p>
<p>假设dp[i]表示用i个小矩形覆盖一个2*i的大矩形的方法，则dp[i]可以由dp[i-1]加上一个竖的矩形，也可以由dp[i-2]加上两个横的矩形，因此递推式可以归纳为：dp[i] = dp[i-1] + dp[i-2]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">2</span>;<span class="comment">//dp[i-1]</span></span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">1</span>;<span class="comment">//dp[i-2]</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            res = one + two;</span><br><span class="line">            two = one;</span><br><span class="line">            one = res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵中的路径">04 矩阵中的路径</h3>
<p><strong>题目描述</strong></p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p>
<p>例如 <span class="math inline">\(\begin{bmatrix} a &amp; b &amp; c &amp;e \\ s &amp; f &amp; c &amp; s \\ a &amp; d &amp; e&amp; e\\ \end{bmatrix}\)</span> 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;ABCESFCSADEE&quot;,3,4,&quot;ABCCED&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n3^k\)</span>)：矩阵每个位置进行一次递归，每次递归时，对于字符串<span class="math inline">\(k\)</span>的每个字符来说，除了到达这个字符的方向之外，还有三个方向可以走，因此递归的复杂度为<span class="math inline">\(3^k\)</span>。</p>
<p>空间复杂度O(<span class="math inline">\(k\)</span>)：递归深度为字符串长度</p>
<p>显然，这道题可以在矩阵中每个元素上进行递归，递归就是朝着四个方向走，并判断是否能够匹配所有字符。</p>
<p>问题1：<strong>如何表示当前所在元素</strong>？</p>
<p>牛客网中，矩阵的表示方式是一维数组，给出矩阵的row和col数。</p>
<p>那么，用x表示row，y表示col，则取值范围是<span class="math inline">\(0\leq x \leq row-1\)</span>，<span class="math inline">\(0\leq y \leq col-1\)</span>。</p>
<p>如何从x、y转为一维数组的坐标？index = x*col +y。（x*col表示经过了多少个行，一行的元素个数刚好等于列的数量）</p>
<p>问题2：<strong>如何朝着四个方向走</strong>？</p>
<p>x-1，y+0向下</p>
<p>x+0，y+1向右</p>
<p>x+1，y+0向上</p>
<p>x+0，y-1向左</p>
<p>数组{-1, 0, 1, 0, -1}，x = index，y = index + 1 刚好可以表示这四个方向。</p>
<p>问题3：<strong>递归中的退出条件？</strong></p>
<p>首先，假如当前坐标（x，y）超出范围，则立即退出。</p>
<p>判断（x，y）所代表的元素是否已经走过，走过则退出。</p>
<p>然后，判断（x，y）所代表的元素和字符串位置是否相等，不等则退出。</p>
<p>判断字符串是否匹配完成，完成则直接返回true，不需要再向下递归。</p>
<p>若没有退出，则将当前位置标记为走过，并朝着四个方向递归，某个方向上返回存在，即立刻返回存在。</p>
<p>四个方向都回退到这里时，将当前位置标记为没走过，且字符串位置回退，返回不存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>[] gmatrix = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">char</span>[] gstr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> grows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gcols = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dir = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//给全局变量赋值</span></span><br><span class="line">    	gmatrix = matrix;</span><br><span class="line">        gstr = str;</span><br><span class="line">        grows = rows;</span><br><span class="line">        gcols = cols;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每个位置上都进行递归判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; rows; x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; cols; y++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Recur(x, y, cur))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Recur</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断越界</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grows || y &lt; <span class="number">0</span> || y &gt;= gcols )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//走过，或是字符不等</span></span><br><span class="line">        <span class="keyword">if</span>(gmatrix[x*gcols+y] == <span class="string">&#x27;#&#x27;</span> || gmatrix[x*gcols+y] != gstr[cur])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否匹配到了字符串底部</span></span><br><span class="line">        <span class="keyword">if</span>(cur == gstr.length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录已经走过</span></span><br><span class="line">        <span class="keyword">char</span> ch = gmatrix[x*gcols+y];</span><br><span class="line">        gmatrix[x*gcols+y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//朝着四个方向递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Recur(x+dir[i], y+dir[i+<span class="number">1</span>], cur+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//到这里说明没有匹配的，将字符恢复原状</span></span><br><span class="line">        gmatrix[x*gcols+y] = ch;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法</title>
    <url>/2021/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<p>回溯算法，建立在深度优先搜索之上。DFS 是一直往某一个方向搜索直到最终结果就结束，而回溯算法是在搜索过程中，达到结束条件后，恢复被改变的状态，回溯上一层，再次搜索，因此回溯算法与 DFS 的区别就是<strong>有无状态重置</strong>。</p>
<a id="more"></a>
<h3 id="回溯">回溯</h3>
<h4 id="问题类型">问题类型</h4>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>题目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>子集、组合</td>
<td>子集、子集 II、组合、组合总和、组合总和 II</td>
</tr>
<tr class="even">
<td>全排列</td>
<td>全排列、全排列 II、字符串的全排列、字母大小写全排列</td>
</tr>
<tr class="odd">
<td>搜索</td>
<td>解数独、单词搜索、N皇后、分割回文串、二进制手表</td>
</tr>
</tbody>
</table>
<h3 id="子集组合">子集/组合</h3>
<p>子集、组合与排列是不同性质的概念。子集、组合是无关顺序的，如 [1，2] 和 [2，1] 是同一个组合(子集)；而排列是和元素顺序有关的， [1,2] 和 [2,1] 是两种不一样的排列，因此被分为两类问题。</p>
<h4 id="子集">子集</h4>
<p><strong>题目描述</strong></p>
<p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）</p>
<p>解集不能包含重复的子集。你可以按任意顺序返回解集。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]</p>
<p>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>
</blockquote>
<p><strong>题解</strong></p>
<p>时间复杂度 <span class="math inline">\(O(n*2^n)\)</span>：回溯法复杂度，对于每个位置有选和不选两种方式，因此复杂度为<span class="math inline">\(O(2^n)\)</span>；对于每个位置要递归下去，探讨选和不选，因此每个位置遍历的复杂度为<span class="math inline">\(O(n)\)</span>，因此总的复杂度为<span class="math inline">\(O(n*2^n)\)</span>。</p>
<p>空间复杂度 <span class="math inline">\(O(n)\)</span>：临时寄存结果List&lt;Integer&gt; tmp的空间占用为<span class="math inline">\(O(n)\)</span>，递归的复杂度为<span class="math inline">\(O(n)\)</span>。</p>
<p>子集，就是求组合，可以发现对于每个位置，就有选和不选两种方式，<strong>代码实现上就是先选，然后再撤销原来的选择，对于每个位置都通过循环的方式实现</strong>。</p>
<p><img src="/2021/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%9E%E6%BA%AF%E6%B3%95/0.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//暂存结果的List</span></span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, <span class="number">0</span>, tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;Integer&gt; tmp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为结果中包括了空的情况，所以直接加入</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(tmp));</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//进行回溯算法，关键是通过循环实现</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="comment">//对于当前位置，选</span></span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">                <span class="comment">//往下递归，注意是i+1不是index+1！</span></span><br><span class="line">                dfs(nums, i+<span class="number">1</span>, tmp);</span><br><span class="line">                <span class="comment">//撤销选择，把不选的情况交给循环</span></span><br><span class="line">                tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子集-ii剪枝">子集 II（剪枝）</h4>
<p><strong>题目描述</strong></p>
<p>给定一个可能<strong>包含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：nums = [1,2,2]</p>
<p>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</p>
</blockquote>
<p><strong>题解</strong></p>
<p>时间复杂度 <span class="math inline">\(O(n*2^n)\)</span>：有重复元素的数组需要排序，复杂度为<span class="math inline">\(O(nlogn)\)</span>；回溯法复杂度，对于每个位置有选和不选两种方式，因此复杂度为<span class="math inline">\(O(2^n)\)</span>；对于每个位置要递归下去，探讨选和不选，因此每个位置遍历的复杂度为<span class="math inline">\(O(n)\)</span>，因此总的复杂度为<span class="math inline">\(O(n*2^n)\)</span>。</p>
<p>空间复杂度 <span class="math inline">\(O(n)\)</span>：临时寄存结果List&lt;Integer&gt; tmp的空间占用为<span class="math inline">\(O(n)\)</span>，递归的复杂度为<span class="math inline">\(O(n)\)</span>。</p>
<p>有重复元素，意味着组合之中存在着重复计算的过程，需要进行<strong>剪枝</strong>，比如对于两个2来说，单独选择它们的时候是重复的，因此不需要进行计算，递归的时候如果紧挨的两个元素是相同的，就需要跳过他们不需要往下递归，即把它们所在的分支剪掉。</p>
<p><img src="/2021/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%9E%E6%BA%AF%E6%B3%95/1.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//注意！这里必须让数组是有序的</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums, <span class="number">0</span>, tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;Integer&gt; tmp)</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//因为结果中包括了空的情况，所以直接加入</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(tmp));</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//进行回溯算法，关键是通过循环实现</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果当前位置和上一轮位置上数值是一样的，就不需要考虑它的情况</span></span><br><span class="line">                <span class="comment">//注意 i = index的情况它不会continue，这保证了 1,2,2 是可以出现的</span></span><br><span class="line">                <span class="comment">//即nums[1] = 2 和 nums[2] = 2时，nums[2]便不再考虑</span></span><br><span class="line">                <span class="comment">//但是1,2,2是在nums[1]处进入递归，然后index+1后处于nums[2]，此时nums[2]就不会被continue，就可以加入</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;index &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//对于当前位置，选</span></span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">                <span class="comment">//往下递归，注意是i+1不是index+1！             </span></span><br><span class="line">                dfs(nums, i+<span class="number">1</span>, tmp);</span><br><span class="line">                <span class="comment">//撤销选择，把不选的情况交给循环</span></span><br><span class="line">                tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂与快速乘法</title>
    <url>/2021/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E5%BF%AB%E9%80%9F%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>快速幂</td>
<td>就是将<span class="math inline">\(a^b\)</span>拆解为<span class="math inline">\(a^b=a^{b_01}*a^{b_12}*a^{b_24}*a^{b_38}*...*a^{b_n2^n}\)</span>。<br>即每一次不断地将a平方，并用b的二进制位判断这个平方数是否被乘进结果中。</td>
</tr>
<tr class="even">
<td>快速乘法</td>
<td>就是将<span class="math inline">\(a*b\)</span>拆解为<span class="math inline">\(a*b=a*b_0*1+a*b_1*2+a*b_2*4+a*b_3*8...+a*b_n*2^n\)</span>。<br>即每一次不断地将a乘上2的平方数，并用b的二进制位判断这个乘积是否被加进结果中。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="快速幂">快速幂</h3>
<p>假设要求 <span class="math inline">\(a^{b}\)</span>，按照朴素算法就是把 a 连乘 b 次，这样一来时间复杂度是 O(b) ，即是 O(n) 级别。</p>
<p>但快速幂能做到 <strong>O(logn)</strong> 的复杂度。</p>
<p>具体来说，就是把b转换成二进制表示，假设b的二进制表示有x位，乘法的次数就转换成最多2x次（二进制位为0时，结果不需要乘）。</p>
<p><strong>举例</strong></p>
<p>以<span class="math inline">\(a^{11}\)</span>为例。</p>
<p>常规的乘法次数，需要将a连续乘11次。</p>
<p>11的二进制为1011，即<span class="math inline">\(11=1*2^0+1*2^1+0*2^2+1*2^3\)</span>。</p>
<p><span class="math inline">\(a^{11} = a^{2^0+2^1+2^3}=a^{2^0}*a^{2^1}*a^{2^3}=a^1*a^2*a^8\)</span>。</p>
<p>令<span class="math inline">\(base=a\)</span>。</p>
<p><span class="math inline">\(base=base*base=a^2\)</span>。</p>
<p><span class="math inline">\(base=base*base=a^2*a^2=a^4\)</span>。注意，这里<span class="math inline">\(a^2\)</span>已经算过了。</p>
<p><span class="math inline">\(base=base*base=a^4*a^4=a^8\)</span>。注意，这里<span class="math inline">\(a^4\)</span>已经算过了。</p>
<p>所以，通过快速幂的方式，将乘法次数转换为3次（计算<span class="math inline">\(a^2、a^4、a^8\)</span>）+2次（计算结果<span class="math inline">\(a^1*a^2*a^8\)</span>）一共5次计算，而非原来的11次计算。</p>
<p>本质上，就是将<span class="math inline">\(a^b\)</span>拆解为<span class="math inline">\(a^b=a^{b_01}*a^{b_12}*a^{b_24}*a^{b_38}*...*a^{b_n2^n}\)</span>，即每一次不断地将a平方，并用b的二进制位判断这个平方数是否被乘进结果中。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ksm</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> base = a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">//当b的二进制位还有数字</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span>(b &amp; <span class="number">1</span> != <span class="number">0</span>) <span class="comment">//如果b的二进制，最末尾为1，则需要把a的2次幂结果乘到最终结果中</span></span><br><span class="line">          res *= base;</span><br><span class="line">      </span><br><span class="line">	  base *= base;<span class="comment">//不断地对a进行平方操作</span></span><br><span class="line">	  b &gt;&gt;= <span class="number">1</span>; <span class="comment">//删除b二进制下最末尾的数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解 <embed src="https://private.codecogs.com/gif.latex?base%5C%2C*%3D%5C%2Cbase"> 这一步：因为 <embed src="https://private.codecogs.com/gif.latex?base%5C%2C*%5C%2Cbase"> == <embed src="https://private.codecogs.com/gif.latex?base%5E%7B2%7D"> ，下一步再乘，就是 (<embed src="https://private.codecogs.com/gif.latex?base%5E%7B2%7D">) * (<embed src="https://private.codecogs.com/gif.latex?base%5E%7B2%7D">) == <embed src="https://private.codecogs.com/gif.latex?base%5E%7B4%7D"> ，然后同理 (<embed src="https://private.codecogs.com/gif.latex?base%5E%7B4%7D">) * (<embed src="https://private.codecogs.com/gif.latex?base%5E%7B4%7D">) == <embed src="https://private.codecogs.com/gif.latex?base%5E%7B8%7D"> ，由此可以做到 <embed src="https://private.codecogs.com/gif.latex?base">→ <embed src="https://private.codecogs.com/gif.latex?base%5E%7B2%7D"> → <embed src="https://private.codecogs.com/gif.latex?base%5E%7B4%7D"> → <embed src="https://private.codecogs.com/gif.latex?base%5E%7B8%7D"> → <embed src="https://private.codecogs.com/gif.latex?base%5E%7B16%7D"> → <embed src="https://private.codecogs.com/gif.latex?base%5E%7B32%7D">.......指数正好是 <embed src="https://private.codecogs.com/gif.latex?2%5E%7Bi%7D"> 。</p>
</blockquote>
<h3 id="快速乘法">快速乘法</h3>
<p>在计算机中做加法运算会比乘法快得多（参考模电中的加法器），做乘法运算往往会溢出，即使用 long long 类型也拯救不了。因此需要寻找一种能高效完成乘法运算且不会溢出的算法，这就是快速乘算法。</p>
<p>快速乘法的本质就是用加法和位运算来代替乘法。</p>
<p>假设要求<span class="math inline">\(a*b\)</span>，就是把b转换成二进制表示，假设b的二进制表示有x位，加法的次数就转换成最多2x次（二进制位为0时，结果不需要加）。</p>
<p><strong>举例</strong></p>
<p>以<span class="math inline">\(a*11\)</span>为例。</p>
<p>11的二进制为1011，即<span class="math inline">\(11=1*2^0+1*2^1+0*2^2+1*2^3\)</span>。</p>
<p><span class="math inline">\(a*11 = a*1*2^0+a*1*2^1+a*0*2^2+a*1*2^3 = a*1+a*2+a*8\)</span>。</p>
<p>令<span class="math inline">\(base=a\)</span>。</p>
<p><span class="math inline">\(base=base+base=a*2\)</span>。</p>
<p><span class="math inline">\(base=base+base=a*2+a*2=a*4\)</span>。注意，这里<span class="math inline">\(a*2\)</span>已经算过了。</p>
<p><span class="math inline">\(base=base+base=a*4+a*4=a*8\)</span>。注意，这里<span class="math inline">\(a*4\)</span>已经算过了。</p>
<p>本质上，就是将<span class="math inline">\(a*b\)</span>拆解为<span class="math inline">\(a*b=a*b_0*1+a*b_1*2+a*b_2*4+a*b_3*8...+a*b_n*2^n\)</span>，即每一次不断地将a乘上2的平方数，并用b的二进制位判断这个乘积是否被加进结果中。</p>
<p><strong>代码</strong></p>
<p>就是快速幂的代码，将乘法换成加法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ksc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> base = a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">//当b的二进制位还有数字</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span>(b &amp; <span class="number">1</span> != <span class="number">0</span>)  <span class="comment">//如果b的二进制，最末尾为1，则需要把a乘上2的平方数的结果加到最终结果中</span></span><br><span class="line">          res += base;</span><br><span class="line">      </span><br><span class="line">	  base += base;<span class="comment">//不断地对a乘上2的平方数</span></span><br><span class="line">	  b &gt;&gt;= <span class="number">1</span>; <span class="comment">//删除b二进制下最末尾的数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/liangllhahaha/article/details/82119378?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树结构</title>
    <url>/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/</url>
    <content><![CDATA[<p>B树、B+树、红黑树、满二叉树、完全二叉树</p>
<a id="more"></a>
<h3 id="b树">B树</h3>
<p>B树即平衡多路查找树。是一种自平衡的数据结构，能对存储的数据进行<span class="math inline">\(O(log n)\)</span>的时间复杂度进行查找、插入和删除。平衡的方式是插入和删除数据会对节点进行分裂和合并。每个节点内存储的就是真实的数据，数据是有序的。B树的特点（优点）是：</p>
<p>1、有<strong>自平衡</strong>的操作，能够解决树结构退化成链表的问题，降低树的深度，提高查询性能。</p>
<p>2、一个节点内部<strong>存储了多个数据</strong>，且数据有序，能够提高磁盘IO的性能。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/2.png" style="zoom: 80%;"></p>
<h4 id="b树的性质">B树的性质</h4>
<p>B树的阶数表示了一个节点最多有多少个孩子节点，用字母m表示阶数。 1、每个节点最多有m-1个值（可以存有的键值对）。 2、根节点最少可以只有1个值，非根节点至少有ceil(m/2)个值。 3、每个节点中的值都按照从小到大的顺序排列，每个值的左子树中的所有值都小于它，而右子树中的所有值都大于它。 4、所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 5、每个节点都存有索引和数据，也就是对应的key和value。</p>
<blockquote>
<p>2-3-4 树，就是阶为4的B树，其中节点和存储的元素符合如下性质要求： 任一节点只能是 2 度节点、3 度节点或 4 度节点，不存在元素数为 0 的节点。 2 度节点：如果节点只包含 1 个元素，那它将只能有 2 个子节点； 3 度节点：如果节点只包含 2 个元素，那它将只能有 3 个子节点； 4 度节点：如果节点只包含 3 个元素，那它将只能有 4 个子节点；</p>
</blockquote>
<h4 id="b树插入">B树插入</h4>
<p>判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，以节点的中间的key为标准，将这个节点分为左右两部分，中间的值放到父节点中即可。</p>
<h4 id="b树删除">B树删除</h4>
<p>1）如果当前需要删除的key位于非叶子结点上，则用后继key覆盖要删除的key（后继key指的是大于该数值的下一个值，比如27的后继就是28，28在叶子节点上）。然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上。删除这个记录后执行第2步</p>
<p>2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。</p>
<p>3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。</p>
<p>​ 否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了 一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。</p>
<h3 id="b树-1">B+树</h3>
<p>B+树是B树的改进，也是一种多路平衡查找树，内部的数据稳定有序，每个节点通常有多个孩子，所有叶子节点通过链表连接在一起。时间复杂度与树的高度有关，能对存储的数据以<span class="math inline">\(O(log n)\)</span>的时间复杂度进行查找、插入和删除。非叶子节点处存储的是索引，叶子节点处才存储真正的数据。B+树的特点（优点）是：</p>
<p>1、B+树的磁盘读写代价更低</p>
<p>B+的非叶子结点并没有存储真正的数据，而<strong>存储的是索引</strong>，因此其非叶子结点相对B树更小，能够容纳的索引数量越多，一次性读入内存中能够查找的数据也就越多，相对来说IO读写次数也就降低了。</p>
<p>2、B+树的数据信息遍历更加方便（基于范围的查询）</p>
<p>B+树只要通过<strong>叶子节点上的链表</strong>，就可以遍历所有叶子节点，从而实现整棵树的遍历，而B树不支持这样的操作（或者说效率太低），而且在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+树。</p>
<p>3、B+树的查询效率更加稳定</p>
<p>B+树中非叶子节点仅存储索引，B树中非叶子节点既存储索引，也存储指向真实数据的指针。所以B+树种任何查询必须走一条从根结点到叶子结点。所有查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/3.png" style="zoom: 50%;"></p>
<h4 id="b树的性质-1">B+树的性质</h4>
<p>B+数的高度h，假设当前数据表的数据为N，每个磁盘页可存放的数据项的数量是m，则树的高度约为<span class="math inline">\(log_{m+1} N\)</span>。</p>
<h3 id="红黑树">红黑树</h3>
<p>是二叉搜索树的一种，他并不是完美平衡的，而是黑色节点完美平衡的，也就是每个节点到叶子节点上都有数量相同的黑色节点。它可以在<span class="math inline">\(O(logn)\)</span>时间内做查找，插入和删除，这里的n是树中元素的数目。红黑树的特点（优点）是：</p>
<p>1、 红黑树的约束条件确保没有一条路径会比其他路径长2倍，使得红黑树大致上是一种平衡的树型结构。</p>
<p>2、相比于AVL树来说，红黑树的因为只需要保证黑色节点平衡，因此维护的代价比AVL树要低。</p>
<blockquote>
<p>为什么有AVL树还要红黑树？ 因为AVL树要求子树的高度差都小于等于1，太过严格的要求导致每次插入或删除几乎都要调整树的结构，大量操作时维护代价太高。</p>
</blockquote>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/4.png" style="zoom:67%;"></p>
<h4 id="红黑树的性质">红黑树的性质</h4>
<p>1、每个节点或者是黑色，或者是红色。 2、根节点是黑色。 3、每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！] 4、如果一个节点是红色的，则它的子节点必须是黑色的。 5、从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<h4 id="红黑树的插入">红黑树的插入</h4>
<p>自平衡的方法为变色、左旋、以及右旋。</p>
<p>插入节点必为红色，首先找到它在叶子节点的位置，若父为黑直接插入，若父为红则需要调整： if 叔叔存在且为红 红黑红，叔叔黑（变色） if 叔叔不存在或为黑： if 父为左孩子： if 子为左孩子： LL双红，变色红黑红，右旋 if 子为右孩子： LR双红，左旋变LL双红，变色红黑红，右旋 if 父为右孩子： 。。。镜像操作</p>
<h3 id="满二叉树">满二叉树</h3>
<p>满二叉树，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/5.png" style="zoom:50%;"></p>
<h4 id="满二叉树性质">满二叉树性质</h4>
<p>1、一个层数为k 的满二叉树总结点数为：<span class="math inline">\(2^k-1\)</span>，k从1开始，因此满二叉树节点数总是为奇数。</p>
<p>2、第i层上的节点数为：<span class="math inline">\(2^{i-1}\)</span>，i从1开始。</p>
<h3 id="完全二叉树">完全二叉树</h3>
<p>在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/6.png" style="zoom: 43%;"></p>
<h4 id="完全二叉树性质">完全二叉树性质</h4>
<p>具有n个节点的完全二叉树的深度为<span class="math inline">\(log_2n+1\)</span>。深度为k的完全二叉树，k从1开始，总的节点数至少有<span class="math inline">\(2^{k-1}\)</span>个，至多有<span class="math inline">\(2^k-1\)</span>个。</p>
<h3 id="avl树">AVL树</h3>
<p>平衡二叉树树，任意节点的子树的高度差都小于等于1，通过旋转操作来保证平衡性。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://www.cnblogs.com/nullzx/p/8729425.html （B树操作）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树算法</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>非递归遍历 https://www.jianshu.com/p/8efe8f281f22</p>
<p>二叉树递归非递归遍历、二叉树高度</p>
<a id="more"></a>
<h3 id="二叉树遍历">二叉树遍历</h3>
<h4 id="前序遍历">前序遍历</h4>
<p>前序遍历按照“根结点-左孩子-右孩子”的顺序进行访问。</p>
<h5 id="递归实现">递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">     	System.out.println(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归实现">非递归实现</h5>
<p>根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。</p>
<p>对于任一结点P：</p>
<p>1、访问结点P，并将结点P入栈;</p>
<p>2、判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1；若不为空，则将P的左孩子置为当前的结点P;</p>
<p>3、直到P为NULL并且栈为空，则遍历结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">		ArrayList&lt;TreeNode&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		TreeNode p = root;</span><br><span class="line">    	<span class="comment">//当栈内还存在元素</span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">			<span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">				alist.add(p.val);<span class="comment">//先访问根节点</span></span><br><span class="line">				stack.push(p);<span class="comment">//先访问根节点</span></span><br><span class="line">				p = p.left;<span class="comment">//再访问左子树</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line">				TreeNode temp = stack.pop();</span><br><span class="line">				p = temp.right;<span class="comment">//访问右子树</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> alist;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历">中序遍历</h4>
<p>中序遍历按照“左孩子-根结点-右孩子”的顺序进行访问。</p>
<h5 id="递归实现-1">递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">			inOrder(root.left);</span><br><span class="line">			System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			inOrder(root.right);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归实现-1">非递归实现</h5>
<p>根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。</p>
<p>对于任一结点P，</p>
<p>1、若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理；</p>
<p>2、若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子；</p>
<p>3、直到P为NULL并且栈为空则遍历结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ArrayList&lt;TreeNode&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;<span class="comment">//先访问左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line">            TreeNode tmp = stack.pop();</span><br><span class="line">            alist.add(tmp.val);<span class="comment">//再访问根节点</span></span><br><span class="line">            p = tmp.right;<span class="comment">//访问右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历">后序遍历</h4>
<p>后序遍历按照“左孩子-右孩子-根结点”的顺序进行访问。</p>
<h5 id="递归实现-2">递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">		postOrder(root.left);</span><br><span class="line">		postOrder(root.right);</span><br><span class="line">		System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归实现-2">非递归实现</h5>
<p>1、要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。</p>
<p>2、如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。</p>
<p>3、若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ArrayList&lt;TreeNode&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    TreeNode cur,pre = <span class="keyword">null</span>;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        cur = stack.peek();</span><br><span class="line">        <span class="comment">//当前节点不存在左右孩子，或者左右孩子都已经被访问过</span></span><br><span class="line">        <span class="keyword">if</span>( (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) || (pre != <span class="keyword">null</span> &amp;&amp; (cur.left == pre || cur.right == pre) ) )&#123;</span><br><span class="line">            <span class="comment">//访问当前节点</span></span><br><span class="line">            TreeNode tmp = stack.pop();</span><br><span class="line">            alist.add(tmp.val);</span><br><span class="line">            pre =tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//否则先将右子节点入栈，再将左子节点入栈，保证先访问左子树再访问右子树</span></span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">					stack.push(cur.right);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> alist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层序遍历">层序遍历</h4>
<p>使用队列实现层序遍历。</p>
<p>1、首先将根节点放入队列中。</p>
<p>2、当队列为非空时，循环执行步骤3到步骤5，否则执行6；</p>
<p>3、出队列取得一个结点，访问该结点；</p>
<p>4、若该结点的左子树为非空，则将该结点的左子树入队列；</p>
<p>5、若该结点的右子树为非空，则将该结点的右子树入队列；</p>
<p>6、结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	queue.offer(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		TreeNode temp  = queue.poll();</span><br><span class="line">		System.out.print(temp.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)</span><br><span class="line">			queue.offer(temp.left);</span><br><span class="line">		<span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)</span><br><span class="line">			queue.offer(temp.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/u011514810/article/details/75907170 （二叉树遍历）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>0725 拼多多笔试</title>
    <url>/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/</url>
    <content><![CDATA[<h2 id="一">一</h2>
<a id="more"></a>
<p><img src="/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/image-20210725220515830.png" alt="image-20210725220515830" style="zoom: 67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">本题是仿照覆盖区间问题，暴力法也可以过</span><br><span class="line">思路一：</span><br><span class="line"><span class="number">1</span>、按照开始的位置排序</span><br><span class="line"><span class="number">2</span>、判断下一个是不是在上一个里面</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入组成二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">7</span>,<span class="number">10</span>&#125;,&#123;<span class="number">13</span>,<span class="number">18</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据线段的起始点排序</span></span><br><span class="line">        Arrays.sort(nums, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断前一个线段是否包含当前线段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//包含则输出并返回</span></span><br><span class="line">            <span class="keyword">if</span>( nums[i][<span class="number">1</span>] &lt;= nums[i-<span class="number">1</span>][<span class="number">1</span>] )&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不包含输出false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">思路二：</span><br><span class="line">直接暴力</span><br></pre></td></tr></table></figure>
<h2 id="二">二</h2>
<p><img src="/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/image-20210725220631616.png" alt="image-20210725220631616" style="zoom: 67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 模拟法，注意是牌多的人赢</span></span><br><span class="line"><span class="comment">* 注意每轮获胜后，放下牌需要再次判断是不是再次获胜，不能直接到下一个人发牌。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* https://www.nowcoder.com/discuss/690459?type=post&amp;order=create&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当有重复牌出现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">winIt</span><span class="params">(ArrayList&lt;Integer&gt; list,HashMap&lt;Integer,Integer&gt; where,<span class="keyword">int</span>[] win,<span class="keyword">int</span> person,<span class="keyword">int</span> put)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获得重复牌下标</span></span><br><span class="line">        <span class="keyword">int</span> index=where.get(put);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//累加它的筹码</span></span><br><span class="line">        win[person]+=list.size()-index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移走这些牌</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=index;i--)&#123;</span><br><span class="line">            <span class="comment">//删除记录的下标，注意不单只删除那个重复的，所有中间的都要删除</span></span><br><span class="line">            where.remove(list.get(i));</span><br><span class="line">            <span class="comment">//在牌局中删除牌</span></span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int[] arr = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; collect = Arrays.stream(arr).boxed().collect(Collectors.toList());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//两者手中的牌</span></span><br><span class="line">        List&lt;Integer&gt; person1 = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>&#125;).boxed().collect(Collectors.toList());</span><br><span class="line">        List&lt;Integer&gt; person2 = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">8</span>,<span class="number">25</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>&#125;).boxed().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//牌局</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录每个牌的位置</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; where=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两者剩余的牌的下标，只需要用index即可，出过的牌就没了</span></span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录获胜的筹码</span></span><br><span class="line">        <span class="keyword">int</span>[] win=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当两者都还有牌</span></span><br><span class="line">        <span class="keyword">while</span>(index1&lt;person1.size() || index2&lt;person2.size())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//person1有牌</span></span><br><span class="line">            <span class="keyword">if</span>(index1&lt;person1.size())&#123;</span><br><span class="line">                <span class="comment">//拿到牌</span></span><br><span class="line">                <span class="keyword">int</span> put1=person1.get(index1);</span><br><span class="line">                index1++;</span><br><span class="line">                <span class="comment">//放入牌局</span></span><br><span class="line">                list.add(put1);</span><br><span class="line">                <span class="comment">//有重复牌</span></span><br><span class="line">                <span class="keyword">while</span>(where.get(put1)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//累加筹码并从牌局中删除牌</span></span><br><span class="line">                    winIt(list,where,win,<span class="number">0</span>,put1);</span><br><span class="line">                    <span class="comment">//是否有牌可出</span></span><br><span class="line">                    <span class="keyword">if</span>(index1&gt;=person1.size())</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//出牌</span></span><br><span class="line">                    put1=person1.get(index1);</span><br><span class="line">                    index1++;</span><br><span class="line">                    list.add(put1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//记录下标</span></span><br><span class="line">                where.put(put1,list.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//person2重复上述过程</span></span><br><span class="line">            <span class="keyword">if</span>(index2&lt;person2.size())&#123;</span><br><span class="line">                <span class="keyword">int</span> put2=person2.get(index2);</span><br><span class="line">                index2++;</span><br><span class="line">                list.add(put2);</span><br><span class="line">                <span class="keyword">while</span>(where.get(put2)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    winIt(list,where,win,<span class="number">1</span>,put2);</span><br><span class="line">                    <span class="keyword">if</span>(index2&gt;=person2.size()) <span class="keyword">break</span>;</span><br><span class="line">                    put2=person2.get(index2);</span><br><span class="line">                    index2++;</span><br><span class="line">                    list.add(put2);</span><br><span class="line">                &#125;</span><br><span class="line">                where.put(put2,list.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历剩余牌局中的牌，按奇数偶数累加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                win[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                win[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(win[<span class="number">0</span>]+<span class="string">&quot; &quot;</span>+win[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三">三</h2>
<p><img src="/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/image-20210725220754513.png" alt="image-20210725220754513" style="zoom: 67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  看 Q能否写成 （C^n）*A+m*B</span></span><br><span class="line"><span class="comment">*  Q = （C^n）*A+m*B</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*https://www.nowcoder.com/discuss/690445?type=post&amp;order=time&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> Q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(C == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (Q-A)%B==<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp_C = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( temp_C*A &lt;= Q )&#123;     <span class="comment">//如果 A*C 比Q小</span></span><br><span class="line">                <span class="keyword">if</span>((Q-temp_C*A)%B==<span class="number">0</span>)   <span class="comment">//如果Q能被拆开，则成功</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                temp_C = temp_C*C; <span class="comment">//否则继续递增C</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println( can(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四">四</h2>
<p><img src="/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/image-20210725221050444.png" alt="image-20210725221050444" style="zoom: 67%;"></p>
<p>例如：0 4 0 0 0 0 0 0 0 0：</p>
<p>输出：121（解释：因为有4个1，最大组成 11 * 11 = 121）</p>
<p>例如：2 3 0 1 0 0 0 0 0 0：</p>
<p>输出：34100（解释：1个3，2个0，三个1 最大组成3100 * 11 = 34100）</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 乘积最大的规律是：大数尽可能排在高位，两个两位数的差尽可能小。</span></span><br><span class="line"><span class="comment">* 最后必然是2个数相乘。</span></span><br><span class="line"><span class="comment">* 高位必须放前面，所以从后往前遍历。</span></span><br><span class="line"><span class="comment">* 然后每个数组优先给2个乘数中较小的那个（也就是数字长度更短的那个，长度相等情况下是较小的那个），来保证两数在满足大数字在前的前提下尽可能接近些。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* https://www.nowcoder.com/discuss/690459?type=post&amp;order=create&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟数字</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终都会成为两个数的乘积，所以仅需要考虑两个数乘积什么时候最大</span></span><br><span class="line">        ArrayList&lt;Integer&gt; left=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        ArrayList&lt;Integer&gt; right=<span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配数字给两个乘数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//把最大的数字给左边的最高位</span></span><br><span class="line">                <span class="keyword">if</span>(left.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    left.add(i);</span><br><span class="line">                    arr[i]--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//其次给右边数的最高位</span></span><br><span class="line">                <span class="keyword">if</span>(right.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    right.add(i);</span><br><span class="line">                    arr[i]--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果左边数的长度比较长，那么就把数字给右边的数</span></span><br><span class="line">                <span class="keyword">if</span>(checkIt(left,right))&#123;</span><br><span class="line">                    right.add(i);</span><br><span class="line">                    arr[i]--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 反之</span></span><br><span class="line">                    left.add(i);</span><br><span class="line">                    arr[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终获得结果</span></span><br><span class="line">        getResult(left,right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkIt</span><span class="params">(ArrayList&lt;Integer&gt; left,ArrayList&lt;Integer&gt; right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果左边的数比较长则返回true，数字给到右边</span></span><br><span class="line">        <span class="keyword">if</span>(left.size()&gt;right.size()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(right.size()&gt;left.size()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果两个长度相等</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;left.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.get(i).equals(right.get(i))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> left.get(i) &gt; right.get(i); <span class="comment">//左边数的数字比较大则返回true，数字会给到右边</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数字全部相等也返回true，数字给到右边</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList转换成字符，然后再转成数字，最后使用大整数乘法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">(ArrayList&lt;Integer&gt; left,ArrayList&lt;Integer&gt; right)</span></span>&#123;</span><br><span class="line">        BigInteger l1=<span class="keyword">new</span> BigInteger(getString(left));</span><br><span class="line">        BigInteger l2=<span class="keyword">new</span> BigInteger(getString(right));</span><br><span class="line">        BigInteger ret=l1.multiply(l2);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList转换成字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(ArrayList&lt;Integer&gt; arr)</span></span>&#123;</span><br><span class="line">        StringBuilder ret=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Integer e:arr)&#123;</span><br><span class="line">            ret.append(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/04/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式（Design pattern）是代码设计经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性。常用设计模式：单例模式</p>
<a id="more"></a>
<h3 id="单例模式">单例模式</h3>
<p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 私有构造方法，防止被实例化 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 静态工程方法，创建实例 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 线程安全</span></span><br><span class="line"><span class="comment">	public static Singleton getInstance() &#123;</span></span><br><span class="line"><span class="comment">		if (instance == null) &#123;</span></span><br><span class="line"><span class="comment">			synchronized (instance) &#123;</span></span><br><span class="line"><span class="comment">				if (instance == null) &#123;</span></span><br><span class="line"><span class="comment">					instance = new Singleton();</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		return instance;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="观察者模式发布-订阅模式">观察者模式/发布-订阅模式</h3>
<p>多个对象间存在一对多关系，当一个对象发生改变时，会把这种改变通知给其他多个对象，从而影响其他对象的行为。</p>
<h3 id="工厂模式">工厂模式</h3>
<p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/sugar_no1/article/details/88317950</p>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP和HTTPS</title>
    <url>/2021/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_HTTP%E5%92%8CHTTPS/</url>
    <content><![CDATA[<p>对称加密虽然性能好但有密钥泄漏的风险，非对称加密（2组公钥+2私钥双向传输）安全但性能低下，因此考虑用非对称加密来传输对称加密所需的密钥，然后进行对称加密，但是为了防止非对称过程产生的中间人攻击，需要对服务器公钥和服务器身份进行配对的数字认证，然后引入了CA数字签名+数字证书验证的方式！这是我梳理的整体逻辑流程。</p>
<a id="more"></a>
<h3 id="https加密过程">HTTPS加密过程</h3>
<p><img src="/2021/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_HTTP%E5%92%8CHTTPS/image-20210914095855554.png" alt="image-20210914095855554" style="zoom: 67%;"></p>
<p>1、客户端发起请求，服务端返回CA数字证书和公钥</p>
<p>2、客户端验证数字证书合法性。（公钥保存在数字证书中，如果合法证明公钥来自正确的服务器）</p>
<p>3、客户端生成私钥，用合法的公钥将私钥加密传输给服务器，服务器用对应的私钥解密。</p>
<p>4、双方通过对称加密的方式进行通信。</p>
<h3 id="数字证书及其验证">数字证书及其验证</h3>
<p>服务器（网站）在使用HTTPS前，需要向CA机构申领一份<strong>数字证书</strong>，数字证书里含有<strong>服务器的信息</strong>以及<strong>服务器的公钥</strong>等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。</p>
<p>如何判断证书是否被篡改：证书原本的内容生成一份<strong>数字签名</strong>（Hash值），比对证书内容和签名是否一致就能判别是否被篡改。</p>
<h4 id="数字证书制作">数字证书制作</h4>
<p><img src="/2021/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_HTTP%E5%92%8CHTTPS/image-20210914093855261.png" alt="image-20210914093855261" style="zoom:67%;"></p>
<p>1、CA机构拥有非对称加密的私钥和公钥。</p>
<p>2、CA机构对证书明文数据T进行hash。</p>
<p>3、对hash后的值用私钥加密，得到数字签名S。</p>
<p>4、明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。</p>
<h4 id="客户端验证证书">客户端验证证书</h4>
<p><img src="/2021/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_HTTP%E5%92%8CHTTPS/image-20210914095109879.png" alt="image-20210914095109879" style="zoom:67%;"></p>
<p>1、拿到证书，得到明文T，签名S。</p>
<p>2、用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</p>
<p>3、用证书里指明的hash算法对明文T进行hash得到T’。</p>
<p>4、显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。</p>
<h4 id="保证证书可信的原因">保证证书可信的原因</h4>
<p><strong>中间人修改证书中的明文部分：</strong></p>
<p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，<strong>无法相应地篡改签名</strong>。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p>
<p><strong>中间人修改证书中的明文和数字签名（直接整个掉包）：</strong></p>
<p>就是中间人直接将原来的数字证书替换成自己的证书，传给客户端。</p>
<p>此时证书里包含了中间人网站的信息，包括域名，浏览器<strong>把证书里的域名与自己请求的域名比对</strong>一下就知道有没有被掉包了。</p>
<p>那证书的安全性怎么保证？为什么中间人不能做一个假证书？</p>
<p>因为这套证书体系已经根植于每一个操作系统里了。每一个操作系统里，都内置了数十张根证书，每个根证书都对应一个非常权威的证书签发机构。这些根证书上记录了各个机构的公钥。</p>
<h3 id="对称和非对称加密">对称和非对称加密</h3>
<p>只用对称加密：</p>
<p>私钥无法保证安全地传输到对方。</p>
<p>非对称加密：</p>
<p>服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了，因为只有服务器有相应的私钥能解开公钥加密的数据。</p>
<p>反过来由服务器到浏览器的这条路怎么保障安全，如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。所以需要有某种手段验证公钥的合法性。</p>
<p>另外，非对称加密的效率相对于对称加密的效率是低的。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://zhuanlan.zhihu.com/p/43789231</p>
<p>https://segmentfault.com/a/1190000021494676</p>
<p>https://zhuanlan.zhihu.com/p/72616216</p>
<p>https://zhuanlan.zhihu.com/p/37738632（根证书）</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层的一些问题</title>
    <url>/2021/04/13/%E8%AE%A1%E7%BD%91_%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h4 id="tcp异常断开">TCP异常断开</h4>
<h5 id="服务器进程终止">服务器进程终止</h5>
<p>当服务器TCP接收到来自客户的数据时，既然先前打开那个套接口的进程已经终止，于是响应一个RST报文。</p>
<h5 id="服务器主机崩溃">服务器主机崩溃</h5>
<p>当服务器主机崩溃时，它不能发送任何东西，客户端TCP持续重传数据，试图从服务器上接受一个ACK。</p>
<ul>
<li>假设服务器已崩溃，从而对客户的数据分节根本没有响应，当客户端TCP最终放弃时，返回客户进程一个错误ETIMEDOUT。</li>
<li>如果某个中间路由器判定服务器主机已不可达，从而响应以一个“destination unreachable”，那么所返回的错误是EHOSTUNREACH或ENETUNREACH。</li>
</ul>
<a id="more"></a>
<p>为了快速检测出服务器已经不可达，有如下解决方案：</p>
<ul>
<li><p>给客户端设置一个超时时间，当超过这个时间后服务器还未响应数据时即认为服务器已经崩溃。</p></li>
<li><p>心跳检测机制，给双方设置一个守护进程，定期发送心跳检测数据包，另一方需要进行回应。</p></li>
<li><p>在Linux Socket编程中，开启SO_KEEPALIVE参数。</p>
<blockquote>
<p>SO_KEEPALIVE的过程？</p>
<p>1、如果通信两端超过2个小时没有交换数据，那么开启keep-alive的一端会自动发一个keep-alive包给对端。 2、如果对端正常的回应ACK包，那么一切都没问题，再等个2小时后发包(如果这两个小时仍然没有数据交换)。 3、如果对端回应RST包，表明对端程序崩溃或重启，这边socket产生ECONNRESET错误，并且关闭。 4、如果对端一直没回应，这边会每75秒再发包给对端，总共发8次共11分钟15秒。最后socket产生 ETIMEDOUT 错误，并且关闭。或者收到ICMP错误，表明主机不可到达，则会产生 EHOSTUNREACH 错误。</p>
<p>SO_KEEPALIVE和心跳机制的区别？</p>
<p>SO_KEEPALIVE是实现在传输层的TCP协议，心跳实现在应用层实现，本质没有任何区别，但应用层需要自己来定义心跳包格式。</p>
</blockquote></li>
</ul>
<h5 id="服务器主机崩溃后重启">服务器主机崩溃后重启</h5>
<p>当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接信息，因此服务器TCP对于所收到的来自客户的数据响应以一个RST，客户端进程返回ECONNRESET错误。</p>
<h5 id="服务器主机关机">服务器主机关机</h5>
<p>Unix系统关机时，init进程通常先给所有进程发送SIGTERM信号（该信号可被捕获），再等待一段固定的时间（一般在5~20秒之间），然后给所有仍在运行的进程发送SIGKILL信号（该信号不能被捕获）。</p>
<p>这么做是留给所有运行中的进程一小段时间来清除和终止。</p>
<p>如果不捕获SIGTERM信号并终止，服务器将由SIGKILL信号终止。当服务器进程终止时，它的所有打开着的描述字都被关闭，随后发生的步骤与服务器主机崩溃一样。</p>
<h4 id="tcp-粘包拆包">TCP 粘包、拆包</h4>
<p>产生的原因：</p>
<ul>
<li><p>粘包</p>
<p>1、发送端要发送的数据小于发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去</p>
<p>2、接收端应用层没有及时读取接收缓冲区中的数据</p></li>
<li><p>拆包</p>
<p>1、发送端要发送的数据大于发送缓冲区剩余空间大小</p>
<p>2、发送端待发送数据大于 MSS（最大报文长度）</p></li>
</ul>
<p>解决方案：</p>
<p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用层协议设计来解决。</p>
<ul>
<li><p>消息定长</p>
<p>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p></li>
<li><p>设置消息边界</p>
<p>接收端按消息边界分离出消息内容。比如可以在包尾增加特殊符号（回车换行符等）进行分割，例如 FTP 协议。</p></li>
<li><p>在消息头中设置消息的长度</p>
<p>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。</p></li>
<li><p>Netty协议</p></li>
</ul>
<h4 id="参考资料">参考资料</h4>
<p>https://zhuanlan.zhihu.com/p/108822858（粘包、拆包）</p>
<p>https://www.nowcoder.com/questionTerminal/72fa8f3cb67e4711ba8eee581f8be92b（TCP异常断开）</p>
<p>https://zhuanlan.zhihu.com/p/79957519 （异常断开）</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>0807虾皮一面</title>
    <url>/2021/08/08/%E9%9D%A2%E8%AF%95_0807%E8%99%BE%E7%9A%AE%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="实习">实习</h3>
<p>根据简历上的实习经历问实习的工作内容是什么，描述一下过程，然后问有什么有意思的事情（就是问难点）。</p>
<a id="more"></a>
<h3 id="大数据框架">大数据框架</h3>
<h4 id="spark">Spark</h4>
<h5 id="怎么理解rdd"><strong>怎么理解RDD？</strong></h5>
<p>RDD，即弹性分布式数据集（从五大特性去回答）。</p>
<p>首先，RDD是一个由多个分区组成的的列表；一般一个hdfs里的块会加载为一个分区。</p>
<p>然后RDD的每个分区上都有函数应用，用来实现RDD之间的转换。</p>
<p>同时，RDD会记录它的依赖关系，也就是这个RDD是怎么生成的，便于容错时进行重新计算。</p>
<p>最后，RDD还具有重分区的能力和数据本地性的特点。</p>
<blockquote>
<p>重分区：如果RDD里面存的数据是key-value形式，则可以传递一个自定义的Partitioner进行重新分区。</p>
<p>数据本地性：Spark在进行任务调度的时候，会尽可能地将计算任务分配到数据块的存储位置。</p>
</blockquote>
<h5 id="怎么理解rdd是弹性的">怎么理解RDD是弹性的？</h5>
<ul>
<li><p>自动进行内存和磁盘数据存储的切换</p>
<p>Spark会优先把数据放到内存中，如果内存实在放不下，会放到磁盘里面，不但能计算内存放下的数据，也能计算内存放不下的数据。</p></li>
<li><p>RDD具有容错机制</p>
<p>基于血统的容错机制，是RDD会记录它的依赖关系，当节点崩溃时可以分配另外的节点，根据血统信息重新运算得出结果。</p>
<p>基于Checkpoint的容错机制，建立检查点，斩断RDD的依赖链（删除依赖信息）将中间结果存储在可靠的存储引擎中。</p></li>
<li><p>分区数的变化</p>
<p>可以对RDD进行重分区来改变RDD的分区数。</p></li>
</ul>
<h5 id="懒加载是什么">懒加载是什么？</h5>
<p>Transformation 操作是延迟计算的，也就是说从一个 RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Acion 操作的时候才会真正触发运算。Transformation返回的数据类型是一个RDD。</p>
<p>Action 算子会触发 Spark 提交作业（Job），并将数据输出 Spark系统。Action返回的类型是一个其他的数据类型。</p>
<blockquote>
<p>为什么？</p>
<p>Transformation操作主要是对每个RDD中的元素进行处理并生成新的RDD；而Action则主要是对RDD进行最后的操作，比如遍历、reduce、保存到文件等（虽然最终可能还是保存到一个新的RDD上，但至少从设计上是具备输出能力的），并可以返回结果给Driver程序。</p>
<p>这样因为Transformation肯定不会输出（中间结果保存在内存），Spark就设定了惰性机制，当没有出现action操作的时候，所有RDD转换操作不会执行，程序会为其生成DAG，直到遇到Action才触发。</p>
<p>这样做的好处时有利于加强并行计算，减少中间结果。比如程序里进行了大量的转换操作，最后才reduce并输出，前面转换操作就可以生成DAG后，不同stage并行计算，甚至可能复用中间结果提高计算效率。这是为了spark的优化机制服务的。</p>
</blockquote>
<h5 id="transformation算子和action算子都有哪些">transformation算子和action算子都有哪些？</h5>
<ul>
<li><p>tranformation</p>
<p>map、flatMap、filter、reduceByKey、combineByKey</p></li>
<li><p>action</p>
<p>collect、count、saveAsTextFile、countByKey、foreach</p></li>
</ul>
<h5 id="cachepersist和懒加载的关系">cache、persist？和懒加载的关系？</h5>
<p>数据在第一次Action 操作时进行计算，并缓存在节点的内存中，在该数据上的其他Transformation 和 Action 操作将直接使用内存中的数据。这样会让以后的操作计算速度加快。</p>
<blockquote>
<p>在 shuffle 操作中（例如 reduceByKey），即便是用户没有调用 persist 方法，Spark 也会自动缓存部分中间数据。这么做的目的是，在 shuffle 的过程中某个节点运行失败时，不需要重新计算所有的输入数据。如果用户想多次使用某个 RDD，强烈推荐在该 RDD 上调用 persist 方法。</p>
</blockquote>
<p>cache就是调用了persist(StorageLevel.MEMORY_ONLY)，默认将数据缓存到内存中，内存不足时将从新计算。</p>
<h5 id="缓存级别">缓存级别？</h5>
<p>是否使用磁盘缓存、是否使用内存缓存、缓存前是否先序列化、是否需要有副本。</p>
<blockquote>
<p>序列化机制允许将实现序列化的Java对象转化为字节序列进行存储。</p>
<p>序列化的优势在于节省很多空间，反序列化的优势在于速度快。</p>
</blockquote>
<p><img src="/2021/08/08/%E9%9D%A2%E8%AF%95_0807%E8%99%BE%E7%9A%AE%E4%B8%80%E9%9D%A2/image-20210812080054947.png" alt="image-20210812080054947" style="zoom: 67%;"></p>
<h5 id="改变rdd的分区数">改变RDD的分区数？</h5>
<ul>
<li><p>创建RDD时可以指定分区数</p>
<blockquote>
<p>//通过本地集合创建的，通过第二个参数指定了分区数量</p>
<p>val rdd1 = sc.parallelize(1 to 100, 6)</p>
<p>//读取 HDFS 中文件创建的, 同样通过第二个参数指定了分区数, 因为是从 HDFS 中读取文件, 所以最终的分区数是由 Hadoop 的 InputFormat 来指定的</p>
<p>val rdd2 = sc.textFile("hdfs:///dataset/wordcount.txt", 6)</p>
</blockquote></li>
<li><p>coalesce()方法和repartition()方法能够改变分区的数量</p>
<p>repartition()方法就是coalesce()方法中shuffle参数为true的情况。（默认是false）</p>
<p>如果传入的参数大于现有的分区数目，而shuffle为false，RDD的分区数不变，也就是说不经过shuffle，是无法将RDDde分区数变多的。</p>
<blockquote>
<p>假设RDD有N = 1000个分区，需要重新划分M个分区：</p>
<p>N = 1000 &lt; M = 5000: 利用HashPartitioner函数将数据重新分区为5000个，这时需要将shuffle设置为true。因为重分区前后相当于宽依赖，会发生shuffle过程，此时可以使用coalesce(shuffle=true)，或者直接使用repartition()。</p>
<p>N = 1000 &gt; M = 100，并此时两者相差不多，那么就可以将N = 1000个分区中的每10个分区合并成一个新的分区，最终合并为M = 100个分区，这是前后是窄依赖关系，可以使用coalesce(shuffle=false)。</p>
<p>如果 N = 1000 &gt; M = 1，此时两者相差悬殊:，这时如果将shuffle设置为false，父子RDD是窄依赖关系，他们同处在一个Stage中，就可能造成Spark程序的并行度不够（每一个分区分配一个task执行，一个Task频繁在不同分区之间切换），从而影响性能，M = 1的时候，为了使coalesce之前的操作有更好的并行度，可以将shuffle设置为true。</p>
</blockquote></li>
</ul>
<h5 id="怎么划分stage">怎么划分stage？</h5>
<p>根据父子RDD之间是否是宽依赖的关系判断，也就是判断是否发生了shuffle操作。</p>
<p>查看算子生成的 RDD，并调用RDD对应的getDependence方法观察是否是ShuffleDependency。</p>
<h4 id="hbase">Hbase</h4>
<h5 id="描述一下hbase的架构">描述一下Hbase的架构？</h5>
<ul>
<li>Master：建表、删表、移动Region、合并等操作(HBase中即使Master宕机了，集群依然可以正常地运行，依然可以存储和删除数据)</li>
<li>RegionServer:服务器上的一个服务，真正存储数据的节点，客户端可以直接从这里获取数据
<ul>
<li>Region：一个RegionServer中有多个Region，Region就是一段数据的集合，每一个Region都有起始rowkey和结束rowkey，代表了它所存储的row范围。一个Region对应了一张表。
<ul>
<li>Store：在一个Region内部，包括多个store，其中一个store对应一个列族。如果一个表中有N个列族，那么它对应的每一个region中有N个store。</li>
<li>MemStore：不是为了加快写速度，而是按照Row Key对这个列族中的数据进行排序（LSM树）</li>
<li>HFile：存储在硬盘上的文件，真正被持久化到硬盘上</li>
</ul></li>
<li>WAL：修改并不直接写入到数据库文件中，而是写入到另外一个称为 WAL 的文件中；如果事务失败，WAL 中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改。</li>
<li>BlockCache：读数据时进行缓存</li>
</ul></li>
<li>ZooKeeper：管理了HBase所有RegionServer的信息，具体的数据段存放在哪个RegionServer上；客户端先和zk通信才能获取数据；取数据所需要的元数据表hbase:meata的位置存储在zk上</li>
</ul>
<h5 id="rowkey设计需要注意什么问题">RowKey设计需要注意什么问题？</h5>
<p>RowKey本质上就是用来定位一条记录的多个字段的集合。</p>
<ul>
<li><p>长度原则：RowKey设计不宜过长，最好不超过16字节，避免给MenmStore和Hfile中的存储带来压力</p></li>
<li><p>唯一原则：必须在设计上保证RowKey的唯一性。由于在HBase中数据存储是Key-Value形式，若向HBase中同一张表插入相同RowKey的数据，则原先存在的数据会被新的数据覆盖。</p></li>
<li><p>排序原则：HBase的RowKey是按照ASCII有序排序的，因此我们在设计RowKey的时候要充分利用这点。</p></li>
<li><p>散列原则：设计的RowKey应均匀的分布在各个HBase节点上。</p></li>
</ul>
<h3 id="数据库">数据库</h3>
<h4 id="数据库索引有什么了解">数据库索引有什么了解？</h4>
<p>B+树：磁盘访问代价、范围查询、查询稳定性</p>
<h4 id="索引设计需要注意什么问题原问题是有些字段需要排序这些字段怎么设计索引">索引设计需要注意什么问题？（原问题是有些字段需要排序，这些字段怎么设计索引）</h4>
<p>在需要排序的字段上建立索引，就可以实现利用索引对排序的优化，因为索引本身就是经过排序的。</p>
<h3 id="数仓">数仓</h3>
<h4 id="oltp和olap的区别">OLTP和OLAP的区别？</h4>
<p>两者都是数据处理的一种概念。</p>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 46%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>OLTP</th>
<th>OLAP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>操作目的</td>
<td>查询、改变数据</td>
<td>分析规律、预测趋势</td>
</tr>
<tr class="even">
<td>操作对象</td>
<td>数据库</td>
<td>数据仓库</td>
</tr>
<tr class="odd">
<td>操作数据量</td>
<td>一般仅一两张表。（数据量小） 点查为主，返回的是记录本身或该记录的多个列。即使是范围查询，基本上也会通过limit来限制返回的记录数。</td>
<td>对多张表的数据进行count()、sum()和avg()等聚合方法 从大量数据中找出规律。 表中单条记录本身并不是查询所关心的，比较典型的特点包括有聚合类算子、涉及多表Join。</td>
</tr>
<tr class="even">
<td>数据模型</td>
<td>实体-关系模型（ER）</td>
<td>星型或雪花</td>
</tr>
<tr class="odd">
<td>延时</td>
<td>低</td>
<td>高</td>
</tr>
</tbody>
</table>
<h4 id="两者分别对应了哪些数据库">两者分别对应了哪些数据库？</h4>
<p>OLAP：Hive、SparkSQL、ClickHouse</p>
<p>OLTP：MySQL、Oracle、PostgreSQL</p>
<h3 id="java基础">Java基础</h3>
<p>1、== 和 equals的区别？</p>
<p>2、描述一下HashMap的结构？</p>
<p>3、Java有哪些集合？</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>0808字节一面</title>
    <url>/2021/08/11/%E9%9D%A2%E8%AF%95_0808%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="实习">实习</h3>
<p>整个系统的SLA是多少</p>
<a id="more"></a>
<p>存储的数据量？</p>
<p>大概5亿行数据，200G左右，宽表约150个字段</p>
<h3 id="大数据框架">大数据框架</h3>
<h4 id="yarn">Yarn</h4>
<h5 id="yarn的执行流程">Yarn的执行流程？</h5>
<p>Yarn是一个资源调度平台，负责为运算程序（MapReduce）分配服务器运算资源。</p>
<p>ResourceManager：总的管理器</p>
<ul>
<li><p>处理客户端的请求</p></li>
<li><p>启动监控 ApplicationMaster</p></li>
<li><p>监控 NodeManager</p></li>
<li><p>资源分配调度</p></li>
</ul>
<p>ApplicationMaster：单个Job的管理器</p>
<ul>
<li>为应用程序申请资源，分配给任务</li>
<li>负责任务的监控与容错</li>
<li>需要与 NM 通信：启动/停止 task，task 是运行在 container 里面，AM 也是运行在 container 里面</li>
</ul>
<p>NodeManager：单个节点的管理器</p>
<ul>
<li>管理单个节点的资源、任务</li>
<li>处理来自ResourceManager的请求：启动 Container</li>
<li>ApplicationMaster的命令：启动task</li>
<li>定时向RM汇报本节点的资源情况</li>
</ul>
<p>Container：资源抽象</p>
<ul>
<li>封装了如内存、cpu、磁盘、网络等资源</li>
</ul>
<blockquote>
<p>YARN 的基本思想是将资源管理和作业调度/监控的功能分解为单独的守护进程。这个包括 2 个部分，一个全局的资源调度 ResourceManager（RM）和针对每个应用程序的ApplicationMaster（AM）</p>
</blockquote>
<p>1、开启ApplicationMaster，计算并申请所需资源：</p>
<p>Client向yarn提交job，首先找ResourceManager分配资源，ResourceManager开启一个Container，在Container中运行一个Application Manager</p>
<p>Application Manager找一台NodeManager启动ApplicationMaster，计算任务所需的计算资源，然后向Application Manager（Yarn）申请运行任务所需的资源</p>
<p>2、AM将资源分发给NM，执行计算</p>
<p>Resource scheduler将资源封装发给ApplicationMaster，ApplicationMaster将获取到的资源分配给各个NodeManager，启动Container执行任务</p>
<p>3、结果反馈</p>
<p>将执行结果反馈给ApplicationMaster，ApplicationMaster将任务执行的结果反馈Application Manager</p>
<h5 id="applicationmaster做了什么">ApplicationMaster做了什么</h5>
<h5 id="nodemanager-的重启过程">NodeManager 的重启过程</h5>
<h5 id="yarn的心跳机制">Yarn的心跳机制</h5>
<h4 id="spark">Spark</h4>
<h5 id="spark的内存管理机制">spark的内存管理机制</h5>
<p>Spark1.6之后引入统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域。</p>
<p>总的内存可以分为：</p>
<ul>
<li>堆内存
<ul>
<li>存储内存：缓存RDD数据和广播变量的数据</li>
<li>执行内存：缓存shuffle操作（reduce by、join）产生的中间数据</li>
<li>系统保留内存：作为存储内存和执行内存的缓冲区，防止OOM</li>
<li>其他内存：用户自定义数据结构及Spark元数据</li>
</ul></li>
<li>堆外内存
<ul>
<li>存储内存</li>
<li>执行内存</li>
</ul></li>
</ul>
<h5 id="spark的副本机制">Spark的副本机制？</h5>
<p>副本的作用是在数据丢失的情况下依然保持服务可用。</p>
<p>Spark防止数据丢之的机制是血统容错机制和Checkpoint机制。通过用父RDD再次执行相应操作得到现有RDD。</p>
<p>一般来说，在已经有RDD容错机制的情况下，没有必要再牺牲内存设计RDD副本容错机制。</p>
<p>但是，在执行缓存的情况下，可以产生副本，向persist方法中传入StorageLevel参数，可以实现不同的缓存级别。其中DISK_ONLY_2、MEMORY_ONLY_2、MEMORY_ONLY_SER_2、MEMORY_AND_DISK_SER_2缓存级别，可以是实现缓存副本数为2，即将所有数据都复制一份副本，并发送到其他节点上。</p>
<h4 id="hbase">Hbase</h4>
<h5 id="描述一下hbase的架构">描述一下Hbase的架构？</h5>
<ul>
<li>Master：建表、删表、移动Region、合并等操作(HBase中即使Master宕机了，集群依然可以正常地运行，依然可以存储和删除数据)</li>
<li>RegionServer:服务器上的一个服务，真正存储数据的节点，客户端可以直接从这里获取数据
<ul>
<li>Region：一个RegionServer中有多个Region，Region就是一段数据的集合，每一个Region都有起始rowkey和结束rowkey，代表了它所存储的row范围。一个Region对应了一张表。
<ul>
<li>Store：在一个Region内部，包括多个store，其中一个store对应一个列族。如果一个表中有N个列族，那么它对应的每一个region中有N个store。</li>
<li>MemStore：不是为了加快写速度，而是按照Row Key对这个列族中的数据进行排序（LSM树）</li>
<li>HFile：存储在硬盘上的文件，真正被持久化到硬盘上</li>
</ul></li>
<li>WAL：修改并不直接写入到数据库文件中，而是写入到另外一个称为 WAL 的文件中；如果事务失败，WAL 中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改。</li>
<li>BlockCache：读数据时进行缓存</li>
</ul></li>
<li>ZooKeeper：管理了HBase所有RegionServer的信息，具体的数据段存放在哪个RegionServer上；客户端先和zk通信才能获取数据；取数据所需要的元数据表hbase:meata的位置存储在zk上</li>
</ul>
<h3 id="sql">SQL</h3>
<p>整个系统的SLA是多少 存储的数据量</p>
<p>yarn的整个执行流程 am做了什么 yarn的心跳机制</p>
<p>node manager 的重启过程</p>
<p>spark的内存管理机制 DD</p>
<p>sql分别有哪些连接</p>
<p>sql是怎么转为map reduce执行的</p>
<p>Hfile是怎么存储文件的</p>
<p>LSM是什么？英文全程是什么？</p>
<p>spark的副本机制？ DD</p>
<p>HdFS宕机，断点续传功能</p>
<p>连续n天登陆 新用户表和旧用户表，怎么判断新用户在旧用户表中出现？（where条件？）</p>
<p>hbase介绍</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>0902字节一面</title>
    <url>/2021/09/06/%E9%9D%A2%E8%AF%95_0902%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="计网">计网</h3>
<h4 id="syn攻击">Syn攻击</h4>
<p><strong>是什么</strong></p>
<p>TCP三次握手中，攻击者向服务器发送连接请求，服务器回复ACK确认后，攻击者并不返回ACK确认，即使得第三次握手无法完成，导致消耗服务器的资源，使得正常的SYN请求被丢弃。</p>
<p><strong>怎么检测</strong></p>
<p>当发现大量的大量的半连接状态时，特别是源IP地址是随机的时候，可以检测为是Sync攻击。</p>
<p><strong>怎么防范</strong></p>
<p>1、降低超时时间，使得主机尽快释放半连接的占用。</p>
<p>2、使用代理服务器。当客户端SYN包到达代理服务器时，SYN代理服务器并不转发SYN包，而是以服务器的名义主动回复SYN/ACK包给客户，如果收到客户的ACK包，表明这是正常的访问，此时代理服务器向服务器发送ACK包并完成三次握手。</p>
<a id="more"></a>
<h3 id="操作系统">操作系统</h3>
<h4 id="进程的通信方式"><strong>进程的通信方式</strong></h4>
<p>1、管道：本质上是内存中的缓冲区，匿名管道用于有亲缘关系的进程通信，有名管道用于无关进程的进程间通信。</p>
<p>2、信号：一个进程通知另一个进程某个事件已经发生。信号量：计数器，用于多进程对共享数据的访问。</p>
<p>3、消息队列：内核中的消息列表。</p>
<p>4、共享内存。</p>
<p>5、套接字：不同主机间进程间的通信。</p>
<h4 id="线程的锁"><strong>线程的锁</strong></h4>
<p>1、互斥量：只有拥有互斥对象的线程才有访问公共资源的权限，互斥对象通常只有一个，比如Java中的synchronized关键字和locks都是类似的机制。</p>
<p>2、信号量：信号量本质上是计数器，允许多个线程访问同一个公共资源。</p>
<p>3、信号：Wait/Notify，通过发送通知的方式来保持多线程同步。</p>
<h3 id="数据库">数据库</h3>
<h4 id="隔离级别"><strong>隔离级别</strong></h4>
<table>
<thead>
<tr class="header">
<th>级别</th>
<th>说明</th>
<th>读写数据</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>未提交读</td>
<td>事务的修改，在提交之前对其他事务也可见。</td>
<td>当前读</td>
</tr>
<tr class="even">
<td>提交读</td>
<td>事务的修改，在提交之前对其他事务不可见。</td>
<td>当前读<br>（也可以是快照读，每次都读取最新的快照）</td>
</tr>
<tr class="odd">
<td>可重复读（MySQL默认）</td>
<td>保证一个事务多次读取同一数据的结果是相同的。</td>
<td>快照读</td>
</tr>
<tr class="even">
<td>可串行化</td>
<td>强制事务串行执行，不会出现并发一致性问题。</td>
<td>当前读</td>
</tr>
</tbody>
</table>
<p>mysql读取数据实际上有两种读取模式：当前读和快照读</p>
<p>当前读：每次读取的都是当前最新的数据，但是读的时候不允许写，写的时候也不允许读。（加锁）</p>
<p>快照读：读写不冲突，每次读取的是快照数据。（版本控制）</p>
<h3 id="大数据">大数据</h3>
<h4 id="flink-exactly-once">Flink Exactly Once</h4>
<p><strong>流程</strong></p>
<p>一条数据只影响一次最终结果。</p>
<p>1、Source：保存读取数据的偏移量。</p>
<p>2、Flink：Checkpoint机制保证系统的一致性。</p>
<p>3、Sink：两阶段提交，当所有算子的快照完成的时候才真正提交。</p>
<p><strong>两阶段提交怎么提交</strong></p>
<p>1、预提交：sink 收到 barrier，保存当前状态，存入 checkpoint，通知 jobmanager，并开启下一阶段的事务，用于提交下个检查点的数据。（<strong>本质上是在目的文件系统中创建了一个临时文件，并向里面写入数据，然后停止写入并关闭该文件</strong>）</p>
<p>2、正式提交：jobmanager 收到所有算子返回的确认消息，向sink发出确认，表示 checkpoint 完成，则sink正式提交这段时间的数据。外部kafka关闭事务，提交的数据就可以正常消费了。（<strong>本质上是通过原子操作将临时文件移动到目的文件夹</strong>）</p>
<h4 id="flink-反压">Flink 反压</h4>
<p><strong>怎么排查</strong></p>
<p>1、通过 Flink Web UI 自带的反压监控面板</p>
<p>Flink Web UI 的反压监控提供了 SubTask 级别的反压监控。原理是通过周期性对 Task 线程的栈信息采样，得到<strong>线程被阻塞在请求 Buffer的频率</strong>来判断该节点是否处于反压状态。默认配置下，这个频率在 0.1 以下则为 OK，0.1 至 0.5 为 LOW，而超过 0.5 则为 HIGH。</p>
<p><img src="/2021/09/06/%E9%9D%A2%E8%AF%95_0902%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2/image-20210906103911274.png" alt="image-20210906103911274" style="zoom: 50%;"></p>
<p>如果处于反压状态，那么有两种可能性：</p>
<p>1、该节点的发送速率跟不上它的产生数据速率。这一般会发生在一条输入多条输出的 Operator（比如 flatmap）。</p>
<p>2、下游的节点接受速率较慢，通过反压机制限制了该节点的发送速率。</p>
<p>如果是第一种状况，那么该节点则为反压的根源节点，它是从 Source Task 到 Sink Task 的第一个出现反压的节点。如果是第二种情况，则需要继续排查下游节点。</p>
<p>2、通过 Flink Task Metrics</p>
<p>Flink本身提供了大量的REST API来获取任务的各种状态，通过各个buffer的使用率情况来进行判定是否产生了反压。</p>
<blockquote>
<p>https://www.cnblogs.com/zhaowei121/p/11950759.html</p>
<p>https://blog.csdn.net/u013411339/article/details/112756701</p>
</blockquote>
<p><strong>解决方案</strong></p>
<p>1、数据倾斜</p>
<p>2、GC（频繁地垃圾回收导致buffer无法被分配）</p>
<p>3、代码问题（算子被阻塞或者性能太低）</p>
<h4 id="kafka">Kafka</h4>
<p><strong>Kafka是什么语义的</strong></p>
<p>三种语义都支持，通过参数进行控制。</p>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 82%">
</colgroup>
<thead>
<tr class="header">
<th>语义</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>at-least-once</td>
<td>这种方式是在消费数据之后，异步提交offset。<br>有可能消费者的消息处理完并输出时，offset还没提交，消费者挂掉了，再重启的时候会重新消费并处理消息。<br>所以至少会处理一次。<br><strong>先消费数据，再提交offset。</strong></td>
</tr>
<tr class="even">
<td>at-most-once</td>
<td>消费者的offset已经提交，但是消息还在处理中(还没有处理完)。<br>这个时候程序挂了，导致数据没有被成功处理。<br>再重启的时候会从上次提交的offset处消费，导致上次没有被成功处理的消息就丢失了。<br><strong>先提交offset，再消费数据。</strong></td>
</tr>
<tr class="odd">
<td>exactly-once</td>
<td>以原子事务的方式保存offset和处理的消息结果，这个时候相当于自己保存offset信息。<br>把offset和具体的数据绑定到一块，数据真正处理成功的时候才会保存offset信息。<br><strong>原子性地绑定消息处理和offset提交。</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>https://blog.csdn.net/lt326030434/article/details/119881907</p>
</blockquote>
<p><strong>kafka会不会丢失数据</strong></p>
<p>1、生产者发送数据。</p>
<p>ack机制。为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p>
<p>ack应答机制。Kafka提供三种可靠性级别，根据对可靠性和延迟的要求进行权衡。acks参数配置：</p>
<p>0：producer不等待broker的ack，最低的延迟，broker一接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据。</p>
<p>1：producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么follower将会丢失数据。</p>
<p>2、Kafka Broker 存储数据。</p>
<p>Kafka把数据写入磁盘时是先写缓存再刷盘，如果数据已经写入系统 cache 中但是还没来得及刷入磁盘，此时突然机器宕机或者掉电那就丢了。</p>
<p>理论上，要完全让kafka保证单个broker不丢失消息是做不到的，只能通过调整刷盘机制的参数缓解该情况。</p>
<p>3、消费者消费数据。</p>
<p>取决于支持的语义，at-least-once和exactly-once 不会，但是at-most-once 会发生丢失。</p>
<p>at-most-once先提交offset，再消费数据，如果数据并未成功被消费的话，呢么数据就丢失了。</p>
<blockquote>
<p>https://www.cnblogs.com/jmcui/p/14032488.html#_label1</p>
</blockquote>
<p><strong>flink+kafka实现两阶段提交</strong></p>
<p>就是flink的两阶段提交过程，再通过幂等性来防止重复提交。</p>
<p>幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带序列号。而Broker端会对&lt; PID, Partition, 序列号&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。</p>
<blockquote>
<p>https://blog.csdn.net/longlovefilm/article/details/104908006</p>
</blockquote>
<h3 id="算法">算法</h3>
<p>leetcode 重排链表</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>0906网易互娱一面</title>
    <url>/2021/09/06/%E9%9D%A2%E8%AF%95_0906%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="hive">Hive</h3>
<h4 id="分区">分区</h4>
<p><strong>分区表是如何加速的</strong></p>
<p>将数据按字段值划分开。</p>
<p>从文件上来看，每个分区就是HDFS上的一个目录。（可以指定多个分区形成多级分区）</p>
<p>查询时通过where进行分区过滤，查询指定分区的数据，避免全表扫描，加快查询速度。</p>
<p><strong>分区表分区字段的指导原则</strong></p>
<p>1、分区字段名称不能是表中已经存在的字段名称，因为分区字段最终也会以虚拟字段的形式显示在表结构上。</p>
<p>2、最好选用那些字段值分布均匀的字段来作为分区字段，否则单个文件可能会过大，失去了分区表的意义。</p>
<a id="more"></a>
<h4 id="数据倾斜">数据倾斜</h4>
<p><strong>数据倾斜有哪几种情况及其解决方案</strong></p>
<p>问题：大表join小表且某个key数据量大</p>
<p>导致大表和小表中，该key对应的数据被分发到同一台机器上，该机器节点成为计算瓶颈。</p>
<p>解决方案：</p>
<p>将小表广播到其他机器上，在map端做join操作，不需要再进行reduce。</p>
<p>hive.map.aggr=true 即可指定Map 端聚合。</p>
<p>问题：大表join大表且某个key对应的数据量大</p>
<p>该key对应的数据被分发到同一台机器上，该机器节点成为计算瓶颈。</p>
<p>解决方案：</p>
<p>将有数据倾斜的这些key的数据拿出来，加上随机前缀，做两阶段join。</p>
<p>问题：group by中某个key对应的数据量大</p>
<p>该key对应的数据被分发到同一台机器上进行聚合</p>
<p>解决方案：</p>
<p>当设定hive.groupby.skewindata为true时，生成的查询计划会有两个MapReduce任务。</p>
<p>在第一个MapReduce 中，map的输出结果集合会随机分布到 reduce 中， 每个 reduce 做部分聚合操作，这样处理之后，相同的 Group By Key 有可能分发到不同的 reduce 中，从而达到负载均衡的目的。</p>
<p>在第二个 MapReduce 任务再根据第一步中处理的数据按照Group By Key分布到reduce中，（这一步中相同的key在同一个reduce中），最终生成聚合操作结果。</p>
<blockquote>
<p>https://zhuanlan.zhihu.com/p/115005700</p>
</blockquote>
<p>问题：字段中null值较多（不管对于join还是group by）</p>
<p>null值或者空值，都会产生数据倾斜的问题</p>
<p>解决方案：</p>
<p>1、用where条件筛选掉null值。</p>
<p>2、给null值赋值上随机数，将数据分散到多个机器上，因为不关心null值的聚合结果，所以没关系。</p>
<p>问题：Count Distinct</p>
<p>Hive中 count(distinct id) 这样的操作，仅生成一个Reduce 任务，该任务会对全部数据进行去重统计，因此会成为瓶颈。</p>
<p>解决方案：</p>
<p>先group by，将数据分散到多个机器上进行去重，最后再count进行统计。</p>
<p><img src="/2021/09/06/%E9%9D%A2%E8%AF%95_0906%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2/image-20210909221725804.png" alt="image-20210909221725804" style="zoom:50%;"></p>
<blockquote>
<p>https://zhuanlan.zhihu.com/p/29276028</p>
<p>https://blog.csdn.net/u013630349/article/details/103660545</p>
</blockquote>
<h4 id="数据建模">数据建模</h4>
<p>维度表、事实表</p>
<p>星型模型、雪花模型</p>
<h4 id="hdfs">HDFS</h4>
<p>如何存储文件的</p>
<h3 id="操作系统">操作系统</h3>
<p>Top命令下CPU占用率能不能超过100%</p>
<p>可以，这里显示的所有的cpu加起来的使用率，说明CPU是多核，运行top后按大键盘1，可以显示每个cpu的使用率，top里显示的是把所有使用率加起来。</p>
<h3 id="kafka">Kafka</h3>
<p><strong>数据是否可以乱序</strong></p>
<p>可以，因为一个topic有多个分区，只能保证每个分区内的数据是有序的，不能保证多个分区内的数据是全局有序的。</p>
<blockquote>
<p>如果Kafka要保证多个partition有序，不仅broker保存的数据要保持顺序，消费时也要按序消费。假设partition1堵了，为了有序，那partition2以及后续的分区也不能被消费，这种情况下，Kafka 就退化成了单一队列，毫无并发性可言，极大降低系统性能。因此Kafka使用多partition的概念，并且只保证单partition有序。这样不同partiiton之间不会干扰对方。</p>
</blockquote>
<p><strong>如何保证数据有序消费</strong></p>
<p>发送端 发送端不能异步发送</p>
<p>存储端 对于存储端，要保证消息顺序，会有以下几个问题： （1）<strong>消息不能分区</strong>。也就是1个topic，只能有1个队列。在Kafka中，它叫做partition；在RocketMQ中，它叫做queue。 如果你有多个队列，那同一个topic的消息，会分散到多个分区里面，自然不能保证顺序。</p>
<p>（2）即使只有一个队列的情况下，会有第二个问题。该机器挂了之后，能否切换到其他机器，也就是高可用问题。比如你当前的机器挂了，上面还有消息没有消费完。此时切换到其他机器，可用性保证了。但消息顺序就乱掉了。要想保证，一方面要<strong>同步复制</strong>，不能异步复制；另一方面得保证，切机器之前，挂掉的机器上面，所有消息必须消费完了，不能有残留。难以实现。</p>
<p>接收端 对于接收端，不能并行消费，也即不能开多线程或者多个客户端消费同1个队列。</p>
<p>因此，实际使用中，只需要在存储端控制消息不分区，且接收端只有一个线程去消费，就能保证消息有序消费。</p>
<blockquote>
<p>Kafka经典三大问：</p>
<p>数据有序：不分区，只有一个消费线程</p>
<p>数据丢失：发送端、存储端、接收端</p>
<p>数据重复：Exactly Once</p>
<p>https://cloud.tencent.com/developer/article/1682566</p>
<p>https://blog.csdn.net/weixin_39877754/article/details/108558016</p>
<p>https://www.cnblogs.com/yisany/p/14736360.html</p>
</blockquote>
<p><strong>消费者分配策略</strong></p>
<p>1、Range：用partition数除以消费者线程的总数来决定每个消费者线程消费几个partition，每一个消费者都能获得尽可能多的分区。（比如消费者1就直接消费partitiion 0,1,2,3）</p>
<p>2、RoundRobinAssignor：所有topic的partition按照字典序排序，然后通过轮询方式逐个将分区以此分配给每个消费者，即先排序后轮询分配。</p>
<p>3、StickyAssignor：分区的分配尽可能的与上次分配的保持相同。（sticky，粘性）</p>
<h3 id="java">Java</h3>
<h4 id="静态">静态</h4>
<p><strong>静态类的加载过程</strong></p>
<p>Java源码到执行的过程，从JVM的角度看可以总结为四个步骤：编译-&gt;加载-&gt;解释-&gt;执行。</p>
<p>编译后的class文件加载到JVM中。</p>
<p>加载又可以细分步骤为：加载-&gt;连接-&gt;初始化。</p>
<p>加载：通过双亲委派机制把.class文件加载至JVM。</p>
<p>连接：对.class的信息进行验证，为类的静态变量分配内存空间并对其赋默认值。</p>
<p>初始化：为类的静态变量赋值为正确的初始值。收集.class的静态变量、静态代码块、静态方法到clinit()方法，然后初始化。</p>
<p><strong>静态方法和非静态方法的区别</strong></p>
<table>
<thead>
<tr class="header">
<th></th>
<th>静态方法</th>
<th>非静态方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>访问变量</td>
<td>可以访问static修饰的变量<br>不能访问非static修饰的变量</td>
<td>都可以访问</td>
</tr>
<tr class="even">
<td>调用方法</td>
<td>只能调用static修饰的方法</td>
<td>都可以调用</td>
</tr>
<tr class="odd">
<td>是否实例化才能调用</td>
<td>不需要类实例化出对象，就能通过 类名.方法名 调用</td>
<td>需要实例化对象，通过 对象.方法名 调用</td>
</tr>
<tr class="even">
<td>super和this关键字</td>
<td>不能使用</td>
<td>可以使用</td>
</tr>
</tbody>
</table>
<h4 id="单例模式">单例模式</h4>
<p><strong>单例模式是什么</strong></p>
<p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例。</p>
<p>该类包括：</p>
<p>1、持有私有静态实例</p>
<p>2、私有构造方法，防止被实例化</p>
<p>3、静态公共获取方法，创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 私有构造方法，防止被实例化 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 静态公共方法，创建实例 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 线程安全</span></span><br><span class="line"><span class="comment">	public static Singleton getInstance() &#123;</span></span><br><span class="line"><span class="comment">		if (instance == null) &#123;</span></span><br><span class="line"><span class="comment">			synchronized (instance) &#123;</span></span><br><span class="line"><span class="comment">				if (instance == null) &#123;</span></span><br><span class="line"><span class="comment">					instance = new Singleton();</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		return instance;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>懒汉式和饿汉式</strong></p>
<p>1、饿汉式：在程序启动或单件模式类被加载的时候，单件模式实例就已经被创建。</p>
<p>2、懒汉式：当程序第一次访问单件模式实例时才进行创建。</p>
<p>如何选择：如果单件模式实例在系统中经常会被用到，饿汉式是一个不错的选择。</p>
<p><strong>单例模式构造函数有参数是否可行</strong></p>
<p>不可行，单例模式本身就要求只有一个实例，传入不同参数意味着需要多种不同的实例，而且本身构造方法就是私有化的不可以传入参数。</p>
<p><strong>单例模式下多线程访问单例</strong></p>
<p>懒汉式：</p>
<p>优点：实例在被使用的时候才被创建，可以节省系统资源，体现了延迟加载的思想。</p>
<p>缺点：由于系统刚启动时且未被外部调用时，实例没有创建；如果同一时间有多个线程同时调用方法获取单例很有可能会产生多个实例。</p>
<p>因此，需要使用双重检查机制</p>
<p>1、第一次检查实例是否存在，如果不存在才进入同步块</p>
<p>2、第二次进入同步块之后再次检查实例是否存在，如果不存在才真正地创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicstaticLazySingletongetLazyInstance()&#123;</span><br><span class="line">     <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">    <span class="keyword">if</span>(lazyInstance==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="comment">//同步块，线程安全地创建实例</span></span><br><span class="line">         <span class="keyword">synchronized</span>（LazySingleton.class）&#123;</span><br><span class="line">             <span class="comment">//再次检查实例是否存在，如果不存在才真正地创建实例</span></span><br><span class="line">             <span class="keyword">if</span>(lazyInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">              	lazyInstance = newLazySingleton();</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazyInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双重检查得以成功的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程 <span class="number">1</span> 进入 getInstance() 方法。 </span><br><span class="line"></span><br><span class="line">由于 instance 为 <span class="keyword">null</span>，线程 <span class="number">1</span> 进入 <span class="keyword">synchronized</span> 块。 </span><br><span class="line"></span><br><span class="line">线程 <span class="number">1</span> 被线程 <span class="number">2</span> 预占</span><br><span class="line"></span><br><span class="line">线程 <span class="number">2</span> 进入 getInstance() 方法。</span><br><span class="line"></span><br><span class="line">由于 instance 仍旧为 <span class="keyword">null</span>，线程 <span class="number">2</span> 试图获取锁。然而，由于线程 <span class="number">1</span> 持有该锁，线程 <span class="number">2</span> 阻塞。</span><br><span class="line"></span><br><span class="line">线程 <span class="number">2</span> 被线程 <span class="number">1</span> 预占。</span><br><span class="line"></span><br><span class="line">线程 <span class="number">1</span> 执行，由于实例仍旧为 <span class="keyword">null</span>，线程 <span class="number">1</span> 还创建一个 Singleton 对象并将其引用赋值给 instance。</span><br><span class="line"></span><br><span class="line">线程 <span class="number">1</span> 退出 <span class="keyword">synchronized</span> 块并从 getInstance() 方法返回实例。 </span><br><span class="line"></span><br><span class="line">线程 <span class="number">1</span> 被线程 <span class="number">2</span> 预占。</span><br><span class="line"></span><br><span class="line">线程 <span class="number">2</span> 获取锁并检查 instance 是否为 <span class="keyword">null</span>。 </span><br><span class="line"></span><br><span class="line">由于 instance 是非 <span class="keyword">null</span> 的，并没有创建第二个 Singleton 对象，由线程 <span class="number">1</span> 创建的对象被返回。</span><br></pre></td></tr></table></figure>
<h4 id="垃圾回收">垃圾回收</h4>
<p><strong>垃圾回收方法</strong></p>
<p>回收那些没有被引用的对象占用的内存空间。</p>
<p>标记清除：通过可达性算法，将存活的对象进行标记，将要被回收的空间用空闲链表连接，分配给其他对象。</p>
<p>标记整理：通过可达性算法，将存活的对象进行标记，移动它们到一侧，并用空闲指针指向可以分配的位置。</p>
<p>复制算法：Eden区和两个Survior区，每次只使用一个Survior区，然后GC的时候将仍然存活的对象复制到空闲的Survior区。</p>
<p><strong>垃圾收集器</strong></p>
<p>CMS</p>
<p>CMS全称 Concurrent Mark Sweep（并发的标记-清除算法）垃圾回收器，该回收器是针对老年代垃圾回收，以响应速度优先为目的，常用于B/S结构（Browser/Server，浏览器/服务器模式）中服务器端的垃圾回收，主要分为四个步骤：</p>
<p>1、初始标记 ：stw，标记GC Roots能直接关联到的对象。</p>
<p>2、并发标记 ：以 GC Roots 为起始点进行搜索，将可达的存活对象标记。该阶段与工作线程并发执行。</p>
<p>3、重新标记 ：stw，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记。</p>
<p>（这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短）</p>
<p>4、并发清理 ：内存回收阶段，将死亡的内存对象占用的空间增加到一个空闲列表(free list)，供以后的分配使用。</p>
<blockquote>
<p>当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。</p>
</blockquote>
<p>G1</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>0907字节二面</title>
    <url>/2021/09/08/%E9%9D%A2%E8%AF%95_0907%E5%AD%97%E8%8A%82%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="操作系统">操作系统</h3>
<h4 id="虚拟内存">虚拟内存</h4>
<p>虚拟内存，是一种内存管理技术，为每个进程提供了⼀个连续私有的地址空间。可以把内存扩展到硬盘空间，使得程序认为它拥有连续的可用的内存（一个连续完整的地址空间），但实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘上，在需要时进行数据交换。</p>
<p>1、程序可以使⽤相邻的虚拟地址来访问物理内存中不相邻的内存缓冲区。</p>
<p>2、程序可以使⽤虚拟地址来访问⼤于可⽤物理内存的空间。</p>
<p>3、不同进程使⽤的虚拟地址彼此隔离，无法修改对方的物理内存。</p>
<a id="more"></a>
<h4 id="进程线程">进程线程</h4>
<p><strong>进程和线程的区别</strong></p>
<p>1、进程是资源分配的最小单位，线程是CPU调度的最小单位</p>
<p>2、进程有自己的独立地址空间，线程没有（线程依托进程存在）</p>
<p>3、进程间的信息难以共享，线程可以通过共享的数据进行通信。</p>
<blockquote>
<p>由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信（inter-process communication，简称IPC）方式，在进程间进行信息交换。</p>
<p>线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。</p>
</blockquote>
<p>4、进程切换的开销为什么比线程大。</p>
<p><strong>进程切换的开销为什么比线程大</strong></p>
<p>切换和调度是一个概念，都是为了保证所有进程可以得到公平的执行机会，使得多个进程间可以并发执行。</p>
<p>进程切换：</p>
<p>进程切换时</p>
<ul>
<li>由于不同进程间的虚拟地址是不同的，会涉及到缺页中断和页面置换的问题。</li>
<li>还需要保存虚拟内存，栈，全局变量等用户空间的资源，以及内核堆栈，寄存器等内核空间的状态。</li>
</ul>
<p>所以开销比较大。</p>
<p>线程切换：</p>
<p>如果前后两个线程属于同一个进程。</p>
<ul>
<li>此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，缺页中断的概率也会降低。</li>
<li>只需要切换线程的私有数据、寄存器等不共享的数据。</li>
</ul>
<blockquote>
<p>https://www.hiyu.space/2021/01/31/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/</p>
<p>https://blog.csdn.net/GMPY_Tiger/article/details/86467830</p>
<p>https://www.cnblogs.com/qingbaizhinian/p/13775327.html#_label1</p>
</blockquote>
<p><strong>线程与页面置换</strong></p>
<p>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。会涉及到缺页中断和页面置换的问题。</p>
<h3 id="java">Java</h3>
<h4 id="arraylist">ArrayList</h4>
<p><strong>介绍一下ArrayList，要注意一些什么</strong></p>
<p>ArrayList是一个底层用数组实现的队列，能够动态地增加和减少元素。</p>
<p><strong>ArrayList扩容</strong></p>
<p>首先将原元素数组的长度增大1.5倍，然后将旧数组拷贝到扩容后的新数组中。删除元素时是不会导致容量缩减的，因为维护数组容量的变化会带来性能的损耗，因此采用空间换时间的策略牺牲部分内存提高响应速度。</p>
<p><strong>ArrayList线程安全</strong></p>
<p>对ArrayList进行添加元素的操作的时候是分两个步骤进行的：</p>
<p>1、先在object[size]的位置上存放需要添加的元素。</p>
<p>2、将size的值增加1。</p>
<p>由于这个过程在多线程的环境下是不能保证具有原子性的，因此ArrayList在多线程的环境下是线程不安全的。</p>
<p>如果非要在多线程的环境下使用ArrayList，就需要保证它的线程安全性，通常有两种解决办法：</p>
<p>1、使用synchronized关键字；</p>
<p>2、换成线程安全的CopyOnWriteArrayList</p>
<blockquote>
<p>CopyOnWriteArrayList是个线程安全且读操作无锁的ArrayList。</p>
<p>读操作是无锁的。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</p>
<p>优点：读多写少的并发场景，在使用迭代器进行遍历时候，若中途有别的线程对容器进行修改，就不会抛出异常了。</p>
<p>缺点：</p>
<p>1、内存占用，需要拷贝数组</p>
<p>2、无法保证实时性，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</p>
</blockquote>
<h4 id="垃圾回收">垃圾回收</h4>
<p><strong>垃圾回收方法</strong></p>
<p>回收那些没有被引用的对象占用的内存空间。</p>
<p>标记清除：通过可达性算法，将存活的对象进行标记，将要被回收的空间用空闲链表连接，分配给其他对象。</p>
<p>标记整理：通过可达性算法，将存活的对象进行标记，移动它们到一侧，并用空闲指针指向可以分配的位置。</p>
<p>复制算法：Eden区和两个Survior区，每次只使用一个Survior区，然后GC的时候将仍然存活的对象复制到空闲的Survior区。</p>
<p><strong>算法分别适用于哪些场景</strong></p>
<p>堆内存被分为新生代和老年代。</p>
<p>新生代用复制，老年代用标记清除或标记整理。</p>
<p>新生代用复制：</p>
<ul>
<li>新生代中，每次垃圾回收都可以释放大量的对象，只有少部分存活，所以只有少部分对象要被复制到保留区中，这也意味着复制并不会太耗时。</li>
<li>除此之外，直接释放被使用的空间的全部内存，比一段一段释放的效率也要高很多。</li>
<li>同时，对象被复制到另外一个区域时，会被整齐地摆放，所以不会出现内存碎片，所以能够更简单地分配空间。</li>
</ul>
<p>老年代用标记清除或标记整理：</p>
<p>对于老年代而言，每次垃圾回收只能释放小部分空间，若使用复制算法，每次将需要做大量复制，所以不适合使用复制算法，因此在老年代中，一般使用标记—清除或者标记—整理算法。</p>
<blockquote>
<p>https://www.cnblogs.com/tuyang1129/p/12508216.html</p>
</blockquote>
<h3 id="算法">算法</h3>
<p>岛屿问题</p>
<h3 id="实习">实习</h3>
<p>介绍实习项目。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>0924 CDG一面</title>
    <url>/2021/09/24/%E9%9D%A2%E8%AF%95_0924CDG%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h4 id="海量数据找top-100账号出现次数">海量数据找Top 100账号出现次数</h4>
<p>1、Hash(账号) % 桶数量 = 小文件id。把账号分离到多个小文件中。</p>
<blockquote>
<p>理想情况下每个小文件的大小应该恰好等于内存容量</p>
</blockquote>
<p>2、对于每一个小文件，在内存中构建一个账号为Key，统计次数为Value的一个HashMap，统计每个账号的出现次数。</p>
<p>把HashMap的结果保存在磁盘上。</p>
<blockquote>
<p>如果小文件数量远大于100个，那么对每个小文件就只需要保存统计次数最多的那个账号。</p>
</blockquote>
<p>3、在内存中构建一个有100个节点的最小堆，堆中的每个节点保存了HashMap中的Key-Value的数据，只是堆调整的依据是Value值，也就是统计次数。</p>
<p>将每个小文件对应的HashMap读取进入内存，把Key-Value数据入堆，最后剩下的账号就是Top 100。</p>
<blockquote>
<p>如果内存足够，也可以直接把账号-次数的数据读取进来做全局排序，因为此时每个小文件只有一个账号。</p>
<p>如果每个HashMap太大，那么就需要在第2步构建一个按照Value排序的HashMap，然后取前100个数据保存下来即可。</p>
</blockquote>
<a id="more"></a>
<p>如果每个小文件里面的Key的数量很多怎么办？</p>
<p>增加桶的数量，将文件分的更小，把Key打散。</p>
<p>如果单个小文件太大怎么办？</p>
<p>分块读取这个小文件。</p>
<h4 id="海量数据找账号出现次数的中位数">海量数据找账号出现次数的中位数</h4>
<p>首先还是得求出每个账号的出现次数，然后利用海量数据找中位数的原理。</p>
<h4 id="海量数据找中位数">海量数据找中位数</h4>
<p>1、外部排序</p>
<p>把所有数据分割成内存能够装载下的大小，每次内存读取一个小文件进行排序，再对所有小文件进行多路归并（2路、3路等，取决于内存大小）。得到所有数据的排序结果后扫描即可得到中位数。</p>
<p>2、堆排序</p>
<p>在内存中建立的最大堆（找最小值），然后每次寻找第k大的元素，直到中间。</p>
<blockquote>
<p>对于10G的数据，它的中位数就是第5G个元素，按常理来说需要构建一个5G大小的堆，但是允许的内存只有2个G，所以先构建一个1G大小的大顶堆，然后求出第1G个元素（根节点），然后利用该元素构建一个新的1G大小的堆，只有大于第1G个元素的数据才能入堆，最后剩下来的就是1G-2G之间的元素，则根节点就是第2G大的元素。依次类推，求出第5G大的元素。</p>
<p>每次构建一个堆求第几G大的元素，都需要重新遍历完所有10G的数据，相当于要遍历5 * 10G次，这需要频繁的IO操作，需要不断的从硬盘中读取数据。</p>
</blockquote>
<p>3、其他？</p>
<p>因为涉及到排序，可以用桶排序、或者位图。</p>
<blockquote>
<p>https://zhuanlan.zhihu.com/p/75397875</p>
</blockquote>
<h4 id="spark-sql底层原理">Spark SQL底层原理</h4>
<p>https://blog.csdn.net/qq_30031221/article/details/109222355</p>
<p>https://www.cnblogs.com/code2one/p/10162632.html</p>
<p>https://juejin.cn/post/6886355913592602631#heading-16</p>
<h4 id="kafka消费者和消费者组有什么区别">Kafka消费者和消费者组有什么区别</h4>
<p>消费者组中包含了多个消费者。</p>
<p>当消息发布到topic后，只会被投递给订阅它的每个消费组中的一个消费者。</p>
<p>每个topic的一个分区，对应一个消费者组中的一个消费者。</p>
<p>一个topic，可以被多个消费者组订阅。</p>
<h4 id="如何设计一个hashmap">如何设计一个HashMap</h4>
<p>1、Hash函数：运算要快，还需要分布均匀，减少 hash 碰撞。</p>
<p>2、Hash冲突：链表+红黑树。</p>
<p>3、Hash扩容：解决Hash冲突的本质方案。（Java8长度扩为原来2倍，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。Java7只能根据Key值重新计算数据所在的位置）</p>
<p>4、高并发：（1）HashTable：直接加锁锁住整个数组。（2）ConcurrentHashMap：读操作volatile，写操作只锁住数组中一个元素，且是cas+synchronized机制（降低锁粒度）。（3）自定义CopyOnWrite的数据结构。</p>
<blockquote>
<p>https://tech.meituan.com/2016/06/24/java-hashmap.html</p>
</blockquote>
<h4 id="java垃圾回收">Java垃圾回收</h4>
<h4 id="hdfs副本机制">HDFS副本机制</h4>
<h4 id="算法题气球游戏">算法题：气球游戏</h4>
<h4 id="智力题电梯">智力题：电梯</h4>
<p>两台电梯，如何合理安排使得运输时间较优。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>0925 CDG二面</title>
    <url>/2021/09/24/%E9%9D%A2%E8%AF%95_0925CDG%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<h4 id="hive-sql的底层执行原理">Hive SQL的底层执行原理</h4>
<p>Parser、Analyser、Optimizer、Planner、Code Generation、Executor。</p>
<h4 id="optimizer优化时采用的分区裁剪">Optimizer优化时采用的分区裁剪</h4>
<p>分区裁剪就是只读取需要的分区，比如指定时间是今年的分区读取。</p>
<p>谓词下推就是将 SQL 语句中的 where 谓词逻辑都尽可能提前执行。</p>
<blockquote>
<p>https://github.com/LiuPengKun1993/Articles/blob/master/contents/BigData/%E6%B5%85%E8%B0%88%20Hive%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md</p>
</blockquote>
<h4 id="hive分区覆盖已有分区的数据会发生什么">Hive分区覆盖已有分区的数据会发生什么</h4>
<p>Hive不支持对同一张表或分区进行并发数据插入，这样会导致多个任务操作同一个数据临时目录，一个任务将另一个任务的数据移走，导致任务失败。</p>
<p>只能在单个任务下对同一个分区的数据采用insert overwrite语句实现分区覆盖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> overwrite <span class="keyword">TABLE</span> test <span class="keyword">PARTITION</span> (<span class="keyword">month</span> <span class="operator">=</span> ‘<span class="number">2015</span><span class="number">-06</span>′,<span class="keyword">day</span> <span class="operator">=</span> ‘<span class="number">2015</span><span class="number">-06</span><span class="number">-15</span>′)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure>
<p>insert into 则是以追加的方式写入数据。</p>
<a id="more"></a>
<h4 id="hive中某个分区有文件正在被读取又同时有数据写入会发生什么">Hive中某个分区有文件正在被读取，又同时有数据写入会发生什么</h4>
<p>Hive不支持并发的读写操作，同时进行读写的话会抛出异常（读的时候文件消失了读不到）。</p>
<p>当 A 用户执行 select count 过程中，B 用户提交 insert overwrite。B 用户的命令不会被阻塞，会立即执行，而 A 用户执行到一半的 MapReduce 就会<strong>出错抛出异常</strong>。而在关系型数据库里，B 的命令同样不阻塞，但由于 MVCC 机制，A 的结果不受 B 影响。</p>
<p>又比如 A 用户在执行 insert overwrite 操作过程中，B 用户提交了 drop table，B 的命令也会立即执行，而 A 的操作就会<strong>出错抛出异常</strong>。在 mysql 中，只有 A 提交了 commit，B 的命令才会执行。</p>
<p>hive 并发问题的解决思路：</p>
<p>读操作需要共享锁，写操作需要排他锁。即利用锁机制来解决并发的问题。</p>
<p>元信息和数据的变更需要互斥锁，数据的读取需要共享锁。</p>
<p>关闭锁机制会造成下面影响：</p>
<p>并发读写同一份数据时，读操作可能会随机失败。</p>
<p>并发写操作的结果在随机出现，后完成的任务覆盖之前完成任务的结果。</p>
<blockquote>
<p>https://www.dazhuanlan.com/al23256/topics/1062367</p>
<p>https://www.modb.pro/db/43858</p>
<p>https://zhuanlan.zhihu.com/p/82039596</p>
</blockquote>
<h4 id="hive中实现大表join小表map-join">Hive中实现大表join小表（Map Join）</h4>
<p>实现原理：</p>
<p>因为Hive底层就是基于HDFS的，所以它的Map Join的实现原理不是像Spark一样去广播小表，而是直接从HDFS中将这个小表读取到每个机器节点的内存中，这样就可以实现在Map端进行Join的操作。</p>
<p>开启方法：</p>
<p>在Hive早期的版本中，需要使用hint提示/<em>+ mapjoin(table) </em>/才会执行Map Join。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="comment">/*+MAPJOIN(smalltable)*/</span></span><br><span class="line">		big.key <span class="keyword">AS</span> key,</span><br><span class="line">		big.value <span class="keyword">AS</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">FROM</span> smalltable small</span><br><span class="line"><span class="keyword">JOIN</span> bigtable big</span><br><span class="line"><span class="keyword">ON</span> small.key<span class="operator">=</span>big.key</span><br></pre></td></tr></table></figure>
<p>在Hive现在的版本中，通过配置属性来设置Map Join的触发时机：</p>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>hive.auto.convert.join</td>
<td>默认值为true，自动开户MAPJOIN优化</td>
</tr>
<tr class="even">
<td>hive.mapjoin.smalltable.filesize</td>
<td>默认值为2500000(25M),通过配置该属性来确定使用该优化的表的大小，如果表的大小小于此值就会被加载进内存中</td>
</tr>
</tbody>
</table>
<blockquote>
<p>https://blog.csdn.net/qq_41018861/article/details/112238592</p>
</blockquote>
<h4 id="hive输出的小文件过多怎么解决">Hive输出的小文件过多怎么解决</h4>
<p>1、通过设置Hive的配置项，在任务结束后对结果文件进行合并。当输出文件的平均大小小于某个设置的阈值时，启动一个独立的map-reduce任务进行文件merge。</p>
<p>2、通过设置Hive的配置项，启动Hadoop Archive，即Hadoop归档文件HAR，将许多小文件打包到更大的HAR文件中，本质上利用了多级目录。</p>
<p>3、通过设置Hive的配置项，如果数据存储的格式不是TexFile而是其他的序列化存储格式（SequenceFile），则开启数据压缩。</p>
<blockquote>
<p>https://blog.csdn.net/lzm1340458776/article/details/43567209</p>
</blockquote>
<h4 id="hive-sql和spark-sql的区别或者是spark为什么比mr快">Hive SQL和Spark SQL的区别？或者是Spark为什么比MR快？</h4>
<p>MR与Spark的区别，内存、算子、容错。</p>
<h4 id="hive-order-by单机十倍以上数据怎么排序">Hive Order By单机十倍以上数据怎么排序</h4>
<p>1、就是采用桶排序的策略啊！按照某个字段分桶，把数据打散到多台机器上进行排序，然后加上统计的偏移量就可以得到啊！</p>
<blockquote>
<p>不知道当时为什么讲了桶排序之后又问了一个一摸一样的问题。。。</p>
</blockquote>
<p>2、使用sort by，先让每个reducer输出有序的文件，再采用外部排序的方法获得全局有序的文件。</p>
<p>3、增加单台机器的资源。</p>
<h4 id="算法力扣字符串的排列">算法：力扣字符串的排列</h4>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive</title>
    <url>/2021/07/24/%E9%9D%A2%E8%AF%95_Hive/</url>
    <content><![CDATA[<p>Hive数据倾斜</p>
<p><strong>Hive中order by，sort by，distribute by，cluster by的区别</strong></p>
<p>order by：会对输入做全局排序，因此只有一个Reducer，导致当输入规模较大时，消耗较长的计算时间。</p>
<p>sort by：不是全局排序，其在数据进入reducer前完成排序，因此，如果用sort by进行排序，并且设置mapred.reduce.tasks&gt;1，则sort by只会保证每个reducer的输出有序，并不保证全局有序。对输出的数据再执行归并排序，即可得到全部结果。</p>
<p>distribute by：根据字段的hash值和reducer的个数进行模除后，余数相同的分到一个区。将具有相同字段的map输出分发到一个reduce节点上做处理。</p>
<p>cluster by：如果 distribute by 和 sort by 中所用的列相同，就可以缩写为 cluster by。</p>
<a id="more"></a>
<p><strong>Hive内部表和外部表的区别</strong></p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 46%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>内部表（默认）</th>
<th>外部表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>修饰符</td>
<td>无</td>
<td>external</td>
</tr>
<tr class="even">
<td>管理者</td>
<td>Hive</td>
<td>HDFS</td>
</tr>
<tr class="odd">
<td>删除结果</td>
<td>删除内部表会直接删除元数据（metadata）及存储数据</td>
<td>删除外部表仅仅会删除元数据，HDFS上的文件并不会被删除</td>
</tr>
<tr class="even">
<td>存储位置</td>
<td>hive.metastore.warehouse.dir指定，默认认：/user/hive/warehouse</td>
<td>由建表语句LOCATION参数指定，如果没有指定则Hive将在HDFS上的/user/hive/warehouse文件夹下以外部表的表名创建一个文件夹，并将属于这个表的数据存放在这里</td>
</tr>
</tbody>
</table>
<p><strong>Hive join原理</strong></p>
<p>Reduce Join</p>
<p>Map阶段：为了构造Key-Value型数据，以on 条件中的字段为 key（on中有多个字段，则将其组合后作为key），以select 或者 where 中用到的字段为value；同时在 value 中还会包含表的 Tag 信息，用于标明此 value 对应哪个表。</p>
<p>Shuffle 阶段：将数据根据Key进行hash，传送到不同的reducer中，相同Key的数据在同一个reducer中（同一个reducer中的key却不一定相同）。</p>
<p>Reduce阶段：对相同Key值的这些数据，根据select语句进行处理，把来自不同表的数据进行组合。</p>
<p><img src="/2021/07/24/%E9%9D%A2%E8%AF%95_Hive/image-20210724120435658.png" alt="image-20210724120435658" style="zoom:67%;"></p>
<p>Map Join</p>
<p>适用于大表连接小表的场景。</p>
<p>前提：小表在每个mapper上有完整的拷贝，常使用Distributed Cache将小表分发到各个节点上</p>
<p>Map Join把小表全部读入内存中，在Map阶段直接用大表的部分数据和内存中小表数据做连接，直接输出结果，没有shuffle和reduce的阶段，因此有多少个mapper就有多少个结果文件。</p>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark</title>
    <url>/2021/07/24/%E9%9D%A2%E8%AF%95_Spark/</url>
    <content><![CDATA[<a id="more"></a>
<p><strong>spark 中一个worker有多少executor ？</strong></p>
<p>最直接的方式worker上有多少个cpu core就克制配置多少个executor，当然可以根据cpu的性能、每个做调整。跑在yarn上也一样，根据container来，container一般也是根据cpu core来计算数量的。</p>
<p><strong>spark提交参数含义</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spark-submit</span><br><span class="line">--master yarn </span><br><span class="line">--deploy-mode client </span><br><span class="line">--class com.practiceSpark.jar</span><br><span class="line">--executor-memory 10G </span><br><span class="line">--num-executors 20 </span><br><span class="line">--executor-cores 2 </span><br><span class="line">--driver-memory 8g </span><br><span class="line">--queue spark </span><br><span class="line">--conf spark.driver.maxResultSize=6G </span><br><span class="line">--conf spark.network.timeout=300 </span><br><span class="line">--conf spark.executor.heartbeatInterval=30 </span><br><span class="line">-conf spark.task.maxFailures=4 </span><br><span class="line">--conf spark.speculation=<span class="literal">true</span> </span><br><span class="line">--conf spark.shuffle.service.enabled=<span class="literal">true</span> </span><br><span class="line">--conf spark.executor.memoryOverhead=8g  </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>--master</td>
<td>master 的地址，提交任务到哪里执行，例如 spark://host:port, yarn, local</td>
</tr>
<tr class="even">
<td>--deploy-mode</td>
<td>在本地 (client) 启动 driver 或在 cluster 上启动，默认是 client</td>
</tr>
<tr class="odd">
<td>--class</td>
<td>应用程序的主类，仅针对 java 或 scala 应用</td>
</tr>
<tr class="even">
<td>--name</td>
<td>应用程序的名称</td>
</tr>
<tr class="odd">
<td>--packages</td>
<td>包含在driver 和executor 的 classpath 中的 jar 的 maven 坐标</td>
</tr>
<tr class="even">
<td>--driver-memory</td>
<td>Driver内存，默认 1G</td>
</tr>
<tr class="odd">
<td>--driver-cores</td>
<td>Driver 的核数，默认是1。在 yarn 或者 standalone 下使用</td>
</tr>
<tr class="even">
<td>--executor-memory</td>
<td>每个 executor 的内存，默认是1G</td>
</tr>
<tr class="odd">
<td>--executor-core</td>
<td>每个 executor 的核数。在yarn或者standalone下使用</td>
</tr>
<tr class="even">
<td>--conf PROP=VALUE</td>
<td>指定 spark 配置属性的值，</td>
</tr>
</tbody>
</table>
<p><strong>spark执行页面关注什么</strong></p>
<p>代表executors页面</p>
<p>这里可以看到执行者申请使用的内存以及shuffle中input和output等数据。比较常用了，一方面通过它可以看出来每个excutor是否发生了数据倾斜，另一方面可以具体分析目前的应用是否产生了大量的shuffle，是否可以通过数据的本地性或者减小数据的传输来减少shuffle的数据量。</p>
<p><img src="/2021/07/24/%E9%9D%A2%E8%AF%95_Spark/image-20210724152629279.png" alt="image-20210724152629279" style="zoom:67%;"></p>
<blockquote>
<p>其他UI界面</p>
<p>https://blog.csdn.net/u013013024/article/details/73498508</p>
</blockquote>
<p><strong>spark类型推断</strong></p>
<p>在spark中，假如需要将读取的数据集，转换成表格的形式，使得它能够支持SQL，那么需要知道这个表的schema，即表结构，有两种方式能够实现这样的操作：</p>
<p>1、通过反射推断出Schema：即定义case class样例类，从指定的地址创建RDD后，将RDD中的数据映射乘case class，通过隐式转换转成DF。</p>
<p>2、通过StructType直接指定Schema：通过StructType直接指定每个字段的Schema,相当于是表的描述信息，在createDataFrame中传入这个StructType，将RDD转为数据表</p>
<p><strong>spark中两个表join不产生shuffle</strong></p>
<p>当两个rdd分区数和分区方式一样时做join就不会产生shuffle，因为分区数和分区方式一样的时候，相同Key的数据都在同一个机器上，发生join操作时可以在本机上执行，不需要数据迁移，所以不会发生shuffle。</p>
<p>（在join之前给两个RDD增加groupByKey()算子，发生shuffle）</p>
<p><strong>参考资料</strong></p>
<p>https://www.cnblogs.com/hexu105/p/8182472.html （spark执行页面）</p>
<p>https://blog.csdn.net/tototuzuoquan/article/details/74936717（自动推断）</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/2021/07/23/%E9%9D%A2%E8%AF%95_%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="分布式锁">分布式锁</h3>
<p>https://blog.csdn.net/wuzhiwei549/article/details/80692278</p>
<h3 id="分布式事务">分布式事务</h3>
<p>https://zhuanlan.zhihu.com/p/183753774</p>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 01 计算机系统概述</title>
    <url>/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>程序生命周期</td>
<td>创建、编译、运行、退出</td>
</tr>
<tr class="even">
<td>编译过程</td>
<td>预处理（头文件插入）、编译（词法分析等）、汇编（汇编转机器指令）、链接（插入库函数）</td>
</tr>
<tr class="odd">
<td>编译过程使用场景</td>
<td>优化程序性能、解决链接错误、安全漏洞</td>
</tr>
<tr class="even">
<td>硬件组成</td>
<td>CPU（PC、Reg、ALU）、内存、总线、IO设备</td>
</tr>
<tr class="odd">
<td>存储设备</td>
<td>寄存器、L1、L2、L3、内存、硬盘、远程服务器（由内而外，越来越慢）</td>
</tr>
<tr class="even">
<td>程序执行流程</td>
<td>1.命令读入寄存器 2.程序从磁盘加载入内存 3.CPU从内存读数据计算 4.数据从内存到寄存器再到IO设备</td>
</tr>
<tr class="odd">
<td>操作系统</td>
<td>在计算机硬件和应用程序之间提供通用服务的系统软件。</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="程序的生命周期">程序的生命周期</h3>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220317104428043.png" alt="image-20220317104428043" style="zoom:50%;"></p>
<h3 id="编译过程">编译过程</h3>
<p>编译系统的大致过程如下，以C程序为例，说明了一个文本形式的代码如何转变成可执行程序的主要步骤。</p>
<p>文本程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span> ( <span class="string">&quot;h, world\n&quot;</span>) ;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hello hell.c</span><br></pre></td></tr></table></figure>
<p>编译过程：</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220317104955417.png" alt="image-20220317104955417" style="zoom: 67%;"></p>
<ul>
<li><p>预处理</p>
<p>预处理器会根据以#开头的代码，来修改原始程序。例如hello程序中引入了头文件 stdio.h ，预处理器会读取该头文件中的内容，将其中的内容直接<strong>插入到源程序中</strong>，结果就得到了另外一个 C 程序。</p>
<p>这个经过预处理器处理后得到的文件通常以 .i 结尾。本质上， hello.c 经过预处理器后得到 hello.i，这个 hello.i 仍旧是一个文本文件。</p></li>
<li><p>编译</p>
<p>编译这一阶段包括词法分析、语法分析、语义分析、中间代码生成以及优化等等一系列的中间操作。具体详细过程参考《编译原理》。</p>
<p>编译器将 hello.i 文件翻译成 hello.s 文件（包含<strong>汇编语言的程序</strong>），这一过程称为编译。</p></li>
<li><p>汇编</p>
<p>汇编器根据指令集将汇编程序 hello.s 翻译成<strong>机器指令</strong>，并且把这一系列的机器指令按照固定的规则进行打包，得到可重定位目标文件 hello.o 。</p>
<p>此时 hello.o 虽然是一个二进制的文件，但是还不能执行。</p></li>
<li><p>链接</p>
<p>链接的过程主要是将汇编产生的目标文件和所使用的<strong>库函数</strong>的目标文件链接生成一个可执行文件的过程。</p>
<p>在 hello 这个程序中，调用了printf 函数，这个函数是标准C库中的一个函数，每一个C语言的编译器都会提供。通俗的讲就是当你调用 printf 这个函数时，编译器就知道你要在屏幕上打印输出内容，它会将这行代码翻译成计算机可以理解的指令。</p>
<p>这个printf 函数在是在名为 printf.o 的文件中，这个文件是一个提前编译好的目标文件，链接器(ld）负责把 hello.o 和 printf.o 进行合并，当然这个合并是要遵循一定规则的。</p>
<p>正是因为链接器要对 hello.o 和 printf.o 的进行调整，所以 hello.o 才会被称之为可重定位目标文件。最终经过链接阶段可以得到可执行目标文件 hello，就可以被加载到内存中执行了。</p>
<blockquote>
<p>广义的链接指的是：</p>
<p>链接（linking）是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（或被拷贝）到存储器并执行。</p>
<p>需要强调的是，链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器（loader）加载到存储器并执行时；甚至执行于运行时（run time），由应用程序来执行。</p>
</blockquote></li>
</ul>
<h3 id="了解编译过程的益处">了解编译过程的益处</h3>
<p>这里其实提示了在什么场景下需要通过分析编译过程来解决问题。</p>
<ul>
<li><p>优化程序的性能</p>
<p>当需要对比不同语句的性能，或是分析开销时，通过对比编译器把不同的C代码转换成的机器代码，可以对代码进行优化。</p></li>
<li><p>解决链接过程中出现的错误</p>
<p>大型系统中通常涉及到大量函数库的调用，可能在链接过程中出错。</p></li>
<li><p>避免安全漏洞</p>
<p>缓冲区溢出（buffer overflow）是导致互联网安全漏洞的主要原因。理解数据和控制信息在程序栈上是如何存储的，能够了解不规范的代码可能会引起怎样的安全漏洞。</p></li>
</ul>
<h3 id="硬件组成">硬件组成</h3>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318124249517.png" alt="image-20220318124249517" style="zoom: 33%;"></p>
<ul>
<li><p>CPU</p>
<p>中央处理单元（Central Processing Unit , CPU），也称处理器。</p>
<ul>
<li><p>PC（Program Count）</p>
<p>PC 本质上是一个大小为一个字的<strong>存储区域</strong>。对于32位的机器，一个字是4个字节；对于64位的机器，一个字就是8个字节。</p>
<p>即PC就是一个4字节或是8字节的存储空间，里面存放的是<strong>某一条指令的地址</strong>。</p>
<p>从系统供电的那一瞬间，直到系统断电，处理器就不断地在执行 PC 指向的指令，然后更新 PC，使其指向下一条要执行的指令。（注意：这个下一条指令与刚刚执行的指令不一定是相邻的）</p></li>
<li><p>寄存器文件（Register File）</p>
<p>CPU 内部的一个存储设备。寄存器文件是由一些单字长的寄存器构成，每个寄存器都有自己唯一的名字。</p>
<p>寄存器可以理解为一个<strong>临时存放数据的空间</strong>。例如我们计算两个变量 a+b 的和，处理器从内存中读取 a 的值暂存在寄存器 X 中，读取 B 的值暂存在寄存器 Y 中，这个操作会覆盖寄存器中原来的数值。</p></li>
<li><p>算数逻辑单元（Arithmatic Logic Unit）</p>
<p>负责执行计算。</p>
<p>在计算a+b时，ALU复制寄存器 X 和 Y 中保存的数值，然后进行算术运算，得到的结果会保存到寄存器 X 或者寄存器 Y 中，此时寄存器中原来的数值会被新的数值覆盖。</p></li>
</ul></li>
<li><p>Main Memory</p>
<p>内存，也称为主存。CPU在执行程序时，内存主要存放程序指令以及数据。</p>
<p>从物理上讲，内存是由随机动态存储器芯片组成；从逻辑上讲，内存可以看成一个从零开始的大数组，每个字节都有相应地址。</p></li>
<li><p>Bus</p>
<p>总线，负责将信息从一个部件传递到另外一个部件，包括System Bus、Memory Bus、IO Bus等。</p>
<p>通常总线被设计成传送固定长度的字节块，也就是字（word），根据不同系统而定。</p></li>
<li><p>IO设备</p>
<p>包括键盘、鼠标、显示器以及磁盘等。每一个输入输出设备都通过一个控制器或者适配器与 IO 总线相连。</p>
<p>控制器与适配器主要区别是在于它们的封装方式，无论是控制器还是适配器，它们的功能都是在 IO 设备与 IO 总线之间传递数据。</p></li>
</ul>
<h3 id="存储设备">存储设备</h3>
<p>一般来说，大容量的存储设备的存取速度要比小容量的设备慢，例如在一个计算机系统中，磁盘的容量一般为 TB 级，内存的容量一般为 GB 级，磁盘的容量大概是内存的 1000 倍。各个主要存储设备的常见大小为：</p>
<p><img src="https://img-blog.csdnimg.cn/20210506133045663.png" alt="在这里插入图片描述" style="zoom: 67%;"></p>
<p>对于CPU而言，从磁盘上读取一个字所花费的时间开销比从内存中读取的开销大1000万倍。寄存器文件的只能存储几百个字节的信息，而内存的可以存放几十亿的字节信息（GB级），从寄存器文件读取数据比从内存读取差不多要快 100 倍。</p>
<p>针对处理器和内存之间的差异，系统设计人员在寄存器文件和内存之间引入了高速缓存（cache），比较新的，处理能力比较强的处理器，一般有三级高速缓存，分别为 L1 cache ， L2 cache 以及L3 cache。</p>
<p>L1 cache 的访问速度与访问寄存器文件几乎一样快，容量大小为数万字节（KB 级别）；L2 cache 的访问速度是 L1 cache 的五分之一，容量大小为数十万到数百万字节之间；L3 cache 的容量更大，同样访问速度与 L2 cache 相比也更慢。</p>
<p>整个计算机系统的信息存储可以用一个层次结构来表示：</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318131141756.png" alt="image-20220318131141756" style="zoom:67%;"></p>
<p>从上到下，设备的访问速度越来越慢，容量越来越大，每字节的造价也越来越便宜。这个层次结构的主要思想就是：上一层存储设备是下一层存储设备的高速缓存。例如，寄存器文件就是 L1 的高速缓存，L1 是 L2 的高速缓存，内存是磁盘的高速缓存等等。</p>
<h3 id="可执行文件的运行流程">可执行文件的运行流程</h3>
<ul>
<li><p>hello.c 经过编译系统得到可执行目标文件 hello，此时可执行目标文件 hello 已经存放在系统的磁盘上。</p></li>
<li><p>在 linux 系统上运行可执行程序，打开一个 shell 程序，然后在 shell 中输入相应可执行程序的文件名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./hello</span></span><br></pre></td></tr></table></figure>
<p>shell 是一个命令解释程序，它输出一个提示符<code>&gt;</code>来等待一个命令行的输入，然后执行这个命令，如果该命令行的第一个单词不是内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，对这个文件进行加载并运行。</p></li>
<li><p>通过键盘输入"./hello" 的字符串，shell 程序会将输入的字符逐一<strong>读入寄存器</strong>，CPU会把 hello 这个字符串放入内存中。</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318132215546.png" alt="image-20220318132215546" style="zoom: 50%;"></p></li>
<li><p>当完成输入，按下回车键时，shell 程序就知道我们已经完成了命令的输入，然后执行一系列的指令来来加载可执行文件 hello ，这些指令将 hello 中的数据和代码<strong>从磁盘复制到内存</strong>。数据就是我们要显示输出的 "hello , world" ，这个复制的过程将利用DMA（Direct Memory Access）技术，数据可以不经过处理器，从磁盘直接到达内存。当可执行文件 hello 中的代码和数据被加载到内存中，处理器就开始执行 main 函数中的代码，main 函数非常简单，只有一个打印功能。</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318132338620.png" alt="image-20220318132338620" style="zoom:50%;"></p></li>
<li><p>CPU会将 "hello , world" 这个字符串<strong>从内存复制到寄存器文件</strong>。然后<strong>再从寄存器文件复制到显示设备</strong>，最终hello , world显示在屏幕上。</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318132305981.png" alt="image-20220318132305981" style="zoom:50%;"></p></li>
</ul>
<p>从 hello 程序执行的过程来看，系统即使执行如此简单的程序，数据信息仍旧需要在磁盘、内存、处理器以及 IO 设备之间进行搬运。数据从一个地方搬运到另外一个地方需要花费时间，系统设计人员的一个主要任务就是缩短信息搬运所花费的时间。</p>
<h3 id="操作系统概述">操作系统概述</h3>
<p>无论是 shell 程序还是 hello 程序都没有直接访问键盘、显示器、磁盘这些硬件设备，真正操挫硬件的是操作系统。</p>
<p>可以把操作系统看成是应用程序和硬件之间的中间层，所有的应用程序对硬件的操作必须通过操作系统来完成。</p>
<blockquote>
<p>操作系统（OS）是管理计算机硬件、软件资源并为计算机程序提供通用服务的系统软件。(Wiki)</p>
</blockquote>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318143512568.png" alt="image-20220318143512568" style="zoom:50%;"></p>
<p>这样设计的目的主要有两个：一是防止硬件被失控的应用程序<strong>滥用</strong>（管理软件）；另外一个目的就是操作系统提供统一的机制来控制这些复杂的底层硬件（管理硬件）。</p>
<p>为了实现对软、硬件管理的功能，操作系统引人了几个抽象的概念。例如：文件是对 IO 设备的抽象；虚拟内存是对内存和磁盘 IO 的抽象；进程是对处理器、内存以及 IO 设备的抽象。</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318143921499.png" alt="image-20220318143921499" style="zoom:50%;"></p>
<ul>
<li><p>进程</p>
<p>进程是一个计算机程序的实例，包含程序代码及其行为。一个进程可能由同时执行指令的多个线程组成。</p>
<p>进程的上下文（Context），指的是进程运行所需要的所有状态信息，包括当前 PC 和寄存器的值，以及内存中的内容等等。</p>
<p>现代操作系统中，一个进程实际上由多个线程组成，每个线程都运行在进程的上下文中，共享代码和数据。</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318150523431.png" alt="image-20220318150523431" style="zoom: 50%;"></p>
<p>最开始的时候，只有 shell 进程在运行，即 shell 在等待命合行的输入。</p>
<p>当我们通过 shell 进程加载 hello 进程时，shell 进程通过<strong>系统调用</strong>来执行我们的请求，<strong>系统调用会将控制权</strong>从 shell 进程传递给<strong>操作系统</strong>，操作系统保存 shell 进程的上下文，然后创建一个新的 hello 进程及其上下文，然后将控制权转交给新的 hello 进程。</p>
<p>Hello进程执行完之后，操作系统就会恢复 shell 进程的上下文，并将控制权交给 shell 进程，之后 shell 进程继续等待下一个命令的输入。</p></li>
<li><p>虚拟内存</p>
<p>操作系统为每个进程提供了一个假象，就是每个进程都在独自占用整个内存空间，每个进程看到的内存都是一样的，称之为虚拟地址空间。</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318145915018.png" alt="image-20220318145915018" style="zoom:67%;"></p>
<p>Linux 的虚拟地址空间如图，从下往上看，地址是增大的。最下面是 0 地址。各个部分存放的内容由下往上为：</p>
<ul>
<li>存放<strong>程序的代码和数据</strong>。这个区域的内容是从可执行目标文件中加载而来的，例如我们多次提到的 hello 程序。对所有的进程来讲，代码都是从固定的地址开始。</li>
<li>读写数据区域，存放<strong>全局变量</strong>（C语言中）。</li>
<li>堆（heap）。学过C语言的同学应该用过 malloc 函数，程序中malloc所<strong>申请的内存空间</strong>就在这个堆中。程序的代码和数据区在程序一开始的时候就被指定了大小，但是堆可以在运行时动态的扩展和收缩。</li>
<li>共享库存放区域。这个区域主要存放像C语言的<strong>标准库和数学库</strong>这种共享库的代码和数据，例如 hello 程序中的 printf 函数就是存放在这里。</li>
<li>用户栈（user stack）。程序中<strong>函数调用</strong>的本质就是压栈，即每一次当程序进行函数调用的时候，栈就会增长，函数执行完毕返回时，栈就会收缩。需要注意的是，栈的增长方向是从高地址到低地址。</li>
<li><strong>内核</strong>保留的区域。应用程序代码不能读写这个区域的数据，也不能直接调用内核中定义的函数，也就是说，这个区域对应用程序是不可见的。</li>
</ul>
<blockquote>

</blockquote></li>
<li><p>文件</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220318144108990.png" alt="image-20220318144108990" style="zoom:50%;"></p>
<p>Linux 系统的核心思想之一是：一切皆为文件。</p>
<p>所有的 IO 设备，包括键盘，磁盘，显示器，甚至网络，这些都可以看成文件，系统中所有的输人和输出都可以通过读写文件来完成。</p>
<p>虽然文件的概念非常简单，但却非常强大。例如︰当程序员需要处理读写磁盘上的文件时，他们不需要了解具体的磁盘技术，同一个程序，可以在不同磁盘技术上的不同系统上运行</p></li>
</ul>
<h3 id="系统加速">系统加速</h3>
<h4 id="加速比">加速比</h4>
<p>阿姆达尔定律： 当对系统的某一部分进行加速时，被加速部分的占比和加速程度是影响整体系统性能的关键因素。</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220319103254704.png" alt="image-20220319103254704" style="zoom: 67%;"></p>
<p>如上为阿姆达尔定律公式的推导，其中<span class="math inline">\(\alpha\)</span>表示可以被加速部分的时间占比，<span class="math inline">\(k\)</span>表示加速因子，<span class="math inline">\(S\)</span>表示加速比。</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220319103412509.png" alt="image-20220319103412509" style="zoom:67%;"></p>
<p>当<span class="math inline">\(\alpha=0.6,k=3\)</span>时，可以看到加速了1.67倍。当<span class="math inline">\(k\)</span>趋近于正无穷时，加速比达到2.5，说明如果对系统加速两倍以上时，只有通过优化大部分的组件才能达到。</p>
<h4 id="加速方法">加速方法</h4>
<ul>
<li><p>线程级并行</p>
<ul>
<li><p>多核技术</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220319104101021.png" alt="image-20220319104101021" style="zoom: 50%;"></p>
<p>现代多核处理器芯片上往往集成了多个CPU核心，每个CPU核心有自己独立的寄存器文件、PC以及ALU。有自己的 L1 cache 和 L2 cache ，多个核心共享 L3 cache。</p>
<p>每个CPU核心都可以独立地执行进程和线程，因此是线程级并行的。</p></li>
<li><p>超线程技术</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220319104349911.png" alt="image-20220319104349911" style="zoom:50%;"></p>
<p>超线程技术允许两个线程同时不冲突地使用CPU中的资源。每个CPU核心内有两个PC和寄存器文件的副本，但ALU只有一份（图中FA即浮点数运算单元硬件）。这使得一个CPU核心可以同时执行两个线程，这是真正的并行。</p>
<p>然而，这并不意味着两个线程在同一个CPU中一直都可以并行执行，只是恰好碰到两个线程当前要执行的指令不使用相同的CPU资源时才可以真正地并行执行。</p>
<p>比如一条整数运算指令只会用到整数运算单元，此时浮点运算单元就空闲了，若使用了超线程技术，且另一个线程刚好此时要执行一个浮点运算指令，CPU就允许属于两个不同线程的整数运算指令和浮点运算指令同时执行。</p></li>
</ul></li>
<li><p>指令集并行</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220319105016428.png" alt="image-20220319105016428" style="zoom:50%;"></p>
<p>计算机处理问题是通过指令实现的，每个指令都是交给CPU执行。通过流水线技术（Pipeline），当指令之间不存在相关时，它们在流水线中可以重叠起来并行执行。</p></li>
<li><p>单指令多数据并行</p>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220319105448702.png" alt="image-20220319105448702" style="zoom:67%;"></p>
<p>现代处理器拥有特殊的硬件部件，允许一条指令产生多个并行的操作，这种方式称为单指令多数据（Single Instruction Multiple Data）。</p>
<blockquote>
<p>考虑下面这个计算式子：(a+b)*(c+d)该计算过程被分解为三步：</p>
<p>1、e = a +b</p>
<p>2、f = c +d</p>
<p>3、m = e * f</p>
<p>早期的计算机一次只能处理一条指令，它要先算步骤1（加法操作），再算步骤2（加法操作），最后算3（乘法操作）。需要三步（花费三个指令）得到答案。</p>
<p>但是可以观察到：3的结果依赖于1和2，而1和2都单纯的加法操作，所以开始想办法让1和2同时计算，那么CPU只要两步得到答案，步骤1和2一次算出来的结果，直接进行乘法运算。</p>
<p>这运用了SIMD(Single -Instruction ,Multple -Data)单指令多数据流技术，通过一个指令执行了(a,b,c,d) 4个操作数。SIMD指令集可以提供更快的图像，声音，视频数据等运行速度。</p>
</blockquote></li>
</ul>
<h3 id="虚拟机">虚拟机</h3>
<p><img src="/2022/03/17/CSAPP_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/image-20220319105728995.png" alt="image-20220319105728995" style="zoom:50%;"></p>
<p>虚拟机是对整个计算机系统的抽象，也就是说，一个完整的虚拟机需要包括操作系统、处理器、内存、IO以及程序。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/qq_29051413/article/details/116450610</p>
<p>https://www.zhihu.com/question/21823699/answer/111606716 (单指令多数据并行)</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 02 信息的表示与处理</title>
    <url>/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="十六进制表示法">十六进制表示法</h3>
<p>按照一位一位（bit）表示数据的方式称为位模式，即二进制表示法。使用位模式表示法比较冗长，而十进制表示法与位模式之间的转换又比较麻烦。因此，引入十六进制数来表示位模式。也就是本质上用十六进制来表示数据或虚拟地址，是为了减少冗长</p>
<p>十进制数，是由数字0到9组成的。对于十六进制数，则是由数字0到9和字母A到F来表示16个可能的数值：</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321110131505.png" alt="image-20220321110131505" style="zoom:67%;"></p>
<p>在C语言中，十六进制数是以0x开头，这个x可以是小写，也可以是大写，其中字母部分，既可以全部是大写，也可以全部是小写，甚至是大小写混合也是正确的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210506161001366.png" alt="在这里插入图片描述" style="zoom:67%;"></p>
<h4 id="二进制与十六进制转换">二进制与十六进制转换</h4>
<p>二进制与十六进制的转换比较简单直接，数字之间的转换可以参照这张表：</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321110334154.png" alt="image-20220321110334154" style="zoom: 50%;"></p>
<p>十六进制转二进制，通过展开每个十六进制数字，然后将它转换成对应的二进制格式即可。</p>
<p>而二进制转十六进制，从右向左，每四位为一组来转换成相应的十六进制数即可。需要注意的是，如果总位数不是4的倍数，那么最左边的一组会出现小于4位的情况，这时将前面进行补零，然后将每4位为一组的二进制数进行一一转换，即可得到对应的十六进制数。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321110454760.png" alt="image-20220321110454760" style="zoom: 67%;"></p>
<p>如何快速地将二进制下的<span class="math inline">\(2^n\)</span>转换为十六进制数：</p>
<p>可以观察到，<span class="math inline">\(2^n\)</span>在二进制表示下就是1后面跟n个0。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321110942559.png" alt="image-20220321110942559" style="zoom:50%;"></p>
<p>由于十六进制下的1个0可以代表4个二进制0。将二进制下 0 的个数 n 分解成 i + 4j，即每4个0为一组。这个式子也可以理解为将 n 除以 4 ， j 是商，而 i 就是余数。因此余数 i 可能的取值为 0,1,2,3。</p>
<p>i=0时，对应二进制的最高位就是1，因此对应十六进制下的1。</p>
<p>i=1时，对应二进制的最高位就是10，因此对应十六进制下的2。</p>
<p>i=3时，对应二进制的最高位就是100，因此对应十六进制下的4。</p>
<p>i=4时，对应二进制的最高位就是1000，因此对应十六进制下的4。</p>
<p>得到十六进制下的最高位后，j就是后面0的个数。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321111226674.png" alt="image-20220321111226674" style="zoom:67%;"></p>
<p>举例，<span class="math inline">\(2048 = 2^{11}\)</span>，因此 n 就等于 3 + 4 × 2 。即二进制下有 11 个 0 ，其中 8 个二进制 0 变成 2 个十六进制的 0 ，剩余的三个二进制 0 构成 1000b = 0x8 。从而可以快速得到十六进制表示为 0x800 。</p>
<h4 id="十进制与十六进制转换">十进制与十六进制转换</h4>
<p>十进制数转十六进制，通过辗转相除法，每次除以16获得余数，然后自下而上将余数换成对应的十六进制符号即可。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321112332739.png" alt="image-20220321112332739" style="zoom:50%;"></p>
<p>将一个十六进制数转换成十进制数，可以用16的幂乘以相应位的十六进制数：</p>
<p><img src="https://img-blog.csdnimg.cn/20210506163433216.png" alt="在这里插入图片描述" style="zoom:50%;"></p>
<h3 id="信息存储">信息存储</h3>
<p>通常情况下，进程将内存视为一个非常大的数组，数组的元素是由一个个的字节组成，每个字节都由一个唯一的数字来表示，我们称为地址（address），这些所有的地址的集合就称为虚拟地址空间（virtual address space）。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321131235944.png" alt="image-20220321131235944" style="zoom:50%;"></p>
<p>字节（byte）时信息存储的基本单元。一个字节是由8个位（bit）组成，在二进制表示法中，每一个位的值可能有两种状态：0或者1。当这8个位全为0时，表示一个字节的最小值；当这8个位全为1时，表示最大值。如果用十进制来表示，那么一个字节的取值范围就在0~255(包含0和255）之间。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321131259612.png" alt="image-20220321131259612" style="zoom:67%;"></p>
<p>字长决定了虚拟地址空间的最大的可以到多少，也就是说，对于一个字长为<span class="math inline">\(w位\)</span>的机器，虚拟地址的范围是0 到 <span class="math inline">\(2^{w - 1}\)</span>。对于32位的机器，虚拟地址空间最大为4GB，而64位的机器，虚拟地址空间最大为16EB。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321131513130.png" alt="image-20220321131513130" style="zoom: 50%;"></p>
<p>在迁移的过程中，大多数64位的机器做了向后兼容，因此为32位机器编译的程序也可以运行在64位机器上，反之则不行。对于32位程序和64位程序，主要的区别还是在于程序是如何编译的，而不是运行机器的类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译32位程序</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -m32 -o hello32 hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编译64位程序</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -m64 -o hello64 hello.c</span></span><br></pre></td></tr></table></figure>
<h4 id="基本数据类型大小">基本数据类型大小</h4>
<p>C语言中，支持整数和浮点数多种数据格式，下表列式了不同数据类型在32位机器与64位机器上所占字节数的大小。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321131835025.png" alt="image-20220321131835025" style="zoom:50%;"></p>
<h4 id="数据在内存中的排布大小端法">数据在内存中的排布（大小端法）</h4>
<p>可以看出很多数据类型都是占用了多个字节空间。对于需要存储的数据，要搞清楚该数据的地址是什么，以及数据在内存中是如何排布的。</p>
<p>例如：一个int类型的变量 x（0x01234567），假设地址位于0x100处，由于int类型占4个字节，因此变量x被存储在地址为 0x100，0x101，0x102，0x103 的内存处。十六进制下，一个数字代表4个二进制位，也就是4 bits，因此每个地址可以存储2个十六进制位数字</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321132027351.png" alt="image-20220321132027351" style="zoom:50%;"></p>
<p>大端法，最高有效字节存储在最前面，也就是低地址处。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321132214872.png" alt="image-20220321132214872" style="zoom:50%;"></p>
<p>小端法，最低有效字节存储在在最前面。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220321132240455.png" alt="image-20220321132240455" style="zoom:50%;"></p>
<p>注意对于变量x，最高有效字节是 0x01,最低有效字节是 0x67。</p>
<p>大多数 Intel 兼容机采用小端模式，IBM和Sun公司的机器大多数机器采用大端法。对于很多新的处理器，支持双端法，可以配置成大端或者小端运行。例如基于ARM架构的处理器，支持双端法，但是Android系统和iOS系统却只能运行在小端模式。</p>
<h4 id="存储字符串">存储字符串</h4>
<p>C语言中的字符串被编码为以NULL字符结尾的字符数组，例如字符串 “abcde" ，这个字符串虽然只有5个字符，但是长度却为6，就是因为结尾字符的存在。</p>
<p><img src="https://img-blog.csdnimg.cn/20210506174326975.png" alt="在这里插入图片描述" style="zoom:50%;"></p>
<p>通过以下程序可以得到每个字符在内存中对应的存储信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	show_bytes((byte pointer) &amp;x,<span class="keyword">sizeof</span>(×));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个程序可以观察到在内存中，字符串以十六进制的形式存储，其中结尾字符"NULL"的十六进制表示为0x00：</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220322191137064.png" alt="image-20220322191137064" style="zoom:67%;"></p>
<p>由上文可知，每个char占用1个字节（8 bits），因此对应两个十六进制数。使用ASCII码来表示字符，在任何系统上都会得到相同的结果。因此，文本数据比二进制数据具有更强的平台独立性。</p>
<h3 id="布尔代数">布尔代数</h3>
<p>数学家乔治布尔通过将逻辑值 true 和 false 编码成二进制的 1 和 0 ，设计出了布尔代数，作为逻辑推理的基本原则。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220322191656369.png" alt="image-20220322191656369" style="zoom:67%;"></p>
<ul>
<li><p>布尔运算中的波浪线对应于逻辑运算的非（NOT），计算机通常将非运算称为取反，当对0进行取反时，运算结果是1，对1进行取反得到0。</p></li>
<li><p>逻辑运算与（AND），两个参数如果有一个数为0，那么与运算的结果就为0，与运算只有当两个参数都为1时，运算结果才为1。</p></li>
<li><p>逻辑运算或（OR）只有当两个参数都为0时，或运算结果才为0，如果两个参数都为1，或者有一个参数为1，或运算的结果就为1。</p></li>
<li><p>异或（EOR）当两个参数同为0，或者同为1时，异或运算的结果为0，当两个参数不同时，异或运算的结果才为1。</p></li>
</ul>
<h4 id="位运算">位运算</h4>
<h5 id="按位进行布尔运算">按位进行布尔运算</h5>
<p>按位进行布尔运算，确定一个位级表达式结果的最好方法，就是将十六进制扩展成二进制表示，然后按位进行相应的运算，最后再转换回十六进制。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220322191856042.png" alt="image-20220322191856042" style="zoom:67%;"></p>
<h5 id="掩码运算">掩码运算</h5>
<p>所谓掩码运算，就是通过位运算得到特定的位序列。</p>
<p>例如对于操作数0x89ABCDEF，我们想要得到该操作数的最低有效字节的值，可以通过&amp; 0xFF，这样我们就得到了最低有效字节 0x0000 00EF。</p>
<p><img src="https://img-blog.csdnimg.cn/20210506180110995.png" alt="在这里插入图片描述" style="zoom:67%;"></p>
<h3 id="逻辑运算">逻辑运算</h3>
<p>逻辑运算认为所有非零的参数都表示true，只有参数0表示false。逻辑运算的运算符与布尔代数中的位级运算不同：</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220322192558057.png" alt="image-20220322192558057" style="zoom:67%;"></p>
<p>逻辑运算的结果只有两种，true或者false。而位运算只有在特殊的数值条件下才会得到0或者1。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220322192653302.png" alt="image-20220322192653302" style="zoom:50%;"></p>
<p>对于图中的这个表达式 a &amp;&amp; 5/a，如果a等于0，该逻辑运算的结果即为false，不用再去计算5除以a，这样就可以避免了出现5除以0的情况。</p>
<h3 id="移位运算">移位运算</h3>
<p>左移n位就是丢弃最高的n位，并在右端补n个0。</p>
<p>右移，分为逻辑右移和算术右移。</p>
<p>逻辑右移和左移只是在方向上存在差异，逻辑右移n位就是丢弃最低的n位，并在左端补n个0。</p>
<p>算术右移，当算术右移的操作对象的最高位等于0时，算术右移与逻辑右移是一样的，没有任何差别。但是当操作数的最高位为1时，算术右移之后，左端需要补1，而不是补0。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220322193305715.png" alt="image-20220322193305715" style="zoom:50%;"></p>
<p>实际上，几乎所有的编译器以及机器的组合都是对有符号数使用算术右移，对于无符号数使用逻辑右移。</p>
<h3 id="整数的表示">整数的表示</h3>
<p>C语言支持多种整型数据类型，例如 char short int等，这些关键字可以用来指定不同类型数据的大小。</p>
<p>64位机器上，不同的数据类型所表示数值的范围如下：</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323100700301.png" alt="image-20220323100700301" style="zoom: 50%;"></p>
<p>不同的数据类型，所占的字节数是不同的，这也是导致数值取围不同的直接原因。关于long类型的大小需要注意一下，这个类型的取值范围是与机器字长相关的，在64位机器上，long类型占8个字节，而在32位机器上，long类型只占4个字节。</p>
<p>当变量声明带有unsigned关键字时，限制了表示的数字只能为非负数，在计算机领域，非负数通常称为无符号数，C语言中支持无符号数和有符号数，有符号数既可以是正数，也可以是负数。</p>
<h4 id="无符号数">无符号数</h4>
<p>假设有一个整数的数据类型有w位，用向量x来表示，如果把向量x看成一个二进制表示的数，向量x中的每一个元素表示一个二进制位，其中每个位的取值为0或者1。用一个函数B2U来表示一个长度为w的0、1串是如何映射到无符号数（十进制）的，B2U的意思是binary to unsigned，具体映射过程如图所示：</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323100853013.png" alt="image-20220323100853013" style="zoom: 67%;"></p>
<p>为了更加清楚的解释无符号数的表示方法，CSAPP的原书中还介绍了一种图形化的表示方法来帮助读者理解无符号数的编码规则。对于向量的第 <span class="math inline">\(i\)</span> 位，我们用一个长度为 <span class="math inline">\(2^i\)</span> 的蓝色条状图来表示。每个位向量对应的值就等于所有值为1的位，所对应的条状图的长度之和。</p>
<p>例如：编码0101，就是长度为4(2的2次方)的条状图加上长度为1(2的0次方)的条状图。对于编码1011，则是长度为8，长度为2，以及长度为1的三者相加。</p>
<p>对于长度为4的编码，所表示的最小值就是所有位都等于0时；最大值就是所有位都等于1时，因此4位编码所能表示的无符号数的取值范围是0~15。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323101412430.png" alt="image-20220323101412430" style="zoom:67%;"></p>
<h4 id="有符号数">有符号数</h4>
<p>计算机中对于有符号数的编码采用补码（two’s-complement）的形式。</p>
<p>同样利用向量x来表示二进制数，对于采用补码方式进行编码的二进制数与有符号数（十进制）之间的转换过程，主要区别在于最高位的权重是<span class="math inline">\(-2^{w-1}\)</span>，当最高位等于1时，表示负数；当最高位等于0时，表示非负数。因此最高位也称为符号位。</p>
<p>不要将最高位理解为负号，进行补码转原码的过程太繁琐，直接将符号位理解为负权重进行计算。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323101710474.png" alt="image-20220323101710474" style="zoom:67%;"></p>
<p>补码的图形化表示方法，需要注意的是最高位的情况，其中灰色的条状图来表示最高符号位等于1时的情况。</p>
<p>对于编码0001和0101，当最高符号位等于0，灰色条状图对映射结果没有任何影响。</p>
<p>但是对于1011和1111，由于最高符号位是1，灰色条状图所代表的负权重使得映射结果一定为负数。对于4位补码，可以表示的最小值是-8，可以表示的最大值是7。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323102045088.png" alt="image-20220323102045088" style="zoom:67%;"></p>
<h4 id="整数的范围">整数的范围</h4>
<p>无符号数的不同字长可以表示整数的范围，减一表示出去0这个值，才是真正的最大正整数：</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323102305296.png" alt="image-20220323102305296" style="zoom:67%;"></p>
<blockquote>
<p><span class="math inline">\(2^7+2^6+2^5+...+2^0 = 2^8-1\)</span></p>
</blockquote>
<p>有符号数的不同字长可以表示整数的范围，以字长为8举例，因为只能占用7位，因此最大值就是<span class="math inline">\(2^7-1\)</span>，包括0在内可以表示<span class="math inline">\(2^7\)</span>个数：</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323102335970.png" alt="image-20220323102335970" style="zoom:67%;"></p>
<blockquote>
<p><span class="math inline">\(2^6+2^5+...+2^0 = 2^7-1\)</span></p>
</blockquote>
<p>有符号数的最小值：</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323104458281.png" alt="image-20220323104458281" style="zoom:67%;"></p>
<blockquote>
<p><span class="math inline">\(-1*2^7+0*2^6+0*2^5+...+0*2^0 = -2^7\)</span></p>
</blockquote>
<p>对于-1，这个需要特别注意一下，无论是字长是8位，还是64位，有符号数-1的补码是一个全为1的串。-1的补码与无符号数的最大值有着相同的二进制位表示。理解了补码编码的含义后，就不会把 -1 看成 1001（四位编码），因为这个是 -1 的原码，计算机表示有符号数用的是补码而不是原码。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323104843342.png" alt="image-20220323104843342" style="zoom:67%;"></p>
<h4 id="补码与原码">补码与原码</h4>
<p>虽然C语言的标准中并没有要求用补码来表示有符号数，但是几乎所有的机器都是<strong>用补码来表示有符号数</strong>。</p>
<p>例：已知一个有符号数12345的补码表示 0011 0000 0011 1001，求 -12345 的补码。</p>
<p><img src="/2022/03/21/CSAPP_02_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20220323105304065.png" alt="image-20220323105304065" style="zoom:67%;"></p>
<p>解：已知<strong>正数的原码和补码相同</strong>，即 12345 的原码也是 0011 0000 0011 1001。<strong>补码和原码相加会刚好溢出，使得结果等于 0</strong>，因此，- 12345 的补码就是 12345 原码对应 0 的位置改为 1，1 的位置改为 0，然后再加 1。</p>
<p>即：0011 0000 0011 1001 -&gt; 1100 1111 1100 0110 -&gt; 1100 1111 1100 0111。</p>
<p>因此，-12345 的补码就是 1100 1111 1100 0111。</p>
<p>与-12345相同位模式的无符号数又是多少呢、？对于无符号数，最高位的1表示的不是负权重，根据无符号数的编码定义可以得到53191。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/qq_29051413/article/details/116455308</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase基本原理</title>
    <url>/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="hbase概述">Hbase概述</h3>
<p>HBase是一个高可靠、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价的PC Server上搭建大规模结构化存储集群。</p>
<p>HBase是Google BigTable的开源实现，与Google BigTable利用GFS作为其文件存储系统类似，HBase利用Hadoop HDFS作为其文件存储系统；</p>
<p>Google运行MapReduce来处理BigTable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；</p>
<p>Google BigTable利用Chubby作为协同服务，HBase利用Zookeeper作为协同服务。</p>
<h3 id="hbase架构">Hbase架构</h3>
<p>物理上，Hbase 是由三种类型的 server 组成的的<strong>主从式</strong>（master-slave）架构：</p>
<ul>
<li><strong>Region Server</strong> 负责处理数据的读写请求，客户端请求数据时直接和 Region Server 交互。</li>
<li><strong>HBase Master</strong> 负责 Region 的分配，DDL（创建，删除 table）等操作。</li>
<li><strong>Zookeeper</strong>，。</li>
</ul>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913110350488.png" alt="image-20210913110350488" style="zoom: 67%;"></p>
<p>底层的存储都是基于 Hadoop HDFS 的：</p>
<ul>
<li>Hadoop <strong>DataNode</strong> 负责存储 Region Server 所管理的数据。所有的 HBase 数据都存储在 HDFS 文件中。Region Server 和 HDFS DataNode 往往是分布在一起的，这样 Region Server 就能够实现<strong>数据本地化</strong>（data locality，即将数据放在离需要者尽可能近的地方）。HBase 的数据在写的时候是本地的，但是当 region 被迁移的时候，数据就可能不再满足本地性了，直到完成 <strong>compaction</strong>，才能又恢复到本地。</li>
<li>Hadoop <strong>NameNode</strong> 维护了所有 HDFS 物理 data block 的元信息。</li>
</ul>
<p>更为完整的架构图为：</p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913110740696.png" alt="image-20210913110740696" style="zoom:80%;"></p>
<h4 id="hbase-hmaster">HBase HMaster</h4>
<p>HMaster在HBase中被称为“主服务器”。 这是一个轻量级的进程，用于在Hadoop集群中分配Region Server以实现负载平衡。 它管理表上的DDL操作。 HMaster监视Region Server。 当客户想要更改结构或想要更改元数据时，所有这些操作都由HMaster完成。 为了确保高可用，一般都会使用两个HMaster。</p>
<p>HMaster的功能包括：</p>
<ul>
<li>负责处理Region的分配和DDL操作(创建、删除表)。</li>
<li>协调RegionServer
<ul>
<li>在启动时分配Region，或者在恢复和负载均衡时重新分配Region</li>
<li>监视集群中的所有Region Server实例（通过与zookeeper进行Heartbeat来监听Region Server在ZooKeeper中的状态，并不直接和Region Server相连）</li>
</ul></li>
<li>管理功能
<ul>
<li>创建、删除和更新表的接口</li>
</ul></li>
</ul>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913113317081.png" alt="image-20210913113317081" style="zoom: 80%;"></p>
<h4 id="zookeeper">ZooKeeper</h4>
<p>Zookeepper是一个分布式的无中心的元数据存储服务。HBase使用ZooKeeper作为分布式协调服务来维护集群中的服务器状态。ZooKeeper监听哪些Region Server是可用的，并提供Region Server故障的通知。ZooKeeper使用信息一致性来保证共同的共享状态。注意为了达成一致性，至少应该有3到5台机器。</p>
<p>ZooKeeper的功能包括：</p>
<ul>
<li>存放整个HBase集群的元数据以及集群的状态信息(avalible/alive)。</li>
<li>实现HMaster主从节点的failover，并在HRegionServer宕机的时候通知HMaster。</li>
</ul>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913124658317.png" alt="image-20210913124658317" style="zoom: 67%;"></p>
<h4 id="hbase-region-server">HBase Region Server</h4>
<p>一个HRegionServer可以存放1000个HRegion(出自BigTable)；HBase使用RowKey将表水平切割成多个HRegion，从HMaster的角度，每个HRegion都纪录了它的StartKey和EndKey（第一个HRegion的StartKey为空，最后一个HRegion的EndKey为空），由于RowKey是排序的，因而Client可以通过HMaster快速的定位每个RowKey在哪个HRegion中。</p>
<p>底层Table数据存储于HDFS中，而HRegion所处理的数据尽量和数据所在的DataNode在一起，实现数据的本地化；数据本地化并不是总能实现，比如在HRegion移动(如因Split)时，需要等下一次Compact才能继续回到本地化。</p>
<p>Region Server的一些功能包括：-</p>
<ul>
<li>存放和管理本地HRegion（包括拆分）。</li>
<li>读写HDFS，管理Table中的数据。</li>
<li>Client直接通过HRegionServer读写数据</li>
</ul>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913130038608.png" alt="image-20210913130038608" style="zoom:67%;"></p>
<h3 id="hbase-region-server详细构造">HBase Region Server详细构造</h3>
<p>HRegionServer一般和DataNode在同一台机器上运行，实现数据的本地性。HRegionServer包含WAL(HLog)、BlockCache和多个HRegion，HRegion又由HStore、MemStore和HFile组成。</p>
<ul>
<li>HRegionServer
<ul>
<li>WAL(Hlog，一个，HDFS中)</li>
<li>BlockCache</li>
<li>HRegion(最多1000个，表的横切，rowkey不会重叠)
<ul>
<li>HStore（列族，HRegion的列切， 多个）
<ul>
<li>MemStore(写完Hlog后，刚生成的数据)</li>
<li>HFile(多个，具体的数据，排序，HDFS中)</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913150552594.png" alt="image-20210913150552594" style="zoom: 67%;"></p>
<h4 id="wal">WAL</h4>
<p>WAL(Write Ahead Log, HLog) 预写日志，是HRegionServer上的一个文件，所有写操作都会先保证将数据写入这个Log文件(每个HRegionServer只有一个)后，才会真正更新MemStore，最后写入HFile中。这样即使HRegionServer宕机，我们依然可以从HLog中恢复数据。</p>
<p>由于HDFS只允许同一时刻对一个文件只能一个客户端写入，所以对HLog只能单线程写入。这样很明显会影响性能，所以再HBase1.0以后的版本，<strong>多个WAL并行写</strong>(MultiWAL)，该实现采用HDFS的多个管道写，以单个HRegion为单位。</p>
<h4 id="blockcache">BlockCache</h4>
<p>读缓存，在内存中存储了最常访问的数据，是 LRU（Least Recently Used）缓存。BlockCache为HRegionServer内存大小的20%。</p>
<p>Hbase中有两种BlockCache：</p>
<ul>
<li><p>on-heap LruBlockCache：LruBlockCache受到java gc的影响，不稳定</p></li>
<li><p>BucketCache(通常是off-heap)：一般采用这种方式，自己管理内存，更加稳定</p></li>
</ul>
<h4 id="hregion">HRegion</h4>
<p>HRegion是一个表的一部分，相当于横着切分了一张表。</p>
<p>HRegion由多个Store(HStore)构成，每个HStore对应了一个Table在这个HRegion中的一个Column Family，即每个Column Family就是一个集中的存储单元，因而最好将具有相近IO特性的Column存储在一个Column Family，以实现高效读取(数据局部性原理，可以提高缓存的命中率)。</p>
<p>HStore是HBase中存储的核心，它实现了读写HDFS功能，<strong>一个HStore由一个MemStore 和0个或多个HFile组成</strong>。</p>
<ul>
<li>MemStore：所有数据的写在完成WAL日志写后，会 写入MemStore中，由MemStore根据一定的算法将数据Flush到底层HDFS文件中(HFile)，通常每个HRegion中的每个 Column Family有一个自己的MemStore。</li>
<li>HFile：在HFile中的数据是按RowKey、Column Family、Column排序，对相同的Cell(即这三个值都一样)，则按timestamp倒序排列</li>
</ul>
<h5 id="memstore">MemStore</h5>
<p>MemStore是一个In Memory Sorted Buffer（在内存中排序的缓冲区），在每个HStore中都有一个MemStore，即它是一个HRegion的一个Column Family对应一个实例。</p>
<p>它的排列顺序以RowKey、Column Family、Column的顺序以及Timestamp的倒序（越新的数据越靠前），如下所示：</p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913152648183.png" alt="image-20210913152648183" style="zoom: 67%;"></p>
<p>每一次Put/Delete请求都是先写入到MemStore中，当MemStore满后会Flush成一个新的HFile，即一个HStore(Column Family)可以有0个或多个StoreFile(HFile)。</p>
<p>有以下三种情况可以触发MemStore的Flush动作，需要注意的是MemStore的最小Flush单元是整个HRegion中所有的MemStore而不是单个MemStore。据说这是Column Family有个数限制的其中一个原因，估计是因为太多的Column Family一起Flush会引起性能问题</p>
<ul>
<li><p>MemStore超过128M，此时当前的HRegion中<strong>所有的MemStore会Flush到HDFS中</strong>。</p></li>
<li><p>HRegionServer上所有MemStore的大小超过了机器上默认40％的内存使用量。此时当前HRegionServer中所有HRegion中的MemStore都会Flush到HDFS中，<strong>Flush顺序是MemStore大小的倒序，直到低于某个阈值</strong>，默认38%</p></li>
<li><p>WAL过大，当前HRegionServer中所有HRegion中的MemStore都会Flush到HDFS中，Flush使用时间顺序，<strong>最早的MemStore先Flush直到WAL的数量少于某个阈值</strong>。</p></li>
</ul>
<p>在MemStore Flush过程中，还会在尾部追加一些Meta数据，其中就包括Flush时最大的WAL Sequence值，以告诉HBase这个StoreFile写入的最新数据的序列，那么在Recover时就直到从哪里开始。</p>
<h5 id="hfile">HFile</h5>
<p>HFile是MemStore在HDFS上的实体，所以写一个HFile是顺序写，速度很快。由于已经在MemStore中排好序了，所以每个HFile内部同样是有序的。</p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913155326063.png" alt="image-20210913155326063" style="zoom:67%;"></p>
<h3 id="hbase物理存储hfile格式">Hbase物理存储（HFile格式）</h3>
<p>HFile一共经历了三个版本，主要以V2版本为主。</p>
<p><strong>v1</strong></p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913155808039.png" alt="image-20210913155808039" style="zoom:67%;"></p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913155820823.png" alt="image-20210913155820823" style="zoom: 50%;"></p>
<p><strong>数据存放在Data块中</strong>，Data块的大小可以用户指定，大的Data块适合scan，小的Data块适合随机查找。</p>
<p>HFile里面的每个KeyValue对就是一个简单的<strong>byte数组</strong>。这个byte数组里面包含了很多项，可以看出包括Key的长度、Value的长度，Key的部分包括Row Key、Column Family、Column Qualifier、TimeStamp等等。</p>
<p>记录了索引信息的Index块（Block Index）需要被一次性读取进入内存中。</p>
<p><strong>v2</strong></p>
<p>解决了V1版本内存占用，特别是Bloom File和Block Index过大的问题。它的解决方案是把Bloom File和Block Index打散放入Data，每次查询不用加载全部信息。</p>
<p>HFile V2是一个多层的类B+树索引，采用这种设计，可以实现查找不需要扫描读取整个文件。因此HFile本质上可以分为：</p>
<ul>
<li>扫描区：包含了数据、索引、布隆过滤器，顺序扫描HFile时所有的数据块将会被读取。
<ul>
<li>Data Block：就是存储的一行行数据，本质上就是byte数组，包括Row Key、Column Family、Column Qualifier、TimeStamp等。</li>
<li>叶子节点索引：就是B+树叶子节点的索引</li>
<li>布隆过滤器</li>
</ul></li>
<li>非扫描区：包含一些元数据块和索引，HFile顺序扫描的时候数据不会被读取。
<ul>
<li>中间节点索引：就是B+树非叶子节点的索引</li>
</ul></li>
<li>打开时加载区：包含一些元数据和索引，在HBase的Region Server启动时，需要加载到内存中。
<ul>
<li>根节点索引：就是B+树根节点的索引</li>
</ul></li>
</ul>
<p>Data Block中的Cell都是升序排列，每个Block都有它自己的Leaf-Index，每个Block的最后一个Key被放入Intermediate-Index中，Root-Index指向Intermediate-Index。Bloom过滤器用于快速定位没有在DataBlock中的数据。</p>
<figure>
<img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913161309091.png" alt="image-20210913161309091"><figcaption aria-hidden="true">image-20210913161309091</figcaption>
</figure>
<p><strong>v3</strong></p>
<p>v3和v2没有太大变化，只是加了一个Tag字段。</p>
<h3 id="hbase三级索引">Hbase三级索引</h3>
<p>Hbase获取数据，需要经过三级索引，才能真正读取到数据。也就是需要通过索引找到究竟去哪个Region Server中的Region读取数据。</p>
<p>HBase有两个特殊的表，ROOT表(唯一)和META表，存储Region的分布情况以及每个Region的详细信息。。</p>
<ul>
<li>ROOT表的位置保存在ZooKeeper中，它存储了META表的RegionInfo信息（也就是Meta表在哪个Region里面）。</li>
<li>META表存储了用户创建Table的RegionInfo信息（也就是用户创建的表在哪个Region里面），META表可以被切分成多个HRegion。</li>
</ul>
<figure>
<img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913163359995.png" alt="image-20210913163359995"><figcaption aria-hidden="true">image-20210913163359995</figcaption>
</figure>
<p>因此，访问数据涉及到的索引表和流程为：</p>
<p>1、从ZooKeeper读取ROOT表位置。</p>
<p>2、HRegionServer中根据请求的Root表和RowKey读取META表位置。</p>
<p>3、最后从该HRegionServer中读取META表的内容而获取此次请求需要访问的HRegion所在的位置。</p>
<p>4、读取内容。</p>
<p>因此，需要3次读取才能获取目标HRegion的位置，然后第4次请求才能获取真正的数据。所以，一般客户端有ROOT表位置和内容的缓存。</p>
<p><strong>BigTable要选择三级索引结构的原因</strong></p>
<p>就是能够对足够多的HRegion进行索引。</p>
<p>BigTable论文里面提到，一般每个HRegion大小为128M，每行META数据1KB。所以，三级索引可以索引<span class="math inline">\(2^{34}\)</span>个HRegion，可以索引很大很大的数据了。但是如果只有二级索引，就只能索引16TB，在大数据情况下这是完全不够。</p>
<h4 id="root表">Root表</h4>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913183028902.png" alt="image-20210913183028902" style="zoom:67%;"></p>
<p>表结构和Meta表完全相同，并且ROOT只会有一个Region，这个Region也是被存在HBase内部。</p>
<h4 id="meta表">Meta表</h4>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913165646478.png" alt="image-20210913165646478" style="zoom:67%;"></p>
<p>RowKey由三部分组成：TableName, StartKey 和 TimeStamp。RowKey存储的内容我们又称之为Region的Name。将组成RowKey的三个部分用逗号连接就构成了整个RowKey，这里TimeStamp使用十进制的数字字符串来表示的。</p>
<blockquote>
<p>用来存放Region的文件夹的名字是RegionName的Hash值，因为RegionName可能包含某些非法字符。RegionName会包含非法字符的原因是因为StartKey是被允许包含任何值的。</p>
</blockquote>
<p>一个RowKey的例子为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Table1,RK10000,<span class="number">12345678</span>  </span><br></pre></td></tr></table></figure>
<p>表中的列族Column Family是info，info里面包含三个Column：regioninfo, server, serverstartcode。</p>
<ul>
<li>regioninfo就是Region的详细信息，包括StartKey, EndKey 以及每个Family的信息等等。</li>
<li>server存储的就是管理这个Region的RegionServer的地址。</li>
</ul>
<p>所以当Region被拆分、合并或者重新分配的时候，都需要来修改Meta表的内容。</p>
<h3 id="hbase读写流程">Hbase读写流程</h3>
<h4 id="hbase读数据">Hbase读数据</h4>
<p>整体的读数据流程为：</p>
<p>1、Client访问Zookeeper，获取Root表所在的RegionServer。</p>
<p>2、访问对应的RegionServer，获取Meta表中的RegionServer，并在对应的RegionServer处获取对应的表存储的RegionServer。</p>
<p>3、访问表所在的RegionServer进行数据的读取。</p>
<p>4、查找对应的Region，在Region中寻找列族，先找BlockCache，找不到去Memstore中寻找，再找不到就进行HFile的遍历</p>
<p>5、找到数据之后会先缓存到BlockCache中，再将结果返回。BlockCache逐渐满了之后，会采用LRU的淘汰策略。</p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913200350146.png" alt="image-20210913200350146" style="zoom:67%;"></p>
<p>一个存在的问题是，相同Cell（RowKey/ColumnFamily/Column相同）并不保证在一起，甚至删除一个Cell也只是写入一个新的Cell，它含有Delete标记，而不一定将一个Cell真正删除了。因此，需要按照一定的顺序来读取数据使得读取到的数据保持一致性。</p>
<p>相同的cell可能存在3个不同的位置，Block Cache，MemStore，HFile中。</p>
<p>1、从Block Cache中读取</p>
<p>2、从MemStore中读取</p>
<p>3、从多个HFile中读取，用Bloom Filter筛掉明显不存在所需数据的HFile，Index用于快速定位HFile中的数据块。</p>
<h4 id="hbase写数据">Hbase写数据</h4>
<p>1、客户端发起一个Put请求时，首先它从hbase:meta表中查出该Put数据最终需要去的HRegionServer。然后客户端将Put请求发送给相应的HRegionServer，在HRegionServer中它首先会将该Put操作写入WAL日志文件中。</p>
<p>2、写完WAL日志文件后，HRegionServer根据Put中的TableName和RowKey找到对应的HRegion，并根据Column Family找到对应的HStore，并将Put写入到该HStore的MemStore中。写入成功，返回给客户端。</p>
<p>3、当MemStore积累一定量的数据后，flush成HFile到HDFS上。</p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913200540718.png" alt="image-20210913200540718" style="zoom:50%;"></p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913200556470.png" alt="image-20210913200556470" style="zoom: 50%;"></p>
<h3 id="hbase为什么快">Hbase为什么快</h3>
<p>1、写数据先写WAL再Memstore，最后才刷到磁盘。不需要每次有数据更新就必须将数据写入到磁盘中，写入时候将随机写入转换成顺序写，数据写入速度也很稳定。</p>
<p>2、读取时先读缓存；数据按RowKey排序；HFile文件为磁盘顺序读取做了优化，按页存储；列式存储。</p>
<p>https://www.cnblogs.com/guoyu1/p/13934002.html</p>
<h3 id="hfile合并">HFile合并</h3>
<p>HFile过多，在数据读取的时候，会产生性能问题。所以一段时间后，HFile会进行合并。HBase中Compaction分为两种：Minor Compaction和Major Compaction。</p>
<ul>
<li><p>Minor Compaction：是指选取一些小的、相邻的HFile将他们合并成一个更大的StoreFile，在这个过程中不会处理已经Deleted或Expired的Cell。(BigTable中将memtable的数据flush的一个HFile/SSTable称为一次Minor Compaction)</p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913201625829.png" alt="image-20210913201625829" style="zoom:50%;"></p>
<blockquote>
<p>为什么HFile的大小会不一样？</p>
<p>由前面Memstore可知，刷盘的时候会将当前的HRegion中所有的HStore对应的MemStore会Flush到HDFS中</p>
</blockquote></li>
<li><p>Major Compaction：是指将所有同一个Region下的HFile合并成一个HFile，可以手动触发或者自动触发，但是会引起性能问题，一般安排在周末。</p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913201708143.png" alt="image-20210913201708143" style="zoom: 60%;"></p></li>
</ul>
<h3 id="hregion分裂">HRegion分裂</h3>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913202120978.png" alt="image-20210913202120978" style="zoom:67%;"></p>
<p>最初，一个Table只有一个HRegion，随着数据写入增加，如果一个HRegion到达一定的大小，就需要Split成两个HRegion，除了负载均衡的考虑还有查询效率的考虑。</p>
<p>这个大小由hbase.hregion.max.filesize指定，默认为10GB。</p>
<p>当split时（split时停止服务），两个新的HRegion会在同一个HRegionServer中创建，它们各自包含父HRegion一半的数据，当Split完成后，父HRegion会下线，而新的两个子HRegion会向HMaster注册上线，处于负载均衡的考虑，这两个新的HRegion可能会被HMaster分配到其他的HRegionServer中。</p>
<figure>
<img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913202139213.png" alt="image-20210913202139213"><figcaption aria-hidden="true">image-20210913202139213</figcaption>
</figure>
<p>具体的分裂流程为：</p>
<ol type="1">
<li>RegionServer在本地决定分割HRegion，并准备分割。第一步，汇报给zookeeper。</li>
<li>master获取zookeeper中的状态。</li>
<li>RegionServer在HDFS的父目录区域目录下创建一个名为“.splits”的子目录。</li>
<li>RegionServer关闭父HRegion，强制刷新缓存，并将该区域标记为本地数据结构中的脱机状态。此时，来到父区域的客户端请求将抛出NotServingRegionException异常。客户端将重试一些备用值。</li>
<li>RegionServer在.splits目录下创建Region目录，为子区域A和B创建必要的数据结构。然后，它分割存储文件，因为它在父区域中为每个存储文件创建两个引用文件。那些引用文件将指向父Region文件。</li>
<li>RegionServer在HDFS中创建实际的区域目录，并移动每个子Region的引用文件。</li>
<li>RegionServer向META表发送请求。将父HRegion设置为.META中的脱机状态，并添加关于子HRegion的信息。在这时，在META中不会为女儿分配单独的条目。客户端会看到父区域是分割的，如果他们扫描.META，但不知道子HRegion，直到他们出现在.META。</li>
<li>RegionServer并行open子HRegion接受写入。</li>
<li>RegionServer将女儿A和B添加到.META。以及它所在地区的信息。此后，客户可以发现新的地区，并向新的地区发出请求，之前的缓存失效。</li>
<li>HRegion Server向zookeeper汇报split结束的消息，master进行负载均衡。</li>
<li>拆分后，meta表和HDFS仍将包含对父HRegion的引用。当子HRegion进行Compaction时，这些引用信息会被删除。Master也会定期检查子HRegion，如果没有父HRegion中的信息，父HRegion将被删除。</li>
</ol>
<h3 id="负载均衡">负载均衡</h3>
<p>出于负载均衡的考虑，HMaster可能会将RegionServer中的若干Region重新分配的其他的HRegionServer中。</p>
<p>这可能会导致之前这个Region产生HFile在其他节点上，已经和这个Region当前所在的机器不同，下一次Major Compaction则会将数据从远端的节点移动到本地节点。</p>
<p>负载均衡对系统性能影响很大，实际一般关闭，每周开启一次。</p>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913202956143.png" alt="image-20210913202956143" style="zoom:67%;"></p>
<h3 id="容错">容错</h3>
<ol type="1">
<li>zookeeper感知，通知HMaster</li>
<li>重新分配HRegion到其他节点</li>
<li>为每个HRegion拆分WAL，将拆分出的WAL文件写入对应的目的HRegionServer的WAL目录中，并并写入对应的DataNode中</li>
<li>回放WAL，重建MemStore</li>
</ol>
<p><img src="/2021/09/12/Hbase_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20210913203057517.png" alt="image-20210913203057517" style="zoom:67%;"></p>
<h3 id="hbase一致性">HBase一致性</h3>
<p>HBase是强一致性，它表现在当如下情况出现的时候HRegion不可用：</p>
<ol type="1">
<li>HRegion 分裂时相关HRegion不可用</li>
<li>HRegion 合并时相关HRegion不可用</li>
<li>HRegionServer Recovery（依靠zookeeper进行主备切换）时相关HRegion不可用</li>
</ol>
<h3 id="参考资料">参考资料</h3>
<p>https://www.cnblogs.com/biterror/p/6909923.html</p>
<p>http://www.lerith.com/architecture/apache-hbase/</p>
<p>https://segmentfault.com/a/1190000019959411</p>
<p>https://blog.csdn.net/wangyiyungw/article/details/80265015</p>
<p>https://blog.csdn.net/ldds_520/article/details/51674315 (Root表和Meta表的详细构造)</p>
]]></content>
      <categories>
        <category>Hbase</category>
      </categories>
      <tags>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive DDL</title>
    <url>/2021/07/25/Hive_DDL/</url>
    <content><![CDATA[<p>数据定义语言 (Data Definition Language, DDL)，是SQL语言集中对数据库内部的对象结构进行创建，删除，修改等的操作语言，这些数据库对象包括<strong>database（schema）、table、view、index</strong>等。核心语法由<strong>CREATE、ALTER与DROP</strong>三个所组成。DDL并不涉及表内部数据的操作。</p>
<a id="more"></a>
<h2 id="hive建表基础">Hive建表基础</h2>
<h3 id="hive建表语法">Hive建表语法</h3>
<p><img src="/2021/07/25/Hive_DDL/image-20210725101854386.png" alt="image-20210725101854386" style="zoom:80%;"></p>
<ul>
<li>蓝色字体是建表语法的关键字，用于指定某些功能。</li>
<li>[]中括号的语法表示可选。</li>
<li>|表示使用的时候，左右语法二选一。</li>
<li>建表语句中的语法顺序要和上述语法规则保持一致。</li>
</ul>
<blockquote>
<p>partitioned by 表示建立分区表</p>
<p>clustered by 表示建立分桶表，sorted by表示桶内排序规则</p>
<p>row format 表示文件对应的序列化类和指定分隔符</p>
</blockquote>
<h3 id="hive数据类型">Hive数据类型</h3>
<p>Hive中的数据类型指的是Hive表中的列字段类型。Hive数据类型整体分为两个类别：原生数据类型（primitive data type）和复杂数据类型（complex data type）。</p>
<p>原生数据类型包括：数值类型、时间类型、字符串类型、杂项数据类型；</p>
<p>复杂数据类型包括：array数组、map映射、struct结构、union联合体。</p>
<p>关于Hive的数据类型，需要注意： 英文字母大小写不敏感； 除SQL数据类型外，还支持Java数据类型，比如：string； int和string是使用最多的，大多数函数都支持； 复杂数据类型的使用通常需要和分隔符指定语法配合使用。 如果定义的数据类型和文件不一致，hive会尝试隐式转换，但是不保证成功。</p>
<h4 id="原生数据类型">原生数据类型</h4>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725100029573.png" alt="image-20210725100029573"><figcaption aria-hidden="true">image-20210725100029573</figcaption>
</figure>
<p>其中标注的数据类型是使用较多的。</p>
<blockquote>
<p>https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types</p>
</blockquote>
<h4 id="复杂数据类型">复杂数据类型</h4>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725100251729.png" alt="image-20210725100251729"><figcaption aria-hidden="true">image-20210725100251729</figcaption>
</figure>
<p>其中标注的数据类型是使用较多的。</p>
<blockquote>
<p>https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types</p>
</blockquote>
<h4 id="数据类型隐式显示转换">数据类型隐式、显示转换</h4>
<p>与SQL类似，HQL支持隐式和显式类型转换。 原生类型从窄类型到宽类型的转换称为隐式转换，反之则不允许。</p>
<p>显式类型转换使用CAST函数。 例如，CAST（'100'as INT）会将100字符串转换为100整数值。 如果强制转换失败，例如CAST（'INT'as INT），该函数返回NULL。</p>
<h3 id="hive-读写文件机制">Hive 读写文件机制</h3>
<h4 id="serde">SerDe</h4>
<p>SerDe是Serializer、Deserializer的简称，目的是用于序列化和反序列化。序列化是对象转化为字节码的过程；而反序列化是字节码转换为对象的过程。</p>
<p>Hive使用SerDe（和FileFormat）读取和写入行对象。</p>
<p>可以通过desc formatted tablename查看表的相关SerDe信息。默认如下：</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725100748683.png" alt="image-20210725100748683"><figcaption aria-hidden="true">image-20210725100748683</figcaption>
</figure>
<p>在Hive的建表语句中，和SerDe相关的语法为：</p>
<p><img src="/2021/07/25/Hive_DDL/image-20210725101013712.png" alt="image-20210725101013712" style="zoom:67%;"></p>
<p>其中ROW FORMAT是语法关键字，<strong>DELIMITED</strong>和<strong>SERDE</strong>二选其一。</p>
<p>如果使用<strong>delimited</strong>表示使用默认的<strong>LazySimpleSerDe</strong>类来处理数据。如果<strong>数据文件格式比较特殊</strong>可以使用ROW FORMAT SERDE serde_name指定其他的Serde类来处理数据,甚至支持用户自定义SerDe类。</p>
<p>LazySimpleSerDe：</p>
<p>LazySimpleSerDe是Hive默认的序列化类，包含4种子语法，分别用于指定字段之间、集合元素之间、map映射 kv之间、换行的分隔符号。在建表的时候可以根据数据的特点灵活搭配使用。</p>
<p><img src="/2021/07/25/Hive_DDL/image-20210725101230559.png" alt="image-20210725101230559" style="zoom:67%;"></p>
<p>默认分隔符：</p>
<p>hive建表时如果没有row format语法。此时字段之间默认的分割符是'\001'，是一种特殊的字符，使用的是ascii编码的值，键盘是打不出来的。</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725101428441.png" alt="image-20210725101428441"><figcaption aria-hidden="true">image-20210725101428441</figcaption>
</figure>
<p>在vim编辑器中，连续按下Ctrl+v/Ctrl+a即可输入'\001' ，显示^A；在一些文本编辑器中将以SOH的形式显示。</p>
<h4 id="hive读写文件流程">Hive读写文件流程</h4>
<p>Hive读取文件机制：首先调用InputFormat（默认TextInputFormat），返回一条一条kv键值对记录（默认是一行对应一条记录）。然后调用SerDe（默认LazySimpleSerDe）的Deserializer，将一条记录中的value根据分隔符切分为各个字段。</p>
<p>Hive写文件机制：将Row写入文件时，首先调用SerDe（默认LazySimpleSerDe）的Serializer将对象转换成字节序列，然后调用OutputFormat将数据写入HDFS文件中。</p>
<p><img src="/2021/07/25/Hive_DDL/image-20210725100917105.png" alt="image-20210725100917105" style="zoom:67%;"></p>
<h3 id="hive数据存储路径">Hive数据存储路径</h3>
<h4 id="默认">默认</h4>
<p>Hive表默认存储路径是由${HIVE_HOME}/conf/hive-site.xml配置文件的hive.metastore.warehouse.dir属性指定。默认值是：/user/hive/warehouse。</p>
<p>在该路径下，文件将根据所属的库、表，有规律的存储在对应的文件夹下。</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725101636846.png" alt="image-20210725101636846"><figcaption aria-hidden="true">image-20210725101636846</figcaption>
</figure>
<h4 id="指定">指定</h4>
<p>在Hive建表的时候，可以通过location语法来更改数据在HDFS上的存储路径，使得建表加载数据更加灵活方便。 语法：LOCATION '<hdfs_location>'。 对于已经生成好的数据文件，使用location指定路径将会很方便。</hdfs_location></p>
<h2 id="hive建表高阶">Hive建表高阶</h2>
<h3 id="hive内外部表">Hive内、外部表</h3>
<h4 id="基础">基础</h4>
<p>内部表（Internal table）也称为被Hive拥有和管理的托管表（Managed table）。默认情况下创建的表就是内部表，Hive拥有该表的结构和文件。换句话说，<strong>Hive完全管理表</strong>（元数据和数据）的生命周期，类似于RDBMS中的表。</p>
<p>当删除内部表时，它会删除<strong>数据以及表的元数据</strong>。</p>
<p>可以使用 DESCRIBE FORMATTED 库名.表名 来获取表的描述信息，从中可以看出表的类型：</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725102314169.png" alt="image-20210725102314169"><figcaption aria-hidden="true">image-20210725102314169</figcaption>
</figure>
<p>外部表（External table）中的数据不是Hive拥有或管理的，<strong>只管理表的元数据</strong>。要创建一个外部表，需要使用<strong>EXTERNAL</strong>语法关键字。</p>
<p>删除外部表只会删除元数据，而<strong>不会删除实际数据</strong>。在Hive外部仍然可以访问实际数据。</p>
<p>而且外部表更为方便的是可以搭配location语法指定数据的路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create external table student_ext(</span><br><span class="line">    num int,</span><br><span class="line">    name string,</span><br><span class="line">    sex string,</span><br><span class="line">    age int,</span><br><span class="line">    dept string)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &#39;,&#39;</span><br><span class="line">location &#39;&#x2F;stu&#39;;</span><br></pre></td></tr></table></figure>
<p>可以使用 DESCRIBE FORMATTED 库名.表名 来获取表的描述信息，从中可以看出表的类型：</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725103016823.png" alt="image-20210725103016823"><figcaption aria-hidden="true">image-20210725103016823</figcaption>
</figure>
<h4 id="对比">对比</h4>
<p>相同点：无论内部表还是外部表，Hive都在Hive Metastore中管理表定义及其分区信息（即元数据）。</p>
<p>不同点：删除内部表会从Metastore中删除表元数据，还会从HDFS中删除其所有数据/文件。 删除外部表，只会从Metastore中删除表的元数据，并保持HDFS位置中的实际数据不变。</p>
<p><img src="/2021/07/25/Hive_DDL/image-20210725103136669.png" alt="image-20210725103136669" style="zoom:67%;"></p>
<h4 id="选择">选择</h4>
<p>当需要通过Hive完全管理控制表的整个生命周期时，请使用内部表。</p>
<p>当文件已经存在或位于远程位置时，请使用外部表，因为即使删除表，文件也会被保留。</p>
<h3 id="hive分区表">Hive分区表</h3>
<h4 id="基础-1">基础</h4>
<p>为了优化查询速度，减少全表扫描，提出分区表的概念。</p>
<p>分区表指的是Hive中可以根据用户<strong>指定的字段进行分区</strong>，分区的字段可以是日期、地域、种类等具有标识意义的字段。比如把一整年的数据根据月份划分12个月（12个分区），后续就可以查询指定月份分区的数据，尽可能避免了全表扫描查询。</p>
<p>分区表建表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name (</span><br><span class="line">    column1 data_type, </span><br><span class="line">    column2 data_type</span><br><span class="line">) </span><br><span class="line">PARTITIONED BY (</span><br><span class="line">    partition1 data_type, </span><br><span class="line">    partition2 data_type,….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>需要注意，<strong>分区字段不能是表中已经存在的字段</strong>，因为分区字段最终也会以虚拟字段的形式显示在表结构上。</p>
<p>针对英雄数据，创建一张分区表t_all_hero_part，以role角色作为分区字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table t_all_hero_part(</span><br><span class="line">       id int,</span><br><span class="line">       name string,</span><br><span class="line">       hp_max int,</span><br><span class="line">       mp_max int,</span><br><span class="line">       attack_max int,</span><br><span class="line">       defense_max int,</span><br><span class="line">       attack_range string,</span><br><span class="line">       role_main string,</span><br><span class="line">       role_assist string</span><br><span class="line">) partitioned by (role string)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725104741873.png" alt="image-20210725104741873"><figcaption aria-hidden="true">image-20210725104741873</figcaption>
</figure>
<p>分区表的创建可以分为静态分区和动态分区，本质上静态分区就是数据已经按照分区的形式划分为多个不同的文件，写SQL语句进行映射即可；而动态分区则是数据未进行分区，分区字段的值通过查询结果自动推断。</p>
<h4 id="静态分区">静态分区</h4>
<p>分区的字段值是由用户在加载数据的时候手动指定的。</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725104852600.png" alt="image-20210725104852600"><figcaption aria-hidden="true">image-20210725104852600</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data [local] inpath &#39; &#39; into table tablename partition(分区字段&#x3D;&#39;分区值&#39;...);</span><br><span class="line"></span><br><span class="line">-- 案例</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;archer.txt&#39; into table t_all_hero_part partition(role&#x3D;&#39;sheshou&#39;);</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;assassin.txt&#39; into table t_all_hero_part partition(role&#x3D;&#39;cike&#39;);</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;mage.txt&#39; into table t_all_hero_part partition(role&#x3D;&#39;fashi&#39;);</span><br></pre></td></tr></table></figure>
<p>Local表示数据是位于本地文件系统还是HDFS文件系统。上述案例表示文件都位于Hive服务器所在机器本地文件系统上。</p>
<h4 id="动态分区">动态分区</h4>
<p>往hive分区表中插入加载数据时，如果需要创建的分区很多，则需要复制粘贴修改很多sql去执行，效率低。因此hive提供了一个动态分区功能，其可以基于查询参数去推断分区的名称，从而建立分区。</p>
<p>所谓动态分区指的是分区的字段值是基于查询结果自动推断出来的。核心语法就是<strong>insert+select</strong>。</p>
<p>启用hive动态分区，需要在hive会话中设置两个参数，第一个参数表示开启动态分区功能；第二个参数指定动态分区的模式，分为nonstick非严格模式和strict严格模式。strict严格模式要求至少有一个分区为静态分区。：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> hive.exec.dynamic.partition=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">set</span> hive.exec.dynamic.partition.mode=nonstrict;</span><br></pre></td></tr></table></figure>
<p>执行动态分区插入的SQL为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into table t_all_hero_part_dynamic partition(role) </span><br><span class="line">select </span><br><span class="line">	tmp.*,</span><br><span class="line">	tmp.role_main </span><br><span class="line">from t_all_hero tmp;</span><br></pre></td></tr></table></figure>
<p>这样分区role字段的值就是通过 tmp.role_main 这个查询出来的字段自动推断的。</p>
<h4 id="hdfs中分区表底层原理">HDFS中分区表（底层原理）</h4>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725105722912.png" alt="image-20210725105722912"><figcaption aria-hidden="true">image-20210725105722912</figcaption>
</figure>
<p>从文件上来看，分区就是HDFS上的一个目录，可以指定多个分区，这样在插入数据的时候，hdfs 会产生多个目录。</p>
<h4 id="分区表的使用">分区表的使用</h4>
<p>1、建表时根据业务场景设置合适的分区字段。比如日期、地域、类别等；</p>
<p>2、查询的时候尽量先使用where进行分区过滤，查询指定分区的数据，避免全表扫描。</p>
<p>比如：查询英雄主要定位是射手并且最大生命大于6000的个数。使用分区表查询和使用非分区表进行查询，SQL如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 非分区表 全表扫描过滤查询</span><br><span class="line">select count(*) from t_all_hero where role_main&#x3D;&quot;archer&quot; and hp_max &gt;6000;</span><br><span class="line"></span><br><span class="line">-- 分区表 先基于分区过滤 再查询</span><br><span class="line">select count(*) from t_all_hero_part where role&#x3D;&quot;sheshou&quot; and hp_max &gt;6000;</span><br></pre></td></tr></table></figure>
<h4 id="多重分区">多重分区</h4>
<p>通过建表语句中关于分区的相关语法可以发现，Hive支持多个分区字段：PARTITIONED BY (partition1 data_type, partition2 data_type,….)。</p>
<p>多重分区下，分区之间是一种递进关系，可以理解为在前一个分区的基础上继续分区。从HDFS的角度来看就是文件夹下继续划分子文件夹。比如：把全国人口数据首先根据省进行分区，然后根据市进行划分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 双分区表，按省份和市分区</span><br><span class="line">create table t_user_province_city (id int, name string,age int) partitioned by (province string, city string);</span><br><span class="line"></span><br><span class="line">-- 加载数据</span><br><span class="line">load data local inpath &#39;文件路径&#39; into table t_user_province_city_county partition(province&#x3D;&#39;zhejiang&#39;,city&#x3D;&#39;hangzhou&#39;,county&#x3D;&#39;xiaoshan&#39;);</span><br></pre></td></tr></table></figure>
<h4 id="总结">总结</h4>
<p>1、分区表不是建表的必要语法规则，是一种优化手段表，可选；</p>
<p>2、分区字段不能是表中已有的字段，不能重复；</p>
<p>3、分区字段是虚拟字段，其数据并不存储在底层的文件中；</p>
<p>4、分区字段值来自于用户手动指定（静态分区）或者根据查询结果位置自动推断（动态分区）</p>
<p>5、Hive支持多重分区，也就是说在分区的基础上继续分区，划分更加细粒度</p>
<h3 id="hive分桶表">Hive分桶表</h3>
<h4 id="基础-2">基础</h4>
<p>分桶表，目的是将数据分为若干部分，在分桶时，要指定根据哪个字段将数据分为几桶（几个部分）。默认规则是：桶编号 = hash_function(分桶字段) mod 桶数量。</p>
<p>可以发现桶编号相同的数据会被分到同一个桶当中。hash_function取决于分桶字段的类型：</p>
<p>如果是int类型，hash_function(int) == int;</p>
<p>如果是其他类型，比如bigint,string或者复杂数据类型，hash_function比较棘手，将是从该类型派生的某个数字，比如hashcode值。</p>
<p>建表语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [EXTERNAL] TABLE [db_name.]table_name</span><br><span class="line">[(col_name data_type, ...)]</span><br><span class="line">CLUSTERED BY (col_name) SORTED BY (col_name) ASC&#x2F;DESC INTO N BUCKETS;</span><br></pre></td></tr></table></figure>
<p>其中CLUSTERED BY (col_name)表示根据哪个字段进行分；</p>
<p>INTO N BUCKETS表示分为几桶（也就是几个部分）。</p>
<p>需要注意的是，分桶的字段必须是<strong>表中已经存在的字段</strong>。</p>
<h4 id="建立分桶表案例">建立分桶表案例</h4>
<p>现有美国2021-1-28号，各个县county的新冠疫情累计案例信息，包括确诊病例和死亡病例，数据格式如下。字段含义为：count_date（统计日期）,county（县）,state（州）,fips（县编码code）,cases（累计确诊病例）,deaths（累计死亡病例）。</p>
<blockquote>
<p>2021-01-28,Juneau City and Borough,Alaska,02110,1108,3</p>
<p>2021-01-28,Kenai Peninsula Borough,Alaska,02122,3866,18</p>
<p>2021-01-28,Ketchikan Gateway Borough,Alaska,02130,272,1</p>
</blockquote>
<p>建表语句如下，可以指定分桶内数据排序规则（也可以不排序）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 根据state州分为5桶 每个桶内根据cases确诊病例数倒序排序</span><br><span class="line">CREATE TABLE itcast.t_usa_covid19_bucket(</span><br><span class="line">      count_date string,</span><br><span class="line">      county string,</span><br><span class="line">      state string,</span><br><span class="line">      fips int,</span><br><span class="line">      cases int,</span><br><span class="line">      deaths int)</span><br><span class="line">CLUSTERED BY(state) sorted by (cases desc) INTO 5 BUCKETS;</span><br></pre></td></tr></table></figure>
<p>将数据加载到创建的分桶表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- step1:开启分桶的功能 从Hive2.0开始不再需要设置</span><br><span class="line">set hive.enforce.bucketing&#x3D;true;</span><br><span class="line"></span><br><span class="line">-- step2:把源数据加载到普通hive表中</span><br><span class="line">CREATE TABLE itcast.t_usa_covid19(</span><br><span class="line">       count_date string,</span><br><span class="line">       county string,</span><br><span class="line">       state string,</span><br><span class="line">       fips int,</span><br><span class="line">       cases int,</span><br><span class="line">       deaths int)</span><br><span class="line">row format delimited fields terminated by &quot;,&quot;;</span><br><span class="line">-- 将源数据上传到HDFS，t_usa_covid19表对应的路径下</span><br><span class="line">hadoop fs -put us-covid19-counties.dat &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;itcast.db&#x2F;t_usa_covid19</span><br><span class="line"></span><br><span class="line">-- step3:使用insert+select语法将数据加载到分桶表中</span><br><span class="line">insert into t_usa_covid19_bucket select * from t_usa_covid19;</span><br></pre></td></tr></table></figure>
<p>到HDFS上查看t_usa_covid19_bucket底层数据结构可以发现，数据被分为了5个部分：</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725155054250.png" alt="image-20210725155054250"><figcaption aria-hidden="true">image-20210725155054250</figcaption>
</figure>
<h4 id="分桶表优点">分桶表优点</h4>
<p>1、基于分桶字段查询时，减少全表扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 基于分桶字段state查询来自于New York州的数据</span><br><span class="line">-- 不再需要进行全表扫描过滤</span><br><span class="line">-- 根据分桶的规则hash_function(New York) mod 5计算出分桶编号</span><br><span class="line">-- 查询指定分桶里面的数据 就可以找出结果  此时是分桶扫描而不是全表扫描</span><br><span class="line">select * from t_usa_covid19_bucket where state&#x3D;&quot;New York&quot;;</span><br></pre></td></tr></table></figure>
<p>2、JOIN时可以提高MR程序效率，减少笛卡尔积数量</p>
<p>对于JOIN操作两个表有一个相同的列，如果对这两个表都进行了分桶操作（刚好在这两列上）。那么将保存相同列值的桶进行JOIN操作就可以，可以大大较少JOIN的数据量。</p>
<p>3、 分桶表数据进行抽样</p>
<p>当数据量特别大时，对全体数据进行处理存在困难时，可以对每一个桶进行抽样。抽样可以从被抽取的数据中估计和推断出整体的特性，是科学实验、质量检验、社会调查普遍采用的一种经济有效的工作和研究方法。</p>
<h4 id="分桶表和分区表的区别">分桶表和分区表的区别</h4>
<h2 id="view-视图">View 视图</h2>
<h3 id="基础-3">基础</h3>
<p>Hive中的<strong>视图（view）是一种虚拟表，只保存定义，不实际存储数据</strong>。通常从真实的物理表查询中创建生成视图，也可以从已经存在的视图上创建新视图。</p>
<p>创建视图时，将冻结视图的架构，如果删除或更改基础表，则视图将失败，并且视图不能存储数据，操作数据，只能查询。</p>
<p>总结：视图是用来<strong>简化操作</strong>的，它其实是一张虚表，在视图中不缓存记录，也没有提高查询性能。</p>
<h3 id="语法">语法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- hive中有一张真实的基础表t_usa_covid19</span><br><span class="line">select *</span><br><span class="line">from itcast.t_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- 1、创建视图</span><br><span class="line">create view v_usa_covid19 </span><br><span class="line">as select count_date, county,state,deaths </span><br><span class="line">from t_usa_covid19 limit 5;</span><br><span class="line"></span><br><span class="line">-- 从已有的视图中创建视图呢</span><br><span class="line">create view v_usa_covid19_from_view as select * from v_usa_covid19 limit 2;</span><br><span class="line"></span><br><span class="line">-- 2、显示当前已有的视图 </span><br><span class="line">show tables;</span><br><span class="line">show views; -- hive v2.2.0之后支持</span><br><span class="line"></span><br><span class="line">-- 3、视图的查询使用</span><br><span class="line">select *</span><br><span class="line">from v_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- 能否插入数据到视图中呢？</span><br><span class="line">-- 不行 报错  SemanticException:A view cannot be used as target table for LOAD or INSERT</span><br><span class="line">insert into v_usa_covid19 select count_date,county,state,deaths from t_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- 4、查看视图定义</span><br><span class="line">show create table v_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- 5、删除视图</span><br><span class="line">drop view v_usa_covid19_from_view;</span><br><span class="line"></span><br><span class="line">-- 6、更改视图属性</span><br><span class="line">alter view v_usa_covid19 set TBLPROPERTIES (&#39;comment&#39; &#x3D; &#39;This is a view&#39;);</span><br><span class="line"></span><br><span class="line">-- 7、更改视图定义</span><br><span class="line">alter view v_usa_covid19 as  select county,deaths from t_usa_covid19 limit 2;</span><br></pre></td></tr></table></figure>
<h3 id="view的优势">View的优势</h3>
<p>1、将真实表中特定的列数据提供给用户，保护数据隐式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--通过视图来限制数据访问可以用来保护信息不被随意查询:</span><br><span class="line">create table userinfo(</span><br><span class="line">    firstname string, </span><br><span class="line">    lastname string, </span><br><span class="line">    ssn string, </span><br><span class="line">    password string);</span><br><span class="line"></span><br><span class="line">create view safer_user_info </span><br><span class="line">as select firstname, lastname from userinfo;</span><br><span class="line"></span><br><span class="line">--可以通过where子句限制数据访问，比如，提供一个员工表视图，只暴露来自特定部门的员工信息:</span><br><span class="line">create table employee(</span><br><span class="line">    firstname string, </span><br><span class="line">    lastname string, </span><br><span class="line">    ssn string,</span><br><span class="line">    password string, </span><br><span class="line">    department string);</span><br><span class="line"></span><br><span class="line">create view techops_employee </span><br><span class="line">as select firstname, lastname, ssn from userinfo </span><br><span class="line">where department &#x3D; &#39;java&#39;;</span><br></pre></td></tr></table></figure>
<p>2、降低查询的复杂度，优化查询语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 把嵌套子查询变成一个视图</span><br><span class="line">create view shorter_join as</span><br><span class="line">select * from people join cart</span><br><span class="line">on (cart.pepople_id &#x3D; people.id) where firstname &#x3D; &#39;join&#39;;</span><br><span class="line"></span><br><span class="line">-- 基于视图查询</span><br><span class="line">select lastname from shorter_join where id &#x3D; 3;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="物化视图">物化视图</h3>
<h4 id="基础-4">基础</h4>
<p>物化视图（Materialized View）是一个包括查询结果的数据库对像，可以用于预<strong>先计算并保存表连接或聚集等耗时较多的操作的结果</strong>。这样，在执行查询时，就可以避免进行这些耗时的操作，而从快速的得到结果。使用物化视图的目的就是<strong>通过预计算，提高查询性能</strong>，当然需要占用一定的存储空间。</p>
<p>Hive3.0开始尝试引入物化视图，并提供对于物化视图的查询自动重写（基于Apache Calcite实现）。值得注意的是，3.0中提供了物化视图存储选择机制，可以本地存储在hive，同时可以通过用户自定义storage handlers存储在其他系统（如Druid）。</p>
<p>Hive引入物化视图的目的就是为了优化数据查询访问的效率,相当于从数据预处理的角度优化数据访问。Hive3.0丢弃了index索引的语法支持，推荐使用物化视图和列式存储文件格式来加快查询的速度。</p>
<h4 id="与视图的区别">与视图的区别</h4>
<p>1、视图是虚拟的，逻辑存在的，只有定义没有存储数据。物化视图是真实的，物理存在的，里面存储着预计算的数据。</p>
<p>不同于视图，物化视图能够缓存数据，在创建物化视图的时候就把数据缓存起来了，hive把物化视图当成一张“表”，将数据缓存。而视图只是创建一个虚表，只有表结构，没有数据，实际查询的时候再去改写SQL去访问实际的数据表。</p>
<p>2、视图的目的是简化降低查询的复杂度，而物化视图的目的是提高查询性能。</p>
<h4 id="语法-1">语法</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--物化视图的创建语法</span><br><span class="line">CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db_name.]materialized_view_name</span><br><span class="line">    [DISABLE REWRITE]</span><br><span class="line">    [COMMENT materialized_view_comment]</span><br><span class="line">    [PARTITIONED ON (col_name, ...)]</span><br><span class="line">    [CLUSTERED ON (col_name, ...) | DISTRIBUTED ON (col_name, ...) SORTED ON (col_name, ...)]</span><br><span class="line">    [</span><br><span class="line">    [ROW FORMAT row_format]</span><br><span class="line">    [STORED AS file_format]</span><br><span class="line">    | STORED BY &#39;storage.handler.class.name&#39; [WITH SERDEPROPERTIES (...)]</span><br><span class="line">  ]</span><br><span class="line">  [LOCATION hdfs_path]</span><br><span class="line">  [TBLPROPERTIES (property_name&#x3D;property_value, ...)]</span><br><span class="line">AS SELECT ...;</span><br></pre></td></tr></table></figure>
<p>语法说明： 1、物化视图创建后，select查询执行数据自动落地，"自动"也即在query的执行期间，任何用户对该物化视图是不可见的</p>
<p>2、默认该物化视图可被用于查询优化器optimizer查询重写（在物化视图创建期间可以通过DISABLE REWRITE参数设置禁止使用）</p>
<p>3、SerDe和storage format非强制参数，可以用户配置，默认可用hive.materializedview.serde、 hive.materializedview.fileformat</p>
<p>4、物化视图可以使用custom storage handlers存储在外部系统（如druid）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE MATERIALIZED VIEW druid_wiki_mv</span><br><span class="line">STORED AS &#39;org.apache.hadoop.hive.druid.DruidStorageHandler&#39;</span><br><span class="line">AS SELECT </span><br><span class="line">__time, page, user, c_added, c_removed</span><br><span class="line">FROM src;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5、目前支持物化视图的drop和show操作，后续会增加其他操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Drops a materialized view</span><br><span class="line">DROP MATERIALIZED VIEW [db_name.]materialized_view_name;</span><br><span class="line">-- Shows materialized views (with optional filters)</span><br><span class="line">SHOW MATERIALIZED VIEWS [IN database_name];</span><br><span class="line">-- Shows information about a specific materialized view</span><br><span class="line">DESCRIBE [EXTENDED | FORMATTED] [db_name.]materialized_view_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>6、当数据源变更（新数据插入inserted、数据修改modified），物化视图也需要更新以保持数据一致性，目前需要用户主动触发rebuild</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER MATERIALIZED VIEW [db_name.]materialized_view_name REBUILD;</span><br></pre></td></tr></table></figure>
<h4 id="基于物化视图的查询重写">基于物化视图的查询重写</h4>
<p>物化视图创建后即可用于相关查询的加速，用户提交查询query，若该query经过重写后可命中已建视图，则被重写命中相关已建视图实现查询加速。</p>
<p>是否重写查询使用物化视图可以通过全局参数控制，默认为true： SET hive.materializedview.rewriting=true;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1、新建一张事务表 student_trans</span><br><span class="line">set hive.support.concurrency &#x3D; true; --Hive是否支持并发</span><br><span class="line">set hive.enforce.bucketing &#x3D; true; --从Hive2.0开始不再需要  是否开启分桶功能</span><br><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict; --动态分区模式  非严格</span><br><span class="line">set hive.txn.manager &#x3D; org.apache.hadoop.hive.ql.lockmgr.DbTxnManager; --</span><br><span class="line">set hive.compactor.initiator.on &#x3D; true; --是否在Metastore实例上运行启动线程和清理线程</span><br><span class="line">set hive.compactor.worker.threads &#x3D; 1; --在此metastore实例上运行多少个压缩程序工作线程。</span><br><span class="line"></span><br><span class="line">CREATE TABLE student_trans (</span><br><span class="line">      sno int,</span><br><span class="line">      sname string,</span><br><span class="line">      sdept string)</span><br><span class="line">clustered by (sno) into 2 buckets stored as orc TBLPROPERTIES(&#39;transactional&#39;&#x3D;&#39;true&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 2、导入数据到student_trans中</span><br><span class="line">insert overwrite table student_trans</span><br><span class="line">select sno,sname,sdept</span><br><span class="line">from student;</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from student_trans;</span><br><span class="line"></span><br><span class="line">-- 3、对student_trans建立聚合物化视图</span><br><span class="line">CREATE MATERIALIZED VIEW student_trans_agg</span><br><span class="line">AS SELECT sdept, count(*) as sdept_cnt from student_trans group by sdept;</span><br><span class="line"></span><br><span class="line">-- 注意 这里当执行CREATE MATERIALIZED VIEW，会启动一个MR对物化视图进行构建</span><br><span class="line">-- 可以发现当下的数据库中有了一个物化视图</span><br><span class="line">show tables;</span><br><span class="line">show materialized views;</span><br><span class="line"></span><br><span class="line">-- 4、对原始表student_trans查询</span><br><span class="line">-- 由于会命中物化视图，重写query查询物化视图，查询速度会加快（没有启动MR，只是普通的table scan）</span><br><span class="line">SELECT sdept, count(*) as sdept_cnt from student_trans group by sdept;</span><br><span class="line"></span><br><span class="line">-- 5、查询执行计划可以发现 查询被自动重写为TableScan alias: itcast.student_trans_agg</span><br><span class="line">-- 转换成了对物化视图的查询  提高了查询效率</span><br><span class="line">explain SELECT sdept, count(*) as sdept_cnt from student_trans group by sdept;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka常见面试题</title>
    <url>/2021/07/29/Kafka_%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="总结">总结</h4>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th>问题</th>
<th>解答</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>为什么用</td>
<td>缓冲、解耦、冗余、健壮与异步</td>
</tr>
<tr class="even">
<td>可靠性</td>
<td>partition向producer发送ack</td>
</tr>
<tr class="odd">
<td>ack机制</td>
<td>接收没写入、leader落盘、全部落盘</td>
</tr>
<tr class="even">
<td>Exactly Once</td>
<td>At Least Once（数据重复） + 幂等性（仅持久化一条） = Exactly Once（数据不重复且不丢失）；对&lt; PID, Partition, SeqNumber&gt;主键做缓存</td>
</tr>
<tr class="odd">
<td>速度快的原因</td>
<td>磁盘顺序写入、parition中数据分段以及段内索引、内存操作直接映射到物理硬盘</td>
</tr>
<tr class="even">
<td>副本同步策略</td>
<td>全部follower完成同步，才发送ack，需要的副本数较少（n+1）</td>
</tr>
<tr class="odd">
<td>ISR</td>
<td>意为和leader保持同步的follower集合，未定期发送ack者被踢出去</td>
</tr>
<tr class="even">
<td>故障处理</td>
<td>HW之前的数据才会对Consumer可见，所以出现故障的时候，Consumer从HW处继续消费消息</td>
</tr>
<tr class="odd">
<td>读写分离</td>
<td>延时敏感应用，数据一致性问题和延迟问题（经过磁盘）</td>
</tr>
<tr class="even">
<td>消费者分区分配策略</td>
<td>range（分区/线程）RoundRobinAssignor（排序加轮询）StickyAssignor（分区数最多差1，与上次分配相同）</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h4 id="为什么要使用-kafka">为什么要使用 kafka？</h4>
<p>1、缓冲：上游数据流量暴增，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的处理速度处理数据。</p>
<p>2、解耦：解耦重要业务，提高扩展能力（需求不确定的时候）</p>
<p>3、冗余：将一个消息提供给多个topic，被不同业务使用</p>
<p>4、健壮：缓存消息，防止消费者挂掉丢失消息</p>
<p>5、异步：缓存消息，需要的时候再处理消息</p>
<h4 id="kafka的数据可靠性怎么保证">kafka的数据可靠性怎么保证</h4>
<p>ack机制。</p>
<p>为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p>
<h4 id="ack应答机制">ack应答机制</h4>
<p>Kafka提供三种可靠性级别，根据对可靠性和延迟的要求进行权衡。acks参数配置：</p>
<ul>
<li>0：producer不等待broker的ack，<strong>最低的延迟</strong>，<strong>broker一接收到还没有写入磁盘</strong>就已经返回，当broker故障时有可能丢失数据。</li>
<li>1：producer等待broker的ack，<strong>partition的leader落盘成功后返回ack</strong>，如果在follower同步成功之前leader故障，那么follower将会丢失数据。</li>
<li>-1（all）：producer等待broker的ack，<strong>partition的leader和follower全部落盘成功后才返回ack</strong>。但是如果在follower同步完成后，broker发送ack之前，leader发生故障，那么会造成数据重复。</li>
</ul>
<h4 id="exactly-once语义pidseq">Exactly Once语义（&lt;PID,Seq&gt;）</h4>
<p>将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即At Least Once语义。将服务器ACK级别设置为0，可以保证生产者每条消息只会被发送一次，即At Most Once语义。</p>
<p>At Least Once可以保证数据不丢失，但是不能保证数据不重复；</p>
<p>At Most Once可以保证数据不重复，但是不能保证数据不丢失。</p>
<blockquote>
<p>但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即Exactly Once语义。在0.11版本以前的Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p>
</blockquote>
<p>0.11版本的Kafka，引入了一项重大特性：幂等性。</p>
<p><strong>幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条</strong>。开启幂等性enable.idempotence=true。</p>
<p>因此，At Least Once（数据重复） + 幂等性（仅持久化一条） = Exactly Once（数据不重复且不丢失）</p>
<p><strong>Exactly Once的语义就是保证Producer的每条消息不会丢失且仅被持久化一条。</strong></p>
<p>Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会<strong>对&lt; PID, Partition, SeqNumber&gt;做缓存</strong>，当具有相同主键的消息提交时，Broker只会持久化一条。</p>
<p>但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once。</p>
<blockquote>
<p>流式计算中怎么Exactly Once语义？以flink为例</p>
<p>1、souce：</p>
<p>使用执行ExactlyOnce的数据源，比如kafka等。</p>
<p>内部使用FlinkKafakConsumer，并开启CheckPoint，<strong>偏移量会保存到StateBackend中</strong>，并且默认会将偏移量写入到topic中去，即 _ consumer_offsets Flink设置CheckepointingModel.EXACTLY_ONCE</p>
<p>2、sink</p>
<p>存储系统支持幂等性：如Redis,Hbase,ES等</p>
<p>存储系统不支持幂等性：需要支持事务(预写式日志或者两阶段提交)，两阶段提交可参考Flink集成的kafka sink的实现。</p>
</blockquote>
<h4 id="kafka为什么速度会快">Kafka为什么速度会快？</h4>
<p>kafka使用的是磁盘存储。</p>
<p>1、顺序写入：因为硬盘每次读写都会先寻址再写入，其中寻址是是耗时的。所以硬盘在顺序I/O的时候能够减少耗时。因此为了提高读写硬盘的速度，Kafka就是使用顺序I/O。</p>
<p>2、高效文件存储设计：<strong>数据文件分段以及每个段内建立索引</strong>。</p>
<blockquote>
<p>数据文件分段：Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</p>
<p>比如有100条Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文件里面，数据文件以该段中 小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段中。</p>
<p>建立索引：为了避免顺序扫描才能找到对应offset的Message，进一步提高查找的效率，Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index</p>
</blockquote>
<p>3、Memory Mapped Files（内存映射文件）：64位操作系统中一般可以表示20G的数据文件，它的工作原理是<strong>直接利用操作系统的Page来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上</strong>。</p>
<h4 id="副本数据同步策略">副本数据同步策略</h4>
<p>副本数包含leader和follower，全部follower完成同步才发送ack。</p>
<blockquote>
<p>Producer 只将该消息发送到该 Partition 的Leader。Leader 会将该消息写入其本地 Log。每个 Follower都从 Leader pull 数据。这种方式上，Follower 存储的数据顺序与 Leader 保持一致。Follower 在收到该消息并写入其Log 后，向 Leader 发送 ACK。一旦 Leader 收到了 ISR 中的所有 Replica 的 ACK，该消息就被认为已经 commit 了，Leader 将增加 HW(HighWatermark)并且向 Producer 发送ACK。</p>
</blockquote>
<p>有两个方案对比如下：</p>
<p>半数以上follower完成同步，就发送ack（优点：延迟低；缺点：选举新的leader时，容忍n台节点的故障，需要2n+1个副本）</p>
<p>全部follower完成同步，才发送ack（优点：选举新的leader时，容忍n台节点的故障，需要n+1个副本；缺点：延迟高）</p>
<p>kafka采用零拷贝技术优化数据传输，因此网络延迟对kafka的影响较小，所以选择全部follower完成同步，才发送ack。</p>
<blockquote>
<p>https://blog.csdn.net/qq_43437122/article/details/108359748</p>
<p>假设有5台机器，现在存在一个topic为A，它有一个分区。5台机器最多容忍4台机器故障（如果全故障那你的Kafka Cluster不就凉了?），现在假设有4台机器故障，只有1台机器健康。</p>
<p>全同步策略：由于是全部follower完成同步，才发送ack，所以topic A 分区下的5个副本（leader + fllower）分别位于这5台机器上，那么那台没有故障的机器（也就是broker）的副本（fllower，假设此时leader故障）就会成为leader继续工作。也即是全同步策略下，容忍n台节点故障，需要n+1个副本。</p>
<p>半数同步策略：现在是4（n）台机器发生了故障，副本数为5（n+1），由于是半数机制，所以topic A 分区下的副本数只要存在3个（leader + flllower）broker就会发送ack。可是此时四台节点故障，<strong>Kafka集群里面只有三个副本，这就不能保证没故障的节点存在topic A 分区下的副本</strong>。副本数应设置为9个（2n+1）。如果副本数为9，topic A分区下副本数量为5时broker才会发送ack， 这<strong>就保证了每个节点都存在topic A 分区下的一个副本</strong>，此时如果4台节点故障（假设leader故障），那台没故障的机器就会成为leader继续工作。也即是半同步策略下，容忍n台节点故障，需要2n+1个副本。</p>
</blockquote>
<h4 id="isr">ISR</h4>
<p>in-sync replica set (ISR)，意为和leader保持同步的follower集合。</p>
<blockquote>
<p>问题产生原因：如果采用全部完成同步，才发送ack的副本的同步策略的话，若所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？</p>
</blockquote>
<p>当ISR中的follower完成数据的同步之后，leader就会给follower发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定。Leader发生故障之后，就会从ISR中选举新的leader。</p>
<h4 id="故障处理">故障处理</h4>
<p>LEO（Log End Offset）：指的是每个副本最大的offset。</p>
<p>HW（High Watermark）：指的是消费者能见到的最大的offset，ISR队列中最小的LEO。</p>
<p>HW之前的数据才会对Consumer可见，所以出现故障的时候，Consumer从HW处继续消费消息，就不会产生重复消费消息的问题。</p>
<p><img src="/2021/07/29/Kafka_%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210729080554829.png" alt="image-20210729080554829" style="zoom: 50%;"></p>
<h4 id="kafka事务">kafka事务</h4>
<p>Kafka从0.11版本开始引入了事务支持。事务可以保证Kafka在Exactly Once语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p>
<ul>
<li>Producer端事务</li>
</ul>
<p>为了实现跨分区跨会话的事务，需要引入一个<strong>全局唯一的Transaction ID，并将Producer获得的PID和Transaction ID绑定</strong>。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的PID。</p>
<p>为了管理Transaction，Kafka引入了一个新的组件Transaction Coordinator。Producer就是通过和Transaction Coordinator交互获得Transaction ID对应的任务状态。Transaction Coordinator还负责将事务所有写入Kafka的一个内部Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p>
<ul>
<li>Consumer端事务</li>
</ul>
<p>对于Consumer而言，事务的保证就会相对较弱，尤其无法保证Commit的信息被精确消费。这是由于Consumer可以通过offset访问任意信息，而且不同的Segment File生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p>
<h4 id="kafka为什么不支持读写分离"><strong>Kafka为什么不支持读写分离？</strong></h4>
<p>在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。</p>
<p>Kafka 并不支持主写从读，因为主写从读有 2 个很明显的缺点:</p>
<p>1、数据一致性问题：数据从主节点转到从节点必然会有一个<strong>延时的时间窗口</strong>，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。</p>
<p>2、延时问题：类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经历 网络→主节点内存→网络→从节点内存 这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历 网络→主节点内存→<strong>主节点磁盘</strong>→网络→从节 点内存→从节点磁盘 这几个阶段。</p>
<p>对延时敏感的应用而言，主写从读的功能并不太适用。</p>
<h4 id="kafka的消费分区分配策略负载均衡">kafka的消费分区分配策略（负载均衡）</h4>
<p>一个consumer group中有多个consumer，一个topic有多个partition，所以必然会涉及到partition的分配问题，即确定哪个partition由哪个consumer来消费。</p>
<p>Kafka有三种分配策略，一是RoundRobin，一是Range。高版本还有一个StickyAssignor策略。</p>
<p>将分区的所有权从一个消费者移到另一个消费者称为重新平衡（rebalance）。当以下事件（消费者增加或减少）发生时，Kafka 将会进行一次分区分配：</p>
<ul>
<li><p>同一个 Consumer Group 内新增消费者。</p></li>
<li><p>消费者离开当前所属的Consumer Group，包括shuts down或crashes。</p></li>
</ul>
<p><strong>Range</strong></p>
<p>用<strong>partition数除以消费者线程的总数</strong>来决定每个消费者线程消费几个partition，每一个消费者都能获得尽可能多的分区。</p>
<p>首先对同一个Topic里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。然后用Partitions分区的个数除以消费者线程的总数来决定每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。</p>
<p>假设n=分区数/消费者数量，m=分区数%消费者数量，那么前m个消费者每个分配n+1个分区，后面的（消费者数量-m）个消费者每个分配n个分区。</p>
<blockquote>
<p>假如有10个分区，3个消费者线程，把分区按照序号排列</p>
<p>0，1，2，3，4，5，6，7，8，9</p>
<p>消费者线程为</p>
<p>C1-0，C2-0，C2-1</p>
<p>在例子里面，有10个分区，3个消费者线程，10/3 = 3，而且除除不尽，那么消费者线程C1-0将会多消费一个分区，所以最后分区分配的结果看起来是这样的：</p>
<p>C1-0：0，1，2，3</p>
<p>C2-0：4，5，6</p>
<p>C2-1：7，8，9</p>
<p>假如有两个主题T1,T2，分别有10个分区，最后的分配结果将会是这样：</p>
<p>C1-0：T1（0，1，2，3） T2（0，1，2，3）</p>
<p>C2-0：T1（4，5，6） T2（4，5，6）</p>
<p>C2-1：T1（7，8，9） T2（7，8，9）</p>
</blockquote>
<p><strong>RoundRobinAssignor</strong></p>
<p>将消费组内所有消费者以及消费者所订阅的所有topic的partition按照字典序排序，然后<strong>通过轮询方式</strong>逐个将分区以此分配给每个消费者，即先排序后轮询分配。</p>
<p>前提是：</p>
<p>1、同一个消费者组里面的所有消费者的num.streams（线程数）必须相等。</p>
<p>2、每个消费者订阅的主题必须相同。</p>
<blockquote>
<p>假如按照 hashCode 排序完的topic-partitions组依次为</p>
<p>T1-5, T1-3, T1-0, T1-8, T1-2, T1-1, T1-4, T1-7, T1-6, T1-9</p>
<p>我们的消费者线程排序为</p>
<p>C1-0, C1-1, C2-0, C2-1</p>
<p>最后分区分配的结果为轮询分配的结果：</p>
<p>C1-0 将消费 T1-5, T1-2, T1-6 分区</p>
<p>C1-1 将消费 T1-3, T1-1, T1-9 分区</p>
<p>C2-0 将消费 T1-0, T1-4 分区</p>
<p>C2-1 将消费 T1-8, T1-7 分区</p>
</blockquote>
<p><strong>StickyAssignor</strong></p>
<p>Kafka从0.11.x版本开始引入这种分配策略，他主要解决当某个消费者离开的时候再分配的问题。</p>
<p>1、分区的分配要尽可能的均匀，分配给消费者者的主题分区数最多相差一个</p>
<p>2、<strong>分区的分配尽可能的与上次分配的保持相同</strong></p>
<p>3、当两者发生冲突时，第一个目标优先于第二个目标。</p>
<blockquote>
<p>原因是：</p>
<p>如果发生分区重分配，那么对于同一个分区而言有可能之前的消费者和新指派的消费者不是同一个，对于之前消费者进行到一半的处理还要在新指派的消费者中再次复现一遍，这显然很浪费系统资源。StickyAssignor策略如同其名称中的“sticky”一样，让分配策略具备一定的“粘性”，尽可能地让前后两次分配相同，进而减少系统资源的损耗以及其它异常情况的发生。</p>
</blockquote>
<p>所有消费者订阅所有主题的案例：</p>
<blockquote>
<p>假设消费组内有3个消费者</p>
<p>C0、C1、C2</p>
<p>它们都订阅了4个主题：</p>
<p>t0、t1、t2、t3</p>
<p>并且每个主题有2个分区，也就是说整个消费组订阅了</p>
<p>t0p0、t0p1、t1p0、t1p1、t2p0、t2p1、t3p0、t3p1这8个分区</p>
<p>最终的分配结果如下：</p>
<p>消费者C0：t0p0、t1p1、t3p0</p>
<p>消费者C1：t0p1、t2p0、t3p1</p>
<p>消费者C2：t1p0、t2p1</p>
<p>这样初看上去似乎与采用RoundRobinAssignor策略所分配的结果相同</p>
<p>此时<strong>假设消费者C1脱离了消费组</strong>，那么消费组就会执行再平衡操作，进而消费分区会重新分配。如果采用RoundRobinAssignor策略，那么此时的分配结果如下：</p>
<p>消费者C0：t0p0、t1p0、t2p0、t3p0</p>
<p>消费者C2：t0p1、t1p1、t2p1、t3p1</p>
<p>如分配结果所示，RoundRobinAssignor策略会按照消费者C0和C2进行重新轮询分配。而如果此时使用的是StickyAssignor策略，那么分配结果为：</p>
<p>消费者C0：t0p0、t1p1、t3p0、t2p0</p>
<p>消费者C2：t1p0、t2p1、t0p1、t3p1</p>
<p>可以看到分配结果中<strong>保留了上一次分配中对于消费者C0和C2的所有分配结果，并将原来消费者C1的“负担”分配给了剩余的两个消费者C0和C2</strong>，最终C0和C2的分配还保持了均衡。</p>
</blockquote>
<p>消费者订阅不同主题的案例：</p>
<blockquote>
<p>消费组内有3个消费者：</p>
<p>C0、C1、C2</p>
<p>集群中有3个主题：</p>
<p>t0、t1、t2</p>
<p>这3个主题分别有</p>
<p>1、2、3个分区</p>
<p>也就是说集群中有</p>
<p>t0p0、t1p0、t1p1、t2p0、t2p1、t2p2这6个分区</p>
<p>消费者C0订阅了主题t0</p>
<p>消费者C1订阅了主题t0和t1</p>
<p>消费者C2订阅了主题t0、t1和t2</p>
<p>如果此时采用RoundRobinAssignor策略：</p>
<p>消费者C0：t0p0</p>
<p>消费者C1：t1p0</p>
<p>消费者C2：t1p1、t2p0、t2p1、t2p2</p>
<p>如果此时采用的是StickyAssignor策略：</p>
<p>消费者C0：t0p0</p>
<p>消费者C1：t1p0、t1p1 （每个消费者分区数最多相差1个，C1和C2都订t1，因此不能都分给C2）</p>
<p>消费者C2：t2p0、t2p1、t2p2</p>
<p>此时消费者C0脱离了消费组，那么RoundRobinAssignor策略的分配结果为：</p>
<p>消费者C1：t0p0、t1p1</p>
<p>消费者C2：t1p0、t2p0、t2p1、t2p2</p>
<p>StickyAssignor策略，那么分配结果为：</p>
<p>消费者C1：t1p0、t1p1、t0p0</p>
<p>消费者C2：t2p0、t2p1、t2p2</p>
<p>可以看到StickyAssignor策略保留了消费者C1和C2中原有的5个分区的分配：</p>
<p>t1p0、t1p1、t2p0、t2p1、t2p2。</p>
</blockquote>
<h4 id="参考资料">参考资料</h4>
<p>https://mp.weixin.qq.com/s/ftkzB36cZ5b-D1go_87fXQ</p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 性能分析：Explain</title>
    <url>/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="简介">简介</h3>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424200735834.png" alt="image-20220424200735834" style="zoom:67%;"></p>
<p>如果想查看某个查询的执行计划的话，可以在具体的查询语句前边加一个EXPLAIN ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM table;</span><br></pre></td></tr></table></figure>
<p>EXPLAIN 语句输出的各个列的作用如下：</p>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424200814109.png" alt="image-20220424200814109" style="zoom:67%;"></p>
<p>注意，EXPLAIN并不会真正去执行SQL语句，而只是返回根据统计信息得到的执行计划。</p>
<p>下文案例中的表结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE s1 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE&#x3D;INNODB CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE s2 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE&#x3D;INNODB CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>
<h3 id="table">table</h3>
<p>table字段表示当前语句需要查询的表的名称。</p>
<p>不论查询语句有多复杂，里面包含了多少个表，到最后也是需要对每个表进行单表访问的，所以MySQL规定<strong>EXPLAIN语句输出的每条记录</strong>都对应着某个单表的访问，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p>
<h3 id="id">id</h3>
<p>id字段表示每个查询。每个SELECT关键字都对应一个唯一的id。</p>
<ul>
<li><p>id如果相同，可以认为是一组，执行顺序从上往下顺序执行。</p></li>
<li><p>在所有组中，id值越大，优先级越高，越先执行。（特别是子查询中出现）</p></li>
<li><p>关注点：每个id，表示一趟独立的查询, 一个sql的查询趟数越少越好，即id号越小越好。</p></li>
</ul>
<p>单表查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424202043937.png" alt="image-20220424202043937" style="zoom:67%;"></p>
<p>双表关联：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424202131030.png" alt="image-20220424202131030" style="zoom: 70%;"></p>
<p>id相同，查询顺序从上往下顺序执行，不是嵌套的关系。</p>
<p>嵌套子查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424202345454.png" alt="image-20220424202345454" style="zoom:67%;"></p>
<p>子查询的id更大，更优先被执行，查询之间是嵌套执行的关系。</p>
<p>重写的嵌套子查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field &#x3D; &#39;a&#39;);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424202525919.png" alt="image-20220424202525919" style="zoom: 75%;"></p>
<p>即使是子查询，id相同，说明并非嵌套的关系，查询语句被重写为顺序执行的多表关联形式。</p>
<p>UNION存在临时表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424202713236.png" alt="image-20220424202713236" style="zoom:75%;"></p>
<p>没有id的表，说明是临时表。这里是UNION操作是需要去重的，因此需要构建临时表进行去重操作。</p>
<p>UNION ALL不存在临时表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424203505976.png" alt="image-20220424203505976" style="zoom: 75%;"></p>
<p>不需要去重操作，因此不需要创建临时表。</p>
<h3 id="select_type">select_type</h3>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424222150781.png" alt="image-20220424222150781" style="zoom:67%;"></p>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424222220693.png" alt="image-20220424222220693" style="zoom:67%;"></p>
<p>SIMPLE：不包括UNION或者子查询的简单查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#简单查询</span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br><span class="line"></span><br><span class="line">#表关联也算SIMPLE</span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure>
<p>PRIMARY、UNION、UNION RESULT：子查询以及包含UNION或UNION ALL的情况</p>
<p>最左边查询的select_type为PRIMARY，其余的为UNION。</p>
<p>子查询中最外层的查询也为PRIMARY。</p>
<p>使用临时表进行去重时，产生临时表的查询对应的select_type为UNION RESULT。（UNION ALL就不会产生临时表）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424222519041.png" alt="image-20220424222519041"><figcaption aria-hidden="true">image-20220424222519041</figcaption>
</figure>
<p>SUBQUERY：不相关子查询</p>
<p>包含子查询的语句不能转换为“semi-join“的形式（即表关联的形式），并且该子查询不是相关子查询（即<strong>子查询用到外查询的表作为过滤条件</strong>），则子查询的select_type为SUBQUERY。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424223021995.png" alt="image-20220424223021995"><figcaption aria-hidden="true">image-20220424223021995</figcaption>
</figure>
<p>DEPENDENT SUBQUERY：相关子查询</p>
<p>包含子查询的语句不能转换为“semi-join“的形式（即表关联的形式），并且该子查询是相关子查询（即<strong>子查询用到外查询的表作为过滤条件</strong>），则子查询的select_type为DEPENDENT SUBQUERY。</p>
<p>这样的子查询可能被执行多次，因为外层每次朝内层传递一个值，内层子查询就会执行一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 &#x3D; s2.key2) OR key3 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424220602045.png" alt="image-20220424220602045"><figcaption aria-hidden="true">image-20220424220602045</figcaption>
</figure>
<p>DEPENDENT UNION：含有UNION的子查询</p>
<p>在包含UNION或UNION ALL的子查询时，如果各个子查询都依赖于外层查询的话，最左边的小查询select_type为DEPENDENT SUBQUERY，其余的就是DEPENDENT UNION。</p>
<p>下面的例子本质上是因为将IN语句改写为了EXSISTS语句，因此会重构为依赖于外层的子查询，所以含有DEPENDENT UNION。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 &#x3D; &#39;a&#39; UNION SELECT key1 FROM s1 WHERE key1 &#x3D; &#39;b&#39;);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424221136519.png" alt="image-20220424221136519"><figcaption aria-hidden="true">image-20220424221136519</figcaption>
</figure>
<p>DERIVED：含有派生表的查询</p>
<p>包含派生表（由查询语句生成的表）的查询语句，生成该派生表的查询语句，对应的select_type为DERIVED。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c &gt; 1;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424221741379.png" alt="image-20220424221741379"><figcaption aria-hidden="true">image-20220424221741379</figcaption>
</figure>
<p>MATERIALIZED：物化表</p>
<p>子查询的结果被转化为物化表，供外层的结果进行表关联时，该子查询对应的select_type为MATERIALIZED</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424222150781.png" alt="image-20220424222150781" style="zoom:67%;"></p>
<h3 id="type">type</h3>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424223923240.png" alt="image-20220424223923240" style="zoom:67%;"></p>
<p>所有访问方法从优到劣可以排序为： system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ，index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL 。</p>
<p>从访问方法可以大约地看出查询语句的执行效率。</p>
<p>结果值从最好到最坏依次是： <strong>system &gt; const &gt; eq_ref &gt; ref </strong>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range &gt; index &gt; ALL</strong>。其中比较重要的几个由粗体标识。</p>
<p>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴开发手册要求）</p>
<p>system</p>
<p>当表中只有一条记录，并且该表使用的存储引擎中统计数据时精确的，那么对表的访问方法是system。</p>
<p>这里存储引擎实际上就是MyISAM或Memory，因为他们额外存储了一些统计数据比如表中的数据条数，使用时直接获得不需要去表中查，而InnoDB则需要查询表中的数据才能获得精确的统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(i int) Engine&#x3D;MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM t;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424224109166.png" alt="image-20220424224109166"></p>
<p>const</p>
<p>根据主键或者唯一性约束的字段，与常数进行等值匹配，那么对表的访问方法是const。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id &#x3D; 10005;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424224701943.png" alt="image-20220424224701943"><figcaption aria-hidden="true">image-20220424224701943</figcaption>
</figure>
<p>eq_ref</p>
<p>在表关联时，若被驱动表通过主键或唯一性约束的字段，和驱动表进行等值访问时，对被驱动表的访问方法是eq_ref。</p>
<p>如果该主键或唯一性约束的字段是联合索引，所有联合索引中的字段都必须进行等值比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id &#x3D; s2.id;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424225155386.png" alt="image-20220424225155386"><figcaption aria-hidden="true">image-20220424225155386</figcaption>
</figure>
<p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问方法是eq_ref ，表明在访问s1表的时候可以通过主键的等值匹配来进行访问。</p>
<p>也就是每次将s2中字段id的值取出来在s1中查询。</p>
<p>ref以及ref_or_null</p>
<p>使用普通的<strong>二级索引（即非聚簇索引）</strong>进行<strong>等值</strong>匹配时，那么对表的访问方法是ref。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425194534782.png" alt="image-20220425194534782"><figcaption aria-hidden="true">image-20220425194534782</figcaption>
</figure>
<p>当该字段上的值可以是NULL时，对表的访问方法是ref_or_null。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39; OR key1 IS NULL;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425194733208.png" alt="image-20220425194733208"><figcaption aria-hidden="true">image-20220425194733208</figcaption>
</figure>
<p>index_merge</p>
<p>查询条件中的字段存在索引，并且使用OR连接时，那么对表的访问方法是index_merge，即采用索引合并的方式进行查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39; OR key3 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425195051891.png" alt="image-20220425195051891"><figcaption aria-hidden="true">image-20220425195051891</figcaption>
</figure>
<p>从执行计划的type 列的值是index_merge 就可以看出，MySQL 打算使用索引合并的方式来执行对s1 表的查询，即两个索引都使用到了。</p>
<p>unique_subquery</p>
<p>是针对子查询中表的访问方法。</p>
<p>当一个查询语句中有包含“IN”的子查询；如果查询优化器决定将“IN”子查询转换为“EXISTS”子查询；且<strong>子查询可以用到主键进行匹配</strong>，那么对表的访问方法是unique_subquery。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 &#x3D; s2.key1) OR key3 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425195724604.png" alt="image-20220425195724604"><figcaption aria-hidden="true">image-20220425195724604</figcaption>
</figure>
<p>可以看出，外层是ALL，因为每次都需要从外层取出一条数据放入子查询，子查询中其实变成了将是s1.key2作为表s2的主键id进行查询，且满足条件s1.key1 = s2.key1，因为查询时用到了表s2的主键，因此对表s2的访问方法是unique_subquery。</p>
<p>index_subquery</p>
<p>和上面的情况相同，不同点是子查询使用的是普通的二级索引进行匹配，那么对表的访问方法是index_subquery。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 &#x3D; s2.key1) OR key3 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425202402000.png" alt="image-20220425202402000"><figcaption aria-hidden="true">image-20220425202402000</figcaption>
</figure>
<p>range</p>
<p>如果使用索引获取某个范围内的记录，则对表的访问方法是range。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425200452627.png" alt="image-20220425200452627"><figcaption aria-hidden="true">image-20220425200452627</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#39;a&#39; AND key1 &lt; &#39;b&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425200525483.png" alt="image-20220425200525483"><figcaption aria-hidden="true">image-20220425200525483</figcaption>
</figure>
<p>index</p>
<p>当发生了索引覆盖（要查询的字段刚好是索引所在的字段，不需要根据主键回表），但是需要扫描索引中的全部记录时（联合索引中不满足最左匹配原则时就无法使用索引，必须在这个联合索引上进行全部扫描），则对表的访问方法是index。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425200959270.png" alt="image-20220425200959270"><figcaption aria-hidden="true">image-20220425200959270</figcaption>
</figure>
<p>all</p>
<p>全表扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425201901480.png" alt="image-20220425201901480"><figcaption aria-hidden="true">image-20220425201901480</figcaption>
</figure>
<h3 id="possible_keys和key">possible_keys和key</h3>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425202858176.png" alt="image-20220425202858176" style="zoom:67%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key3 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425203339480.png" alt="image-20220425203339480"><figcaption aria-hidden="true">image-20220425203339480</figcaption>
</figure>
<p>key并非是possible_keys的子集，possible_keys只要是筛选字段中存在的索引都会列出。但是假如SQL中未写筛选条件，而优化器优化后能够使用索引，则possible_keys是NULL，但key不是NULL。</p>
<h3 id="key_len">key_len</h3>
<p>使用的索引字段类型所占的字节数，对于联合索引比较有意义，在联合索引下，占用字节数越多说明使用到了更多的联合索引中的索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425203856989.png" alt="image-20220425203856989"><figcaption aria-hidden="true">image-20220425203856989</figcaption>
</figure>
<p>varchar类型，utf-8字符集下一个字符占3个字节，再加上可能为空的1个字节，和记录总的长度信息的2个字节，一共是303个字节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 &#x3D; &#39;a&#39; AND key_part2 &#x3D; &#39;b&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425204033120.png" alt="image-20220425204033120"><figcaption aria-hidden="true">image-20220425204033120</figcaption>
</figure>
<p>使用了联合索引中的多个字段。</p>
<p>key_len的长度计算公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">varchar(10)变长字段且允许NULL &#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)+1(NULL)+2(变长字段)</span><br><span class="line"></span><br><span class="line">varchar(10)变长字段且不允许NULL &#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)+2(变长字段)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且允许NULL &#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)+1(NULL)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且不允许NULL &#x3D; 10 * ( character set：utf8&#x3D;3,gbk&#x3D;2,latin1&#x3D;1)</span><br></pre></td></tr></table></figure>
<h3 id="ref">ref</h3>
<p>当使用索引列进行等值查询时，ref字段表示进行等值匹配时的对象信息。比如是一个常数，或几个列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id &#x3D; s2.id;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425213829312.png" alt="image-20220425213829312"><figcaption aria-hidden="true">image-20220425213829312</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 &#x3D; UPPER(s1.key1);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425213856084.png" alt="image-20220425213856084"><figcaption aria-hidden="true">image-20220425213856084</figcaption>
</figure>
<p>表示匹配的对象经过了函数处理。</p>
<h3 id="rows">rows</h3>
<p>预估需要读取的记录条数，并非最终查询的结果记录条数。</p>
<p>通常来说，rows需要越小越好。</p>
<p>个人理解：在MySQL中仅仅根据给出的关于这个索引的条件和索引本身，来判断需要扫描多少行。</p>
<blockquote>
<p>MYSQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估计记录数。</p>
<p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p>
<p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p>
<p>链接：https://juejin.cn/post/6864517310649286669</p>
</blockquote>
<h3 id="filtered">filtered</h3>
<p>某个表经过搜索条件过滤后，剩余记录条数的百分比。和rows配合起来看，rows x filtered% = 大约需要查询的数据条数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 &#x3D; s2.key1 WHERE s1.common_field &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425215848978.png" alt="image-20220425215848978"><figcaption aria-hidden="true">image-20220425215848978</figcaption>
</figure>
<p>表明内层子查询大概需要执行9688 x 10% = 968次，因为这是外层查询传入内层查询的数据条数。</p>
<h3 id="extra">Extra</h3>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425220135434.png" alt="image-20220425220135434" style="zoom:67%;"></p>
<p>没有过滤条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425220430016.png" alt="image-20220425220430016"><figcaption aria-hidden="true">image-20220425220430016</figcaption>
</figure>
<p>Impossible WHERE</p>
<p>过滤条件恒为false，此时无法检索出任何数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE 1 !&#x3D; 1;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425220520269.png" alt="image-20220425220520269"><figcaption aria-hidden="true">image-20220425220520269</figcaption>
</figure>
<p>Using where</p>
<p>使用全表扫描（无索引），并且WHERE中有针对该表的搜索条件，在EXTAR字段中显示Using where。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425222029075.png" alt="image-20220425222029075"><figcaption aria-hidden="true">image-20220425222029075</figcaption>
</figure>
<p>使用了索引，且WHERE中除了索引列外还有其他字段，在EXTAR字段中显示Using where。（如果WHERE中只有索引列，则不提示任何东西）</p>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425222050630.png" alt="image-20220425222050630"><figcaption aria-hidden="true">image-20220425222050630</figcaption>
</figure>
<p>No matching min/max row</p>
<p>存在MIN/MAX的聚合函数却过滤不出任何数据时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 &#x3D; &#39;abcdefg&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425222352953.png" alt="image-20220425222352953"><figcaption aria-hidden="true">image-20220425222352953</figcaption>
</figure>
<p>Using index</p>
<p>存在覆盖索引的情况时（索引中包括了需要查询的字段，不需要根据主键回表时）显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425222705604.png" alt="image-20220425222705604"><figcaption aria-hidden="true">image-20220425222705604</figcaption>
</figure>
<p>Using index condition</p>
<p>使用了索引条件下推的情况，即在索引中就能够过滤出数据再进行回表，而不是先回表再过滤数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key1 LIKE &#39;%b&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425223153402.png" alt="image-20220425223153402"><figcaption aria-hidden="true">image-20220425223153402</figcaption>
</figure>
<p>在索引的B+树中就将满足后缀的数据筛选出来再进行回表，而不是先回表再筛选满足后缀的数据。</p>
<p>Using join buffer (Block Nested Loop)</p>
<p>执行表关联时，被驱动表不能利用索引有效加快速度，MySQL分配一块称为“join buffer”的内存空间加速查询，即基于块的嵌套循环算法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field &#x3D; s2.common_field;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425223712380.png" alt="image-20220425223712380"><figcaption aria-hidden="true">image-20220425223712380</figcaption>
</figure>
<p>Not exists</p>
<p>左外连接，且WHERE条件中被驱动表的过滤条件要求某个列等于NULL，但是那个列本身不允许为NULL时，显示Not exists。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 &#x3D; s2.key1 WHERE s2.id IS NULL;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425224007085.png" alt="image-20220425224007085"><figcaption aria-hidden="true">image-20220425224007085</figcaption>
</figure>
<p>Using intersect(...) 、Using union(...) 和Using sort_union(...)</p>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425224042275.png" alt="image-20220425224042275"><figcaption aria-hidden="true">image-20220425224042275</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39; OR key3 &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425224232022.png" alt="image-20220425224232022"><figcaption aria-hidden="true">image-20220425224232022</figcaption>
</figure>
<p>Using filesort</p>
<p>如果查询语句中存在ORDER BY 索引字段，则可以通过索引直接获得排序的结果。</p>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425224313736.png" alt="image-20220425224313736"><figcaption aria-hidden="true">image-20220425224313736</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425224518876.png" alt="image-20220425224518876"><figcaption aria-hidden="true">image-20220425224518876</figcaption>
</figure>
<p>Using temporary</p>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425224634425.png" alt="image-20220425224634425"><figcaption aria-hidden="true">image-20220425224634425</figcaption>
</figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425225025148.png" alt="image-20220425225025148"><figcaption aria-hidden="true">image-20220425225025148</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT DISTINCT common_field FROM s1;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425224741172.png" alt="image-20220425224741172"><figcaption aria-hidden="true">image-20220425224741172</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY</span><br><span class="line">common_field;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425224806912.png" alt="image-20220425224806912"><figcaption aria-hidden="true">image-20220425224806912</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220425224908790.png" alt="image-20220425224908790"><figcaption aria-hidden="true">image-20220425224908790</figcaption>
</figure>
<h3 id="partitions">partitions</h3>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220424223257524.png" alt="image-20220424223257524" style="zoom:67%;"></p>
<h3 id="其他">其他</h3>
<ul>
<li><p>EXPLAIN不考虑各种Cache，即没有进行缓存优化</p></li>
<li><p>EXPLAIN不能显示MySQL在执行查询时所作的优化工作，只能显示结果</p></li>
<li><p>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</p></li>
<li><p>部分统计信息是估算的，并非精确值（rows）</p></li>
</ul>
<h3 id="explain的四种输出方法">Explain的四种输出方法</h3>
<h4 id="传统格式">传统格式</h4>
<p>即最普通的表格。</p>
<h4 id="json格式">JSON格式</h4>
<p>传统格式中缺乏了衡量执行计划好坏的重要属性：成本。</p>
<p>在EXPLAIN单词和真正的查询语句中间加上FORMAT=JSON即可以JSON格式展示更为详细的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN FORMAT&#x3D;JSON SELECT ....</span><br><span class="line"></span><br><span class="line">#例如</span><br><span class="line">mysql&gt; EXPLAIN FORMAT&#x3D;JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 &#x3D; s2.key2 WHERE s1.common_field &#x3D; &#39;a&#39;\G</span><br></pre></td></tr></table></figure>
<p>其中找到"cost_info"字段里的详细信息，即描述了成本：</p>
<ul>
<li><p>read_cost 是由下边这两部分组成的：</p>
<ul>
<li>IO 成本。</li>
<li>检测rows × (1 - filter) 条记录的CPU 成本。（即过滤数据的成本）</li>
</ul>
<blockquote>
<p>rows和filter都是前边介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan，filtered名称不变。</p>
</blockquote></li>
<li><p>eval_cost ：检测 rows × filter 条记录的成本。（即保留数据的成本）</p></li>
<li><p>prefix_cost 就是单独查询表的成本，也就是：read_cost + eval_cost（总的查询成本）</p></li>
<li><p>data_read_per_join 表示在此次查询中需要读取的数据量。</p></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s1表</span></span><br><span class="line">....</span><br><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">&quot;read_cost&quot;: &quot;1840.84&quot;,</span><br><span class="line">&quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">&quot;prefix_cost&quot;: &quot;2034.60&quot;,</span><br><span class="line">&quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s2表</span></span><br><span class="line">...</span><br><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">&quot;read_cost&quot;: &quot;968.80&quot;,</span><br><span class="line">&quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">&quot;prefix_cost&quot;: &quot;3197.16&quot;,</span><br><span class="line">&quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于s2 表是被驱动表，所以可能被读取多次，这里的read_cost 和eval_cost 是访问多次s2 表后累加起来的值，主要关注里边的prefix_cost 的值代表的是整个连接查询预计的成本，也就是单次查询s1 表和多次查询s2 表后的成本的和，也就是：</p>
<blockquote>
<p>968.80 + 193.76 + 2034.60 = 3197.16</p>
</blockquote>
<h4 id="tree格式">TREE格式</h4>
<p>主要根据查询的各个部分之间的关系和各部分的执行顺序来描述如何查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT&#x3D;TREE SELECT * FROM s1 INNER JOIN s2 ON s1.key1 &#x3D; s2.key2 WHERE s1.common_field &#x3D; &#39;a&#39;\G</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220426152758016.png" alt="image-20220426152758016"><figcaption aria-hidden="true">image-20220426152758016</figcaption>
</figure>
<p>可以看出展示了内外层表扫描时的过滤条件。</p>
<h4 id="可视化输出">可视化输出</h4>
<p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。</p>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220426152512046.png" alt="image-20220426152512046" style="zoom:67%;"></p>
<p>上图按从左到右的连接顺序显示表。红色框表示全表扫描，而绿色框表示使用索引查找。对于每个表，显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。</p>
<h3 id="show-warnings">SHOW WARNINGS</h3>
<p>在使用EXPLAIN语句查看执行计划后，可以紧接着使用SHOW WARNINGS语句查看扩展信息。</p>
<p>主要是将具体的表格和字段对应上查询语句，以及展现真正执行的查询语句（即如果存在改写的情况，则显示改写后的语句）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 &#x3D; s2.key1 WHERE s2.common_field IS NOT NULL;</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Level: Note</span><br><span class="line">Code: 1003</span><br><span class="line">Message: &#x2F;* select#1 *&#x2F; select &#96;atguigu&#96;.&#96;s1&#96;.&#96;key1&#96; AS &#96;key1&#96;,&#96;atguigu&#96;.&#96;s2&#96;.&#96;key1&#96;</span><br><span class="line">AS &#96;key1&#96; from &#96;atguigu&#96;.&#96;s1&#96; join &#96;atguigu&#96;.&#96;s2&#96; where ((&#96;atguigu&#96;.&#96;s1&#96;.&#96;key1&#96; &#x3D;</span><br><span class="line">&#96;atguigu&#96;.&#96;s2&#96;.&#96;key1&#96;) and (&#96;atguigu&#96;.&#96;s2&#96;.&#96;common_field&#96; is not null))</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220426152309951.png" alt="image-20220426152309951" style="zoom:67%;"></p>
<p>经过优化器优化之后将IN语句改写为JOIN语句：</p>
<p><img src="/2022/04/24/MySQL_%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90_03Explain/image-20220426151919663.png" alt="image-20220426151919663" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁机制</title>
    <url>/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<a id="more"></a>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种多用户共享的资源。</p>
<p>通过锁机制，对并发操作进行控制，以确保数据一致性，实现了MySQL的隔离级别。</p>
<h3 id="mysql并发事务访问相同记录">MySQL并发事务访问相同记录</h3>
<p>并发地访问相同记录时，才会产生并发问题。</p>
<h4 id="读-读情况">读-读情况</h4>
<p>读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>
<h4 id="写-写情况">写-写情况</h4>
<p>写-写情况，即并发事务对相同的记录进行改动。在这种情况下会发生脏写的问题，即已经提交的事务对数据做出的改动不生效或者被其他事务更改。</p>
<p>解决方案：任何一种隔离级别都不允许脏写的发生，所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。</p>
<p>这个所谓的锁其实是一个<strong>内存中的结构</strong>，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联。当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1 要对这条记录做改动，就需要生成一个锁结构与之关联：</p>
<figure>
<img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220321170447687.png" alt="image-20220321170447687"><figcaption aria-hidden="true">image-20220321170447687</figcaption>
</figure>
<figure>
<img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220321170431224.png" alt="image-20220321170431224"><figcaption aria-hidden="true">image-20220321170431224</figcaption>
</figure>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220321170536711.png" alt="image-20220321170536711" style="zoom: 67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220321170628869.png" alt="image-20220321170628869" style="zoom:67%;"></p>
<p>因此，在对同一个记录进行写-写的并发操作时，总共会有如下几种情况：</p>
<ul>
<li>不加锁 不需要在内存中生成对应的锁结构，可以直接执行操作。</li>
<li>获取锁成功，或者加锁成功 在内存中生成了对应的锁结构，而且锁结构的is_waiting 属性为false ，也就是事务可以继续执行操作。</li>
<li>获取锁失败，或者加锁失败，或者没有获取到锁 在内存中生成了对应的锁结构，不过锁结构的is_waiting 属性为true ，也就是事务需要等待，不可以继续执行操作。</li>
</ul>
<h4 id="读-写或写-读">读-写或写-读</h4>
<p>读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。</p>
<p>解决方案：MVCC（读旧版本，写加锁）或读写均加锁。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220321171524397.png" alt="image-20220321171524397" style="zoom: 67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220321171709764.png" alt="image-20220321171709764" style="zoom:67%;"></p>
<p>则两种方案的对比：</p>
<ul>
<li>采用MVCC 方式的话， 读-写操作彼此并不冲突， 性能更高。</li>
<li>采用加锁方式的话， 读-写操作彼此需要排队执行，影响性能。</li>
</ul>
<p>一般情况下采用MVCC 来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行。</p>
<h3 id="mysql锁分类">MySQL锁分类</h3>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322203221846.png" alt="image-20220322203221846" style="zoom:80%;"></p>
<h3 id="读写锁">读/写锁</h3>
<p>这里读/写锁的概念就是最基本的锁。</p>
<ul>
<li><p>读锁：也称为共享锁、英文用S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞。</p></li>
<li><p>写锁：也称为排他锁、英文用X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p></li>
</ul>
<p>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p>
<blockquote>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322203428181.png" alt="image-20220322203428181" style="zoom:67%;"></p>
</blockquote>
<p>S锁与X锁的兼容情况：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322203508545.png" alt="image-20220322203508545" style="zoom:67%;"></p>
<h4 id="锁定读">锁定读</h4>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322203726430.png" alt="image-20220322203726430" style="zoom:67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322203801569.png" alt="image-20220322203801569" style="zoom:67%;"></p>
<p>锁定读时的等待策略：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322203916576.png" alt="image-20220322203916576" style="zoom:67%;"></p>
<h4 id="锁定写">锁定写</h4>
<p>写操作，一定是加上排他锁X。写操作就是DELETE、UPDATE、INSERT三种行为。其中UPDATE中涉及到主键修改和字段空间变化时，就是先删除数据，再插入数据，插入过程由隐式锁保护。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322204051258.png" alt="image-20220322204051258" style="zoom:67%;"></p>
<h3 id="表级锁">表级锁</h3>
<h4 id="读写锁-1">读/写锁</h4>
<p>表级别下的读/写锁（S/X锁）会锁住整个表。</p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的S锁和X锁，只会在一些特殊情况下，比方说崩溃恢复过程中用到。因为InnoDB提供行级锁以提高事务的并发能力。当存在DDL语句时，必须对表加锁，则InnoDB使用被称为元数据锁（英文名： Metadata Locks ， 简称MDL ）的结构来实现。</p>
<p>比如，在系统变量autocommit=0，innodb_table_locks = 1 时， 手动获取InnoDB存储引擎提供的表t 的S锁或者X锁可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOCK TABLES t READ ：InnoDB存储引擎会对表t 加表级别的S锁。</span><br><span class="line"></span><br><span class="line">LOCK TABLES t WRITE ：InnoDB存储引擎会对表t 加表级别的X锁。</span><br></pre></td></tr></table></figure>
<p>加锁之后，不同的MySQL会话中事务对表的读写情况为：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322211551706.png" alt="image-20220322211551706" style="zoom:67%;"></p>
<h4 id="意向锁">意向锁</h4>
<p>InnoDB 支持多粒度锁（multiple granularity locking） ，它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。</p>
<p>意向锁的出现是为了高效地解决一个事务需要<strong>对表加锁</strong>时，如何<strong>快速判断</strong>有没有其他事务对表中的某几行记录加锁的问题。</p>
<blockquote>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322212317758.png" alt="image-20220322212317758" style="zoom:67%;"></p>
</blockquote>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322212023034.png" alt="image-20220322212023034" style="zoom:67%;"></p>
<p>意向锁的具体实现：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322212228798.png" alt="image-20220322212228798" style="zoom:67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322212444759.png" alt="image-20220322212444759" style="zoom:70%;"></p>
<p>也就是说，意向锁是在对记录加上行锁的时候自动产生的，不能手动生成。</p>
<p>意向锁之间的兼容性：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322212717546.png" alt="image-20220322212717546" style="zoom:67%;"></p>
<p>注意，对同一个记录加上行锁时，意向锁是不兼容的；只有对不同的记录加上行锁时，意向锁之间才是兼容的。即意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。</p>
<p>意向锁与表锁之间的兼容性：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220322212758110.png" alt="image-20220322212758110" style="zoom:67%;"></p>
<p>也就是说，当某个事务想要在某个表上加排他锁X时，假如发现这个表上存在意向锁（IS或IX），则加锁操作是不能完成的，因为有其他事务正在读取（IS）或更新数据（IX）。</p>
<p>意向锁与行锁之间的兼容性：</p>
<p>对记录加上行锁时，就会在这个表上产生对应的意向锁。行锁与意向锁是完全兼容的。</p>
<p>可以总结为：</p>
<ol type="1">
<li>InnoDB 支持多粒度锁，特定场景下，行级锁可以与表级锁（意向锁）共存。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li>
<li>意向锁之间互不排斥，但除了 IS 与 表级S 兼容外， 意向锁会与表级的共享锁 / 排他锁 互斥。</li>
<li>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</li>
</ol>
<h4 id="自增锁">自增锁</h4>
<p>在使用MySQL过程中，可以为表的某个列添加AUTO_INCREMENT 属性，在书写插入语句时不需要为其赋值，系统会自动为它赋上递增的值。</p>
<p>所有插入数据的方式总共分为三类，分别是“ Simple inserts ”（简单插入，可以预先确定要插入的行数），“ Bulk inserts ”（批量插入，事先不知道要插入的行数）和“ Mixed-mode inserts ”（混合模式插入，指定部分新行的自动递增值）。</p>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p>
<ul>
<li>innodb_autoinc_lock_mode = 0(“传统”锁定模式)：所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁。</li>
<li>innodb_autoinc_lock_mode = 1(“连续”锁定模式)：对于“Simple inserts”（要插入的行数事先已知），则通过在mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它<strong>只在分配过程的持续时间内保持</strong>，而不是直到语句完成。</li>
<li>innodb_autoinc_lock_mode = 2(“交错”锁定模式)：从 MySQL 8.0 开始，交错锁模式是默认设置。为任何给定语句插入的行生成的值可能不是连续的。</li>
</ul>
<h4 id="元数据锁mdl锁">元数据锁（MDL锁）</h4>
<p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。</p>
<p>MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构（即DDL语句）做变更，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<p>不需要显示使用，在访问表的时候会被自动加上。</p>
<h3 id="行级锁">行级锁</h3>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323151501333.png" alt="image-20220323151501333" style="zoom:67%;"></p>
<h4 id="记录锁record-locks">记录锁（Record Locks）</h4>
<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。</p>
<p>比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323151643201.png" alt="image-20220323151643201" style="zoom: 50%;"></p>
<p>记录锁是有S锁和X锁之分的，称之为S型记录锁和X型记录锁。</p>
<p>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</p>
<p>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</p>
<p>不显式。</p>
<h4 id="间隙锁gap-locks">间隙锁（Gap Locks）</h4>
<p>MySQL 在REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC 方案解决，也可以采用加锁方案解决。</p>
<p>但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。InnoDB提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们可以简称为gap锁。</p>
<p>比如，把id值为8的那条记录加一个gap锁的示意图如下:</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323152026334.png" alt="image-20220323152026334" style="zoom: 50%;"></p>
<p>图中id值为8的记录加了gap锁，意味着不允许别的事务在id值为8的记录前边的间隙插入新记录，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323155813729.png" alt="image-20220323155813729" style="zoom:67%;"></p>
<p>gap锁的提出仅仅是为了防止插入幻影记录而提出的。并且，间隙锁是可以共存的，这就会导致死锁的问题。</p>
<p>不显式。</p>
<h4 id="临键锁next-key-locks">临键锁（Next-Key Locks）</h4>
<p>有时候既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以InnoDB就提出了一种称之为Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为next-key锁。</p>
<p>Next-Key Locks是在存储引擎innodb 、事务级别在可重复读的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323160143680.png" alt="image-20220323160143680" style="zoom:67%;"></p>
<p>这里，锁定的区间就变成了(3,8]。</p>
<h4 id="插入意向锁insert-intention-locks">插入意向锁（Insert Intention Locks）</h4>
<p>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁（ next-key锁也包含gap锁），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。</p>
<p>但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks ，官方的类型名称为：LOCK_INSERT_INTENTION ，称为插入意向锁。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323160518503.png" alt="image-20220323160518503" style="zoom:67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323160752863.png" alt="image-20220323160752863" style="zoom:67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323160908602.png" alt="image-20220323160908602" style="zoom:67%;"></p>
<h3 id="悲观乐观锁">悲观/乐观锁</h3>
<p>乐观锁和悲观锁并不是锁，而是锁的设计思想，是两种看待数据并发的思维方式。</p>
<h4 id="悲观锁pessimistic-locking">悲观锁（Pessimistic Locking）</h4>
<p>悲观锁对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p>
<p>悲观锁，每次当事务去获取数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。</p>
<p>Java中synchronized 和ReentrantLock 等独占锁就是悲观锁思想的实现。</p>
<p>案例：</p>
<p>问题描述：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323202152224.png" alt="image-20220323202152224" style="zoom:67%;"><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323202334453.png" alt="image-20220323202334453"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323202501699.png" alt="image-20220323202501699" style="zoom:67%;"></p>
<p>解决方案：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323202611476.png" alt="image-20220323202611476" style="zoom:67%;"><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323202729011.png" alt="image-20220323202729011"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323202611476.png" alt="image-20220323202611476" style="zoom:67%;"><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323202729011.png" alt="image-20220323202729011"></p>
<h4 id="乐观锁optimistic-locking">乐观锁（Optimistic Locking）</h4>
<p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。</p>
<p>也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者CAS机制实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在Java中java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现。</p>
<ol type="1">
<li>乐观锁的版本号机制 在表中设计一个版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行UPDATE ... SET version=version+1 WHERE version=version 。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</li>
<li>乐观锁的时间戳机制 时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</li>
</ol>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323203022903.png" alt="image-20220323203022903" style="zoom:67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323203059145.png" alt="image-20220323203059145" style="zoom:67%;"></p>
<h4 id="两种锁的适用场景">两种锁的适用场景</h4>
<p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>
<ol type="1">
<li>乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现， 不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li>悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读 - 写和写 - 写的冲突。</li>
</ol>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323203130054.png" alt="image-20220323203130054" style="zoom:67%;"></p>
<h3 id="隐式锁显式锁">隐式锁/显式锁</h3>
<h4 id="隐式锁">隐式锁</h4>
<p>如果一个事务首先插入一条记录（此时没有锁结构），然后另一个事务希望：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323214018926.png" alt="image-20220323214018926" style="zoom:67%;"></p>
<p>因此，通过事务id实现一个隐式锁。</p>
<p>对于聚簇索引记录来说，有一个trx_id 隐藏列，该隐藏列记录着最后改动该记录的事务id 。</p>
<p>那么如果在当前事务中新插入一条聚簇索引记录后，该记录的trx_id 隐藏列代表的的就是当前事务的事务id 。</p>
<p>如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id 隐藏列代表的事务是否是当前的活跃事务（正在执行的事务），如果是的话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个锁结构， is_waiting 属性是false ），然后自己进入等待状态（也就是为自己也创建一个锁结构， is_waiting 属性是true ）。</p>
<blockquote>
<p>也就是说，事务A正在插入记录，事务B想对该记录加锁，发现A正在活跃，这时就相当于事务A上存在了一个隐式的锁，事务B给记录创建显式的锁，以及为自己创建显式的锁。</p>
</blockquote>
<p>对于二级索引记录来说，本身并没有trx_id 隐藏列，但是在二级索引页面的PageHeader 部分有一个PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的事务id ，如果PAGE_MAX_TRX_ID 属性值小于当前最小的活跃事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复情景一的做法。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220323214350402.png" alt="image-20220323214350402" style="zoom:67%;"></p>
<p>案例：</p>
<p>session 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert INTO student VALUES(34,&quot;周八&quot;,&quot;二班&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>session 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student lock in share mode; #执行完，当前事务被阻塞</span><br></pre></td></tr></table></figure>
<p>可以看到此时增加了显示锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.data_lock_waits\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">REQUESTING_ENGINE_LOCK_ID: 140562531358232:7:4:9:140562535668584</span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: 422037508068888</span><br><span class="line">REQUESTING_THREAD_ID: 64</span><br><span class="line">REQUESTING_EVENT_ID: 6</span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: 140562535668584</span><br><span class="line">BLOCKING_ENGINE_LOCK_ID: 140562531351768:7:4:9:140562535619104</span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID: 15902</span><br><span class="line">BLOCKING_THREAD_ID: 64</span><br><span class="line">BLOCKING_EVENT_ID: 6</span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN: 140562535619104</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>隐式锁的逻辑过程如下： A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。</p>
<p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将隐式锁转换为显式锁(就是为该事务添加一个锁)。</p>
<p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。</p>
<p>D. 等待加锁成功，被唤醒，或者超时。</p>
<p>E. 写数据，并将自己的trx_id写入trx_id字段。</p>
<h4 id="显示锁">显示锁</h4>
<p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p>
<p>显示加共享锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select .... lock in share mode</span><br></pre></td></tr></table></figure>
<p>显示加排它锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select .... for update</span><br></pre></td></tr></table></figure>
<h3 id="全局锁数据库锁">全局锁（数据库锁）</h3>
<p>全局锁就是对整个数据库实例加锁。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>全局锁的典型使用场景是：做全库逻辑备份。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure>
<h3 id="死锁">死锁</h3>
<p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致事务无法继续推进。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220324202824491.png" alt="image-20220324202824491" style="zoom:67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220324202912294.png" alt="image-20220324202912294" style="zoom:67%;"></p>
<p>当出现死锁以后，有两种策略： 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout 来设置。缺点：并发度高时，超时时间太长。</p>
<p>另一种策略是，发起死锁检测（wait-for graph算法），发现死锁后，主动回滚死锁链条中的某一个事务（将持有最少行级排他锁的事务进行回滚），让其他事务得以继续执行。将参数innodb_deadlock_detect 设置为on ，表示开启这个逻辑。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220324203218167.png" alt="image-20220324203218167" style="zoom:67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220324203253025.png" alt="image-20220324203253025" style="zoom:67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220324203351500.png" alt="image-20220324203351500" style="zoom:67%;"></p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220324203641654.png" alt="image-20220324203641654" style="zoom:67%;"></p>
<p>避免死锁的方式：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220324203729478.png" alt="image-20220324203729478" style="zoom:67%;"></p>
<h3 id="锁的内存结构">锁的内存结构</h3>
<p>对一条记录加锁的本质就是在内存中创建一个锁结构，与之关联。</p>
<p>满足如下条件的记录会被放到一个锁结构中：</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220325150720845.png" alt="image-20220325150720845" style="zoom:67%;"></p>
<p>也就是说，满足了这些条件时，这些记录共享同一个锁结构。避免创建太多的锁结构以占用内存，产生大量开销。</p>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220325144847977.png" alt="image-20220325144847977" style="zoom: 50%;"></p>
<ol type="1">
<li>锁所在的<strong>事务信息</strong>： 不论是表锁还是行锁，都是在事务执行过程中生成的，哪个事务生成了这个锁结构，这里就记录这个 事务的信息。 此锁所在的事务信息在内存结构中只是一个<strong>指针</strong>，通过指针可以找到内存中关于该事务的更多信息，比 方说事务id等。</li>
<li>索引信息： 对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</li>
<li>表锁／行锁信息： 表锁结构和行锁结构在这个位置的内容是不同的：</li>
</ol>
<ul>
<li><p>表锁： 记载着是对哪个表加的锁，还有其他的一些信息。</p></li>
<li><p>行锁： 记载了三个重要的信息：</p>
<ul>
<li><p>Space ID ：记录所在表空间。</p></li>
<li><p>Page Number ：记录所在页号。</p></li>
<li><p>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个 <strong>n_bits 属性代表使用了多少比特位</strong>。</p>
<p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</p></li>
</ul></li>
</ul>
<ol start="4" type="1">
<li>type_mode ： 这是一个<strong>32位的数</strong>，被分成了lock_mode 、lock_type 和rec_lock_type 三个部分。</li>
</ol>
<p><img src="/2022/03/21/MySQL_%E9%94%81%E6%9C%BA%E5%88%B6/image-20220325145100885.png" alt="image-20220325145100885" style="zoom:67%;"></p>
<ul>
<li><p>锁的模式（ <strong>lock_mode</strong> ），占用低4位，可选的值如下：</p>
<ul>
<li><p>LOCK_IS （十进制的0 ）：表示共享意向锁，也就是IS锁。</p></li>
<li><p>LOCK_IX （十进制的1 ）：表示独占意向锁，也就是IX锁。</p></li>
<li><p>LOCK_S （十进制的2 ）：表示共享锁，也就是<strong>S锁</strong>。</p></li>
<li><p>LOCK_X （十进制的3 ）：表示独占锁，也就是<strong>X锁</strong>。</p></li>
<li><p>LOCK_AUTO_INC （十进制的4 ）：表示AUTO-INC锁。</p>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p></li>
</ul></li>
<li><p>锁的类型（ <strong>lock_type</strong> ），占用第5～8位，不过现阶段只有第5位和第6位被使用：</p>
<ul>
<li>LOCK_TABLE （十进制的16 ），也就是当第5个比特位置为1时，表示<strong>表级锁</strong>。</li>
<li>LOCK_REC （十进制的32 ），也就是当第6个比特位置为1时，表示<strong>行级锁</strong>。</li>
</ul></li>
<li><p>行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在lock_type 的值为LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</p>
<ul>
<li>LOCK_ORDINARY （十进制的0 ）：表示next-key锁。</li>
<li>LOCK_GAP （十进制的512 ）：也就是当第10个比特位置为1时，表示<strong>gap锁</strong>。</li>
<li>LOCK_REC_NOT_GAP （十进制的1024 ）：也就是当第11个比特位置为1时，表示正经<strong>记录锁</strong>。</li>
<li>LOCK_INSERT_INTENTION （十进制的2048 ）：也就是当第12个比特位置为1时，表示<strong>插入意向锁</strong>。</li>
<li>其他的类型：不常用。</li>
</ul></li>
<li><p>is_waiting 属性</p>
<p>基于内存空间的节省，所以把is_waiting 属性放到了type_mode 这个32位的数字中：</p>
<p>LOCK_WAIT （十进制的256 ） ：<strong>当第9个比特位（rec_lock_type 中）置为1 时</strong>，表示is_waiting 为true ，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为0 时，表示is_waiting 为false ，也就是当前事务获取锁成功。</p></li>
</ul>
<ol start="5" type="1">
<li><p>其他信息： 为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p></li>
<li><p>一堆比特位： 如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits 属性表示的。</p></li>
</ol>
<p>InnoDB数据页中的每条记录在记录头信息中都包含一个heap_no 属性，伪记录Infimum 的heap_no 值为0 ， Supremum 的heap_no 值为1 。</p>
<p>之后每插入一条记录， heap_no 值就增1。锁结构最后的一堆比特位就<strong>对应着一个页面中的记录</strong>，一个比特位映射一个heap_no ，即一个比特位映射到页内的一条记录。</p>
<h3 id="锁监控">锁监控</h3>
<p>可以通过一些命令查看此时存在的锁，及其对应的情况。</p>
<p>通过检查InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#39;innodb_row_lock%&#39;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Innodb_row_lock_current_waits | 0 |</span><br><span class="line">| Innodb_row_lock_time | 0 |</span><br><span class="line">| Innodb_row_lock_time_avg | 0 |</span><br><span class="line">| Innodb_row_lock_time_max | 0 |</span><br><span class="line">| Innodb_row_lock_waits | 0 |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</p></li>
<li><p>Innodb_row_lock_time ：从系统启动到现在锁定总时间长度；（等待总时长）</p></li>
<li><p>Innodb_row_lock_time_avg ：每次等待所花平均时间；（等待平均时长）</p></li>
<li><p>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</p></li>
<li><p>Innodb_row_lock_waits ：系统启动后到现在总共等待的次数；（等待总次数）</p></li>
</ul>
<p>MySQL把事务和锁的信息记录在了information_schema 库中。</p>
<p>MySQL 8.0删除了information_schema.INNODB_LOCKS，添加了performance_schema.data_locks ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p>
<p>同时，information_schema.INNODB_LOCK_WAITS也被performance_schema.data_lock_waits 所代替。</p>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Parquet列式存储</title>
    <url>/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 22%">
<col style="width: 77%">
</colgroup>
<thead>
<tr class="header">
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Parquet</td>
<td>是一种列式数据存储格式，和语言、平台无关，Spark的默认存储格式。</td>
</tr>
<tr class="even">
<td>数据模型</td>
<td>Schema是类似树形结构的约束，包括message、filed。<br>每个field中又包括repetition, type, name三种描述。</td>
</tr>
<tr class="odd">
<td>物理存储</td>
<td>将数据分为Row Group，里面包含所有的列Column Chunk，每个列可分为多个Page<br>最底层还有个footer存储了文件的元数据信息和统计信息</td>
</tr>
<tr class="even">
<td>Striping/Assembly</td>
<td>这个算法是专门设计的一种数据存储方式，<strong>用于将嵌套类型的数据序列化和反序列化</strong>。<br>对于嵌套数据类型，除了存储数据本身的值 value 之外还需要两个变量 Repetition Level(R)，Definition Level(D) 才能存储其完整的信息用于<strong>序列化和反序列化</strong>数据。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="概述">概述</h3>
<p>Apache Parquet是Hadoop生态圈中一种新型列式存储格式，它可以兼容Hadoop生态圈中大多数计算框架(Hadoop、Spark等)，被多种查询引擎支持（Hive、Impala、Drill等），并且它是语言和平台无关的。</p>
<p>Parquet的灵感来自于2010年Google发表的Dremel论文，文中介绍了一种支持嵌套结构的存储格式，并且使用了列式存储的方式提升查询性能，在Dremel论文中还介绍了Google如何使用这种存储格式实现并行查询的。</p>
<p>Parquet最初是由Twitter和Cloudera(由于Impala的缘故)合作开发完成并开源，2015年5月从Apache的孵化器里毕业成为Apache顶级项目。</p>
<p>目前能够和Parquet适配的组件包括下面这些，可以看出基本上通常使用的查询引擎和计算框架都已适配，并且可以很方便的将其它序列化工具生成的数据转换成Parquet格式。</p>
<p>查询引擎: Hive, Impala, Pig, Presto, Drill, Tajo, HAWQ, IBM Big SQL</p>
<p>计算框架: MapReduce, Spark, Cascading, Crunch, Scalding, Kite</p>
<p>数据模型: Avro, Thrift, Protocol Buffers, POJOs</p>
<h3 id="parquet的组成与组件">Parquet的组成与组件</h3>
<p><strong>项目组成</strong></p>
<ul>
<li>parquet-format项目由java实现
<ul>
<li>定义了所有Parquet元数据对象，Parquet的元数据是使用Apache Thrift进行序列化并存储在Parquet文件的尾部。</li>
<li>同时包括了多个模块，例如实现了读写Parquet文件的功能，并且提供一些和其它组件适配的工具，如Hadoop Input/Output Formats、Hive Serde(目前Hive已经自带Parquet了)、Pig loaders等。</li>
</ul></li>
<li>parquet-compatibility项目，包含不同编程语言之间(JAVA和C/C++)读写文件的测试代码。</li>
<li>parquet-cpp项目，它是用于用于读写Parquet文件的C++库。</li>
</ul>
<p><strong>相关组件</strong></p>
<p>Parquet仅仅是一种存储格式，它是语言、平台无关的，并且不需要和任何一种数据处理框架绑定。为了实现平台无关的功能，各个大数据框架需要支持相关的组件：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/image-20210912200414640.png" alt="image-20210912200414640" style="zoom:67%;"></p>
<ul>
<li><p>对象模型层（Object Model）定义了如何读取Parquet文件的内容，它为各个不同的大数据组件提供了读写Parquet文件的工具，这一层转换包括Avro、Thrift、PB等序列化格式、Hive Serde等的适配。并且为了帮助大家理解和使用，Parquet提供了org.apache.parquet.example包实现了java对象和Parquet文件的转换。</p></li>
<li><p>对象转换层（Converters）完成其他对象模型与Parquet内部数据模型的映射和转换，Parquet的编码方式使用的是striping and assembly算法。</p></li>
<li><p>数据存储层（Language Agnosic）定义了Parquet的文件格式，其中元数据在parquet-format中定义，包括Parquet原始类型定义、Page类型、编码类型、压缩类型等等。</p></li>
</ul>
<h3 id="parquet的数据模型">Parquet的数据模型</h3>
<p>此处介绍Parquet 的逻辑存储结构。</p>
<p>Parquet 的Schema（视图约束）不是传统的关系型（二维表格）约束，而是类似树形结构的约束。</p>
<p>每个 Schema 的结构组成为：</p>
<ul>
<li>根叫做 message，message 包含多个 fields
<ul>
<li>每个 field 包含三个属性：repetition, type, name。
<ul>
<li>repetition 可以是以下三种：required（出现 1 次），optional（出现 0 次或者 1 次），repeated（出现 0 次或者多次）。</li>
<li>type 可以是一个 group 类型或者一个 primitive（Int, Long, String等基本类型） 类型。</li>
</ul></li>
</ul></li>
</ul>
<p>注意，Parquet 格式的数据类型没有复杂的 Map, List, Set 等，而是使用 repeated fields 或 groups 来表示。例如 List 和 Set 可以被表示成一个 repeated field，Map 可以表示成一个包含有 key-value 对的 repeated field，而且 key 是 required 的。</p>
<p>例如一个 AddressBook 主题的存储，它的Schema可以表示为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">message AddressBook &#123;</span><br><span class="line"> required string owner;</span><br><span class="line"> repeated string ownerPhoneNumbers;</span><br><span class="line"> repeated group contacts &#123;</span><br><span class="line">   required string name;</span><br><span class="line">   optional string phoneNumber;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 schema 中每条记录表示一个人的 AddressBook。</p>
<ul>
<li>有且只有一个 owner</li>
<li>owner 可以有 0 个或者多个 ownerPhoneNumbers，</li>
<li>owner 可以有 0 个或者多个 contacts。
<ul>
<li>每个 contact 有且只有一个 name</li>
<li>这个 contact 的 phoneNumber 可有可无。</li>
</ul></li>
</ul>
<p>这个 schema 可以用树结构来表示：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/image-20210912203137743.png" alt="image-20210912203137743" style="zoom:67%;"></p>
<h3 id="parquet的物理存储">Parquet的物理存储</h3>
<p>此处介绍Parquet 的物理存储结构。</p>
<p>在 Parquet 格式的存储中，一个 schema 的树结构有几个叶子节点，实际的存储中就会有多少 column。</p>
<p>上述案例的 Schema 的数据存储实际上有四个 Column：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/image-20210912203605062.png" alt="image-20210912203605062" style="zoom:67%;"></p>
<p>Parquet 文件在磁盘上的存储如下图所示，注意左右两边表示的是同一个主题的存储数据（只是怕太长难看所以分了左右）：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/image-20210912203743337.png" alt="image-20210912203743337" style="zoom:67%;"></p>
<ul>
<li><p><strong>Row Group</strong>：所有数据被分割成多个Row Group存储。以HDFS为例，一个 Row group 大小 1G，一个 HDFS 块大小 1G，刚好一个Row Group对应一个HDFS块是常见的设置。</p>
<p>同时，一个 Row group 包含所有的列（即包含多个Column Chunk）。</p>
<ul>
<li><strong>Column Chunk</strong>：就是每一列，一个 Column Chunk 负责存储某一列的数据，这些数据是这一列的 Repetition levels, Definition levels 和 values（详见后文）
<ul>
<li><strong>Page</strong>：一个 Column Chunk 是由多个 Page 组成的，Page 是压缩和编码的单元，对数据模型来说是透明的。</li>
</ul></li>
</ul></li>
<li><p><strong>Footer</strong>：一个 Parquet 文件最后是 Footer，存储了文件的元数据信息和统计信息。</p></li>
</ul>
<p>用上述的 Schema 举例，</p>
<p>每一个Row Group存储了多个owner的信息。</p>
<p>在任何一个 Row Group 内，会顺序存储四个 Column Chunk，这四个 Column Chunk 都是 string 类型。</p>
<p>每一个Column Chunk内部分成了多个 Page，按列存储这一列对应的数据。</p>
<p>这个时候 Parquet 就需要把内存中的 AddressBook 对象映射到四个 string 类型的 column 中。</p>
<p>如果读取磁盘上的 4 个 column 要能够恢复出 AddressBook 对象。这就用到了前面提到的 Striping/Assembly 算法。</p>
<h3 id="stripingassembly-算法">Striping/Assembly 算法</h3>
<p>这个算法是专门设计的一种数据存储方式，<strong>用于将嵌套类型的数据序列化和反序列化</strong>。直观地来说就是定义了数据存储的方式，来决定嵌套类型的数据如何存储到磁盘，以及如何在内存中恢复这些数据。</p>
<p>对于嵌套数据类型，除了存储数据本身的值 value 之外<strong>还需要两个变量 Repetition Level(R), Definition Level(D)</strong> 才能存储其完整的信息用于<strong>序列化和反序列化</strong>嵌套数据类型。</p>
<p>Repetition Level 和 Definition Level 可以说是为了支持嵌套类型而设计的，但是它同样适用于数据模型为关系型的数据。</p>
<p>在 Parquet 中只需定义和存储 Schema 的叶子节点所在列的 Repetition Level 和 Definition Level。</p>
<h4 id="definition-level">Definition Level</h4>
<p>Definition Level指的是截至当前位置（当前Field）为止，从根节点一路到这个Field的路径上有多少节点（Field）被定义了。</p>
<ul>
<li><p>如果一个 Field的 Definition Level 等于这个 Field 的最大 Definition Level 就说明这个 Field是有数据的。</p></li>
<li><p>从根节点开始遍历，当某一个 Field的路径上的节点开始是空的时候我们记录下当前的深度作为这个 Field的 Definition Level。</p></li>
<li><p>如果一个 Field是定义的，那么它的所有的父节点都是被定义的。</p></li>
<li><p>对于 required 类型的 field 必须是有定义的，所以这个 Definition Level 是不需要的。</p></li>
<li><p>注意每一个列对应的值都有不同的Definition Level，要分开不同的列来看。</p></li>
</ul>
<p>用 AddressBook 的例子来说明Definition Level：</p>
<p>有如下两条数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//Schema</span><br><span class="line">message AddressBook &#123;</span><br><span class="line"> required string owner;</span><br><span class="line"> repeated string ownerPhoneNumbers;</span><br><span class="line"> repeated group contacts &#123;</span><br><span class="line">   required string name;</span><br><span class="line">   optional string phoneNumber;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据1</span><br><span class="line">AddressBook &#123;</span><br><span class="line"> owner: &quot;Julien Le Dem&quot;,</span><br><span class="line"> ownerPhoneNumbers: &quot;555 123 4567&quot;,</span><br><span class="line"> ownerPhoneNumbers: &quot;555 666 1337&quot;,</span><br><span class="line"> contacts: &#123;</span><br><span class="line">   name: &quot;Dmitriy Ryaboy&quot;,</span><br><span class="line">   phoneNumber: &quot;555 987 6543&quot;,</span><br><span class="line"> &#125;,</span><br><span class="line"> contacts: &#123;</span><br><span class="line">   name: &quot;Chris Aniszczyk&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据2</span><br><span class="line">AddressBook &#123;</span><br><span class="line"> owner: &quot;A. Nonymous&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 contacts.phoneNumber 这一列为例，按照正常情况来看找到一个phoneNumber 需要经历的层级是（AddressBook，contacts，phoneNumber ），因此最大的Definition Level就是2（从0开始 ）：</p>
<ul>
<li>"555 987 6543"这个 contacts.phoneNumber 的 Definition Level 是最大 Definition Level=2。（数据1的第一个contacts）</li>
<li>而如果一个 contact 没有 phoneNumber，那么它的 Definition Level 就是 1。（数据1的第二个contacts）</li>
<li>如果连 contact 都没有，那么它的 Definition Level 就是 0。（数据2的第一个contacts）</li>
</ul>
<p>针对contacts.phoneNumber 这一列来说，这两条数据的序列化过程如下：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/image-20210912221630425.png" alt="image-20210912221630425" style="zoom:67%;"></p>
<p>因此在磁盘中，这一列对应的数据，在每个Page中可以存储为：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/image-20210912221904125.png" alt="image-20210912221904125" style="zoom:67%;"></p>
<p>NULL 实际上不会被存储，如果一个 column value 的 Definition Level 小于该 column 最大 Definition Level 的话，那么就表示这是一个空值。</p>
<h4 id="repetition-level">Repetition Level</h4>
<p>Repetition Level指的是截至当前位置（当前Field）为止，从根节点一路到这个Field的路径上重复节点的个数。本质上，是记录了该 field 的值是在哪一个深度上重复的。</p>
<ul>
<li><p>只有 repeated 类型的 field 需要 Repetition Level，optional 和 required 类型的不需要。</p></li>
<li><p>Repetition Level = 0 表示开始一个新的 record。</p></li>
</ul>
<p>用下面的例子来说明Repetition Level：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">message nested &#123;</span><br><span class="line">     repeated group leve1 &#123;</span><br><span class="line">          repeated string leve2;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据1</span><br><span class="line">nested &#123;</span><br><span class="line">    leve1 &#123;</span><br><span class="line">    	leve2:&quot;a&quot;,</span><br><span class="line">    	leve2:&quot;b&quot;,</span><br><span class="line">    	leve2:&quot;c&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    leve1 &#123;</span><br><span class="line">    	leve2:&quot;d&quot;,</span><br><span class="line">    	leve2:&quot;e&quot;,</span><br><span class="line">    	leve2:&quot;f&quot;,</span><br><span class="line">    	leve2:&quot;g&quot;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据2</span><br><span class="line">nested &#123;</span><br><span class="line">    leve1 &#123;</span><br><span class="line">    	leve2:&quot;h&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    leve1 &#123;</span><br><span class="line">    	leve2:&quot;i&quot;,</span><br><span class="line">    	leve2:&quot;j&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 leve2 这一列为例：</p>
<ul>
<li><p>value = a 是一条记录的开始，和前面的值(已经没有值了)在根节点(第0层)上是不共享的，所以repeated level = 0。</p></li>
<li><p>value = b 它和前面的值共享了level1这个节点，但是level2这个节点上是不共享的，所以repeated level = 2。</p></li>
<li><p>同理value = c, repeated level = 2。</p></li>
<li><p>value = d 和前面的值共享了根节点(属于相同记录)，但是在level1这个节点上是不共享的，所以repeated level = 1。</p></li>
<li><p>value = h 和前面的值不属于同一条记录，也就是不共享任何节点，所以repeated level=0。</p></li>
</ul>
<p>针对level 2这一列来说，两条数据的序列化过程为：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/image-20210913092856023.png" alt="image-20210913092856023" style="zoom:67%;"></p>
<p>读取的时候，两条数据的反序列化过程为：</p>
<p>在读取的时候，顺序的读取每一个值，然后根据它的repeated level创建对象。</p>
<ul>
<li>当读取value = a时repeated level = 0，表示需要创建一个新的根节点(新记录)</li>
<li>value = b时repeated level = 2，表示需要创建一个新的level2节点</li>
<li>value = d时repeated level = 1，表示需要创建一个新的level1节点</li>
<li>当所有列读取完成之后可以创建一条新的记录，即一行数据。</li>
</ul>
<h4 id="反序列化过程">反序列化过程</h4>
<p>以简化的AddressBook来看，仅看phoneNumber这一列的反序列化过程。</p>
<p>数据为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//数据1</span><br><span class="line">AddressBook &#123;</span><br><span class="line">     contacts: &#123;</span><br><span class="line">       phoneNumber: &quot;555 987 6543&quot;</span><br><span class="line">     &#125;</span><br><span class="line">     contacts: &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据2</span><br><span class="line">AddressBook &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>序列化过程： <img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/image-20210912221630425.png" alt="image-20210912221630425" style="zoom:67%;"></p>
<p>磁盘存储为：</p>
<p><img src="/2021/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE_Parquet/image-20210912221904125.png" alt="image-20210912221904125" style="zoom:67%;"></p>
<p>从磁盘上读取数据并反序列化为Address对象的过程为：</p>
<ul>
<li>读取第一个三元组 R=0, D=2, Value=”555 987 6543”
<ul>
<li>R=0 表示是一个新的 record，要根据 schema 创建一个新的 nested record 直到 Definition Level=2。</li>
<li>D=2 说明 Definition Level=Max Definition Level，那么这个 Value 就是 contacts.phoneNumber 这一列的值，赋值操作 contacts.phoneNumber=”555 987 6543”。</li>
</ul></li>
<li>读取第二个三元组 R=1, D=1
<ul>
<li>R=1 表示不是一个新的 record，是上一个 record 中一个新的 contacts。</li>
<li>D=1 表示 contacts 定义了，但是 contacts 的下一个级别也就是 phoneNumber 没有被定义，所以创建一个空的 contacts。</li>
</ul></li>
<li>读取第三个三元组 R=0, D=0
<ul>
<li>R=0 表示一个新的 record，根据 schema 创建一个新的 nested record。</li>
<li>Definition Level=0，也就是创建一个 AddressBook 根节点。</li>
</ul></li>
</ul>
<h4 id="小结">小结</h4>
<p>可以看出在 Parquet 列式存储中，对于一个 schema 的所有叶子节点会被当成 column 存储，而且叶子节点一定是 primitive 类型的数据。</p>
<p>对于这样一个 primitive 类型的数据会衍生出三个 sub columns (R, D, Value)，也就是从逻辑上看除了数据本身以外会存储大量的 Definition Level 和 Repetition Level。</p>
<p>那么这些 Definition Level 和 Repetition Level 是否会带来额外的存储开销呢？实际上这部分额外的存储开销是可以忽略的。</p>
<p>因为对于一个 schema 来说 level 都是有上限的，而且非 repeated 类型的 field 不需要 Repetition Level，required 类型的 field 不需要 Definition Level，也可以缩短这个上限。例如对于 Twitter 的 7 层嵌套的 schema 来说，只需要 3 个 bits 就可以表示这两个 Level 了。</p>
<p>对于存储关系型的记录，记录中的元素都是非空的（NOT NULL in SQL）。Repetion Level 和 Definition Level 都是 0，所以这两个 sub column 就完全不需要存储了。所以在存储非嵌套类型的时候，Parquet 格式也是一样高效的（不需要额外存储这两个变量）。</p>
<h3 id="性能">性能</h3>
<p>Parquet 列式存储带来的性能上的提高在业内已经得到了充分的认可，特别是当你的表非常宽（column 非常多）的时候，Parquet 无论在资源利用率还是性能上都优势明显。</p>
<p>Spark 已经将 Parquet 设为默认的文件存储格式，Cloudera 投入了很多工程师到 Impala+Parquet 相关开发中，Hive/Pig 都原生支持 Parquet。</p>
<p>Parquet 现在为 Twitter 至少节省了 1/3 的存储空间，同时节省了大量的表扫描和反序列化的时间。这两方面直接反应就是节约成本和提高性能。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://www.cnblogs.com/panpanwelcome/p/10248990.html</p>
<p>https://blog.csdn.net/yu616568/article/details/50993491</p>
<p>https://www.cnblogs.com/helongBlog/p/13750315.html</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>海量小文件问题</title>
    <url>/2021/08/02/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E5%B0%8F%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 5%">
<col style="width: 35%">
<col style="width: 23%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Hadoop</th>
<th>Hive</th>
<th>Spark</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>小文件来源</td>
<td>数据源有大量小文件；reducer太多，每个都生成小文件</td>
<td>Hive分区表的每个分区数据量很小</td>
<td>sparkstreaming在每个batch结束后都会重新打开一个新的文件作为输出，因此每个batch下的每个分区生成大量小文件</td>
</tr>
<tr class="even">
<td>解决方案</td>
<td>1、在数据源处就合并小文件</td>
<td>1、配置map前合并和reduce后合并小文件</td>
<td>1、增加batch大小</td>
</tr>
<tr class="odd">
<td></td>
<td>2、定期运行一个MR任务，读取某一个文件夹中的所有小文件，并通过减少reduce的数量将它们重写为较少数量的大文件</td>
<td>2、使用HAR归档文件</td>
<td>2、通过coalesce和repartition减少分区数量</td>
</tr>
<tr class="even">
<td></td>
<td>3、SequenceFile将数据以KV的形式序列化到文件中，MR任务只需要为每个block启动一个map任务，并且保留文件名</td>
<td>3、减少分区表中的分区数量</td>
<td>3、自定义合并脚本</td>
</tr>
<tr class="odd">
<td></td>
<td>4、使用Hbase进行数据存储，将数据抽取过程从生成大量小HDFS文件更改为以逐条记录写入到HBase表</td>
<td>4、数据压缩，通过序列化存储方式存储数据</td>
<td>4、通过foreach输出类追加小文件</td>
</tr>
<tr class="even">
<td></td>
<td>5、CombineFileInputFormat是Hadoop提供的抽象类，在MR读取时合并小文件。合并的文件不会持久化到磁盘</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>6、自己编写特定的程序通过输出类来追加到现有的小文件</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>7、NameNode中通过Hadoop Archive(HAR)和联邦机制解决内存不足的问题</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="问题概述">问题概述</h3>
<p>海量小文件（LSOF，lots of small files）问题，使得分布式系统在在元数据管理、存储效率、访问的性能等方面面临巨大的挑战。</p>
<p>存储磁盘最适合顺序的大文件I/O读写模式，非常不适合随机的小文件I/O读写模式（顺序读写，避免寻址），这是磁盘文件系统在海量小文件应用下性能表现不佳的根本原因。磁盘文件系统的设计大多都侧重于大文件，包括元数据管理、数据布局和I/O访问流程，另外VFS系统调用机制也非常不利于海量小文件，这些软件层面的机制和实现加剧了小文件读写的性能问题。</p>
<p>Hadoop中的海量小文件问题，核心问题是它需要把文件meta信息缓存在内存里，这个内存只能是单机的，所以变成了一个很大的瓶颈。虽然后面HDFS一直尝试解决这个问题，比如引入联邦制等，但是也变相的引入了复杂性。</p>
<h3 id="存储系统性能衡量">存储系统性能衡量</h3>
<p>IOPS (Input/Output Per Second) 即每秒的输入输出量 (或读写次数) ，是衡量存储系统性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位，I/O请求通常为读或写数据操作请求。随机读写频繁的应用，如OLTP(OnlineTransaction Processing)，IOPS是关键衡量指标。</p>
<p>数据吞吐量(Throughput)，指单位时间内可以成功传输的数据数量。对于大量顺序读写的应用，如VOD(VideoOn Demand)，则更关注吞吐量指标。</p>
<p>对于LOSF而言，IOPS/OPS是关键性能衡量指标。</p>
<h3 id="小文件过多引起的问题">小文件过多引起的问题</h3>
<h4 id="元数据管理低效"><strong>元数据管理低效</strong></h4>
<p>磁盘文件系统中，目录项(dentry)、索引节点(inode)和数据(data)保存在存储介质的不同位置上。因此，访问一个文件需要经历至少3次独立的访问。这样，并发的小文件访问就转变成了大量的随机访问，而这种访问对于广泛使用的磁盘来说是非常低效的。</p>
<p>同时，文件系统通常采用Hash树、B+树或B*树来组织和索引目录，这种方法不能在数以亿计的大目录中很好的扩展，海量目录下检索效率会明显下降。正是由于单个目录元数据组织能力的低效，文件系统使用者通常被鼓励把文件分散在多层次的目录中以提高性能。然而，这种方法会进一步加大路径查询的开销。</p>
<h4 id="数据布局低效"><strong>数据布局低效</strong></h4>
<p>磁盘文件系统使用块来组织磁盘数据，并在inode中使用多级指针或hash树来索引文件数据块。数据块通常比较小，一般为1KB、2KB或4KB。当文件需要存储数据时，文件系统根据预定的策略分配数据块，分配策略会综合考虑数据局部性、存储空间利用效率等因素，通常会优先考虑大文件I/O带宽。</p>
<p>对于大文件，数据块会尽量进行连续分配，具有比较好的空间局部性。</p>
<p>对于小文件，尤其是大文件和小文件混合存储或者经过大量删除和修改后，数据块分配的随机性会进一步加剧，数据块可能零散分布在磁盘上的不同位置，并且会造成<strong>大量的磁盘碎片</strong>(包括内部碎片和外部碎片)，不仅造成<strong>访问性能下降</strong>（寻址随机访问），还导致大量磁盘空间浪费。</p>
<p>对于特别小的小文件，比如小于4KB，<strong>inode与数据分开存储</strong>，这种数据布局也没有充分利用空间局部性，导致随机I/O访问，目前已经有文件系统实现了data in inode。</p>
<h4 id="io访问流程复杂">I/O访问流程复杂</h4>
<p>Linux等操作系统采用VFS或类似机制来抽象文件系统的实现，提供标准统一访问接口和流程，它提供通用的Cache机制，处理文件系统相关的所有系统调用，与具体文件系统和其他内核组件(如内存管理)交互。VFS可以屏蔽底层文件系统实现细节，简化文件系统设计，实现对不同文件系统支持的扩展。</p>
<p>VFS通用模型中有涉及四种数据类型：超级块对象(superblock object)、索引结点对象(inode object)、文件对象(file object)和目录项对象(dentry object)，进程在进行I/O访问过程中需要频繁与它们交互(如下图所示)。</p>
<p><img src="/2021/08/02/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E5%B0%8F%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/image-20210801234410484.png" alt="image-20210801234410484" style="zoom:67%;"></p>
<p>对于小文件的I/O访问过程，读写数据量比较小，这些流程太过复杂，系统调用开销太大，尤其是其中的<strong>open()操作占用了大部分的操作时间</strong>。当面对海量小文件并发访问，<strong>读写之前的准备工作</strong>占用了绝大部分系统时间，有效磁盘服务时间非常低，从而导致小I/O性能极度低下。</p>
<p>对于大多数分布式文件系统而言，通常将元数据与数据两者独立开来，即控制流与数据流进行分离，从而获得更高的系统扩展性和I/O并发性。数据和I/O访问负载被分散到多个物理独立的存储节点，从而实现系统的高扩展性和高性能，每个节点使用磁盘文件系统管理数据，比如XFS、EXT4、XFS等。</p>
<p>因此，相对于磁盘文件系统而言，每个节点的小文件问题是相同的。由于分布式的架构，分布式文件系统中的网络通信、元数据服务MDC、Cache管理、数据布局和I/O访问模式等都会对IOPS/OPS性能产生影响，进一步加剧小文件问题。</p>
<h3 id="解决方案小文件合并">解决方案：小文件合并</h3>
<p>小文件合并存储是目前优化LOSF问题最为成功的策略，已经被包括Facebook Haystack和淘宝TFS在内多个分布式存储系统采用。它通过<strong>多个逻辑文件共享同一个物理文件</strong>，将多个小文件合并存储到一个大文件中，实现高效的小文件存储。</p>
<p>（1）首先减少了大量元数据，提高了元数据的检索和查询效率，降低了文件读写的 I/O 操作延时。</p>
<p>（2）其次将可能连续访问的小文件一同合并存储，增加了文件之间的局部性，将原本小文件间的随机访问变为了顺序访问，大大提高了性能。</p>
<p>（3）同时，合并存储能够有效的减少小文件存储时所产生的磁盘碎片问题，提高了磁盘的利用率。</p>
<p>（4）最后，合并之后小文件的访问流程也有了很大的变化，由原来许多的open操作转变为了seek操作，定位到大文件具体的位置即可。</p>
<p>小文件合并存储，本质上是大文件加上索引文件，相当于一个微型文件系统。这种机制对于WORM(Write Once Read Many)模式的分布式存储系统非常适合，而不适合允许改写和删除的存储系统。（1）因为文件改写和删除操作，<strong>会造成大文件内部的碎片空洞</strong>，如果进行空间管理并在合适时候执行碎片整理，实现比较复杂而且产生额外开销。（2）如果不对碎片进行处理，采用追加写的方式，一方面会浪费存储容量，另一方面又会破坏数据局部性，增加数据分布的随机性，导致读性能下降。（3）此外，如果支持随机读写，大小文件如何统一处理，小文件增长成大文件，大文件退化为小文件，这些问题都是在实际处理时面临的挑战。</p>
<h3 id="hadoop小文件">Hadoop小文件</h3>
<h4 id="小文件来源">小文件来源</h4>
<p>一个Hadoop集群中存在小文件的可能原因如下：</p>
<p><strong>1.流式任务（如spark streaming/flink等实时计算框架）</strong></p>
<p>在做数据处理时，无论是纯实时还是基于batch的准实时，在小的时间窗口内都可能产生大量的小文件。此外对于Spark任务如果过度并行化，每个分区一个文件，产生的文件也可能会增多</p>
<p><strong>2.Hive分区表的过度分区</strong></p>
<p>这里的过度分区是指Hive分区表的每个分区数据量很小（比如小于HDFS block size）的Hive表。那么Hive Metastore Server调用开销会随着表拥有的分区数量而增加，影响性能。此时，要衡量数据量重新进行表结构设计（如减少分区粒度）。</p>
<p><strong>3.数据源有大量小文件，未做处理直接迁移到Hadoop集群。</strong></p>
<p><strong>4.对于计算引擎处理任务，以MR为例。</strong></p>
<p>大量的map和reduce task存在。在HDFS上生成的文件基本上与map数量（对于Map-Only作业）或reduce数量（对于MR作业）成正比。此外，MR任务如果未设置合理的reduce数或者未做限制，每个reduce都会生成一个独立的文件。对于数据倾斜，导致大部分的数据都shuffle到一个或几个reduce，然后其他的reduce都会处理较小的数据量并输出小文件。</p>
<p>对于Spark任务，过度并行化也是导致小文件过多的原因之一。</p>
<p>在Spark作业中，根据写任务中提到的分区数量，每个分区会写一个新文件。这类似于MapReduce框架中的每个reduce任务都会创建一个新文件。Spark分区越多，写入的文件就越多。控制分区的数量来减少小文件的生成。</p>
<h4 id="发现小文件的方式">发现小文件的方式</h4>
<p>NameNode存储了所有与文件相关的元数据，所以它将整个命名空间保存在内存中，而fsimage是NameNode的本地本机文件系统中的持久化记录。因此，我们可以通过分析fsimage来找出文件的元信息。fsimage中可用的字段有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Path, Replication, ModificationTime, AccessTime, PreferredBlockSize, BlocksCount, FileSize, NSQUOTA, DSQUOTA, Permission, UserName, GroupName</span><br></pre></td></tr></table></figure>
<p>1、通过hdfs oiv命令解析fsimage</p>
<p>拷贝Namenode数据目录下的fsimage文件到其他目录，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdfs oiv -p Delimited -delimiter <span class="string">&quot;|&quot;</span> -t /tmp/tmpdir/ -i fsimage_copy_file -o fsimage_deal.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、使用fsck命令扫描当前的HDFS目录并保存扫描后的信息。但是不建议在生产环境使用fsck命令，因为它会带来额外的开销，可能影响集群的稳定性。</p>
<h4 id="hadoop小文件合并策略和方式">Hadoop小文件合并策略和方式</h4>
<p>Hadoop中的小文件一般是指明显小于HDFS的block size（默认128M，一般整数倍配置如256M）的文件。但需要注意，HDFS上的有些小文件是不可避免的，比如jar、临时缓存文件等。但当小文件数量变的"海量"，以至于Hadoop集群中存储了大量的小文件，就需要对小文件进行处理，而处理的目标是让文件大小尽可能接近HDFS的block size大小或者整数倍。</p>
<h4 id="namenode中的小文件问题">NameNode中的小文件问题</h4>
<p>每个block的元数据都需要加载到NameNode的内存中，这导致一个Hadoop集群在NameNode中存储的对象是有上限的，并且对象太多会带来启动时间较长以及网络延迟的问题。常见的有两种解决方案：</p>
<p>1、减少集群的NameNode中的对象数量</p>
<p>2、以某种方式让NameNode使用更多的内存，但不会导致较长的启动时间</p>
<ul>
<li><p>Hadoop Archive(HAR)</p>
<p>（本质上应该是一种多级目录）</p>
<p>Hadoop archive files通过将许多小文件打包到更大的HAR文件中来缓解NameNode内存问题，类似于Linux上的TAR文件。这样可以让NameNode只处理单个HAR文件，而不是数十个或数百个小文件。可以使用har://前缀而不是hdfs://来访问HAR文件中的文件。HAR文件是基于HDFS中已有的文件创建的。因此，HAR文件不仅可以合并从数据源抽取到HDFS中的数据，也可以合并通过正常的MR处理创建的数据。HAR文件可以独立的用于解决小文件问题，除了HDFS没有其他的依赖。</p>
<p><img src="/2021/08/02/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E5%B0%8F%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/image-20210802085228880.png" alt="image-20210802085228880" style="zoom:67%;"></p>
<p>虽然HAR文件减少了NameNode中小文件对内存的占用，但访问HAR文件内容性能可能会更低。<strong>HAR文件仍然随机存储在磁盘上，并且读取HAR内的文件需要访问两个索引 - 一个用于NameNode找到HAR文件本身，一个用于在HAR文件内找到小文件的位置</strong>。在HAR中读取文件实际上可能比读取存储在HDFS上的相同文件慢。<strong>MapReduce作业的性能同样会受到影响，因为它仍旧会为每个HAR文件中的每个文件启动一个map任务</strong>。</p>
<p>所以这里我们需要有一个权衡，HAR文件可以解决NameNode内存问题，但同时会降低读取性能。如果你的小文件主要用于存档，并且不经常访问，那么HAR文件是一个很好的解决方案。如果小文件经常要被读取或者处理，那么可能需要重新考虑解决方案。</p></li>
<li><p>NameNode联邦</p>
<p>NameNode联邦允许你在一个集群中拥有多个NameNode，每个NameNode都存储元数据对象的子集。这样可以让所有的元数据对象都不止存储在单个机器上，也消除了单个节点的内存限制，因为你可以扩容。这听上去是一个很美丽的方案，但其实它也有局限性。</p>
<p>NameNode联邦隔离了元数据对象 - <strong>仅仅只有某一个NameNode知道某一个特定的元数据对象在哪里，意思就是说如果你想找到某个文件，你必须知道它是保存在哪个NameNode上的</strong>。如果你的集群中有多个租户和/或隔离的应用程序，那使用NameNode联邦是挺不错的，你可以通过租户或者应用程序来隔离元数据对象。但是，如果要在所有的应用程序之间共享数据，则该方法其实也并不是完美的。</p>
<p>由于NameNode联邦<strong>并不会改变集群中对象或者块的数量</strong>，所以<strong>它并没有解决MapReduce的性能问题</strong>。相反，联邦会增加Hadoop集群安装和维护的复杂度。所以我们说联邦可以解决小文件问题，倒不如说它提供了一种办法让你“隐藏”小文件。</p></li>
</ul>
<h4 id="mapreduce的小文件问题">MapReduce的小文件问题</h4>
<p>MR性能问题主要是由随机磁盘IO和启动/管理太多的map任务组合引起的。解决方案似乎很明显 - 合并小文件，然而这个事往往说起来容易做起来难。以下讨论一下几种解决方案：</p>
<p>注：虽然为解决MR的性能问题，但其实同样也是为了解决NameNode的压力，以及解决其他计算引擎比如Impala/Spark的性能问题。</p>
<p>解决方案：</p>
<p><strong>1、从数据源处处理</strong></p>
<p>数据源是否能生成一些大文件，或者从数据源到HDFS的数据抽取过程中进行数据处理合并小文件。如果每小时只抽取10MB的数据，考虑是否改为每天一次，这样创建1个240MB的文件而不是24个10MB的文件。</p>
<p>缺点：可能无法控制数据源的改动配合或业务对数据抽取间隔的需求，这样小文件问题无法避免，这时可能需要考虑其他的解决方案。</p>
<p><strong>2、批量文件合并</strong></p>
<p><strong>定期运行一个MR任务，读取某一个文件夹中的所有小文件，并通过减少reduce的数量将它们重写为较少数量的大文件。</strong></p>
<p>比如一个文件夹中有1000个文件，你可以在一个MR任务中指定reduce的数量为5，这样1000个输入文件会被合并为5个文件。</p>
<p>随后进行一些简单的HDFS文件/文件夹操作(将新文件覆盖回原目录)，则可以将NameNode的内存使用减少到200分之1，并且可以提高以后MR或其他计算引擎对同一数据处理的性能。</p>
<p>这些MR任务运行同样需要集群资源，所以建议调度在生产系统非繁忙时间段执行。同时，应该定期执行这种合并的MR作业，因为小文件随时或者几乎每天都可能产生。</p>
<p>但这个合并程序需要有额外的逻辑来判断存在大量小文件的目录，或者你自己是知道哪些目录是存在大量小文件的。因为假如某个目录只有3个文件，运行合并作业远不如合并一个500个文件的文件夹的性能优势提升明显。</p>
<p>检查所有文件夹并确认哪些文件夹中的小文件需要合并，目前主要是通过自定义的脚本或程序，当然一些商业工具也能做，比如Pentaho可以迭代HDFS中的一组文件夹，找到最小合并要求的文件夹。</p>
<p>缺点：批量合并文件的方法无法保留原始文件名，如果原始文件名对于你了解数据来源非常重要，则批量合并文件的方法也不适用。但一般来说，我们一般只会设计HDFS的各级目录的文件名，而不会细化到每个文件的名字，所以理论来说这种方法问题也不大。</p>
<p><strong>3、Sequence文件</strong></p>
<p>SequenceFile是Hadoop API提供的一种二进制文件，它将数据以&lt;key,value&gt;的形式序列化到文件中，这种二进制文件内部使用Hadoop的标准Writable接口实现序列化和反序列化。有如下特点：</p>
<p><img src="/2021/08/02/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E5%B0%8F%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/image-20210802004812454.png" alt="image-20210802004812454" style="zoom: 50%;"></p>
<p>（1）基于行存储。它与Hadoop API中的MapFile是互相兼容的。Hive中的SequenceFile继承自Hadoop API的SequenceFile，不过它的key为空，使用value存放实际的值，这样是为了避免MR在运行map阶段的排序过程。</p>
<p>（2）支持三种压缩类型：None、Record、Block。默认采用Record，但是Record压缩率低；一般建议使用Block压缩。</p>
<p>（3）优势是文件和Hadoop API的MapFile是相互兼容的。</p>
<p>当需要维护原始文件名时，就可以使用sequence文件。在此解决方案中，文件名作为key保存在sequence文件中，然后文件内容会作为value保存。下图给出将一些小文件存储为sequence文件的示例：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Key  |  Value  |  Key  |  Value  |  Key  |  Value</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  file1.txt  | file1 contents| file2.txt    |file2 contents  | fileN.txt    | fileN contents</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>如果一个sequence文件包含10000个小文件，则同时会包含10000个key在一个文件中。sequence文件支持块压缩，并且是可被拆分的。<strong>这样MR作业在处理这个sequence文件时，只需要为每个128MB的block启动一个map任务，而不是每个小文件启动一个map任务。当你在同时抽取数百个或者数千个小文件，并且需要保留原始文件名时，这是非常不错的方案。</strong></p>
<p>缺点：如果你一次仅抽取少量的小文件到HDFS，则sequence文件的方法也不太可行，因为sequence文件是不可变的，无法追加。比如3个10MB文件将产生1个30MB的Sequence文件，根据本文前面的定义，这仍然是一个小文件。另外一个问题是如果需要检索sequence文件中的文件名列表则需要遍历整个文件。</p>
<p>另外一个问题是Hive并不能较好的处理由该方法合并出来的sequence文件。Hive将value中的所有数据视为单行。这样会导致Hive查看这些数据不方便，因为以前小文件中的一行的所有数据也是Hive中的单行，即相当于只有一个字段。同时，Hive没办法访问这种sequence的key，即文件名（可以自定义Hive Serde来解决）</p>
<p><strong>4、使用Hbase进行数据存储</strong></p>
<p>解决小文件问题，除了HDFS存储外，当然还可以考虑HBase列式存储。使用HBase可以<strong>将数据抽取过程从生成大量小HDFS文件更改为以逐条记录写入到HBase表</strong>。如果你对数据访问的需求主要是随机查找或者叫点查，则HBase是最好的选择。HBase在架构上就是为快速插入，存储大量数据，单个记录的快速查找以及流式数据处理而设计的。但如果你对数据访问的需求主要是全表扫描，则HBase不是最适合的。</p>
<p>可以基于HBase的表的数据创建Hive表，但是查询这种Hive表对于不同的查询类型性能会不一样。当查询单行或者范围查找时，Hive on HBase会表现不错，但是如果是全表扫描则效率比较低下，大多数分析查询比如带group by的语句都是全表扫描。</p>
<p>缺点：使用HBase，可以较好的应对实时数据写入以及实时查询的场景。但是如何分配和平衡HBase与集群上其他的组件的资源使用，以及HBase本身运维都会带来额外的运维管理成本。另外，HBase的性能主要取决于你的数据访问方式，所以在选择HBase解决小文件问题之前，应该进行仔细调研和设计。</p>
<p><strong>5、使用CombineFileInputFormat</strong></p>
<p>CombineFileInputFormat是Hadoop提供的抽象类，<strong>它在MR读取时合并小文件。合并的文件不会持久化到磁盘，它是在一个map任务中合并读取到的这些小文件。好处是MR可以不用为每个小文件启动一个map任务</strong>，而且因为是自带的实现类，你不用额外将小文件先提前合并。</p>
<p>为了实现这个，需要为不同的文件类型编写Java代码扩展CombineFileInputFormat类。这样实现一个自定义的类后，就可以配置最大的split大小，然后单个map任务会读取小文件并进行合并直到满足这个大小。Hive作业直接配置参数即可实现。</p>
<p>缺点：这解决了MR作业启动太多map任务的问题，但是因为作业仍然在读取多个小文件，随机磁盘IO依旧是一个问题。另外，CombineFileInputFormat大多数情况下都不会考虑data locality，往往会通过网络从其他节点拉取数据。</p>
<p>注意以上无论是MR代码实现方式还是Hive，因为合并的文件并不会持久化保存到磁盘，因此CombineFileInputFormat方式并不会缓解NameNode内存管理问题。只是提高MR或者Hive作业的性能。</p>
<p><strong>6、通过Hive合并小文件</strong></p>
<p>如果你在使用Hive时因为"create table as"或"insert overwrite"语句输出了小文件，你可以通过设置一些参数来缓解。通过设置这些参数。Hive会在本身的SQL作业执行完毕后会单独起一个MR任务来合并输出的小文件。</p>
<p>注意这个设置仅对Hive创建的文件生效，比如你使用Sqoop导数到Hive表，或者直接抽数到HDFS等，该方法都不会起作用。</p>
<p><strong>7、使用Hadoop的文件追加特性</strong></p>
<p>Hadoop自带的Append特性，即当第一次输出是小文件时，后面的文件输出可以继续追加这些小文件，让小文件变成大文件。</p>
<p>这听上去是个不错的建议，但其实做起来挺难的。因为MR任务有一个规定，输出结果目录必须是在之前不存在的。所以MR作业肯定无法使用Append特性，由于Sqoop，Pig和Hive都使用了MR，所以这些工具也不支持Append。Flume不支持Append主要是因为它假设经过一段时间比如几秒，多少字节，多少事件数或者不活动的秒数，Flume就会关闭文件而不再打开它。</p>
<p>因此，需要自己编写特定的程序来追加到现有的文件。另外，当集群中其他应用程序如果正在读取或处理这些需要追加的文件，你就不能使用自定义的MR或者Spark程序来追加这些文件了。所以如果要使用这种方法，最好还是谨慎考虑。</p>
<h3 id="hive小文件">Hive小文件</h3>
<h4 id="解决方案">解决方案</h4>
<p>1、配置输入合并和输出合并小文件</p>
<p>配置map输入合并</p>
<p>在执行map任务前进行小文件合并：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 每个Map最大输入大小，决定合并后的文件数</span><br><span class="line"><span class="built_in">set</span> mapred.max.split.size=256000000;</span><br><span class="line">-- 一个节点上split的至少的大小 ，决定了多个data node上的文件是否需要合并</span><br><span class="line"><span class="built_in">set</span> mapred.min.split.size.per.node=100000000;</span><br><span class="line">-- 一个交换机下split的至少的大小，决定了多个交换机上的文件是否需要合并</span><br><span class="line"><span class="built_in">set</span> mapred.min.split.size.per.rack=100000000;</span><br><span class="line">-- 执行Map前进行小文件合并</span><br><span class="line"><span class="built_in">set</span> hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;</span><br></pre></td></tr></table></figure>
<p>配置hive结果端合并</p>
<p>通过设置hive的配置项在执行结束后对结果文件进行合并。hive在对结果文件进行合并时会执行一个额外的map-only脚本，mapper的数量是文件总大小除以size.per.task参数所得的值，触发合并的条件是：根据查询类型不同，相应的mapfiles/mapredfiles参数需要打开；结果文件的平均大小需要大于avgsize参数的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 在Map-only的任务结束时合并小文件</span><br><span class="line"><span class="built_in">set</span> hive.merge.mapfiles = <span class="literal">true</span></span><br><span class="line">-- 在Map-Reduce的任务结束时合并小文件</span><br><span class="line"><span class="built_in">set</span> hive.merge.mapredfiles = <span class="literal">true</span></span><br><span class="line">-- 合并文件的大小</span><br><span class="line"><span class="built_in">set</span> hive.merge.size.per.task = 256*1000*1000 </span><br><span class="line">-- 当输出文件的平均大小小于该值时，启动一个独立的map-reduce任务进行文件merge</span><br><span class="line"><span class="built_in">set</span> hive.merge.smallfiles.avgsize=16000000</span><br></pre></td></tr></table></figure>
<p>2、Hive使用HAR归档文件</p>
<p>Hadoop的归档文件格式也是解决小文件问题的方式之一。而且hive提供了原生支持：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">set</span> hive.archive.enabled=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">set</span> hive.archive.har.parentdir.settable=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">set</span> har.partfile.size=1099511627776;</span><br><span class="line">ALTER TABLE srcpart ARCHIVE PARTITION(ds= <span class="string">&#x27;2021-02-01&#x27;</span>, hr= <span class="string">&#x27;12&#x27;</span> );</span><br><span class="line">ALTER TABLE srcpart UNARCHIVE PARTITION(ds= <span class="string">&#x27;2021-02-01&#x27;</span>, hr= <span class="string">&#x27;12&#x27;</span> );</span><br></pre></td></tr></table></figure>
<p>3、数据仓库Hive表分区优化</p>
<p>数据仓库创建数仓表时，ETL开发人员基于使用习惯和处理的方便性，经常创建多级分区存储数据。但是过多的分区会消耗NameNode大量的资源，而且也会引入小文件的问题。所以对于创建数仓表的分区，要求如下（本质就是尽可能减少分区创建）：</p>
<p>（1）对于统计数据表、数据量不大的基础表、业务上无累计快照和周期性快照要求的数据表，尽可能的不创建分区，而采用数据合并回写的方式解决。</p>
<p>（2）对于一些数据量大的表，如果需要创建分区，提高插叙过程中数据的加载速度，尽可能的只做天级分区。而对于埋点数据，这种特大的数据量的，可以采用小时分区。</p>
<p>（3）对于一些周期快照和累计快照的表，我们尽可能只创建日分区。</p>
<p>4、对Hive数据进行压缩</p>
<p>出于对小文件数据治理的目的，建议使用非TexFile的序列化存储方式存储数据。并且如果一张Hive表存在大量的小文件，建议通过以下参数设置压缩：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">set</span> hive.exec.compress.output<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> parquet.compression<span class="operator">=</span>snappy;</span><br><span class="line"><span class="keyword">set</span> hive.merge.mapfiles<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.merge.mapredfiles<span class="operator">=</span><span class="literal">true</span>; </span><br><span class="line"><span class="keyword">set</span> hive.merge.mapredfiles<span class="operator">=</span><span class="literal">true</span></span><br><span class="line"><span class="keyword">set</span> hive.optiming.sort.dynamic.partition <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">--256M</span></span><br><span class="line"><span class="keyword">set</span> parquet.blocksize<span class="operator">=</span> <span class="number">268435456</span>;</span><br><span class="line"><span class="comment">--256M</span></span><br><span class="line"><span class="keyword">set</span> dfs.block.size<span class="operator">=</span><span class="number">268435456</span>; </span><br><span class="line"><span class="comment">--128M</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.smallfiles.avgsize<span class="operator">=</span><span class="number">134217728</span>; </span><br><span class="line"><span class="comment">--256M</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.size.per.task <span class="operator">=</span> <span class="number">268435456</span>;</span><br></pre></td></tr></table></figure>
<h3 id="spark小文件">Spark小文件</h3>
<h4 id="问题">问题</h4>
<p>使用sparkstreaming时，如果实时计算结果要写入到HDFS，那么不可避免的会遇到一个问题，那就是<strong>在默认情况下会产生非常多的小文件</strong>，这是由sparkstreaming的微批处理模式和DStream(RDD)的分布式(partition)特性导致的，sparkstreaming为每个partition启动一个独立的线程来处理数据，一旦文件输出到HDFS，那么这个文件流就关闭了，再来一个batch的parttition任务，就再使用一个新的文件流。</p>
<p>那么假设，一个batch为10s，每个输出的DStream有32个partition，那么一个小时产生的文件数将会达到(3600/10) * 32=11520个之多。众多小文件带来的结果是有大量的文件元信息，比如文件的location、文件大小、block number等需要NameNode来维护，NameNode压力会非常大。</p>
<p>不管是什么格式的文件，parquet、text、JSON或者Avro，都会遇到这种小文件问题，这里讨论几种处理sparkstreaming小文件的典型方法。</p>
<h4 id="解决方案-1">解决方案</h4>
<p><strong>1、增加batch大小</strong></p>
<p>batch越大，从外部接收的event就越多，内存积累的数据也就越多，那么输出的文件数也就回变少，比如将上面例子中的batch时间从10s增加为100s，那么一个小时的文件数量就会减少到1152个。但是此时延迟会比较大，不适合实时性要求高的场景。</p>
<p><strong>2、coalesce和repartition</strong></p>
<p>小文件的基数是：batch_number * partition_number，而第一种方法是减少batch_number，那么这种方法就是减少partition_number了，这个api不细说，就是减少初始的分区个数。看过spark源码的童鞋都知道，对于窄依赖，一个子rdd的partition规则继承父rdd，对于宽依赖(就是那些ByKey操作)，如果没有特殊指定分区个数，也继承自父rdd。那么初始的SourceDstream是几个partiion，最终的输出就是几个partition。</p>
<p>所以coalesce大法的好处就是，可以在最终要输出的时候，来减少partition个数。</p>
<p>但是这个方法的缺点也很明显，本来是32个线程在写256M数据，现在可能变成了4个线程在写256M数据，而没有写完成这256M数据，这个batch是不算做结束的。那么一个batch的处理时延必定增长，batch挤压会逐渐增大。</p>
<p><strong>3、自定义合并脚本</strong></p>
<p>在sparkstreaming外再启动定时的批处理任务来合并sparkstreaming产生的小文件。需要注意合并任务的时间划分，避免合并正在写入的sparkstreaming文件。</p>
<p><strong>4、通过foreach输出类追加小文件</strong></p>
<p>sparkstreaming提供的foreach这个outout类api，可以让我们自定义输出计算结果的方法。那么我们其实也可以利用这个特性，那就是每个batch在要写文件时，并不是去生成一个新的文件流，而是把之前的文件打开。考虑这种方法的可行性，首先，HDFS上的文件不支持修改，但是很多都支持追加，那么每个batch的每个partition就对应一个输出文件，每次都去追加这个partition对应的输出文件，这样也可以实现减少文件数量的目的。这种方法要注意的就是不能无限制的追加，当判断一个文件已经达到某一个阈值时，就要产生一个新的文件进行追加了。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://mp.weixin.qq.com/s/Bg70xFG9BIbhzO4tzMfH_A</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 链表</title>
    <url>/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>LeetCode中与链表有关的题目。</p>
<a id="more"></a>
<h3 id="lru缓存">146 LRU缓存</h3>
<p>题目描述</p>
<p>实现一个最近最少使用的缓存策略。</p>
<p>题解</p>
<p>时间复杂度O(1)：</p>
<p>空间复杂度O(n)：使用Hash表和双向链表对元素进行存储</p>
<p>当添加元素的时候，如果还有位置，则直接添加到头部，否则需要将最久没有被访问过的元素移出去。</p>
<p>Java中使用LinkedHashMap进行实现，其本质是HashMap加双向链表的形式。</p>
<p>HashMap用于保证查找和删除的时间为O(1)。LinkedHashMap用来存储元素的访问顺序。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/0.jpg" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现双向链表</span></span><br><span class="line"><span class="comment">//首先实现双向链表中的每个节点，假设Key、Value都是int类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key,value;</span><br><span class="line">    <span class="keyword">public</span> Node pre,next;<span class="comment">//前后节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在头部添加节点，即插入元素或访问一个已存在元素</span></span><br><span class="line">    <span class="comment">//注意它只能在头部插入元素表示访问该元素，其他位置都不需要插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = tail = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head.pre = node;</span><br><span class="line">            head = head.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表中某个节点，即当访问某个元素时，它被提到双向链表最前面，因此需要先删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果只剩下一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == node &amp;&amp; tail == node)&#123;</span><br><span class="line">          head = <span class="keyword">null</span>;</span><br><span class="line">          tail = <span class="keyword">null</span>;   </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head == node)&#123; <span class="comment">//删除头节点</span></span><br><span class="line">            head.next.pre = <span class="keyword">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tail == node)&#123; <span class="comment">//删除尾节点</span></span><br><span class="line">            tail = tail.pre;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            node.pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//删除中间节点</span></span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            node.pre = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表最末尾的元素，为新增加的元素空出位置，要返回这个节点便于HashMao删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node tmp = tail;</span><br><span class="line">        remove(tail);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">        cap = capacity;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该函数的作用就是访问一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(key).value;</span><br><span class="line">        <span class="comment">//改变双向链表中元素的顺序</span></span><br><span class="line">        put(key,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个函数的作用就是把元素插入到哈希表和双向链表中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node tmp = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">		<span class="comment">//如果这个元素已经存在，那么只要调整在双向链表中的位置即可</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//在双向链表中删除</span></span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">            <span class="comment">//插入头部</span></span><br><span class="line">            cache.addFirst(tmp);</span><br><span class="line">            <span class="comment">//更新map中的值</span></span><br><span class="line">            map.put(key, tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//元素不存在</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果容量已经满了</span></span><br><span class="line">            <span class="keyword">if</span>(cache.size() == cap)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//从双向链表和HashMao中删除最近最少使用页面</span></span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//插入头部</span></span><br><span class="line">            cache.addFirst(tmp);</span><br><span class="line">            <span class="comment">//更新map中的值</span></span><br><span class="line">            map.put(key, tmp);</span><br><span class="line">            </span><br><span class="line">                  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回文链表">234 回文链表</h3>
<p>题目描述</p>
<p>请判断一个链表是否为回文链表。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2 输出: false 示例 2:</p>
<p>输入: 1-&gt;2-&gt;2-&gt;1 输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(1)：不使用额外存储空间</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/1.png" style="zoom:50%;"></p>
<p>使用快慢指针找到链表一半处的位置。两个指针都从头部开始，慢指针每次走一步，快指针每次走两步，并且需要维护一个pre指针指向慢指针的前一个节点。这样当节点数量为<strong>偶数</strong>时（例如4个），快指针 == null，pre指向链表节点一半处（第二个节点）；当节点数量为<strong>奇数</strong>时（例如5个），快指针 == null，pre指向链表节点一半处的前一个节点（第二个节点）。</p>
<p>技巧是边遍历边反转，直到慢指针到达链表一半处的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//head为空时返回true</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head, fast = head, pre = <span class="keyword">null</span>, tmp = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        当节点数量为奇数时，fast.next == null</span></span><br><span class="line"><span class="comment">        当节点数量为偶数时，fast == null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//fast先走两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//慢指针走一步并同时进行翻转</span></span><br><span class="line">            tmp = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是奇数节点，例如5个，慢指针刚好指向第3个位置，因此多走一步指向第二个链表头</span></span><br><span class="line">        <span class="comment">//注意这里要两个条件，避免fast指向null时出错</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next == <span class="keyword">null</span>)</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//pre和slow同时开始遍历，判断是否是回文</span></span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.val != slow.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            pre = pre.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两数相加">2 两数相加</h3>
<p><strong>题目描述</strong></p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储一位数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(max(m,n))：m、n分别为两个链表的长度</p>
<p>空间复杂度O(max(m,n))</p>
<p>直接采用模拟竖式加法的过程，新建一个虚拟头节点，然后同时遍历两个链表，从最低位至最高位，逐位相加，如果和大于等于 10，则保留个位数字，同时记录进位为 1留给下一轮相加。当某个链表为空时，补上0 。</p>
<p>注意不能将数字转为int相加，因为链表本身代表的数字有可能越界。</p>
<p>注意最后的进位如果不是0，要新建一个节点给它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//记录进位</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 记录每一位相加</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode tmp = vhead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            sum = (l1 == <span class="keyword">null</span>? <span class="number">0</span> : l1.val) + (l2 == <span class="keyword">null</span>? <span class="number">0</span> : l2.val) + carry;</span><br><span class="line"></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            tmp.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>)</span><br><span class="line">            tmp.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vhead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序链表">148 排序链表</h3>
<p><strong>题目描述</strong></p>
<p>给你链表的头结点 head ，请将其按升序排列并返回 排序后的链表 。要求在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(nlogn\)</span>)：归并排序</p>
<p>空间复杂度O(1)：不使用额外存储空间，仅改变链表指针的指向</p>
<p>时间复杂度是 O(<span class="math inline">\(nlogn\)</span>)的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(<span class="math inline">\(n^2\)</span>))），其中最适合链表的排序算法是归并排序。</p>
<p>归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(<span class="math inline">\(logn\)</span>)。如果要达到 O(1)的空间复杂度，则需要使用自底向上的实现方式。</p>
<p>所谓自底向上，就是将链表拆分成子链表进行合并。</p>
<p>第一轮子链表长度为1，归并第1、2节点，第3、4节点等；</p>
<p>第二轮子链表长度为2，归并第1-2、3-4节点、第5-6、7-8节点等；</p>
<p>第三轮子链表长度为4，归并第1-4、5-8节点、第9-12、13-16节点等。</p>
<p>直到子链表的长度等于整个链表的长度为止，停止归并。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E9%93%BE%E8%A1%A8/0.png" style="zoom: 33%;"></p>
<p>需要使用两个个子函数辅助实现：</p>
<p>1、<strong>断链操作</strong>，<code>split(l,n)</code> 即<strong>切掉</strong>链表l的前n个节点，并返回后半部分的链表头。注意，此时子链表中不一定有n个节点，或后半部分链表头不一定存在，这时候该函数返回null。</p>
<p>2、<strong>合并两个有序链表</strong>，这是一道经典题目，创建一个虚拟头并逐个比较。（递归法不满足空间复杂度要求）</p>
<p>算法的大致流程为：</p>
<p>1、依次将链表分成1块，2块，4块...</p>
<p>2、每次分割时，分别找到第一部分和第二部分数组的头节点，两个两个数组合并</p>
<p>3、用一个指针将前面的部分与排序好的部分连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取链表的长度用于判断归并终止条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;              </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//split(l,n) 即切掉链表l的前n个节点，并返回后半部分的链表头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">split</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; tmp.next!= <span class="keyword">null</span>; i++)&#123; <span class="comment">//走n步刚好到达后半部分链表头，从1开始走n-1步则走到前一个节点（为了断链）</span></span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode right = tmp.next; <span class="comment">//返回后半部分的链表头</span></span><br><span class="line">        tmp.next = <span class="keyword">null</span>;<span class="comment">//断链操作</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并两个有序链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode h1, ListNode h2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = vhead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(h1 != <span class="keyword">null</span> &amp;&amp; h2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(h1.val &lt; h2.val)&#123;</span><br><span class="line">                p.next = h1;</span><br><span class="line">                h1 = h1.next;       </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = h2;</span><br><span class="line">                h2 = h2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p.next = h1 == <span class="keyword">null</span> ? h2 : h1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vhead.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = getLength(head);</span><br><span class="line">        <span class="comment">//新建虚拟头节点，该头节点的next指针永远指向链表的第一个位置</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt; len; step = step*<span class="number">2</span>)&#123; <span class="comment">//依次将链表分成1块，2块，4块...</span></span><br><span class="line">            </span><br><span class="line">            ListNode pre = dummy; <span class="comment">//每次迭代开始时pre都指向虚拟头节点，并用pre将排序好的链表串联起来</span></span><br><span class="line">            ListNode cur = dummy.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                ListNode h1 = cur;</span><br><span class="line">                ListNode h2 = split(h1, step); <span class="comment">//将第一部分数组切割，并返回第二部分数组头</span></span><br><span class="line">                cur = split(h2, step); <span class="comment">//将第二部分数组切割，将cur往后移动</span></span><br><span class="line">                </span><br><span class="line">                ListNode tmp = merge(h1, h2); <span class="comment">//合并两个排序链表</span></span><br><span class="line">                pre.next = tmp; <span class="comment">//用pre将排序链表串起来（首次执行时pre = dummy，则虚拟头永远可以指向链表头）</span></span><br><span class="line">                <span class="keyword">while</span>(pre.next != <span class="keyword">null</span>)</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                  </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并k个升序链表">23 合并K个升序链表</h3>
<p><strong>题目描述</strong></p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例 1：</p>
<p>输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6] 将它们合并到一个有序链表中得到。 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(nlogk\)</span>)：循环遍历所有元素，并且每次堆的复杂度为<span class="math inline">\(logk\)</span></p>
<p>空间复杂度O(<span class="math inline">\(k\)</span>)：<span class="math inline">\(k\)</span>表示指针数组中指针元素的个数</p>
<p>设置一个最小堆，这个堆里面存储的是k个链表的指针，排序方式是按照指针指向的数字排序。每次将一个指针出堆，让该指针往后移动，并将后面的链表节点入堆（除非为null），如此重复直到堆中没有任何元素。</p>
<p>相当于我们需要准备一个「集合」，将所有链表的头结点放入「集合」，然后每次都从「集合」中挑出最小值，并将最小值的下一个节点添加进「集合」（如果有的话），循环这个过程，直到「集合」为空（说明所有节点都处理完，进过集合又从集合中出来）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立最小堆</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;( <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;   </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123; <span class="comment">//返回负数表示不需要交换1和2的位置</span></span><br><span class="line">                <span class="keyword">return</span> l1.val - l2.val;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        插曲：最大堆时，希望o1&gt;o2，但是o1-o2会是正数，这样会交换位置</span></span><br><span class="line"><span class="comment">        因此反过来用o2-o1，这样会得到负数，就不交换位置因此形成最大堆</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用链表数组中的元素初始化堆</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode h: lists)</span><br><span class="line">            <span class="keyword">if</span>(h != <span class="keyword">null</span>) heap.add(h);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建虚拟头节点</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tmp = vhead;</span><br><span class="line">        ListNode out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当堆不为空时，循环出入堆的操作</span></span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</span><br><span class="line">            </span><br><span class="line">            out = heap.remove();</span><br><span class="line">            tmp.next = out;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(out.next != <span class="keyword">null</span>)</span><br><span class="line">                heap.add(out.next);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vhead.next;</span><br><span class="line">               </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>LRU：https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/</p>
<p>回文链表：https://leetcode-cn.com/problems/palindrome-linked-list/solution/di-gui-zhan-deng-3chong-jie-jue-fang-shi-zui-hao-d/</p>
<p>两数相加：https://leetcode-cn.com/problems/add-two-numbers/solution/po-su-jie-fa-shao-bing-ji-qiao-by-ac_oie-etln/</p>
<p>排序链表：https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-di-gui-die-dai-xiang-jie-by-cherr/</p>
<p>https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/</p>
<p>https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/</p>
<p>合并K个升序链表：https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/shua-chuan-lc-you-xian-dui-lie-jie-fa-sh-3flb/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 堆栈</title>
    <url>/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>剑指Offer中关于堆栈的题目解析。</p>
<a id="more"></a>
<h3 id="用两个栈实现队列">01 用两个栈实现队列</h3>
<p><strong>题目描述</strong> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>题解</strong></p>
<p>Push：</p>
<p>时间复杂度O(<span class="math inline">\(1\)</span>)：stack1每次仅涉及一个元素的操作。</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：stack1中存储<span class="math inline">\(n\)</span>个元素。</p>
<p>Pop：</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：在最坏情况下，stack2 为空，算法需要从 stack1 中弹出 <span class="math inline">\(n\)</span> 个元素，然后再压入stack2中；最好情况下stack2不为空，则复杂度为O(1)。</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：stack2中存储<span class="math inline">\(n\)</span>个元素。</p>
<p>栈，是一种先进后出的数据结构。队列，是一种先进先出的数据结构。</p>
<p>有两个栈stack1和stack2，当队列进入元素时（Push），压入stack1中。</p>
<p>当需要出队时（Pop），若stack2中有元素，则先将stack2中元素弹出，直到为空，再将stack1中元素全部弹出压入stack2中，然后继续弹出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                stack2.push( stack1.pop() );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包含min函数的栈最小栈">02 包含min函数的栈/最小栈</h3>
<p><strong>题目描述</strong> 定义栈的数据结构，请在该类型中实现一个能够获得栈中所含最小元素的min函数（时间复杂度应为O(1)）。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(1)：所有操作的复杂度均为O(1)。</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一共有n个待入栈元素，最差情况下栈中存储所有待入栈元素。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/0.png" style="zoom:67%;"></p>
<p>可通过建立辅助栈实现； 数据栈 A： 栈 A用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。 辅助栈 B： 栈 B中存储栈 A中所有 非严格降序 的元素，则栈 A中的最小元素始终对应栈 B的栈顶元素，即 min() 函数只需返回栈 B的栈顶元素即可。 因此，只需设法维护好 栈 B的元素，使其保持非严格降序，即可实现 min() 函数的 O(1)复杂度。维护则分为push和pop，只有小于等于当前栈顶的才push，只有A pop的元素和栈顶相等才pop。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; master = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; slave = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        master.push(node);</span><br><span class="line">        <span class="keyword">if</span>(slave.size() == <span class="number">0</span>)</span><br><span class="line">            slave.push(node);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(slave.peek() &gt;= node)</span><br><span class="line">                slave.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node = master.pop();</span><br><span class="line">        <span class="keyword">if</span>(node == slave.peek())</span><br><span class="line">            slave.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> master.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> slave.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈的压入弹出序列">03 栈的压入、弹出序列</h3>
<p>题目描述</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5],[4,3,5,1,2]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2<span class="math inline">\(n\)</span> 次出入栈操作。 空间复杂度 O(<span class="math inline">\(n\)</span>) ： 辅助栈 stack 最多同时存储 <span class="math inline">\(n\)</span> 个元素。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/1.png" style="zoom: 50%;"></p>
<p>考虑借用一个辅助栈 stack，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p>
<p>入栈操作： 按照压栈序列的顺序执行。 出栈操作： <strong>每次</strong>入栈后，循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。</p>
<p>若最终能够全部弹出，则表明该弹出序列是满足条件的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//模拟栈</span></span><br><span class="line">        Stack&lt;Integer&gt; sta = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个指针，一个指向压入序列，一个指向弹出序列</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按照压入序列逐个压入</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; pushA.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            sta.push(pushA[i]);</span><br><span class="line">            <span class="comment">//每次压入后都判断是否能够弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!sta.isEmpty() &amp;&amp; sta.peek() == popA[j])&#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最终若能全部弹出则满足条件</span></span><br><span class="line">        <span class="keyword">return</span> sta.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流中的中位数">04 数据流中的中位数</h3>
<p>题目描述 如何得到一个数据流中的中位数？</p>
<p>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(logn\)</span>) ： 优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的。 空间复杂度 O(<span class="math inline">\(n\)</span>) ： 使用了三个辅助空间，其中两个堆的空间复杂度是 O(<span class="math inline">\(n/2\)</span>)， 一个表示数据流元素个数的计数器占用空间O(1)。</p>
<p>一种最容易想到的思路是，数据流新进来一个数，都把它与已经读出来的数进行一次排序，这样中位数就可以很容易得到。这样做不好的地方是：排序的时间复杂度为 O(<span class="math inline">\(nlogn\)</span>)，但事实上，对除了中位数以外的其它位置的元素并不关心。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/2.png" style="zoom:67%;"></p>
<p>通过维护一个大顶堆表示前有序数组，维护一个小顶堆表示后有序数组，解决求取中位数的问题。</p>
<p>堆可以通过java中的优先队列PriorityQueue实现。</p>
<p>注意到，大顶堆堆顶元素必须小于小顶堆堆顶元素，这可以通过先将数据加入大顶堆再加入小顶堆实现。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/3.png" style="zoom: 60%;"></p>
<p>大顶堆存储<span class="math inline">\(n\)</span>个或<span class="math inline">\(n+1\)</span>个数，取决于数据流的总数据量是偶数还是奇数，小顶堆存储<span class="math inline">\(n\)</span>个元素。</p>
<p>每当一个元素到来时，先将其添加到大顶堆，然后取出堆顶元素表示大顶堆中的最大值，加入小顶堆中。</p>
<p>若总数据量是偶数，则两边存储元素数目一样，不做任何操作。</p>
<p>若总数据量是奇数，则大顶堆应该多存储一个值表示中位数，因此将小顶堆堆顶元素取出表示堆中最小值，并加入大顶堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数可以优化成boolean</span></span><br><span class="line">    <span class="comment">//PriorityQueue&lt;Integer&gt; left = new PriorityQueue&lt;Integer&gt;((x, y)-&gt;(y-x)); //左边大顶堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;( <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125; ); <span class="comment">//传入lambda表达式会慢非常多    </span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();<span class="comment">//右边默认小顶堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        left.add(num);</span><br><span class="line">        right.add( left.remove() );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            left.add( right.remove() );</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        奇数情况下，可以先判断num是否大于小顶堆中的最小值，如果大于则需要插入并删除堆顶，</span></span><br><span class="line"><span class="comment">        否则直接插入大顶堆即可，这样就免去了维护小顶堆的时间</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        if(count%2 == 1)&#123;    </span></span><br><span class="line"><span class="comment">            if(right.size()&gt;0 &amp;&amp; num &gt; right.peek() )&#123;</span></span><br><span class="line"><span class="comment">                right.add(num);</span></span><br><span class="line"><span class="comment">                num = right.remove();</span></span><br><span class="line"><span class="comment">            &#125;      </span></span><br><span class="line"><span class="comment">            left.add( num );            </span></span><br><span class="line"><span class="comment">        &#125;else&#123;            </span></span><br><span class="line"><span class="comment">            left.add(num);</span></span><br><span class="line"><span class="comment">            right.add( left.remove() );            </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (left.peek()+right.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)left.peek(); <span class="comment">//注意数据类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口的最大值堆或双端队列">05 滑动窗口的最大值/堆或双端队列</h3>
<p>题目描述</p>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<p>窗口大于数组长度的时候，返回空</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2,3,4,2,6,2,5,1],3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,4,6,6,6,5]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(nlogk\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为数组长度，<span class="math inline">\(logk\)</span>为重建堆的时间复杂度。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 维护窗口中元素的堆。</p>
<p>对滑动窗口中的元素维护一个最大堆。堆通过java中的优先队列PriorityQueue实现。每次窗口移动时，先删除掉窗口上一个元素，然后将新元素加入堆，则堆顶就是窗口元素的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length == <span class="number">0</span> || num.length &lt; size || size == <span class="number">0</span>) <span class="comment">//注意size不能为0</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//声明最大堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;( <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;                 </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用第一个窗口初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">            pq.add(num[j]);</span><br><span class="line">        res.add(pq.peek());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//窗口移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i+size &lt;= num.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            pq.remove(num[i-<span class="number">1</span>]);</span><br><span class="line">            pq.add(num[i+size-<span class="number">1</span>]);</span><br><span class="line">            res.add(pq.peek());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>) ： 只需要遍历一次数组，同时每一个下标恰好被放入队列一次，并且最多被弹出队列一次。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 双端队列中存储的元素。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/4.png"></p>
<p>双端队列，既可以从队头出队，也可以从队尾出队，则不用遵循先进先出的规则。</p>
<p>双端队列中，本质上是维护了窗口中<strong>以最大值为开始的递减序列</strong>。非递减序列中的数值则被删除，不会出现在双端队列中。当窗口移动时，只有那些递减序列中的值才有可能被删除。</p>
<p>整个过程为：</p>
<p>1.想将我们第一个窗口的所有值存入单调双端队列中，单调队列里面的值为单调递减的。如果发现队尾元素小于要加入的元素，则将队尾元素出队，直到队尾元素大于新元素时，再让新元素入队，目的就是维护一个单调递减的队列。</p>
<p>2.我们将第一个窗口的所有值，按照单调队列的规则入队之后，因为队列为单调递减，所以队头元素必为当前窗口的最大值，则将队头元素添加到数组中。</p>
<p>3.移动窗口，<strong>判断当前窗口前的元素是否和队头元素相等，如果相等则出队</strong>。</p>
<p>4.继续然后按照规则进行入队，维护单调递减队列。</p>
<p>5.每次将队头元素存到返回数组里。</p>
<p>最终返回数组。</p>
<p>使用Java中的LinkedList类来实现双端队列，其中有offerFirst()、offerLast()、removeFirst()、removeLast()、peekFirst()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length == <span class="number">0</span> || size == <span class="number">0</span> || size &gt; num.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立一个双端队列</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化双端队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="comment">//当队列中的元素小于当前元素时，出队</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;num[i]) deque.removeLast();</span><br><span class="line">            <span class="comment">//将当前元素加入队列</span></span><br><span class="line">            deque.offerLast(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(deque.peekFirst());<span class="comment">//注意这里也要加入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始滑动窗口,注意此时新加入的元素是num[i+size-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num.length - size; i++ )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断是否要出队列</span></span><br><span class="line">            <span class="keyword">if</span>(num[i-<span class="number">1</span>] == deque.peekFirst()) deque.removeFirst();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当队列中的元素小于当前新加入的元素，出队</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;num[i+size-<span class="number">1</span>]) deque.removeLast();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前元素加入队列</span></span><br><span class="line">            deque.offerLast(num[i+size-<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            res.add(deque.peekFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小的k个数快速选择">06 最小的K个数/快速选择</h3>
<p><strong>题目描述</strong></p>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,5,1,6,2,7,3,8],4</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(nlogk\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为数组长度，每个元素都要进行一次入堆操作，<span class="math inline">\(logk\)</span>为重建堆的时间复杂度。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 维护窗口中元素的堆。</p>
<p>维护一个堆。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/5.png" style="zoom:67%;"></p>
<p>平均时间复杂度 O(<span class="math inline">\(n\)</span>)，最坏情况下为O(<span class="math inline">\(n^2\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为数组长度，时间复杂度根据不同主元的选择而不同。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 维护窗口中元素的堆。</p>
<p>“查找第 k 大的元素”是一类算法问题，称为<strong>选择问题</strong>。找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p>
<p>回顾快速排序的思路。快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边，如下图所示：</p>
<p>这个 partition 操作是原地进行的，需要 O(n)的时间，接下来，快速排序会递归地排序左右两侧的数组。</p>
<p>而快速选择（quick select）算法的不同之处在于，接下来只需要<strong>递归地选择一侧的数组</strong>。快速选择算法想当于一个“<strong>不完全</strong>”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并<strong>不需要知道它们的顺序</strong>。</p>
<p>目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p>
<ul>
<li>若 k=m，我们就找到了最小的 k 个数，就是左侧的数组；</li>
<li>若 k&lt;m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li>
<li>若 k&gt;m，则左侧数组中的 mm 个数都属于最小的 kk 个数，我们还需要在右侧数组中寻找最小的 k-mk−m 个数，对右侧数组递归地 partition 即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传入的全部是数组中的下标，所以传入k-1</span></span><br><span class="line">        recur(input, <span class="number">0</span>, input.length-<span class="number">1</span>, k-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将数组中的值进行复制</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left == right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = input[left];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; input[i] &lt; pivot) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; pivot &lt; input[j]) j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= j)&#123; <span class="comment">//++、--之后可能会不满足i&lt;=j的条件，需要进行判断</span></span><br><span class="line">                swap(input, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断递归条件，这里只会递归左数组或者右数组之一，此时 j+1 = i 或 i == j</span></span><br><span class="line">        <span class="keyword">if</span>( left &lt;= k &amp;&amp; k &lt;= j) recur(input, left, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( i &lt;= k &amp;&amp; k &lt;= right) recur(input, i, right, k);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = input[i];</span><br><span class="line">        input[i] = input[j];</span><br><span class="line">        input[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行划分</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = input.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = input[left];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">//注意这里不能等</span></span><br><span class="line">                                   </span><br><span class="line">            pivot = input[left]; i = left; j = right;</span><br><span class="line">             <span class="keyword">while</span>(i &lt;= j)&#123; <span class="comment">//进行多次交换</span></span><br><span class="line">                <span class="keyword">while</span>(i &lt;= j &amp;&amp; input[i] &lt; pivot) i++;</span><br><span class="line">            	<span class="keyword">while</span>(i &lt;= j &amp;&amp; pivot &lt; input[j] )  j--;           </span><br><span class="line">            	<span class="keyword">if</span>(i &lt;= j)&#123;</span><br><span class="line">                    swap(input, i, j);</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">//判断，并更改left、right的范围</span></span><br><span class="line">            <span class="comment">//注意这里只能if else，不能用if else if把递归的条件照搬（会导致同时满足条件？暂不清楚）</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt;= k-<span class="number">1</span> &amp;&amp; k-<span class="number">1</span> &lt;= j) right = j;</span><br><span class="line">            <span class="keyword">else</span> left = i;</span><br><span class="line">            </span><br><span class="line">        &#125;       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将数组中的值进行复制</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = input[i];</span><br><span class="line">        input[i] = input[j];</span><br><span class="line">        input[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考题解">参考题解</h3>
<p>包含min函数的栈：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/</p>
<p>栈的压入、弹出序列：https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/mian-shi-ti-31-zhan-de-ya-ru-dan-chu-xu-lie-mo-n-2/</p>
<p>https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/tan-xin-by-z1m/</p>
<p>数据流中的中位数：https://leetcode-cn.com/problems/find-median-from-data-stream/solution/you-xian-dui-lie-python-dai-ma-java-dai-ma-by-liwe/</p>
<p>滑动窗口的最大值：https://leetcode-cn.com/problems/sliding-window-maximum/solution/zhe-hui-yi-miao-dong-bu-liao-liao-de-hua-7fy5/</p>
<p>最小的k个数：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/tu-jie-top-k-wen-ti-de-liang-chong-jie-fa-you-lie-/</p>
<p>https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/wei-ruan-mian-shi-jiao-xun-x-by-jerry_nju/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 字符串</title>
    <url>/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>剑指Offer中关于字符串的题目解析。</p>
<a id="more"></a>
<h3 id="左旋转字符串">01 左旋转字符串</h3>
<p>题目描述</p>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;abcXYZdef&quot;,3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;XYZdefabc&quot;</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中<span class="math inline">\(n\)</span>为字符串<span class="math inline">\(s\)</span>的长度，字符串切片函数为线性时间复杂度 空间复杂度 O(<span class="math inline">\(n\)</span>)： 两个字符串切片的总长度为<span class="math inline">\(n\)</span></p>
<p>字符串切片：新建两切片字符串，并将两切片拼接为结果字符串，无冗余操作，效率最高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当n超过数组长度时，对n取模使得分割下标位于数组长度以内</span></span><br><span class="line">        <span class="keyword">int</span> sub_index = n % str.length() ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意切片时不包括末尾的下标</span></span><br><span class="line">        <span class="keyword">return</span> str.substring(sub_index, str.length())+str.substring(<span class="number">0</span>, sub_index); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>列表遍历拼接：先把后面的字符加入StringBuilder，再将前面的字符加入。列表(Python) 和 StringBuilder(Java) 都是可变对象，每轮遍历拼接字符时，只是向列表尾部添加一个新的字符元素。最终拼接转化为字符串时，系统 仅申请一次内存 。</p>
<p>字符串遍历拼接：也是先把后面的字符加入，但是用的是字符串拼接。string + string，在 Python 和 Java 中，字符串是 “不可变对象” 。因此，每轮遍历拼接字符时，都需要新建一个字符串；因此，系统 需申请 n 次内存 ，数据量较大时效率低下。</p>
<h3 id="反转单词序列">02 反转单词序列</h3>
<p>题目描述</p>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;nowcoder. a am I&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;I am a nowcoder.&quot;</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中<span class="math inline">\(n\)</span>为字符串<span class="math inline">\(s\)</span>的长度。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 因为给定的是不可变的String，因此需要额外开辟空间存储。</p>
<p>每个字母的顺序并没有反转，仅反转单词顺序。可以采用先反转每个单词，再将整个句子反转的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] cha = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= cha.length; i++)&#123; <span class="comment">//注意这里有个等号，用来处理最后一个单词</span></span><br><span class="line">            <span class="keyword">if</span>( i == cha.length || cha[i] == <span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">//注意这个位置，先判断是不是超过数组，否则cha[i]会发生越界</span></span><br><span class="line">                Reverse(cha, j, i-<span class="number">1</span>);</span><br><span class="line">                j = i+<span class="number">1</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        Reverse(cha, <span class="number">0</span>, cha.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        不可以用toString！！！</span></span><br><span class="line"><span class="comment">        一般类的toString()方法返回的是该类所在的地址值。</span></span><br><span class="line"><span class="comment">        而由于String类和Integer类已经重写了toString()方法，所以输出的是类对象中存储的内容</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(cha); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将一段数组内的字符全部反转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> [] str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            Swap(str, left++, right--);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> [] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = str[i];</span><br><span class="line">        str[i] = str[j];</span><br><span class="line">        str[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符流中第一个不重复的字符-及其位置">03 字符流中第一个不重复的字符 （及其位置）</h3>
<p><strong>题目描述</strong></p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。</p>
<p>返回值描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果当前字符流没有存在出现一次的字符，返回#字符。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong>：</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中<span class="math inline">\(n\)</span>为字符串<span class="math inline">\(s\)</span>的长度，遍历字符流和有序哈希表的复杂度是<span class="math inline">\(O(n)\)</span>，有序哈希表的查找操作是<span class="math inline">\(O(1)\)</span>，哈希表的插入操作复杂度是？？？？； 空间复杂度 O(<span class="math inline">\(1\)</span>)： 由于题目中指出的是字符流，LinkedHashMap 中字符的个数是有限的256个</p>
<p>Java 使用 LinkedHashMap 实现<strong>有序哈希表</strong>。有序哈希表中的<strong>键值对是按照插入顺序排序的</strong>。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为1的字符”。</p>
<p>LinkedHashMap中put方法参数为key和value，表示插入key与value。如果key存在，则旧值被替换。containsKey方法表示是否含有该key，含有则返回true。（本题中，含有则表示字符之前已经出现过了）</p>
<p>使用哈希表的本质原因是为了给每个字符进行统计。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Character, Boolean&gt; res = <span class="keyword">new</span> LinkedHashMap&lt;Character, Boolean&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.put(ch, res.containsKey(ch)); <span class="comment">//如果首次加入，则不包含该值，会返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//遍历有序哈希表，就是元素加入的顺序，找到第一个为false的即可</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d: res.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(d.getValue() == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">return</span> d.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种简单的方式是用HashMap的值储存元素出现的次数，遍历两次字符串即可，但是这样的问题是当字符串很长且前面有很多重复元素时，时间效率低下。</p>
<p><strong>第一个只出现一次的字符位置</strong></p>
<p><strong>题目描述</strong></p>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;google&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历两次字符数组的复杂度是<span class="math inline">\(O(n)\)</span>，有序哈希表的查找操作是<span class="math inline">\(O(1)\)</span> 空间复杂度 O(<span class="math inline">\(1\)</span>)： 由于题目中指出的是字符流，HashMap中字符的个数是有限的256个</p>
<p>若要求取位置，则就用HashMap，并且采用两次遍历的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Character, Boolean&gt; hm = <span class="keyword">new</span> HashMap&lt;Character, Boolean&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> [] array = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : array)&#123;</span><br><span class="line">            hm.put(c, hm.containsKey(c)); <span class="comment">//首次加入时因为没有而是false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hm.get(array[i]) == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="替换空格">04 替换空格</h3>
<p><strong>题目描述</strong> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历统计和遍历修改的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(1\)</span>)： 由于是原地扩展字符串的长度，因此使用<span class="math inline">\(O(1)\)</span>额外空间。</p>
<p>一种简单的思路是构建StringBuilder，然后遇到空格就添加%20，但是这样会额外使用O(<span class="math inline">\(n\)</span>)的空间，因此考虑直接在原字符串（StringBuffer类型，直接String类型则无法修改）上进行修改。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/0.png" style="zoom:67%;"></p>
<p>具体做法就是先统计空格的数量，然后增加原字符串的长度，并用双指针从后往前移动字符。因为后指针每次遇到空格都会比前指针多走，所以当两个指针相遇时，即表示前面已经无空格，可停止算法。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png" style="zoom:45%;"></p>
<p>Java中StringBuffer类型有方法setLength()、setCharAt()、toString()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">//统计空格数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//增加StringBuffer长度</span></span><br><span class="line">        <span class="keyword">int</span> ol = str.length();</span><br><span class="line">        <span class="keyword">int</span> nl = ol+count*<span class="number">2</span>;</span><br><span class="line">        str.setLength(nl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//双指针移动</span></span><br><span class="line">        <span class="keyword">int</span> left = ol - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nl - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果是空格，则right处填充符号</span></span><br><span class="line">            <span class="keyword">if</span>(str.charAt(left) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                str.setCharAt(right - <span class="number">2</span>, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                str.setCharAt(right - <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                str.setCharAt(right, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                right = right - <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//不是空格，则移动left处数值</span></span><br><span class="line">                str.setCharAt(right, str.charAt(left)); </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            left--;</span><br><span class="line">            right--;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表示数值的字符串">05 表示数值的字符串</h3>
<p><strong>题目描述</strong></p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;123.45e+6&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;1.2.3&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历字符串的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(1\)</span>)： 使用<span class="math inline">\(O(1)\)</span>额外空间。</p>
<p>表示数值的字符串可以分为A.B<strong>e</strong>C或A.B<strong>E</strong>C。整数部分为A，小数部分为B，指数部分为C，按顺序判断是否包含这三部分。如果符合条件，则指针可以指向字符串的末尾。</p>
<p>使用全局index遍历字符串。</p>
<p>scanInteger扫描有符号整数，用来匹配A和C部分。</p>
<p>scanUnsignedInteger扫描无符号整数，用来匹配B部分。</p>
<p>每次匹配元素时，都要判断下标是否发生越界，此问题可以用加入终止符号来解决，但是本例是数组，因此只能每次判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局下标</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//scanUnsignedInteger扫描无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> before = index; <span class="comment">//判断指针是否移动，成功移动才说明匹配成功       </span></span><br><span class="line">        <span class="keyword">while</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; (str[index]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; str[index]&lt;=<span class="string">&#x27;9&#x27;</span>) )</span><br><span class="line">            index++;        </span><br><span class="line">        <span class="keyword">return</span> index &gt; before;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//scanInteger扫描有符号整数（可能有也可能没有正负号）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; (str[index] == <span class="string">&#x27;+&#x27;</span> || str[index] == <span class="string">&#x27;-&#x27;</span>)) </span><br><span class="line">            index++;       </span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始匹配整个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">boolean</span> res;</span><br><span class="line">               </span><br><span class="line">        <span class="comment">//首先匹配A</span></span><br><span class="line">        res = scanInteger(str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如存在小数点</span></span><br><span class="line">        <span class="comment">//如果是a.xx这种，则index停留在非数值处，不会进入小数点匹配</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; str[index]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            index++; <span class="comment">//匹配小数点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*+.5、5.、.5都是可行的，即 scanInteger.scanUnsignedInteger 即为合法</span></span><br><span class="line"><span class="comment">             ||只要满足第一个条件，后面的条件就不再判断</span></span><br><span class="line"><span class="comment">             若为 res || scanUnsignedInteger(str) 则只要scanInteger部分为true则不再判断，这不可行，因为要判断</span></span><br><span class="line"><span class="comment">             小数点后是否存在非数字，如1.a</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            res = scanUnsignedInteger(str) || res;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如存在科学计数法e或E</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; (str[index] == <span class="string">&#x27;e&#x27;</span> || str[index] == <span class="string">&#x27;E&#x27;</span>))&#123;</span><br><span class="line">            </span><br><span class="line">            index++;</span><br><span class="line">            res = res &amp;&amp; scanInteger(str) ; <span class="comment">//&amp;&amp;只要第一个条件不满足，后面条件就不再判断，这里相当于提前返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指针成功移动到末尾则表明符合判断</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        需要res，比如12e，当进入有e时执行scanInteger(str)会返回false，因为没有数字没有发生移动</span></span><br><span class="line"><span class="comment">        但此时指针依然指向最后一位，所以不能光靠是否移动到结尾判断</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> (index == str.length ) &amp;&amp; res == <span class="keyword">true</span> ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种解法为有限状态自动机，正则表达式的内部实现即为有限状态自动机，不用正则表达式则需手动实现各种状态的转换。</p>
<h3 id="扑克牌顺子">06 扑克牌顺子</h3>
<p><strong>题目描述</strong></p>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历数组的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(n\)</span>)： 使用<span class="math inline">\(O(n)\)</span>额外空间，额外使用数据结构HashSet来保证无重复。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/2.png" style="zoom: 67%;"></p>
<p>顺子即不能出现重复的数字，并且顺子中最大值减去最小值的差距小于5。</p>
<p>Java中Set数据结构不允许出现重复元素，不保证集合中元素出现的顺序。</p>
<p>Set是一个接口，实例化Set可以采用HashSet， HashSet类按照哈希算法来存取集合中的对象，存取速度比较快 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先判断元素个数</span></span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length != <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用集合去重</span></span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">14</span>; <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//跳过0，因为0可以重复</span></span><br><span class="line">            min = Math.min(min, numbers[i]);</span><br><span class="line">            max = Math.max(max, numbers[i]);</span><br><span class="line">            <span class="keyword">if</span>(res.contains(numbers[i])) <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            res.add(numbers[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用空间复杂度低，时间复杂度高的方法，就是先排序，然后遍历数组的同时判断是否有重复，并记录最大最小值。</p>
<h3 id="把字符串转换成整数">07 把字符串转换成整数</h3>
<p><strong>题目描述</strong></p>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历字符串的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(n\)</span>)： 使用<span class="math inline">\(O(1)\)</span>额外空间，即结果处的整数。</p>
<p>首先是整数，因此不存在'.'和'E'、'e'等任何字符，只存在正负号这个特殊字符。</p>
<p>然后就是越界问题，整数的范围是<span class="math inline">\([-2^{31},2^{31}-1]\)</span>，即<span class="math inline">\([-2147483648,2147483647]\)</span>。整数最多只能是十位数，因此只需要判断每次转换一个数字时是否到达边界<span class="math inline">\(bndry = Integer.MAX\_VALUE /10 = 214748364\)</span>，以及该边界处的处理情况。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/3.png" style="zoom:67%;"></p>
<p>注意牛客网中超过该范围时返回的时非法情况，leetcode中则返回最大最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理符号</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">true</span>; <span class="comment">//表示正数</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            index++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            sign = <span class="keyword">false</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历字符串判断边界</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bndry = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt; str.length(); index++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//不是数字立刻返回</span></span><br><span class="line">            <span class="keyword">char</span> ca = str.charAt(index);</span><br><span class="line">            <span class="keyword">if</span>(ca &gt; <span class="string">&#x27;9&#x27;</span> || ca &lt; <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	判断加入该数后是否越界，越界则直接返回 </span></span><br><span class="line"><span class="comment">            	现在是214748364x，判断x，整数位数最多十位，因此在这里就要返回</span></span><br><span class="line"><span class="comment">            	若是 214748363 38，则此刻 res == 214748363 3依然超过bndry，可直接返回</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; bndry) <span class="comment">//这里其实有两种情况，一种是res的长度刚好是9位，另一种刚好是10位，然后判断下一位数字，10位时直接越界，因为还存在第11位</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( res == bndry)&#123;                </span><br><span class="line">                <span class="keyword">if</span>(sign)&#123;<span class="comment">//如果是正数越界直接返回,否则加入该数，到字符串尾部了就会跳出循环，否则下一轮res &gt; bndry越界</span></span><br><span class="line">                    <span class="keyword">if</span>( ca &gt; <span class="string">&#x27;7&#x27;</span> ) <span class="keyword">return</span>  <span class="number">0</span> ;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果是负数</span></span><br><span class="line">                    <span class="keyword">if</span>( ca &gt; <span class="string">&#x27;8&#x27;</span> ) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                            </span><br><span class="line">            <span class="comment">//加入该数</span></span><br><span class="line">            res = res * <span class="number">10</span> + (ca - <span class="string">&#x27;0&#x27;</span>);                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign == <span class="keyword">true</span> ? res : -res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串的排列-子串包含">08 字符串的排列 &amp; 子串包含</h3>
<p>题目描述</p>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;ab&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;ab&quot;,&quot;ba&quot;]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n!\)</span>)：比如3个字符的全排列有6种。 空间复杂度O(1)：原地交换。</p>
<p>字符串的全排列就是序列中的字符不断与后面的字符做交换，通过<strong>递归</strong>进行实现。字典序打印就是排列完成后进行排序即可。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/5.png" style="zoom:50%;"></p>
<p>注意到，假如当前元素和要交换的元素是重复元素时，不进行交换，来节省时间，除非是首个元素自己和自己交换。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/6.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局结果</span></span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> [] cha = str.toCharArray();</span><br><span class="line">        recurPermu(cha, <span class="number">0</span>);       </span><br><span class="line">        Collections.sort(res);<span class="comment">//注意这个sort是不返回东西的</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurPermu</span><span class="params">(<span class="keyword">char</span> [] cha, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(index == cha.length - <span class="number">1</span>) <span class="comment">//只剩最后一个char，不用交换</span></span><br><span class="line">            res.add(<span class="keyword">new</span> String(cha));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; cha.length; i++)&#123; <span class="comment">//将首个char和后面所有元素交换</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                cha[index] != cha[i] 防止重复元素交换浪费时间</span></span><br><span class="line"><span class="comment">                index == i 数组中首个元素必须能够进入进行递归</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span>( cha[index] != cha[i] || index == i  )&#123;</span><br><span class="line">                    swap(cha, index, i);</span><br><span class="line">                    recurPermu(cha, index+<span class="number">1</span>); <span class="comment">//将位置往后移动一个，进行递归交换</span></span><br><span class="line">                    swap(cha, index, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> [] cha, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = cha[i];</span><br><span class="line">        cha[i] = cha[j];</span><br><span class="line">        cha[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目描述</strong></p>
<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>
<p>示例1:</p>
<p>输入: s1 = "ab" s2 = "eidbaooo" 输出: True 解释: s2 包含 s1 的排列之一 ("ba").</p>
<p>注意：</p>
<p>输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(l_1 + 26*(l_2 - l1)\)</span>)： <span class="math inline">\(l_1、l_2\)</span>均为字符串长度，即初始化时间+遍历<span class="math inline">\(l_2\)</span>并判断的时间。 空间复杂度 O(<span class="math inline">\(1\)</span>)： 使用O<span class="math inline">\((1)\)</span>常数级额外空间，因为只有26个字符。</p>
<p>滑动窗口解法。</p>
<p>将排列转换为比较字母出现的次数是否相同。</p>
<p>求s2中是否存在s1的全排列，即窗口大小为s1的长度，在这个窗口长度内，两个字符串是否存在所有字母个数一一对应。</p>
<p>字母从a-z，所以可以使用两个长度为26的int数组来表示出现的个数，即哈希表的长度可以仅维持在26，并且滑动窗口始终维护同一个哈希表，而不是每次移动都要建立一个新的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//因为字符串都是a-z的字母，所以我们可以使用一个长度为26的int数组来存储每个字母出现的个数</span></span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//s2map实际上代表了字符串s2在窗口内所有字母的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="comment">//窗口大小为s1.length，索引从[0 —— s1.length-1]到[s2.length-s1.length —— s2.length-1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果匹配，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果不匹配，窗口向后移动一位</span></span><br><span class="line">            <span class="comment">//窗口加入下一个字母</span></span><br><span class="line">            s2map[s2.charAt(i + s1.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="comment">//窗口移除第一个字母</span></span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matches(s1map, s2map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配">09 正则表达式匹配</h3>
<p><strong>题目描述</strong></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</p>
<p>'.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(mn\)</span>)： 遍历两个字符串的复杂度。 空间复杂度 O(<span class="math inline">\(mn\)</span>)： dp数组的空间。</p>
<p>字符串匹配的题目可以使用动态规划的解法。</p>
<p>s表示string，p表示pattern。</p>
<p><span class="math inline">\(dp[i][j]\)</span> 表示字符串中s中的前i个字符与字符串p中的前j个字符是否能够匹配。因此当p[i-1]和s[i-1]能够发生匹配时，需要判断它们的状态从哪里转移过来，如果不能匹配则直接为false状态。以下情况都是发生匹配时的状态转移，这里假设数组的下标从1开始：</p>
<ul>
<li><p>当 s[i] == p[j] 或 p[j] == '.'时</p>
<p><span class="math inline">\(dp[i][j] = dp[i-1][j-1]\)</span>。</p>
<p>即包括当前两个字符的前i个字符和前j个字符的整个字符串的匹配状态，由前 i-1 个字符和 s 前 j-1 个字符的匹配状态决定，能匹配就匹配，不能匹配就不匹配。</p></li>
<li><p>p[j] == '*'时，有两种情况。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/4.png" style="zoom: 50%;"></p>
<ul>
<li><p>s[i] == p[j-1]（p[j-1] == '.'）</p>
<p>即'*'之前的字符能和当前string中的字符发生匹配。</p>
<p><span class="math inline">\(dp[i][j] = dp[i-1][j]\)</span>。</p>
<p>也是就相当于看string前一个字符和当前pattern中'*'的状态。（这个状态在确认的时候会检查条件s[i-1]和p[j-1]，如此递归下去。）</p>
<p>即使能发生匹配，也可以不使用这个匹配。（因为'*'表明可以是0次）</p>
<p><span class="math inline">\(dp[i][j] = dp[i][j-2]\)</span>。</p>
<p>直接删除'*'及其前一个字符，并检查s[i]和p[j-2]时的匹配情况。</p></li>
<li><p>s[i] != p[j-1]</p>
<p>即'*'之前的字符不能和当前string中的字符发生匹配。</p>
<p><span class="math inline">\(dp[i][j] = dp[i][j-2]\)</span>。</p>
<p>直接删除'*'及其前一个字符，并检查s[i]和p[j-2]时的匹配情况。</p></li>
</ul></li>
</ul>
<p>注意初始化的时候，当string为''时，pattern为'.*'也是可以匹配的，因为'*'可以表示不取。所以此时要单独初始化dp数组中的第一行，初始化的准则是，当dp数组第一行奇数位不管什么字符都是false（包括.，因为.指的是任意字符，必须存在），dp数组中偶数位为* 时则: dp[0][i] = dp[0][i - 2]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s_len = str.length;</span><br><span class="line">        <span class="keyword">int</span> p_len = pattern.length;</span><br><span class="line">        <span class="keyword">boolean</span> [][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s_len+<span class="number">1</span>][p_len+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化动态规划数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理 i = 0， j的情况，即string是空字符，pattern不为空</span></span><br><span class="line">        <span class="comment">//dp数组中奇数位不管什么字符都是false（包括.，因为.指的是任意字符，必须存在），dp数组中偶数位为* 时则: dp[0][i] = dp[0][i - 2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; p_len + <span class="number">1</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( pattern[i-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//双层循环遍历两个字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s_len+<span class="number">1</span>; i++ )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p_len + <span class="number">1</span>; j++ )&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(str[i-<span class="number">1</span>] == pattern[j-<span class="number">1</span>] || pattern[j-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(pattern[j-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;                    </span><br><span class="line">                    <span class="keyword">if</span>(str[i-<span class="number">1</span>] == pattern[j-<span class="number">2</span>] || pattern[j-<span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>];                                                            </span><br><span class="line">                &#125;</span><br><span class="line">                               </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直接返回最后一个位置的情况</span></span><br><span class="line">        <span class="keyword">return</span> dp[s_len][p_len];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>左旋转字符串：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/</p>
<p>字符流中第一个不重复的字符：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/mian-shi-ti-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-3/</p>
<p>替换空格：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/</p>
<p>表示数值的字符串：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/zui-jian-dan-si-lu-xiang-xi-zhu-shi-zheng-shu-xiao/</p>
<p>扑克牌顺子：https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solution/mian-shi-ti-61-bu-ke-pai-zhong-de-shun-zi-ji-he-se/</p>
<p>把字符串转为整数：https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/mian-shi-ti-67-ba-zi-fu-chuan-zhuan-huan-cheng-z-4/</p>
<p>字符串的排列 &amp; 字串：https://leetcode-cn.com/problems/permutation-in-string</p>
<p>https://leetcode-cn.com/problems/permutation-in-string/solution/hua-dong-chuang-kou-by-mu-da-bai-yi-ndu7/</p>
<p>https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/</p>
<p>正则表达式匹配：https://leetcode-cn.com/problems/regular-expression-matching/solution/10-zheng-ze-biao-da-shi-pi-pei-by-ming-zhi-shan-yo/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 数学</title>
    <url>/2021/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p>剑指Offer中关于数学的题目解析。</p>
<a id="more"></a>
<h3 id="求123...n">01 求1+2+3+...+n</h3>
<p><strong>题目描述</strong></p>
<p>求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(n​)：需要开启n个递归函数</p>
<p>空间复杂度O(n)：递归深度达到n</p>
<p>传统的递归操作为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//结束条件</span></span><br><span class="line">          <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//返回</span></span><br><span class="line">          <span class="keyword">return</span> sumNums(n-<span class="number">1</span>) + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由题目可知不能使用if语句，为了使得递归有终结，需要进行判断，则联想到判断语句的等价代替，即逻辑操作符与或非，因为它们也能进行判断。采用逻辑符短路操作，可以在第一个条件为false时，不再执行后面的语句，即不再向下递归。</p>
<p>A &amp;&amp; B 若A == false，则不执行B</p>
<p>A || B 若A == true，则不执行B</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//递归部分只负责返回加数，由全局变量记录加和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当 n = 1 时，由于逻辑符短路操作，则不再继续递归</span></span><br><span class="line">        <span class="keyword">boolean</span> x = (n&gt;<span class="number">1</span>) &amp;&amp; ( Sum_Solution(n-<span class="number">1</span>) &gt; <span class="number">0</span> ); </span><br><span class="line">        </span><br><span class="line">        sum = sum + n;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不用加减乘除做加法">02 不用加减乘除做加法</h3>
<p><strong>题目描述</strong></p>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(1​)：最差情况下需要循环32 次</p>
<p>空间复杂度O(1)：使用常数大小额外空间</p>
<p>不是四则运算就是二进制运算，则显然此处使用二进制运算。</p>
<p>例如：</p>
<p>12的二进制：1100 15的二进制：1111</p>
<p>1.各位置上的数字分别相加先不管进位的问题：</p>
<blockquote>
<p>1100 + 1111 = 0011 得到临时二进制结果：0011</p>
</blockquote>
<p>2.计算进位的数字（两者同时为1的位置才会进位1）：</p>
<blockquote>
<p>0100 + 0100 = 1000 1000 + 1000= 10000 得到进位结果：10000+1000=11000</p>
</blockquote>
<p>3.将进位和临时结果相加得到结果</p>
<blockquote>
<p>0011 + 11000 = 11011（十进制：27）</p>
</blockquote>
<p>第一步中<strong>不进位的加法通过异或实现</strong>（相同为0，不同为1，刚好满足）：a^b = 1100 ^ 1111 = 0011</p>
<p>第二步中<strong>进位的加法通过与操作实现</strong>，并在最低位补充0，即<strong>左移1位</strong>：(a&amp;b) &lt;&lt; 1 = (1100&amp;1111)&lt;&lt;1 = 1100&lt;&lt;1 = 11000</p>
<p>第三步，两个结果相加就是重复第一步、第二步。即 1100 + 1111 = 0011 + 11000。再次对0011和11000通过不进位加法和进位加法进行变化，直到进位加法为0 。</p>
<p>为什么不断变化之后，进位会变成0呢？因为不断变化时会进行a&amp;b操作，并且左移，左移在低位补充0，当a和b有1的位置完全错开时，整个计算结果就会变成0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = num1^num2; <span class="comment">//存储非进位和</span></span><br><span class="line">        <span class="keyword">int</span> b = (num1&amp;num2)&lt;&lt;<span class="number">1</span>; <span class="comment">//存储进位和</span></span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = a;</span><br><span class="line">            a = a^b;</span><br><span class="line">            b = (tmp&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二进制中1的个数">03 二进制中1的个数</h3>
<p><strong>题目描述</strong></p>
<p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(log_2n\)</span>)：基本运算的复杂度均为O(1)，逐个位数判断需要经历<span class="math inline">\(log_2n\)</span>次，<span class="math inline">\(n\)</span>表示这个十进制数，<span class="math inline">\(log_2n\)</span>即表示最高位是1时究竟有几位数。（如<span class="math inline">\(log_24=2，log_216=4\)</span>，即4的二进制是2位，16的二进制为4位）</p>
<p>空间复杂度O(1)：使用常数大小额外空间</p>
<p>Java中，与运算<strong>&amp;将两边的数转换为二进制位</strong>，然后运算最终值。</p>
<p>可以<strong>循环判断</strong> ：</p>
<ol type="1">
<li>判断 n 最右一位是否为 1（通过与运算） ，根据结果计数。</li>
<li>将 n 右移一位（本题要求把数字 n 看作无符号数，因此使用 <strong>无符号右移 &gt;&gt;</strong> 操作）。</li>
</ol>
<p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E5%AD%A6/Users\lenovo\0.png" style="zoom: 50%;"></p>
<p>时间复杂度O(<span class="math inline">\(logM\)</span>)：基本运算的复杂度均为O(1)，M表示该整数的二进制表示中1的个数。</p>
<p>空间复杂度O(1)：使用常数大小额外空间</p>
<p>巧用n&amp;(n-1)来不停地消去n的二进制表示中的1。</p>
<p>分析n以n-1两个数的差别，</p>
<ul>
<li>如果n != 0，那么其二进制位中至少有一个1</li>
<li>如果n的最低位是1（奇数），那么n-1正好把这个最低位的1变成0，其他位不变</li>
<li>如果n的最低位是0（偶数），那么假设其右起第一个1位于m位，即m位后面全是0，那么n-1的第m位由1变成0，而第m位后面的所有0均变成1（<strong>还原进位的操作</strong>），m位之前的所有位保持不变。</li>
</ul>
<p>当n&amp;(n-1)时，最右边的1即被消去变为0，其他位置的数值不变。</p>
<p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E5%AD%A6/Users\lenovo\1.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123; <span class="comment">//不为0的时候，二进制的表示中必定有一个位是1</span></span><br><span class="line">            res++;</span><br><span class="line">            n = n&amp;(n-<span class="number">1</span>); <span class="comment">//消去一个1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数值的整数次方">04 数值的整数次方</h3>
<p><strong>题目描述</strong></p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2,3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.00000</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(logn\)</span>)：将原本的<span class="math inline">\(n\)</span>次循环转换成二进制的位数<span class="math inline">\(logn\)</span></p>
<p>空间复杂度O(1)：使用常数大小额外空间</p>
<p>快速幂的二进制角度。设要求<span class="math inline">\(x^n\)</span>次方，例如<span class="math inline">\(2^3\)</span>。<span class="math inline">\(n\)</span>的二进制表示为<span class="math inline">\(b_m...b_2b_1\)</span>。</p>
<p><span class="math inline">\(n\)</span>由二进制转换为十进制可以表示为：<span class="math inline">\(n=1b_1+2b_2+4b_3+...2^{m-1}b_m\)</span>。其中每一项<span class="math inline">\(2^{m-1}b_m\)</span>可以看成是2的幂再乘上0或1。例如<span class="math inline">\(3\)</span>的二进制表示为<span class="math inline">\(11\)</span>，<span class="math inline">\(3 = 2^0\cdot 1 + 2^1\cdot 1\)</span>。</p>
<p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E5%AD%A6/Users\lenovo\2.png" style="zoom:67%;"></p>
<p><span class="math inline">\(x^n\)</span>可以表示为：<span class="math inline">\(x^{1b_1+2b_2+4b_3+...2^{m-1}b_m} = x^{1b_1}\cdot x^{2b_2}\cdot x^{4b_3}...\cdot x^{2^{m-1}b_m}\)</span>。这样原本暴力乘法需要将<span class="math inline">\(x\)</span>累计乘上<span class="math inline">\(n\)</span>次，<strong>现在将<span class="math inline">\(n\)</span>拆分成二进制的位数<span class="math inline">\(logn\)</span>，则只需要循环<span class="math inline">\(logn\)</span>次</strong>，每个循环中计算<span class="math inline">\(x = x^2\)</span>，然后根据<span class="math inline">\(b\)</span>是否为1决定能否将当前的项乘进答案，所以每个循环内最多计算两次乘法。例如<span class="math inline">\(2^3 = 2^{1\cdot1}\cdot2^{2\cdot1}\)</span>。</p>
<p>在Java中，通过<span class="math inline">\(n\&amp;1\)</span>操作可以判断<span class="math inline">\(n\)</span>的二进制的最右一位是否为1；通过<span class="math inline">\(n&gt;&gt;1\)</span>右移操作可以删除二进制表示中的最右一位。</p>
<p>则整个算法就是不断地判断<span class="math inline">\(n\)</span>的二进制表示位数中是否为1，如果是1则将当前<span class="math inline">\(x\)</span>的幂次方的结果乘进最终结果中。</p>
<p>注意如果<span class="math inline">\(n\)</span>为负数，则<span class="math inline">\(x^n = (\frac{1}{x})^{-n}\)</span>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断n为负数</span></span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            base = <span class="number">1</span> / base;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用与运算判断当前位数是1还是0，用右移删除二进制最末尾</span></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="comment">//当前n的二进制位数为1，可以乘进答案</span></span><br><span class="line">                res = res * base;</span><br><span class="line">            base = base * base;</span><br><span class="line">            exponent = exponent &gt;&gt; <span class="number">1</span>; <span class="comment">//用右移删除指数二进制最末尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(<span class="math inline">\(log_2n\)</span>)：二分的时间复杂度为对数级别</p>
<p>空间复杂度O(1)：使用常数大小额外空间</p>
<p>快速幂，从分治法角度理解。当<span class="math inline">\(n\)</span>为偶数时，<span class="math inline">\(x^n = (x^2)^{n/2}\)</span>；当<span class="math inline">\(n\)</span>为奇数时，<span class="math inline">\(x^n = (x^2)^{(n-1)/2}\cdot x\)</span>；<strong>快速幂的核心思想就是不断二分幂次项，每次二分幂次项（幂次项整除2）时，底数都变成原来的平方，遇到幂次项为奇数时就可以将底数乘进结果当中（偶数才能二分）</strong>，直到幂次项变成0为止（幂次项为1的时候一定会将底数乘进结果）。</p>
<p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E5%AD%A6/Users\lenovo\3.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*该代码与二进制角度完全相同！！！只是解释不同！*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断n为负数</span></span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            base = <span class="number">1</span> / base;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="comment">//用%判断幂次项为奇数，相当于判断二进制最右是否为1 </span></span><br><span class="line">                res = res * base;</span><br><span class="line">            </span><br><span class="line">            base = base * base; <span class="comment">//底数变为原来的平方</span></span><br><span class="line">            exponent = exponent &gt;&gt; <span class="number">1</span>; <span class="comment">//指数整除2，相当于右移1         </span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整数中1出现的次数">05 整数中1出现的次数</h3>
<p><strong>题目描述</strong></p>
<p>求出1<sub>13的整数中1出现的次数,并算出100</sub>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：只遍历每个位上的数字</p>
<p>空间复杂度O(1)：使用常数大小额外空间</p>
<p>注意题目中是1出现的次数，不是有1的数字是多少个，<strong>比如11中，1是出现了两次</strong>。</p>
<p>因此，给定一个数字，它的某一位上出现了1，即可计数1次。</p>
<p>LeetCode题目描述中写到要求时间复杂度为O(n)，所以想到能否遍历输入数字的每一位来得到答案。按照这个思路进行思考，发现了每一位可能为1的个数是有一定的规律，按照规律遍历该数上的每一位，将每一位上能取到的1的个数相加，即可得到最终结果。</p>
<p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E5%AD%A6/Users\lenovo\4.png" style="zoom: 40%;"></p>
<p>每一位上的数字有三种可能，每种选项对应规律为：</p>
<ul>
<li><p>当给出的n中某一位上的数字大于1时</p>
<p>如果倒数第x位上的数字大于1，则该位置上的数为1的情况有<span class="math inline">\((preNum+1)·(10^{x-1})\)</span>种，其中preNum为该位数字之后的所有数字所组成的数字。</p>
<p>比如n=3<strong>2</strong>514,正数第2位，也就是倒数第4位的数字为2，大于1，此时该位置为1的情况有4·1000种，即(01000~01999) + (11000~11999) + (21000~21999) + (31000~31999)。（可以看出当前位数之前的数取值为0-3，当前位数之后的取值为000-999，则组合起来就是4·1000种）</p>
<p>再如正数第1位，也就是倒数第5位的数字为3，大于1，此时该位置上为1的情况有(0+1)·10000种,即10000~19999。</p></li>
<li><p>当给出的n中某一位上的数字等于1时</p>
<p>如果倒数第x位上的数字等于1，则该位置上的数为1的情况有<span class="math inline">\(preNum·(10^{x-1})+postNum+1\)</span>种，其中postNum为该位数字之后的所有数字所组成的数字。</p>
<p>比如n=3<strong>1</strong>567，正数第2位，也就是倒数第4位的数字为1，此时该位置为1的情况有3·1000+568种，即(01000~01999) + (11000~11999) + (21000~21999) + (31000~31567)。（可以看出和大于1不同的地方在于，最后一次只能取到567，而非999）</p>
<p>再比如14，第一位上的数字等于1，该位上数字为1的可能的情况有5种，即10，11，12，13，14。</p></li>
<li><p>当给出的n中某一位上的数字等于0时</p>
<p>如果倒数第x位上的数字小于1，则该位置上的数为1的情况有<span class="math inline">\(preNum·(10^{x-1})\)</span>种。</p>
<p>比如n=30567，正数第2位，也就是倒数第4位的数字为0，此时该位置为1的情况有3·1000种，即(01000~01999) + (11000~11999) + (21000~21999)。</p></li>
</ul>
<p>digit从低位到高位分别是1、10、100等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从低位到高位，遍历每一位</span></span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>; <span class="comment">//记录当前是10的0次方，即最低位，不要用pow函数，因为其类型是double</span></span><br><span class="line">        <span class="keyword">int</span> pre = n / <span class="number">10</span>, cur = n % <span class="number">10</span>, post = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="number">0</span> || cur != <span class="number">0</span>)&#123; <span class="comment">//当两者都为0的时候，就没有多余的位了</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>)</span><br><span class="line">                res = res + pre*digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>)</span><br><span class="line">                res = res + pre*digit + post + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur &gt; <span class="number">1</span>)</span><br><span class="line">                res = res + (pre+<span class="number">1</span>)*digit;</span><br><span class="line">            </span><br><span class="line">            post = post + cur * digit; <span class="comment">//每次增加1位</span></span><br><span class="line">            cur = pre % <span class="number">10</span>; <span class="comment">//每次只有1位</span></span><br><span class="line">            pre = pre / <span class="number">10</span>; <span class="comment">//每次减少1位</span></span><br><span class="line">            digit =digit * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="丑数">06 丑数</h3>
<p>题目描述</p>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：求第n个丑数就要维护n个元素的数组</p>
<p>丑数的因子只有2、3、5,一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到。 因此维护一个数组，这个数组中的每个值都将乘上2、3、5,每次判断乘之后谁最小，最小的就加入这个数组。 设置三个指针分别指向该乘2、3、5的数，每次加入后将对应指针往后移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [] ugnums = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        ugnums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            tmp = Math.min(<span class="number">2</span>*ugnums[p2], Math.min(<span class="number">3</span>*ugnums[p3], <span class="number">5</span>*ugnums[p5]) );</span><br><span class="line">            ugnums[i] = tmp;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//为了防止重复需要三个if都能够走到！不能用if else if</span></span><br><span class="line">            <span class="comment">//比如6可以是2*3，也可以是3*2，这样6会加入两次</span></span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">2</span>*ugnums[p2]) p2++;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">3</span>*ugnums[p3]) p3++;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">5</span>*ugnums[p5]) p5++;</span><br><span class="line">            </span><br><span class="line">        &#125;                </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ugnums[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="圆圈中剩下的数字约瑟夫环">07 圆圈中剩下的数字（约瑟夫环）</h3>
<p><strong>题目描述</strong></p>
<p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>示例 1：</p>
<p>输入: n = 5, m = 3 输出: 3</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要循环n-1次找到结果</p>
<p>空间复杂度O(<span class="math inline">\(1\)</span>)：</p>
<p>题目本质上询问n个数组成一个环，每次从环中删除第m个元素，则最后剩余的数是哪个。令f(n,m)表示最后剩下数字的索引号，如下图所示进行模拟：</p>
<p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E5%AD%A6/Users\lenovo\5.png" style="zoom: 50%;"></p>
<p>可以采用反推的方式，由图可知，最后剩余的那个数，数组中只有1个元素，且该元素的下标为0，即f(1,3)=0（它在原本的数组中下标为f(8,3)=6）。则思考当数组元素增加一个时，它的下标变化为多少。</p>
<p>以n=7到n=8的时候举例，如下图所示：</p>
<p><img src="/2021/09/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E5%AD%A6/Users\lenovo\6.png" style="zoom:67%;"></p>
<p><strong>先把被删掉的数补充回来，然后右移m个数，发现溢出了，再把溢出的补充在最前面。</strong>（暗示删除其实是左移）</p>
<p>这样就能使得n=7的数组复原回n=8。这里，复原指代的是不仅增加了一个数，<strong>每个数字的数组下标也发生了改变</strong>。</p>
<p>因此，可以得到<strong>递推式</strong><span class="math inline">\(f(n,m)=[f(n−1,m)+m]\%n\)</span>。+m是还原取模是防止溢出。</p>
<p>注意，这里的f始终表示的是最后剩余的那个数，它的下标变化情况，因为只有它能够确定一开始是从0开始的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>; <span class="comment">//记录下标的变化，一开始为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123; <span class="comment">//从数组内只剩下两个数开始计算下标</span></span><br><span class="line">            f = (f+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f; <span class="comment">//这里表明下标为f的值存储数字f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题不可以用链表模拟的方法，因为从ArrayList中删除一个数的复杂度为O(n)，要删除n-1个数，复杂度变为O(<span class="math inline">\(n^2\)</span>)。</p>
<h3 id="剪绳子">08 剪绳子</h3>
<p>题目描述</p>
<p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：两重循环</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：需要辅助数组</p>
<p>实际上，就是将一个整数拆分，使得它的乘积最大。利用DP的思想。</p>
<p>定义f(n)表示整数n拆分之后的乘积最大值，则有<strong>递推式</strong>：</p>
<p><span class="math inline">\(f(n) = max( i*f(n-i),i*(n-i) ),\quad i = 1,2...n-1\)</span></p>
<p><span class="math inline">\(i*f(n-i)\)</span>表示<strong>将数字i从整数中拆分出来，并继续拆分n-i</strong>；<span class="math inline">\(i*(n-i)\)</span>就表示<strong>仅仅将当前长度分成两段，不再划分</strong>。</p>
<p>可以发现，i从1到n-1；</p>
<p>n从3开始到n（当长度为1时，不可分，当长度为2时，只能分成1和1，因此最大乘积为1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];<span class="comment">//动态规划数组</span></span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">3</span>; n &lt;= target; n++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">                dp[n] = Math.max( Math.max( i*dp[n-i], i*(n-i) ), dp[n] );</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>求1+2+3+...+n：https://leetcode-cn.com/problems/qiu-12n-lcof/solution/di-gui-jie-fa-ni-yi-ding-ke-yi-du-dong-b-vms4/</p>
<p>不用加减乘除做加法：https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/jin-zhi-tao-wa-ru-he-yong-wei-yun-suan-wan-cheng-j/</p>
<p>二进制中1的个数：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/</p>
<p>数值的整数次方：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</p>
<p>整数中1出现的次数：https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/jian-dan-yi-dong-zhao-gui-lu-by-zhige/</p>
<p>https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/</p>
<p>圆圈中剩下的数字（约瑟夫环）：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</p>
<p>剪绳子：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/jian-sheng-zi-dong-tai-gui-hua-by-97wgl/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 链表</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>剑指Offer中关于链表的题目解析。</p>
<a id="more"></a>
<h3 id="两个链表的第一个公共节点">01 两个链表的第一个公共节点</h3>
<p><strong>题目描述</strong></p>
<p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(m+n\)</span>)：m，n分别为链表A，B的长度，最坏情况下，公共结点为最后一个，需要遍历m+n个结点。 空间复杂度：O(1)。</p>
<p>公共节点，定义为两个链表从某一节点开始，他们的next都指向同一个节点。由于是单向链表的节点，每个节点只有一个next，因此从第一个公共节点开始，之后他们的所有节点都是重合的，不可能再出现分叉。</p>
<p>所以可以先遍历两个链表得到他们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，<strong>在较长的链表上先走若干步</strong>，接着同时在两个链表上遍历，找到的第一个相同的结点就是他们的第一个公共结点。</p>
<p>一个巧妙的实现方式为如果A指针把链表A走完了，然后再从链表B开始走到相遇点就相当于把这两个链表的所有节点都走了一遍，同理如果B指针把链表B走完了，然后再从链表A开始一直走到相遇点也相当于把这两个链表的所有节点都走完了。这样它们的长度就是一致的，且同时会在相遇点结束。本质上同上述方法一样，代码实现更简单。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/0.png" style="zoom: 90%;"></p>
<p>注意当两个链表没有公共节点时候的死循环问题。（第一种解法就不会存在）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //当他们指向空指针的时候，有两种情况。</span></span><br><span class="line"><span class="comment">            其一是某个指针先走完了，此时应该换一个链表走。（只有一个指向null）</span></span><br><span class="line"><span class="comment">            其二是两个指针都走完了，链表没有任何公共节点，都指向null，这时它们是相等的，可以退出循环。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(p1 != p2)&#123; </span><br><span class="line">                <span class="keyword">if</span>(p1 == <span class="keyword">null</span>) p1 = pHead2;</span><br><span class="line">                <span class="keyword">if</span>(p2 == <span class="keyword">null</span>) p2 = pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            也可以写成这样，这样就已经先判断p1 != p2 ，此时如果还等于null，则就可以交换链表继续遍历</span></span><br><span class="line"><span class="comment">            p1= p1!=null? p1.next:pHead2;</span></span><br><span class="line"><span class="comment">            p2= p2!=null? p2.next:pHead1;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p1; <span class="comment">//若不存在公共节点，则返回null</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表双指针">02 反转链表（双指针）</h3>
<p><strong>题目描述</strong></p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(1)：</p>
<p>使用三个指针来调整指针的位置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode left = <span class="keyword">null</span>;<span class="comment">//指向前一个节点</span></span><br><span class="line">        ListNode right = head;<span class="comment">//指向当前节点</span></span><br><span class="line">        ListNode tmp;<span class="comment">//记录当前节点下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123; <span class="comment">//注意这里是right ！= null 而不是 right.next != null</span></span><br><span class="line">            tmp = right.next;<span class="comment">//记录下一个节点位置</span></span><br><span class="line">            right.next = left;<span class="comment">//调整指向下一个位置的指针</span></span><br><span class="line">            left = right;</span><br><span class="line">            right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">//注意返回的是left节点，因为此时right为null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从尾到头打印链表递归">03 从尾到头打印链表（递归）</h3>
<p><strong>题目描述</strong></p>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;67,0,24,58&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[58,24,0,67]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(<span class="math inline">\(n\)</span>)：递归栈内同时存储所有节点</p>
<p>可以采用递归解法。</p>
<p>递归终止条件为：当node == null时，表明到达链表最底端，什么都不做直接返回。</p>
<p>如何递归：先递归到最底端，然后向 ArrayList 添加值，再一层层返回不断添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        recur(listNode);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;        </span><br><span class="line">        recur(node.next);        </span><br><span class="line">        res.add(node.val);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种更直接、简单的解法是反转链表，然后打印，这样空间复杂度是O(1)，因为栈内不需要存储递归结果。但是这样的缺点就是会改变原来的链表状态，不符合某些题意。</p>
<h3 id="删除链表中重复的结点虚拟头">04 删除链表中重复的结点（虚拟头）</h3>
<p><strong>题目描述</strong></p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,3,4,4,5&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,5&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(<span class="math inline">\(1\)</span>)：不使用额外存储空间</p>
<p>双指针解法。首先创建一个<strong>虚拟的头节点</strong>。</p>
<p>left指向当前节点，right不停判断和right.next是否相等，并作出反应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建虚拟头节点</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        vhead.next = pHead;</span><br><span class="line">        </span><br><span class="line">        ListNode left = vhead;</span><br><span class="line">        ListNode right = vhead.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//处理right处有重复值的情况</span></span><br><span class="line">            <span class="keyword">if</span>(right.next != <span class="keyword">null</span> &amp;&amp; right.val == right.next.val)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(right.next != <span class="keyword">null</span> &amp;&amp; right.val == right.next.val) right = right.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">                left.next = right;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = left.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vhead.next; <span class="comment">//为null则说明链表中节点全部重复</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个排序链表虚拟头递归">05 合并两个排序链表（虚拟头|递归）</h3>
<p><strong>题目描述</strong></p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,3,5&#125;,&#123;2,4,6&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(m+n\)</span>)：分别遍历两个链表 空间复杂度O(<span class="math inline">\(1\)</span>)：不使用额外存储空间</p>
<p>一个直观的方法就是建立一个虚拟头节点，然后分别遍历两个链表加入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//新建虚拟头</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode res = vhead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当两个链表都没有到末尾</span></span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val )&#123;</span><br><span class="line">                vhead.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                vhead.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            vhead = vhead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将还有剩的链表直接赋值</span></span><br><span class="line">        vhead.next = list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(<span class="math inline">\(m+n\)</span>)：</p>
<p><span class="math inline">\(m、n\)</span>为两个链表的元素个数。递归函数每次去掉一个元素，直到两个链表都为空，因此需要调用 <span class="math inline">\(R=O(m + n)\)</span> 次。而在递归函数中我们只进行了 next 指针的赋值操作，复杂度为 <span class="math inline">\(\mathcal{O}(1)\)</span>，故递归的总时间复杂度为 <span class="math inline">\({\mathcal{O}(T) = R * \mathcal{O}(1)}={\mathcal{O}}(m + n)\)</span>。</p>
<p>空间复杂度O(<span class="math inline">\(m+n\)</span>)：</p>
<p>对于递归调用，当它遇到终止条件准备回溯时，已经递归调用了 m+n 次，使用了 m+n 个栈帧，故最后的空间复杂度为 <span class="math inline">\({\mathcal{O}}(m + n)\)</span>。</p>
<p>递归法。</p>
<p>递归的终止条件是：当两个链表都为空时，表示对链表已合并完成。</p>
<p>递归的过程是：判断 <code>l1</code> 和 <code>l2</code> 头结点哪个更小，然后较小结点的 <code>next</code> 指针指向<strong>其余结点的合并结果。（调用递归）</strong></p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/1.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">            list1.next = Merge(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1; <span class="comment">//注意这里要return给上一轮提供结果！</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2; <span class="comment">//注意这里要return给上一轮提供结果！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中倒数第k个结点快慢">06 链表中倒数第k个结点（快慢）</h3>
<p><strong>题目描述</strong></p>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,&#123;1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;5&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(<span class="math inline">\(1\)</span>)：不使用额外存储空间</p>
<p>快慢指针解法。先让快指针走k步，然后快慢指针同时走1步，当快指针达到终点null时，慢指针刚好指向该数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ListNode slow, fast = head; 这样写会导致slow没赋值</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先让快指针多走k</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span>) <span class="comment">//提前达到null说明链表不足k</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;            </span><br><span class="line">            fast = fast.next; <span class="comment">//刚好在第k步时走到null是不会有影响的</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//快慢各走1</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回慢指针</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中环的入口结点快慢">07 链表中环的入口结点（快慢）</h3>
<p><strong>题目描述</strong></p>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：线性复杂度，快慢指针走的步数与链表的长度有关 空间复杂度O(<span class="math inline">\(1\)</span>)：使用常数的额外空间</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/2.png" style="zoom: 50%;"></p>
<p>1、双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；</p>
<ul>
<li><p>第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；</p></li>
<li><p>第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：设链表共有 <code>a+b</code> 个节点，其中链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4, b=5）；设两指针分别走了 f，s 步，则有： <strong>fast 走的步数是slow步数的 2 倍，即 f = 2s；</strong>（解析： fast 每轮走 2 步） <strong>fast 比 slow多走了 n 个环的长度，即 f = s + nb；</strong>（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）； <strong>以上两式相减得：f = 2nb，s = nb，即fast和slow 指针分别走了 2n，n 个 环的周长</strong>（注意： n 是未知数，不同链表的情况不同）。</p></li>
</ul>
<p>2、目前情况分析：</p>
<ul>
<li>如果让指针从链表头部一直向前走并统计步数k，那么<strong>所有 走到链表入口节点时的步数 是：<code>k=a+nb</code></strong>（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。</li>
<li>而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。</li>
<li>但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。</li>
</ul>
<p>3、双指针第二次相遇：</p>
<ul>
<li>slow指针位置不变 ，将fast指针重新指向链表头部节点 ；slow和fast同时每轮向前走 1 步；此时 f = 0，s = nb ；</li>
<li>当 fast 指针走到f = a步时，slow 指针走到步s = a+nb，<strong>此时 两指针重合，并同时指向链表环入口</strong> 。</li>
</ul>
<p>4、返回slow指针指向的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode slow = pHead, fast = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)</span><br><span class="line">                fast = fast.next.next; <span class="comment">//走两步</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//没有环</span></span><br><span class="line">            &#125;            </span><br><span class="line">            slow = slow.next;                </span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast); <span class="comment">//先执行一次后判断，因为刚开始时是相等的</span></span><br><span class="line">        </span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂链表的复制">08 复杂链表的复制</h3>
<p>题目描述</p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：两次遍历链表进行复制 空间复杂度O(<span class="math inline">\(n\)</span>)：使用额外存储空间HashMap存储所有节点</p>
<p>使用哈希表，key是原链表中的元素，value是新链表中的new 出来的元素，key-value对中的node.val是相同的。</p>
<p>第一次遍历，构建这个哈希表。第二次遍历，构建新链表中的random指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashMap&lt; RandomListNode, RandomListNode&gt; hm = <span class="keyword">new</span> HashMap&lt; RandomListNode, RandomListNode&gt;();</span><br><span class="line">        </span><br><span class="line">        RandomListNode tmp = pHead;</span><br><span class="line">        <span class="comment">//第一次遍历</span></span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            hm.put( tmp, <span class="keyword">new</span> RandomListNode(tmp.label));</span><br><span class="line">            tmp =tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二次遍历</span></span><br><span class="line">        tmp = pHead;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//分别构建新链表中每个元素的next和random，注意为null的情况</span></span><br><span class="line">            hm.get(tmp).next = tmp.next == <span class="keyword">null</span>? <span class="keyword">null</span> : hm.get(tmp.next);</span><br><span class="line">            hm.get(tmp).random = tmp.random == <span class="keyword">null</span>? <span class="keyword">null</span> : hm.get(tmp.random);</span><br><span class="line">            tmp =tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hm.get(pHead);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种解法是构建，原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。最后将其拆开即可，这样空间复杂度为O(1)，因为不会使用额外的空间HashMap。</p>
<h3 id="题解来源">题解来源</h3>
<p>两个链表的第一个公共节点：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/ji-he-shuang-zhi-zhen-deng-3chong-jie-jue-fang-shi/</p>
<p>https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tab=answerKey</p>
<p>合并两个排序链表：https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/</p>
<p>环形链表：https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/</p>
<p>复杂链表的复制：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>可以按照复杂度将排序算法进行分类。<span class="math inline">\(O(nlogn)\)</span>：快速排序、归并排序、堆排序；<span class="math inline">\(O(n^2)\)</span> ：冒泡排序、简单选择排序、直接插入排序、希尔排序；<span class="math inline">\(O(n)\)</span>：计数排序、桶排序、基数排序。</p>
<a id="more"></a>
<h3 id="onlogn"><span class="math inline">\(O(nlogn)\)</span></h3>
<h4 id="快速排序">快速排序</h4>
<p>通过一趟排序将数值分隔成独立的两部分，其中一部分均比另一部分小，然后再分别对这两部分记录继续进行排序，以达到整个序列有序。改进方法之一是</p>
<ul>
<li><p>时间复杂度。</p>
<p>最优的情况下时间复杂度为<span class="math inline">\(O( nlogn )\)</span>：主元每次都刚好平分整个数组。</p>
<p>最差的情况下时间复杂度为<span class="math inline">\(O( n^2 )\)</span>：主元每次就是数组中最小/最大的，即冒泡排序。每一次都排好一个元素的顺序)</p></li>
<li><p>空间复杂度。</p>
<p>首先就地快速排序使用的空间是<span class="math inline">\(O(1)\)</span>的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据。</p>
<p>最优的情况下空间复杂度为：<span class="math inline">\(O(logn)\)</span>；每一次都平分数组的情况。</p>
<p>最差的情况下空间复杂度为：<span class="math inline">\(O( n )\)</span> ；退化为冒泡排序的情况。</p></li>
</ul>
<p>递归算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[low];</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[low] = arr[i];</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i的位置就是主元的位置</span></span><br><span class="line"></span><br><span class="line">    quickSort(arr, low, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>非递归 使用栈来实现，通过不断将left和right压入栈中，模拟递归的操作。双指针法部分不需要发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;;</span><br><span class="line">    </span><br><span class="line">    stack.push(left);</span><br><span class="line">    stack.push(right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        right = stakc.pop();</span><br><span class="line">        left = stack.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = partition(array, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &lt; pivot - <span class="number">1</span>)&#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">            stack.push(pivot - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &gt; pivot + <span class="number">1</span>)&#123;</span><br><span class="line">            stack.push(pivot+<span class="number">1</span>);</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序">归并排序</h4>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/0.png" style="zoom:67%;"></p>
<p>将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<ul>
<li><p>时间复杂度</p>
<p>归并排序平均时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最好时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> [] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        MergeSort(arr, low, mid);<span class="comment">//对左边排序</span></span><br><span class="line">        MergeSort(arr, mid+<span class="number">1</span>, high);<span class="comment">//对右边排序</span></span><br><span class="line"></span><br><span class="line">        merge(arr, low, high); <span class="comment">// 合并两个有序数组</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂存数组</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low +<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[j])&#123;</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制剩余的，注意是while！！</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) tmp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; tmp.length; l++)&#123;</span><br><span class="line">        arr[low+l] = tmp[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归 实际上就是每次将2个长度为k的子序列合并为1个。k从1开始，每次递增2倍，直到k超过数组长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k &lt; len)&#123;</span><br><span class="line">        <span class="comment">//每次将2个长度为k的子序列合并为1个</span></span><br><span class="line">        MergePass(array, k, len);</span><br><span class="line">        k = k*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次将2个长度为k的子序列合并为1个</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= len - <span class="number">2</span>*k; i = i + <span class="number">2</span>*k )&#123;</span><br><span class="line">        merge(array, i, i+ <span class="number">2</span>*k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果落单的元素数目超过k，但又不到2k，也是可以两两合并的</span></span><br><span class="line">    <span class="comment">//如果落单的元素数目不超过k，则已经有序</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; n - k)</span><br><span class="line">    &#123;</span><br><span class="line">        merge(array, i, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>]; <span class="comment">//新建一个数组用来暂存</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = (low+high)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//二路归并</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= (low+high)/<span class="number">2</span> || j &lt;= high )&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; array[j])&#123;</span><br><span class="line">            tmp[k] = array[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k] = array[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩余拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= (low+high)/<span class="number">2</span>) tmp[k++] = array[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) tmp[k++] = array[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; tmp.length; l++ )&#123;</span><br><span class="line">        array[low + l] = tmp[l];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序">堆排序</h4>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/1.png" style="zoom: 50%;"></p>
<p>堆，就是一个普通的二叉树，只不过它需要满足的条件是左右子节点都要大于或小于父节点，它复杂度不变的原因就在于它不会像二叉搜索树那样要求左小右大，且它能够调整元素位置，因此不会退化为链表。</p>
<ul>
<li><p>时间复杂度</p>
<p>堆排序平均时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最好时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。 堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树（不会退化为链表）的可以得出它在任何情况下时间复杂度均是<span class="math inline">\(O(nlogn)\)</span>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len;<span class="comment">//表示数组中堆的有效范围</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建最小堆</span></span><br><span class="line">    buildHeap(array);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不断地缩小</span></span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">//交换堆顶和最后一个元素，</span></span><br><span class="line">        <span class="keyword">int</span> tmp = array[len];</span><br><span class="line">        array[len] = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//缩短堆的范围</span></span><br><span class="line">        len--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从堆顶开始向下调整</span></span><br><span class="line">        adjustHeap(<span class="keyword">int</span>[] array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最终得到的结果是一个降序排列的数组！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断本节点，与左右子节点谁小，将小的交换到父节点位置，递归往下调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leastIndex = parent; <span class="comment">//记录最小值的下标</span></span><br><span class="line">    <span class="keyword">int</span> left = parrent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = parrent*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有左孩子，且小于父节点</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; len &amp;&amp; array[left] &lt; array[parent])</span><br><span class="line">        leastIndex = left;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; len &amp;&amp; array[right] &lt; array[parent])</span><br><span class="line">        leastIndex = right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="keyword">if</span>(leastIndex != parent)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tmp = array[parent];</span><br><span class="line">        array[parent] = array[leastIndex];</span><br><span class="line">        array[leastIndex] = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//继续往下调整</span></span><br><span class="line">        adjustHeap(array, leastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上构建最小堆，从第一个非叶子节点开始往上逐步调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        adjustHeap(array, i);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="on2"><span class="math inline">\(O(n^2)\)</span></h3>
<h4 id="冒泡排序">冒泡排序</h4>
<p>比较相邻的元素。如果前一个比后一个大，就交换它们两个；</p>
<ul>
<li><p>时间复杂度</p>
<p>冒泡排序平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最好时间复杂度为<span class="math inline">\(O(n)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p></li>
</ul>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/4.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BubbleSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示比较次数，实际上就已经是n-1趟</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> swap = <span class="keyword">false</span>; <span class="comment">//不再发生交换就可以退出        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123; <span class="comment">//注意-1-i</span></span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                 <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                 array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                 array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                 swap = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!swap)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单选择排序">简单选择排序</h4>
<p>每次都选择最大或最小的元素和起始位置交换</p>
<ul>
<li><p>时间复杂度</p>
<p>简单选择排序平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最好时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> minIndex = i;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length; j++)&#123; <span class="comment">//找到最小的元素</span></span><br><span class="line">             <span class="keyword">if</span>(array[j] &lt; array[minIndex])</span><br><span class="line">                 minIndex = j;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//和序列头部交换</span></span><br><span class="line">         <span class="keyword">int</span> tmp = array[i];</span><br><span class="line">         array[i] = array[minIndex];</span><br><span class="line">         array[minIndex] = array[i];</span><br><span class="line">         </span><br><span class="line">     &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="直接插入排序">直接插入排序</h4>
<p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。（从后往前）注意直接插入排序能够保持元素的相对顺序。</p>
<ul>
<li><p>时间复杂度</p>
<p>直接插入排序平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最好时间复杂度为<span class="math inline">\(O(n)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p></li>
</ul>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/3.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> current = array[i];<span class="comment">//未排序元素下标</span></span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;<span class="comment">//已经排序的元素下标</span></span><br><span class="line">       <span class="keyword">while</span>( preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; current)&#123; <span class="comment">//从小到大排序</span></span><br><span class="line">           array[preIndex+<span class="number">1</span>] = array[preIndex];</span><br><span class="line">           preIndex--;</span><br><span class="line">       &#125; </span><br><span class="line">        </span><br><span class="line">        array[preIndex + <span class="number">1</span>] = current; <span class="comment">//找到合适的位置插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array; <span class="comment">//改进方法是在有序区内使用二分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序onlogn">希尔排序(<span class="math inline">\(O(nlogn)\)</span>)</h4>
<p>直接插入排序的改进版，整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成），对子序列分别进行直接插入排序，然后缩减增量为之前的一半再进行排序。gap初始值一般取 len / 2。</p>
<ul>
<li><p>时间复杂度</p>
<p>希尔排序平均时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最好时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。</p></li>
</ul>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/2.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> gap = array.length / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; array.length; i++)</span><br><span class="line">            <span class="keyword">int</span> current = array[i];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; current)&#123;</span><br><span class="line">                array[preIndex + gap] = array[preIndex];</span><br><span class="line">                preIndex = preIndex - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            array[preIndex + gap] = current; <span class="comment">// 插入元素</span></span><br><span class="line">        &#125;        </span><br><span class="line">        gap = gap / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="on"><span class="math inline">\(O(n)\)</span></h3>
<h4 id="计数排序">计数排序</h4>
<p>将数值转化为键存储在额外的有序空间中，并统计各个元素出现多少次。</p>
<ul>
<li><p>时间复杂度</p>
<p>计数排序平均时间复杂度为<span class="math inline">\(O(n + k)\)</span>，最好时间复杂度为<span class="math inline">\(O(n + k)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n + k)\)</span>。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。</p></li>
<li><p>空间复杂度</p>
<p>计数排序空间复杂度为<span class="math inline">\(O(k)\)</span>，k为桶数组的长度。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span> [] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计最大值和最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; min)</span><br><span class="line">            min = array[i];</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; max)</span><br><span class="line">            max = array[i];    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用偏移量进行计数</span></span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length; i++)        </span><br><span class="line">        bucket[ array[i] - min ]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a_index = <span class="number">0</span>, b_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a_index &lt; array.length)&#123;</span><br><span class="line">        <span class="comment">//如果桶不是空的</span></span><br><span class="line">        <span class="keyword">if</span>(bucket[b_index] != <span class="number">0</span>)&#123;</span><br><span class="line">            array[a_index] = min+b_index;<span class="comment">//数组当前位置有值</span></span><br><span class="line">            bucket[b_index]--;</span><br><span class="line">            a_index++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b_index++;<span class="comment">//移动桶的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="桶排序">桶排序</h4>
<p>桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。</p>
<p>桶排序每个桶存储一定范围的元素，通过映射函数，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序，最后将非空桶中的元素逐个放入原序列中。</p>
<p>桶排序平均时间复杂度为O(n + k)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算最大值与最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算桶的数量</span></span><br><span class="line">    <span class="comment">// 桶排序需要尽量保证元素分散均匀，否则当所有数据集中在同一个桶中时，桶排序失效</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min) / (arr.length); <span class="comment">//根据商来计算桶号，而不是余数！</span></span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将桶中的元素赋值到原序列</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)&#123;</span><br><span class="line">			arr[index++] = bucketArr.get(i).get(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基数排序-radix-sort">基数排序 radix sort</h4>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先统计最多有多少位</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        max = max/<span class="number">10</span>;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">1</span>;<span class="comment">//除数，每次去除最低位</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//给十进制每一位赋予一个桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        bucket.add( <span class="keyword">new</span> ArrayList&lt;Integer&gt;() );</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//从低位到高位遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++)&#123;</span><br><span class="line">        <span class="comment">//统计  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">             <span class="comment">//计算当前位数是几</span></span><br><span class="line">             <span class="keyword">int</span> num = (array[j]/div)%<span class="number">10</span>;</span><br><span class="line">             <span class="comment">//放入桶中</span></span><br><span class="line">             bucket.get(num).add(array[j]);   </span><br><span class="line">        &#125;</span><br><span class="line">        div = div * <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历桶，收集</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.size(); j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucket.get(j).size();k++)</span><br><span class="line">                array[index++] = bucket.get(j).get(k);</span><br><span class="line">            bucket.get(j).clear();<span class="comment">//清空    </span></span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="稳定性">稳定性</h3>
<p>假定在待排序的序列中，存在多个具有相同数值的记录，若经过排序，这些记录的相对次序保持不变，则排序算法是稳定的。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/5.png" style="zoom:50%;"></p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/u013309870/article/details/68578011</p>
<p>https://www.jianshu.com/p/47170b1ced23</p>
<p>https://blog.csdn.net/qq_27124771/article/details/87651495 （桶排序）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>05 Flink DataStream</title>
    <url>/2021/05/09/Flink05_DataStreamAPI/</url>
    <content><![CDATA[<p>Flink中对无界数据进行计算（流处理）。</p>
<a id="more"></a>
<h3 id="流处理的wordcount">流处理的WordCount</h3>
<p>与批处理对比：</p>
<p>1、运行环境对象不同，StreamExecutionEnvironment。</p>
<p>2、某些算子不同，如批处理中按key分组是groupby，流处理中按key分组是keyby。</p>
<p>3、程序是一直运行，除非手动停止。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">KeyedStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">流式计算的wordcount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCountDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     1 创建一个流处理的运行环境</span></span><br><span class="line"><span class="comment">     2 构建socket source数据源</span></span><br><span class="line"><span class="comment">     3 接收到的数据转为（单词，1）</span></span><br><span class="line"><span class="comment">     4 对元组使用keyby分组（类似于批处理中的groupby）</span></span><br><span class="line"><span class="comment">     5 使用窗口进行5s的计算</span></span><br><span class="line"><span class="comment">     6 sum出单词数量</span></span><br><span class="line"><span class="comment">     7 打印输出</span></span><br><span class="line"><span class="comment">     8 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2 构建socket source数据源</span></span><br><span class="line">    <span class="comment">//  socketTextStream参数：ip,port </span></span><br><span class="line">    <span class="comment">//  返回值类型是datastream</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//这里可以在node1节点上使用nc -lk 9999命令开启一个服务器，并可以往里面写入数据</span></span><br><span class="line">    <span class="comment">//-l 用于指定netcat将处于侦听模式,指定该参数意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。</span></span><br><span class="line">    <span class="comment">//-k 表示持续打开连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3 接收到的数据转为（单词，1）</span></span><br><span class="line">    <span class="keyword">val</span> tupleDs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = socketDs.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4 对元组使用keyby分组（类似于批处理中的groupby）</span></span><br><span class="line">    <span class="keyword">val</span> keyedStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = tupleDs.keyBy(<span class="number">0</span>) <span class="comment">//选择key value中的key</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 使用窗口进行5s的计算,每5s计算一次</span></span><br><span class="line">    <span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = keyedStream.timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6 已经按照key进行了分组，因此这里对key value中的value进行求和</span></span><br><span class="line">    <span class="keyword">val</span> resDs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = windowStream.sum(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7 打印输出    </span></span><br><span class="line">    resDs.print()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8 执行   流处理中一定要使用env.execute()来执行程序，不管有无print</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="source">Source</h3>
<p>从数据源读取数据形成数据流DataStream。</p>
<h4 id="custom-source-自定义数据源">Custom Source 自定义数据源</h4>
<p>除了预定义的Source外，可以通过实现SourceFunction/ParallelSourceFunction/RichParallelSourceFunction等接口自定义数据源Source。</p>
<p>然后，可以在运行环境上指定使用的数据源，用StreamExecutionEnvironment.addSource( source )添加自定义数据源。</p>
<p>非并行数据源：SourceFunction, source不能设置大于1的并行度，效率会比较低。</p>
<p>并行数据源：ParallelSourceFunction，source可以设置大于1的并行度，效率更高。</p>
<p>富并行数据源：RichParallelSourceFunction，source可以设置大于1的并行度，此外还提供了open，close等方法。</p>
<h5 id="非并行数据源">非并行数据源</h5>
<p>此时addSource这个Operator的并行度（线程数量）只能设置为1，否则报错。</p>
<ul>
<li><p>创建一个class实现SourceFunction接口</p></li>
<li><p>重写写run方法，定义生产数据的业务逻辑，重写cancle方法定义取消发送数据</p></li>
<li><p>senv.addSource()添加自定义的source</p></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.<span class="type">SourceFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自定义非并行数据源实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MySourceNoParalle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="keyword">val</span> myDs: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MyNoParalleSourceFunction</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    myDs.print()</span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SourceFunction泛型是自定义source的返回数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNoParalleSourceFunction</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">Long</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ele: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//发送数据，生产数据的方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Long</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      ele += <span class="number">1</span></span><br><span class="line">      <span class="comment">//通过上下文对象发送数据</span></span><br><span class="line">      ctx.collect(ele)</span><br><span class="line">      <span class="comment">//降低发送速度</span></span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消方法，取消是通过控制一个变量来影响run方法中的while循环，从而控制是否停止发送数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    isRunning = <span class="literal">false</span> <span class="comment">//取消发送数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="并行数据源">并行数据源</h5>
<p>ParallelSourceFunction</p>
<p>只需要将非并行自定义数据源实现的接口改为ParallelSourceFunction即可。</p>
<p>可以在Source Operator上设置大于1的并行度，从而并行读取数据。此时，发送数据是重复的，可以理解为有多个线程都在执行run这个方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.&#123;<span class="type">ParallelSourceFunction</span>, <span class="type">SourceFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并行数据源实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyParallelSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="keyword">val</span> myDs: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MyParalleSourceFunction</span>).setParallelism(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    myDs.print()</span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ParallelSourceFunction泛型是我们自定义source的返回数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParalleSourceFunction</span> <span class="keyword">extends</span> <span class="title">ParallelSourceFunction</span>[<span class="type">Long</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ele: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//发送数据，生产数据的方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Long</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      ele += <span class="number">1</span></span><br><span class="line">      <span class="comment">//通过上下文对象发送数据</span></span><br><span class="line">      ctx.collect(ele)</span><br><span class="line">      <span class="comment">//降低发送速度</span></span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消方法，取消是通过控制一个变量来影响run方法中的while循环，从而控制是否停止发送数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    isRunning = <span class="literal">false</span> <span class="comment">//取消发送数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RichParallelSourceFunction</p>
<p>富并行数据源，可以提供open，close等方法（如果操作数据库可以实现在open或者close打开关闭连接），也可以在其中获取到上下文执行更复杂的操作。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.&#123;<span class="type">RichParallelSourceFunction</span>, <span class="type">SourceFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">富并行数据源实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyRichParallelSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="keyword">val</span> myDs: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MyRichParalleSourceFunction</span>).setParallelism(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    myDs.print()</span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SourceFunction泛型是我们自定义source的返回数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRichParalleSourceFunction</span> <span class="keyword">extends</span> <span class="title">RichParallelSourceFunction</span>[<span class="type">Long</span>] </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//todo 初始化方法比如打开数据库连接等昂贵操作</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = <span class="keyword">super</span>.open(parameters)</span><br><span class="line">  <span class="comment">//todo 关闭连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = <span class="keyword">super</span>.close()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ele: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//发送数据，生产数据的方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Long</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      ele += <span class="number">1</span></span><br><span class="line">      <span class="comment">//通过上下文对象发送数据</span></span><br><span class="line">      ctx.collect(ele)</span><br><span class="line">      <span class="comment">//降低发送速度</span></span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消方法，取消是通过控制一个变量来影响run方法中的while循环</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    isRunning = <span class="literal">false</span> <span class="comment">//取消发送数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>订单数据源样例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">UUID</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">TimeUnit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.&#123;<span class="type">RichParallelSourceFunction</span>, <span class="type">SourceFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自定义数据源，练习 生成订单数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//订单信息(订单ID、用户ID、订单金额、时间戳)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">id: <span class="type">String</span>, userId: <span class="type">Int</span>, money: <span class="type">Long</span>, createTime: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">OrderCustomSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 创建订单样例类</span></span><br><span class="line"><span class="comment">    2. 获取流处理环境</span></span><br><span class="line"><span class="comment">    3. 创建自定义数据源</span></span><br><span class="line"><span class="comment">       - 循环1000次</span></span><br><span class="line"><span class="comment">       - 随机构建订单信息</span></span><br><span class="line"><span class="comment">       - 上下文收集数据</span></span><br><span class="line"><span class="comment">       - 每隔一秒执行一次循环</span></span><br><span class="line"><span class="comment">    4. 打印数据</span></span><br><span class="line"><span class="comment">    5. 执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//1  获取流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 2 加载自定义的order数据源,RichParallelSourceFunction泛型是生产的数据类型，order</span></span><br><span class="line">    <span class="keyword">val</span> orderDs: <span class="type">DataStream</span>[<span class="type">Order</span>] = env.addSource(<span class="keyword">new</span> <span class="type">RichParallelSourceFunction</span>[<span class="type">Order</span>] &#123;</span><br><span class="line">      <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.1生成订单数据方法</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Order</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">//2.1.1 生成订单 业务逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">          <span class="comment">//orderid</span></span><br><span class="line">          <span class="keyword">val</span> orderId = <span class="type">UUID</span>.randomUUID().toString</span><br><span class="line">          <span class="comment">//userid</span></span><br><span class="line">          <span class="keyword">val</span> userId = <span class="type">Random</span>.nextInt(<span class="number">3</span>)</span><br><span class="line">          <span class="comment">//money</span></span><br><span class="line">          <span class="keyword">val</span> money = <span class="type">Random</span>.nextInt(<span class="number">101</span>)</span><br><span class="line">          <span class="comment">//createTime</span></span><br><span class="line">          <span class="keyword">val</span> createTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">          ctx.collect(<span class="type">Order</span>(orderId, userId, money, createTime))</span><br><span class="line">          <span class="comment">//每隔一秒中执行一次</span></span><br><span class="line">          <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>.sleep(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.2 取消数据的生成方法</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        isRunning = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;) <span class="comment">//.setParallelism(1) 并行度设置可不用</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    orderDs.print()</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 4 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="mysql数据源">MySQL数据源</h5>
<p>选择RichParallelSourceFunction接口作为要实现的接口，利用提供的open和close方法打开和关闭mysql的链接，实现链接的重用。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Connection</span>, <span class="type">DriverManager</span>, <span class="type">PreparedStatement</span>, <span class="type">ResultSet</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">TimeUnit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.&#123;<span class="type">RichParallelSourceFunction</span>, <span class="type">SourceFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示自定义并行数据源读取mysql</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义student 样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">Int</span>, name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MysqlRichParallelSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="keyword">val</span> stuDs: <span class="type">DataStream</span>[<span class="type">Student</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MysqlRichParalleleSource</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    stuDs.print()</span><br><span class="line">    <span class="comment">//4 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2自定义mysql并行数据源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlRichParalleleSource</span> <span class="keyword">extends</span> <span class="title">RichParallelSourceFunction</span>[<span class="type">Student</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ps: <span class="type">PreparedStatement</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> connection: <span class="type">Connection</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.1 开启mysql连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//驱动方式</span></span><br><span class="line">    connection = <span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:mysql://node1:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">    <span class="comment">//准备sql语句查询表中全部数据</span></span><br><span class="line">    <span class="keyword">var</span> sql = <span class="string">&quot;select id ,name,age from t_student&quot;</span>;</span><br><span class="line">    <span class="comment">//准备执行语句对象</span></span><br><span class="line">    ps = connection.prepareStatement(sql)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.3 释放资源，关闭连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      connection.close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">null</span>) ps.close()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2 读取mysql数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Student</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      <span class="comment">//读取mysql中的数据</span></span><br><span class="line">      <span class="keyword">val</span> result: <span class="type">ResultSet</span> = ps.executeQuery()</span><br><span class="line">      <span class="keyword">while</span> (result.next()) &#123;</span><br><span class="line">        <span class="keyword">val</span> userId = result.getInt(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> name = result.getString(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> age = result.getInt(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">        <span class="comment">//收集并发送</span></span><br><span class="line">        ctx.collect(<span class="type">Student</span>(userId, name, age))</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//休眠5s,执行一次</span></span><br><span class="line">      <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>.sleep(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    isRunning = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kafka数据源">Kafka数据源</h5>
<p>Flink提供了基于Kafka的数据源实现类FlinkKafkaConsumer011等 ，可以通过addSource添加该Kafka数据源。FlinkKafkaConsumer011等实现类最终是实现了RichParallelSourceFunction接口。</p>
<p><img src="/2021/05/09/Flink05_DataStreamAPI/Blog\source\_posts\Flink05_DataStreamAPI\0.png" style="zoom: 50%;"></p>
<p>FlinkKafkaConsumer等集成了Flink的检查点机制，可提供一次性处理语义。为实现这一目标，Flink并不完全依赖Kafka的消费者群体偏移跟踪，而是在内部实现了跟踪和检查这些偏移的机制。</p>
<ul>
<li><p>构造函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> flinkKafkaConsumer: <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>](topic, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), prop)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>主题名称/主题名称列表</p></li>
<li><p>DeserializationSchema / KeyedDeserializationSchema</p>
<p>作用：对kafka里获取的二进制数据进行反序列化</p>
<p>反序列化Schema类型(接口)：DeserialzationSchema(只反序列化value)、KeyedDeserializationSchema(反序列化key和value)</p>
<p>FlinkKafkaConsumer需要知道如何将kafka中的二进制数据转换成Java/Scala对象，这两个接口定义了该转换模式，从kafka获取的每条消息都会通过其中的方法T deserialize(byte[] message)进行反序列化处理。接口源码为：</p>
<p><img src="/2021/05/09/Flink05_DataStreamAPI/Blog\source\_posts\Flink05_DataStreamAPI\1.png" style="zoom: 54%;"></p>
<p><img src="/2021/05/09/Flink05_DataStreamAPI/Blog\source\_posts\Flink05_DataStreamAPI\2.png" style="zoom:50%;"></p>
<p>常用的反序列化Schema：</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Schema</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SimpleStringSchema</td>
<td>可以将消息反序列化为字符串。当接收到消息并且反序列化失败的时候，会出现以下两种情况: <br>1) Flink从deserialize(..)方法中抛出异常，这会导致job的失败，然后job会重启；<br>2) 在deserialize(..) 方法出现失败的时候返回null，这会让Flink Kafka Consumer忽略这条消息。如果配置了checkpoint 为enable，由于consumer的失败容忍机制，失败的消息会被继续消费，因此还会继续失败，这就会导致job被不断自动重启</td>
</tr>
<tr class="even">
<td>JSONDeserializationSchema<br>JSONKeyValueDeserializationSchema</td>
<td>可以把序列化后的Json反序列化成ObjectNode，ObjectNode可以通过objectNode.get(“field”).as(Int/String/…)() 来访问指定的字段</td>
</tr>
<tr class="odd">
<td>TypeInformationSerializationSchema<br>TypeInformationKeyValueSerializationSchema</td>
<td>适合读写均是flink的场景。这会基于Flink的TypeInformation来创建Schema。这对于那些从Flink写入，又从Flink读出的数据是很有用的。这种Flink-Specific的反序列化会比其他通用的序列化方式带来更高的性能。</td>
</tr>
</tbody>
</table></li>
<li><p>Kafka消费者的属性。需要以下属性： “bootstrap.servers”（以逗号分隔的Kafka集群列表）</p>
<p>“group.id”消费者群组的ID</p>
<p>“zookeeper.connect”（逗号分隔的Zookeeper服务器列表）（仅Kafka 0.8需要）</p></li>
</ol></li>
<li><p>FlinkKafkaConsumer消费模式设置</p>
<p>这指定了了FlinkKafkaConsumer究竟是如何从Kafaka中消费数据的。</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<tbody>
<tr class="odd">
<td>setStartFromEarliest</td>
<td>从队列头开始，最早的记录。内部的consumer递交到kafka/zk的偏移量将被忽略。</td>
</tr>
<tr class="even">
<td>setStartFromLatest</td>
<td>从队列尾开始，最新的记录 内部的consumer递交到kafka/zk的偏移量将被忽略。</td>
</tr>
<tr class="odd">
<td>setStartFromGroupOffsets</td>
<td>默认值，从当前消费组记录的偏移量开始，接着上次的偏移量消费。以consumer递交到kafka/zk中的偏移量为起始位置开始消费，group.id设置在consumer的properties里面。<br>如果没有找到记录的偏移量，则使用consumer的properties的auto.offset.reset设置的策略。</td>
</tr>
<tr class="even">
<td>setStartFromSpecificOffsets(Map&lt;TopicPartition, Long&gt;的参数)</td>
<td>从指定的具体位置开始消费。</td>
</tr>
<tr class="odd">
<td>setStartFromTimestamp(long)</td>
<td>从指定的时间戳开始消费 对于每个分区，时间戳大于或者等于指定时间戳的记录将用作起始位置，如果一个分区的最新时间早于时间戳，那么只需要从最新记录中读取该分区，在此模式下，kafka/zk中递交的偏移量将被忽略。<br>时间戳指的是kafka中消息自带的时间戳。</td>
</tr>
</tbody>
</table>
<ul>
<li><p>setStartFromEarliest()/ setStartFromLatest()</p>
<p>只会从最新或最老的地方开始消费。 注意：properties.setProperty("auto.offset.reset", "latest")和kafkaConsumer010.setStartFromLatest()不是一回事。</p></li>
<li><p>setStartFromGroupOffsets</p>
<p>任务从检查点重启，按照重启前的offset进行消费，如果直接重启不从检查点重启并且group.id不变，程序会按照上次提交的offset的位置继续消费。如果group.id改变了，则程序按照auto.offset.reset设置的属性进行消费。但是如果程序带有状态的算子，还是建议使用检查点重启。</p></li>
<li><p>setStartFromSpecificOffsets</p>
<p>从每个分区指定的偏移量读取。</p>
<p>注意 1：如果使用者需要读取在提供的偏移量映射中没有指定偏移量的分区，则它将回退到setStartFromGroupOffsets()该特定分区的默认组偏移行为。 注意 2：当作业从故障中自动恢复或使用保存点手动恢复时，这些起始位置配置方法不会影响起始位置。在恢复时，每个Kafka分区的起始位置由存储在保存点或检查点中的偏移量确定。</p>
<p>下面的示例将消费者配置为从主题“myTopic”的分区0,1和2的指定偏移量开始读取消息。偏移值应该是消费者应为每个分区读取的下一条记录的位置：</p>
<p><img src="/2021/05/09/Flink05_DataStreamAPI/Blog\source_posts\Flink05_DataStreamAPI\3.png"></p></li>
<li><p>setStartFromTimestamp</p>
<p>允许用户从指定的时间戳消费Kafka中的数据，指定一个时间戳即可，单位毫秒。从时间戳消费者忽略Zookeeper / Kafka代理中任何提交的组偏移量。消费者将查找时间戳大于或等于的最早偏移量到Kafka的特定时间戳。如果没有这样的偏移量，消费者将使用从kafka读取数据的最新偏移量。</p></li>
</ul></li>
<li><p>容错</p>
<p>启用Flink的检查点后，Flink Kafka Consumer将使用主题中的记录，并以一致的方式定期检查其所有Kafka偏移以及其他操作的状态。如果作业失败，Flink会将流式程序恢复到最新检查点的状态，从存储在检查点中的偏移量开始重新使用来自Kafka的消息数据。因此，设置检查点的间隔定义了程序在发生故障时最多可以返回多少。flink在使用kafka是要实现容错，需要在执行环境中启用拓扑的检查点：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">env.enableCheckpointing(<span class="number">1000</span>) <span class="comment">// checkpoint every 1000 msecs</span></span><br></pre></td></tr></table></figure>
<p>如果未启用检查点，Kafka（kafka 0.9 以前）使用者将定期向Zookeeper提交偏移量，kafka 0.9 以后提交到broker，都是将topic提交给__consumer_offsets函数来执行。</p>
<p>注意 ：如果flink任务 不通过检查点重启，而是直接重启（groupId不变），可能会丢失数据。</p>
<p>原因：kafka自动更新offset时，fetch到消息后就可以定期更新offset，无论是否消费成功。如果在kafka更新offset的间期内数据没有写入第三方介质，任务挂掉这部分数据就会丢失。</p></li>
<li><p>动态分区检测</p>
<p>随着业务增长数据量也会同步增长，将导致原有的 Kafka 分区数不满足数据写入所需的并发度，需要扩展 Kafka 的分区或者增加 Kafka 的 topic，这时实时处理框架能动态发现新增Topic分区并消费处理新增分区的数据。Flink则是通过创建一个线程，该线程会定期检测 Kafka 新增分区，然后将其添加到 KafkaFetcher 里。</p>
<p>Flink需要将 flink.partition-discovery.interval-millis 属性设置为大于 0 ，属性值为时间间隔，单位为毫秒。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态感知kafka主题分区的增加 单位毫秒</span></span><br><span class="line">properties.setProperty(<span class="string">&quot;flink.partition-discovery.interval-millis&quot;</span>, <span class="string">&quot;5000&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>并行度</p>
<p>如果没有指定，Source Operator的个数与集群中的TaskManager的个数相等。如果手动设置，建议将总的Slot数量设为和Kafka的主题分区数相同。</p></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer011</span></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.<span class="type">ConsumerConfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">验证flinkkafkaconsumer如何消费kafka中的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFlinkKafkaConsumer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="comment">//2.1 构建properties对象</span></span><br><span class="line">    <span class="keyword">val</span> prop = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    <span class="comment">//kafka 集群地址</span></span><br><span class="line">    prop.setProperty(<span class="type">ConsumerConfig</span>.<span class="type">BOOTSTRAP_SERVERS_CONFIG</span>, <span class="string">&quot;node1:9092,node2:9092&quot;</span>)</span><br><span class="line">    <span class="comment">//消费者组</span></span><br><span class="line">    prop.setProperty(<span class="type">ConsumerConfig</span>.<span class="type">GROUP_ID_CONFIG</span>, <span class="string">&quot;flink&quot;</span>)</span><br><span class="line">    <span class="comment">//动态分区检测</span></span><br><span class="line">    prop.setProperty(<span class="string">&quot;flink.partition-discovery.interval-millis&quot;</span>, <span class="string">&quot;5000&quot;</span>)</span><br><span class="line">    <span class="comment">//设置kv的反序列化使用的类</span></span><br><span class="line">    prop.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    prop.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    <span class="comment">//设置默认消费的便宜量起始值</span></span><br><span class="line">    prop.setProperty(<span class="type">ConsumerConfig</span>.<span class="type">AUTO_OFFSET_RESET_CONFIG</span>, <span class="string">&quot;latest&quot;</span>) <span class="comment">//从最新处消费</span></span><br><span class="line">    <span class="comment">//定义topic</span></span><br><span class="line">    <span class="keyword">val</span> topic = <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得了kafkaconsumer对象</span></span><br><span class="line">    <span class="comment">//泛型限定了从kafka读取数据的类型</span></span><br><span class="line">    <span class="keyword">val</span> flinkKafkaConsumer: <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>](topic, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), prop)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">val</span> kafkaDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.addSource(flinkKafkaConsumer)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    kafkaDs.print()</span><br><span class="line">    <span class="comment">//4 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可用的版本：</p>
<blockquote>
<p>Maven 依赖：flink-connector-kafka-0.11_2.11</p>
<p>Flink支持到的版本 ：1.4.0</p>
<p>生产者和消费者类的名称：FlinkKafkaConsumer011、FlinkKafkaProducer011</p>
<p>Kafka Version：0.11.x</p>
<p>描述：0.11.x Kafka不支持scala 2.10。此连接器支持Kafka事务性消息传递，为生产者提供一次语义。</p>
<p>​</p>
</blockquote>
<h4 id="socket-source">Socket Source</h4>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line"><span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2 构建socket source数据源</span></span><br><span class="line"><span class="comment">//  socketTextStream参数：ip,port </span></span><br><span class="line"><span class="comment">//  返回值类型是datastream</span></span><br><span class="line"><span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br></pre></td></tr></table></figure>
<h4 id="集合source">集合Source</h4>
<h4 id="文件source">文件Source</h4>
<h3 id="transformation">Transformation</h3>
<p>对DataStream进行各种转换操作。</p>
<h4 id="keyby">keyby</h4>
<p>类似批处理中的group by算子，对数据流按照指定规则进行分区。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">keyby的实现单词统计</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KeyByDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 加载socketstream</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//3 对接收到的数据切分压平转成单词，1的元组</span></span><br><span class="line">    <span class="keyword">val</span> wordAndOneDs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = socketDs.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map(_ -&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 4 按照单词分组</span></span><br><span class="line"><span class="comment">//    wordAndOneDs.keyBy(_._1).sum(1).print()</span></span><br><span class="line">    wordAndOneDs.keyBy(<span class="number">0</span>).sum(<span class="number">1</span>).print()</span><br><span class="line">    <span class="comment">//5 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="connect">connect</h4>
<p>将两个DataStream合并为一个流，数据类型可以不同。批处理中union算子必须要求数据类型一致才能union。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">TimeUnit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.<span class="type">SourceFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">ConnectedStreams</span>, <span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flink中connect的用法，把两个数据流连接到一起</span></span><br><span class="line"><span class="comment">需求：</span></span><br><span class="line"><span class="comment">创建两个流，一个产生数值，一个产生字符串数据</span></span><br><span class="line"><span class="comment">使用connect连接两个流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConnectDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 加载source</span></span><br><span class="line">    <span class="keyword">val</span> numDs: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MyNumberSource</span>)</span><br><span class="line">    <span class="keyword">val</span> strDs = env.addSource(<span class="keyword">new</span> <span class="type">MyStrSource</span>)</span><br><span class="line">    <span class="comment">// 3 使用connect进行两个连接操作</span></span><br><span class="line">     <span class="keyword">val</span> connectedDs: <span class="type">ConnectedStreams</span>[<span class="type">Long</span>, <span class="type">String</span>] = numDs.connect(strDs)</span><br><span class="line">    <span class="comment">//传递两个函数，分别处理数据</span></span><br><span class="line">    <span class="keyword">val</span> resDs: <span class="type">DataStream</span>[<span class="type">String</span>] = connectedDs.map(l=&gt;<span class="string">&quot;long&quot;</span>+l, s=&gt;<span class="string">&quot;string&quot;</span>+s)</span><br><span class="line">    <span class="comment">//connect意义在哪里呢？只是把两个合并为一个，但是处理业务逻辑都是按照自己的方法处理？</span></span><br><span class="line">    <span class="comment">//connect之后两条流可以共享状态数据</span></span><br><span class="line">    resDs.print()</span><br><span class="line">    <span class="comment">//5 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义产生递增的数字 第一个数据源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumberSource</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">Long</span>]</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> num=<span class="number">1</span>L</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Long</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">      num +=<span class="number">1</span></span><br><span class="line">      ctx.collect(num)</span><br><span class="line">      <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>.sleep(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    flag=<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义产生从1开始递增字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStrSource</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">String</span>]</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> num=<span class="number">1</span>L</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">      num +=<span class="number">1</span></span><br><span class="line">      ctx.collect(<span class="string">&quot;str&quot;</span>+num)</span><br><span class="line">      <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>.sleep(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    flag=<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="splitselect">split+select</h4>
<p>实现对数据流的切分，使用split切分流，通过select获取到切分之后的流。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">SplitStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">示例</span></span><br><span class="line"><span class="comment">加载本地集合(1,2,3,4,5,6), 使用split进行数据分流,分为奇数和偶数. 并打印奇数结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SplitSelectDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2 加载source</span></span><br><span class="line">    <span class="keyword">val</span> numDs: <span class="type">DataStream</span>[<span class="type">Int</span>] = env.fromCollection(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 3 转换 使用split把数据流中的数据分为奇数和偶数</span></span><br><span class="line">    <span class="keyword">val</span> splitStream: <span class="type">SplitStream</span>[<span class="type">Int</span>] = numDs.split(</span><br><span class="line">      item =&gt; &#123;</span><br><span class="line">        <span class="comment">//模以2</span></span><br><span class="line">        <span class="keyword">var</span> res = item % <span class="number">2</span></span><br><span class="line">        <span class="comment">//模式匹配的方式</span></span><br><span class="line">        res <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="type">List</span>(<span class="string">&quot;even&quot;</span>) <span class="comment">//偶数  even与odd只是名称，代表数据流的名称，但是必须放在list集合</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="type">List</span>(<span class="string">&quot;odd&quot;</span>) <span class="comment">//奇数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 4 从splitStream中获取奇数流和偶数流</span></span><br><span class="line">    <span class="keyword">val</span> evenDs: <span class="type">DataStream</span>[<span class="type">Int</span>] = splitStream.select(<span class="string">&quot;even&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> oddDs = splitStream.select(<span class="string">&quot;odd&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> allDs: <span class="type">DataStream</span>[<span class="type">Int</span>] = splitStream.select(<span class="string">&quot;even&quot;</span>,<span class="string">&quot;odd&quot;</span>)</span><br><span class="line">    <span class="comment">// 5打印结果</span></span><br><span class="line">    <span class="comment">//evenDs.print()</span></span><br><span class="line">    <span class="comment">//oddDs.print()</span></span><br><span class="line">    allDs.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5启动程序</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sink">Sink</h3>
<h4 id="mysql-sink">MySQL Sink</h4>
<p>大致流程：</p>
<p>1、创建class实现RichSinkFunction接口，并通过addSink方法添加给DataStream实现数据的保存。</p>
<p>2、重写invoke方法，设置SQL语句中的数值，执行真正写入逻辑的方法。</p>
<p>3、利用open和close方法实现对数据库连接的管理</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Connection</span>, <span class="type">DriverManager</span>, <span class="type">PreparedStatement</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.sink.&#123;<span class="type">RichSinkFunction</span>, <span class="type">SinkFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flink程序计算结果保存到mysql中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义student case class</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">Int</span>, name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SinkToMysqlDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    读取数据然后直接写入mysql,需要自己实现mysql sinkfunction</span></span><br><span class="line"><span class="comment">    自定义class实现RichSinkFunction重写open,invoke,close方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 加载source</span></span><br><span class="line">    <span class="keyword">val</span> stuDs: <span class="type">DataStream</span>[<span class="type">Student</span>] = env.fromElements(<span class="type">Student</span>(<span class="number">0</span>, <span class="string">&quot;tony&quot;</span>, <span class="number">18</span>))</span><br><span class="line">    <span class="comment">// 3 直接写出到mysql</span></span><br><span class="line">    stuDs.addSink(<span class="keyword">new</span> <span class="type">MySqlSinkFunction</span>)</span><br><span class="line">    <span class="comment">// 4 执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备自定义mysql sinkfunciton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySqlSinkFunction</span> <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>[<span class="type">Student</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ps: <span class="type">PreparedStatement</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> connection: <span class="type">Connection</span> = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 3.1 打开连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 3.1.1驱动方式</span></span><br><span class="line">    connection = <span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:mysql://node1:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">    <span class="comment">//3.1.2准备sql语句插入数据到mysql表中</span></span><br><span class="line">    <span class="keyword">var</span> sql = <span class="string">&quot;insert into t_student(name,age) values(?,?)&quot;</span>;</span><br><span class="line">    <span class="comment">//3.1.3准备执行语句对象</span></span><br><span class="line">    ps = connection.prepareStatement(sql)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//关闭连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      connection.close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">null</span>) ps.close()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.2 这个方法负责写入数据到mysql中,value就是上游datastream传入需要写入mysql的数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invoke</span></span>(value: <span class="type">Student</span>, context: <span class="type">SinkFunction</span>.<span class="type">Context</span>[_]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 3.2.1设置参数</span></span><br><span class="line">    ps.setString(<span class="number">1</span>, value.name)</span><br><span class="line">    ps.setInt(<span class="number">2</span>, value.age)</span><br><span class="line">    <span class="comment">//3.2.2执行插入动作</span></span><br><span class="line">    ps.executeUpdate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kafka-sink">Kafka Sink</h4>
<p>利用Flink提供的FlinkKafkaProducer这个类，实现写出数据到Kafka中，此时Flink作为生产者，Kafka作为消费者。</p>
<p>FlinkKafkaProducer的构造参数需要指定序列化数据的Schema，下面的案例使用keyedSerializationWrapper：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaProducer011</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.util.serialization.<span class="type">KeyedSerializationSchemaWrapper</span></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.<span class="type">ProducerConfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flink程序计算结果保存到kafka</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义student case class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">Int</span>, name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SinkToKafkaDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flink读取数据然后把数据写入kafka中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2 加载source</span></span><br><span class="line">    <span class="keyword">val</span> stuDs: <span class="type">DataStream</span>[<span class="type">Student</span>] = env.fromElements(<span class="type">Student</span>(<span class="number">0</span>, <span class="string">&quot;tony&quot;</span>, <span class="number">18</span>))</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//3 直接使用flinkkafkaproducer来生产数据到kafka</span></span><br><span class="line">    <span class="comment">//3.1 准备一个flinkkafkaproducer对象</span></span><br><span class="line">    <span class="comment">//param1 Kafaka中的主题名称</span></span><br><span class="line">    <span class="keyword">var</span> topic=<span class="string">&quot;test&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//param2 指定序列化所使用的Schema</span></span><br><span class="line">    <span class="keyword">val</span> keyedSerializationWrapper: <span class="type">KeyedSerializationSchemaWrapper</span>[<span class="type">String</span>] =</span><br><span class="line">      <span class="keyword">new</span> <span class="type">KeyedSerializationSchemaWrapper</span>(<span class="keyword">new</span> <span class="type">SimpleStringSchema</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//param3 指定属性，Kafka集群地址</span></span><br><span class="line">    <span class="keyword">val</span> prop = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    prop.setProperty(<span class="type">ProducerConfig</span>.<span class="type">BOOTSTRAP_SERVERS_CONFIG</span>,<span class="string">&quot;node1:9092,node2:9092&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//泛型指定写入kafka的数据类型      </span></span><br><span class="line">    <span class="keyword">val</span> flinkKafkaProducer: <span class="type">FlinkKafkaProducer011</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">FlinkKafkaProducer011</span>[<span class="type">String</span>](</span><br><span class="line">      topic,keyedSerializationWrapper,prop)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 4 sink 操作</span></span><br><span class="line">    stuDs.map(_.toString).addSink(flinkKafkaProducer)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 5 执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="redis-sink">Redis Sink</h4>
<p>借助Flink提供的Redis Sink我们可以方便的把数据写入Redis中。使用Redis Sink需要提供两项内容：</p>
<p>1、连接Redis的配置文件</p>
<p>2、提供一个RedisMapper接口的实现类的对象，其中重写三个方法，分别定义了操作的数据结构，写入的key和value。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.redis.<span class="type">RedisSink</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.redis.common.config.<span class="type">FlinkJedisPoolConfig</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.redis.common.mapper.&#123;<span class="type">RedisCommand</span>, <span class="type">RedisCommandDescription</span>, <span class="type">RedisMapper</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flink程序计算结果保存到redis，使用flink提供的redissink</span></span><br><span class="line"><span class="comment">从socket接收数据然后计算出单词的次数，最终使用redissink写数据到redis中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SinkToRedisDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2 加载socket数据，</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    单词计数的逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//3 转换</span></span><br><span class="line">    <span class="keyword">val</span> resDs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = socketDs.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map(_ -&gt;<span class="number">1</span>).keyBy(<span class="number">0</span>).sum(<span class="number">1</span>)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//4 Sink 操作 使用Redis Sink</span></span><br><span class="line">    <span class="comment">//4.1 redissink的构造：1、需要redis配置文件（连接信息），2、RedisMapper接口的实现类的对象</span></span><br><span class="line">    <span class="comment">//4.1.1 jedisconfig</span></span><br><span class="line">    <span class="keyword">val</span> config: <span class="type">FlinkJedisPoolConfig</span> = <span class="keyword">new</span> <span class="type">FlinkJedisPoolConfig</span>.<span class="type">Builder</span>().setHost(<span class="string">&quot;node2&quot;</span>).setPort(<span class="number">6379</span>).build()</span><br><span class="line"></span><br><span class="line">    resDs.addSink(<span class="keyword">new</span> <span class="type">RedisSink</span>[(<span class="type">String</span>, <span class="type">Int</span>)](config,<span class="keyword">new</span> <span class="type">MyRedisMapper</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.1.2 RedisMapper的对象，泛型就是DataStream的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRedisMapper</span> <span class="keyword">extends</span> <span class="title">RedisMapper</span>[(<span class="type">String</span>, <span class="type">Int</span>)]</span>&#123;</span><br><span class="line">  <span class="comment">//获取命令描述器，确定数据结构,使用hash结构</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCommandDescription</span></span>: <span class="type">RedisCommandDescription</span> = &#123;</span><br><span class="line">    <span class="comment">//指定使用hset命令，并提供hash结构的第一个key</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">RedisCommandDescription</span>(<span class="type">RedisCommand</span>.<span class="type">HSET</span>,<span class="string">&quot;REDISSINK&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定key</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getKeyFromData</span></span>(data: (<span class="type">String</span>, <span class="type">Int</span>)): <span class="type">String</span> = &#123;</span><br><span class="line">    data._1</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//指定value</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getValueFromData</span></span>(data: (<span class="type">String</span>, <span class="type">Int</span>)): <span class="type">String</span> = &#123;</span><br><span class="line">    data._2.toString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意导入Maven依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;flink-connector-redis_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.1.5&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>06 Flink四大基石：窗口与时间</title>
    <url>/2021/05/13/Flink06_WindowAndTime/</url>
    <content><![CDATA[<h3 id="window">Window</h3>
<p>窗口 Window 是Flink中用来收集一定范围内数据的一种方式。</p>
<p>滑动窗口，指的是把源源不断的数据看成是已经存在的，然后通过滑动设定好的窗口来对每个窗口内的数据进行计算。滑动窗口有两个属性，一个是窗口大小，一个是滑动间隔。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513182928464.png" style="zoom:67%;"></p>
<p>当 滑动窗口大小 = 滑动间隔时，所有的数据都能参与计算，且窗口内的数据不重复，此时称这样的窗口为滚动窗口。</p>
<a id="more"></a>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513183200282.png" style="zoom:67%;"></p>
<p>当 滑动窗口大小 &gt; 滑动间隔时，所有的数据都能参与计算，且窗口内的数据有重复，会重复地参与计算。</p>
<h4 id="窗口划分方式">窗口划分方式</h4>
<p>在 Flink 中 Window 可以是时间驱动的(Time Window)，即以时间为标准对数据进行划分，也可以是数据驱动的(Count Window)，即以数据的数量为标准对流式数据进行划分。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/0.png" style="zoom:80%;"></p>
<p>如果根据时间划分窗口，那么它就是一个time-window，比如每1分钟统计一次或每10分钟统计一次。如果根据数据划分窗口，那么它就是一个count-window，比如每5个数据统计一次或每50个数据统计一次。</p>
<p>Flink支持窗口的两个重要属性窗口长度size和滑动间隔interval。</p>
<ul>
<li>如果size = interval，那么就会形成tumbling-window(无重叠数据)：滚动窗口。</li>
<li>如果size(1min) &gt; interval（30s），那么就会形成sliding-window(有重叠数据)：正常的滑动窗口<br>
</li>
<li>如果size&lt;interval，那么这种窗口将会丢失数据。比如每5秒钟，统计过去3秒的通过路口汽车的数据，将会漏掉2秒钟的数据。</li>
</ul>
<p>因此，通过窗口的划分标准和窗口属性进行组合，可以得到四种基本的窗口：</p>
<p>time-tumbling-window：无重叠数据的时间窗口，设置方式举例：timeWindow(Time.seconds(5))---基于时间的滚动窗口</p>
<p>time-sliding-window：有重叠数据的时间窗口，设置方式举例：timeWindow(Time.seconds(10), Time.seconds(5))---基于时间的滑动窗口</p>
<p>count-tumbling-window：无重叠数据的数量窗口，设置方式举例：countWindow(5)---基于数量的滚动窗口</p>
<p>count-sliding-window：有重叠数据的数量窗口，设置方式举例：countWindow(10,5)---基于数量的滑动窗口</p>
<p>注意：Flink中还支持一个特殊的窗口:会话窗口SessionWindows</p>
<h4 id="time-windows">Time-Windows</h4>
<p>对于基于时间来进行数据划分的TimeWindow，可以根据窗口实现原理的不同分成三类：滚动窗口(Tumbling Window)、滑动窗口(Sliding Window)和会话窗口(Session Window)。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513195510260.png" style="zoom:67%;"></p>
<p>滚动窗口将数据依据固定的窗口长度对数据进行切分，窗口内的数据不重复。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513195540682.png" style="zoom:67%;"></p>
<p>滑动窗口的窗口长度大于滑动的间隔，因此窗口内会产生重复的数据。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513195913227.png" style="zoom: 58%;"></p>
<p>Session窗口在一个固定的时间周期内不再收到元素，即非活动间隔产生，那个这个窗口就会关闭。</p>
<p>使用窗口对数据进行统计的案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">AllWindowedStream</span>, <span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.&#123;<span class="type">EventTimeSessionWindows</span>, <span class="type">SlidingEventTimeWindows</span>, <span class="type">TumblingEventTimeWindows</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送内容</span></span><br><span class="line"><span class="comment">路灯编号,通过的数量</span></span><br><span class="line"><span class="comment">9,3</span></span><br><span class="line"><span class="comment">9,2</span></span><br><span class="line"><span class="comment">9,7</span></span><br><span class="line"><span class="comment">4,9</span></span><br><span class="line"><span class="comment">2,6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求</span></span><br><span class="line"><span class="comment">每5秒钟统计一次，在这过去的5秒钟内，各个路口通过红绿灯汽车的数量--滚动窗口</span></span><br><span class="line"><span class="comment">每5秒钟统计一次，在这过去的10秒钟内，各个路口通过红绿灯汽车的数量--滑动窗口</span></span><br><span class="line"><span class="comment">在30秒内无数据接入则触发窗口计算--会话窗口(需要事件时间支持):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamingTimeWindow</span> </span>&#123;</span><br><span class="line">  <span class="comment">//样例类CarWC(信号灯id,数量)</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">sensorId: <span class="type">Int</span>, carCnt: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1.准备环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2.接收数据</span></span><br><span class="line">    <span class="keyword">val</span> socketData = env.socketTextStream(<span class="string">&quot;node01&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//3.处理数据socketData-&gt;carWcData</span></span><br><span class="line">    <span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line">    <span class="keyword">val</span> carData: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketData.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">String</span>] = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">      <span class="type">CarWc</span>(arr(<span class="number">0</span>).toInt, arr(<span class="number">1</span>).toInt)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//nokeyed数据</span></span><br><span class="line">    <span class="comment">//val value: AllWindowedStream[CarWc, TimeWindow] = carData.timeWindowAll(Time.seconds(5),Time.seconds(5))</span></span><br><span class="line">    <span class="comment">//keyed数据</span></span><br><span class="line">    <span class="comment">//val value1: WindowedStream[CarWc, Tuple, TimeWindow] = carData.keyBy(0).timeWindow(Time.seconds(5),Time.seconds(5))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.窗口聚合</span></span><br><span class="line">    <span class="comment">//4.1 滚动窗口</span></span><br><span class="line">    <span class="comment">//每5秒钟统计一次，在这过去的5秒钟内，各个路口通过红绿灯汽车的数量</span></span><br><span class="line">    <span class="comment">//无重叠数据，所以只需要给一个参数即可，每5秒钟统计一下各个路口通过红绿灯汽车的数量</span></span><br><span class="line">    <span class="keyword">val</span> result1: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carData.keyBy(<span class="number">0</span>)</span><br><span class="line">      <span class="comment">//.timeWindow(Time.seconds(5),Time.seconds(5))</span></span><br><span class="line">      .timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">      .sum(<span class="number">1</span>)</span><br><span class="line">    result1.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 滑动窗口</span></span><br><span class="line">    <span class="comment">//每5秒钟统计一次，在这过去的10秒钟内，各个路口通过红绿灯汽车的数量。</span></span><br><span class="line">    <span class="keyword">val</span> result2: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carData.keyBy(<span class="number">0</span>)</span><br><span class="line">      .timeWindow(<span class="type">Time</span>.seconds(<span class="number">10</span>),<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">      .sum(<span class="number">1</span>)</span><br><span class="line">    result2.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 会话窗口(需要时间事件支持)</span></span><br><span class="line">    <span class="comment">//指定会话超时，即会话之间的时间间隔，是指在规定的时间内如果没有数据活跃接入，则认为窗口结束，触发窗口计算</span></span><br><span class="line">    <span class="comment">// .window(EventTimeSessionWindows.withGap(Time.seconds(30)))</span></span><br><span class="line">    <span class="comment">//如果有时间事件,滚动窗口和滑动窗口也可以使用如下API</span></span><br><span class="line">    <span class="comment">//.window(TumblingEventTimeWindows.of(Time.seconds(5)))</span></span><br><span class="line">    <span class="comment">//.window(SlidingEventTimeWindows.of(Time.seconds(10),Time.seconds(5)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.启动执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="count-window">Count-Window</h4>
<p>对于基于数据个数来进行数据划分的CountWindow，可以根据窗口实现原理的不同分成两类：滚动窗口(Tumbling Window)、滑动窗口(Sliding Window)。</p>
<p>tumbling-count-window（无重叠数据）按照个数进行统计，比如：对每个路口分别统计，统计在最近5条消息中，各自路口通过的汽车数量，相同的key每出现5次进行统计；即对应的key出现的次数达到5次作为一个窗口，即相同的key出现5次才做一次sum聚合。</p>
<p>sliding-count-window （有重叠数据）窗口长度大于滑动间隔，比如：对每个路口分别统计，统计在最近5条消息中，各自路口通过的汽车数量，相同的key每出现3次进行统计。</p>
<p>这里<strong>窗口长度是5，滑动间隔是3，也就是说，每收到3个相同key的数据就计算一次，每一次计算的窗口是这个key里面前后输入的5个范围的元素</strong>（如果只是单纯统计个数的话，最大就是窗口的大小5个）。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">StreamExecutionEnvironment</span>, _&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送内容</span></span><br><span class="line"><span class="comment">路灯编号,通过的数量</span></span><br><span class="line"><span class="comment">9,3</span></span><br><span class="line"><span class="comment">9,2</span></span><br><span class="line"><span class="comment">9,7</span></span><br><span class="line"><span class="comment">4,9</span></span><br><span class="line"><span class="comment">2,6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求</span></span><br><span class="line"><span class="comment">对每个路口分别统计,统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现5次进行统计(对应的key出现的次数达到5次作为一个窗口,即相同的key出现5次才做一次sum聚合)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对每个路口分别统计,统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现3次进行统计。</span></span><br><span class="line"><span class="comment">每收到3个相同key的数据就计算一次，每一次计算的窗口是前后输入的5个范围的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamingCountWindow</span> </span>&#123;</span><br><span class="line">  <span class="comment">//样例类CarWC(信号灯id,数量)</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">sensorId: <span class="type">Int</span>, carCnt: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1.准备环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2.接收数据</span></span><br><span class="line">    <span class="keyword">val</span> socketData = env.socketTextStream(<span class="string">&quot;node01&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//3.处理数据 socketData-&gt;carWcData</span></span><br><span class="line">    <span class="keyword">val</span> carData: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketData.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> arr = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">      <span class="type">CarWc</span>(arr(<span class="number">0</span>).toInt, arr(<span class="number">1</span>).toInt)</span><br><span class="line">    &#125;)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//4.窗口聚合</span></span><br><span class="line">    <span class="comment">//4.1对每个路口分别统计,统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现5次进行统计</span></span><br><span class="line">    <span class="comment">//对应的key出现的次数达到5次作为一个窗口,即相同的key出现5次才做一次sum聚合</span></span><br><span class="line">    carData.keyBy(<span class="number">0</span>)</span><br><span class="line">        .countWindow(<span class="number">5</span>)</span><br><span class="line">        .sum(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//.print()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2对每个路口分别统计,统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现3次进行统计</span></span><br><span class="line">    carData.keyBy(<span class="number">0</span>)</span><br><span class="line">        .countWindow(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">        .sum(<span class="number">1</span>)</span><br><span class="line">        .print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.启动执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于sliding-count-window，又比如假设有一个滑动计数窗口，每2个元素计算一次最近4个元素的总和，此时窗口长度为4，滑动间隔为2，那么窗口工作示意图如下所示：</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513204137999.png" style="zoom:67%;"></p>
<p>按照上述逻辑实现的字符串相加的示例代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.utils.ParameterTool;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.ReduceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkCountWindowDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ParameterTool params = ParameterTool.fromArgs(args);</span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.getConfig().setGlobalJobParameters(params);</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> windowSize = params.getInt(<span class="string">&quot;window&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> slideSize = params.getInt(<span class="string">&quot;slide&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read source data</span></span><br><span class="line">        DataStreamSource&lt;Tuple2&lt;String, String&gt;&gt; inStream = env.addSource(<span class="keyword">new</span> StreamDataSource());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, String&gt;&gt; outStream = </span><br><span class="line">        inStream</span><br><span class="line">        .keyBy(<span class="number">0</span>)</span><br><span class="line">        .countWindow(windowSize, slideSize)</span><br><span class="line">        .reduce(</span><br><span class="line">        <span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, String&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, String&gt; value1, Tuple2&lt;String, String&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> Tuple2.of(value1.f0, value1.f1 + <span class="string">&quot;&quot;</span> + value2.f1);</span><br><span class="line">                                                                   &#125;</span><br><span class="line">                                                               &#125;</span><br><span class="line">                                                           );</span><br><span class="line">        outStream.print();</span><br><span class="line">        env.execute(<span class="string">&quot;WindowWordCount&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="time">Time</h3>
<h4 id="时间分类">时间分类</h4>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513211157290.png" style="zoom:67%;"></p>
<ul>
<li><p><strong>EventTime</strong> 事件时间</p>
<p>事件发生的时间，例如：点击网站上的某个链接的时间，每一条日志都会记录自己的生成时间。</p>
<p>如果以EventTime为基准来定义时间窗口那将形成EventTimeWindow,要求消息本身就应该携带EventTime。</p>
<p>EvenetTime通常使用</p></li>
<li><p><strong>IngestionTime</strong> 摄入时间</p>
<p>数据进入Flink的时间，即某个Flink节点的source operator接收到数据的时间，例如：某个source消费到kafka中的数据的时间。</p>
<p>如果以IngesingtTime为基准来定义时间窗口那将形成IngestingTimeWindow，以source的系统时间为准。</p></li>
<li><p><strong>ProcessingTime</strong> 处理时间</p>
<p>某个Flink节点执行某个operation的时间，例如：timeWindow处理数据时的系统时间，默认的时间属性就是ProcessingTime</p>
<p>如果以ProcessingTime基准来定义时间窗口那将形成ProcessingTimeWindow，以operator的系统时间为准。</p></li>
</ul>
<p>在Flink的流式处理中，绝大部分的业务都会使用EventTime，一般只在EventTime无法使用时，才会被迫使用ProcessingTime或者IngestionTime。<strong>如果要使用EventTime，那么需要引入EventTime的时间属性</strong>，引入方式如下所示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>) <span class="comment">//设置使用事件时间</span></span><br></pre></td></tr></table></figure>
<h4 id="watermark-水位线">Watermark 水位线</h4>
<p>Watermark是一种机制，用来解决数据延迟到达时因为窗口关闭无法计算数据的问题。Watermark需要和窗口机制Window配合起来使用。</p>
<p>Watermark本质上是一个时间戳，只能是单项递增的，用来判断究竟哪些窗口需要关闭。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210515151731959.png" style="zoom:67%;"></p>
<h5 id="理解">理解</h5>
<p>Watermark表示最大允许数据延迟达到多久，任何窗口结束时间<strong>小于等于</strong>这个Watermark的窗口，都需要被关闭并进行计算，简单理解来看就是 <strong>水位线 = 事件时间 - 延迟时间</strong>：</p>
<blockquote>
<p>Watermark = Event Time - Delay Time</p>
<p>10:09:57 = 10:10:00 - 3s</p>
</blockquote>
<p>Watermark通常使用在基于Event Time数据的场景，这种数据自身需要包含一个timestamp，例如1472693399700（2016-09-01 09:29:<strong>59</strong>.700），代表这个数据的Event Time，而这条数据的Watermark则可能是：</p>
<p>Watermark(1472693399700) = 1472693396700 (2016-09-01 09:29:<strong>56</strong>.700)</p>
<p>这个Watermark代表的含义是，timestamp小于1472693396700 (2016-09-01 09:29:<strong>56</strong>.700) 的数据，都已经到达了。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210515144519581.png" style="zoom:67%;"></p>
<p>上图表示了一组数据到达某个Operator时，水位线变化情况以及数据的计算。</p>
<p>纵轴表示Processing Time，<strong>这是每个数据到达Operator的时间</strong>，也可以认为是当前系统的时间。</p>
<p>横轴表示Event Time，这是每个数据的产生时间。</p>
<p>由图可以看出出，理想情况下数据一产生就被处理，因此理想的Watermark中，Processing Time = Event Time表示没有任何延迟。</p>
<p>但是实际情况下可能产生延迟，此时 Event Time - Delay Time = Actual Watermark。可以看到，当实际时间是12:06的时候，水位线触发了第一个窗口的计算，<strong>也就是12:06分到达的某个数据，它的 Event Time - Delay Time恰好等于12:02，把水位线提高了</strong>，因此触发了第一个窗口的计算，使得窗口关闭，该窗口的计算总和为5。（注意这里水位线的单位并不是纵轴的Processing Time，也不是横轴的Event Time，<strong>它只代表了当前有某个数据到达了，触发了当前窗口的计算，只有这个水位线下面的数值才能参与计算</strong>）</p>
<p>当实际时间是12:08分多几秒的时候，可以看到标定为9的数据，虽然它的Event Time在12:01至12:02之间，可是此时它在水位线的上方，窗口已经关闭，因此无法参与计算。</p>
<p>总之，水位线的工作流程可以看成：</p>
<blockquote>
<p>1、一组数据流到来，根据数据流中数据的Event Time判断该数据属于哪个窗口，并将数据分配到这个窗口。</p>
<p>2、在数据流到来的同时每隔一定时间（定期水位线）根据这段时间内的所有数据计算出一个水位线。</p>
<p>3、将水位线以下的窗口进行数据计算，并关闭这个窗口，完成计算。</p>
</blockquote>
<h5 id="解决问题">解决问题</h5>
<p>Watermark是用于处理<strong>乱序</strong>事件的，通常用Watermark机制结合Window来实现。</p>
<blockquote>
<p>流处理从事件产生，到流经source，再到operator，中间是有一个过程和时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生（out-of-order或者说late element）。</p>
<p>对于late element，不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发window去进行计算，这个机制就是Watermark。</p>
</blockquote>
<h5 id="窗口的开始和结束时间">窗口的开始和结束时间</h5>
<p>TimeWindow extends Window；TumblingEventTimeWindows调用了TimeWindow 中的getWindowStartWithOffset(timestamp, offset, size)方法，获得窗口的开始时间。</p>
<blockquote>
<p>https://github.com/apache/flink/blob/master/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/assigners/TumblingEventTimeWindows.java</p>
<p>https://github.com/apache/flink/blob/d241759b89ae3455afae5e434a9384ebdc3c1f5f/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/windows/TimeWindow.java#L264</p>
</blockquote>
<p>TimeWindow类中写明了一个窗口的开始时间的计算方法，其中 timestamp 就是数据的EventTime，windowSize就是窗口的大小。<strong>即窗口的开始时间取决于第一条数据的EventTime</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method to get the window start for a timestamp.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp epoch millisecond to get the window start.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset The offset which window start would be shifted by.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> windowSize The size of the generated windows.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> window start</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getWindowStartWithOffset</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">long</span> offset, <span class="keyword">long</span> windowSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>窗口的结束时间就是开始时间+窗口大小</strong>。</p>
<h5 id="watermark-api">Watermark API</h5>
<p>Flink中可以通过调用 DataStream 中的两个 API 来提取时间和分配Watermark，它们被称为水位线分配器，分别是 AssignerWithPunctuatedWatermarks 和 AssignerWithPeriodicWatermarks：</p>
<ul>
<li><p>标点水位线(Punctuated Watermark)</p>
<p>标点水位线（Punctuated Watermark）通过<strong>数据流中某些特殊标记事件来触发新Watermark</strong>的生成**。这种方式下窗口的触发与时间无关，而是决定于何时收到标记事件。</p>
<p>在实际的生产中Punctuated方式在TPS很高的场景下会产生大量的Watermark在一定程度上对下游算子造成压力，所以只有在实时性要求非常高的场景才会选择Punctuated的方式进行Watermark的生成。</p>
<p>对应接口<strong>AssignerWithPunctuatedWatermarks</strong>。</p></li>
<li><p>定期水位线(Periodic Watermark) <strong>周期性的（允许一定时间间隔或者达到一定的记录条数）产生一个Watermark</strong>。水位线提升的时间间隔是由用户设置的，在两次水位线提升时隔内会有一部分消息流入，用户可以根据这部分数据来计算出新的水位线。</p>
<p>举个例子，最简单的水位线算法就是取目前为止最大的事件时间。比如时间间隔是200ms，在这200ms内流入的所有数据中，取它们最大的Evenet Time，然后计算出Watermark，然后根据这个Watermark判断有哪些窗口需要被关闭进行计算。然而这种方式比较暴力，对乱序事件的容忍程度比较低，容易出现大量迟到事件。</p>
<p>在实际的生产中Periodic的方式必须结合时间和积累条数两个维度继续周期性产生Watermark，否则在极端情况下会有很大的延时。</p>
<p>对应接口<strong>AssignerWithPeriodicWatermarks</strong>。</p></li>
</ul>
<p>基本步骤是：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定为evenTime时间语义</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"><span class="comment">//生成watermark的周期</span></span><br><span class="line">env.getConfig.setAutoWatermarkInterval(watermarkInterval)</span><br><span class="line"><span class="comment">//指定方式</span></span><br><span class="line">dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">Element</span>](<span class="type">Time</span>.seconds(allowDealy)) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">Element</span>): <span class="type">Long</span> = element.dT <span class="comment">//该方法用来提取数据流中的EventTime</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>使用定期水位线的案例如下，简单来说，需要先在数据流中定义水位线的插入方式，再定义窗口及其处理函数。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.timestamps.<span class="type">BoundedOutOfOrdernessTimestampExtractor</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">WindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示使用周期性方式生成Watermark</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求：</span></span><br><span class="line"><span class="comment">编写代码, 计算5秒内（滚动时间窗口），每个信号灯汽车数量</span></span><br><span class="line"><span class="comment">信号灯数据(信号ID(String)、通过汽车数量、时间戳(事件时间))，要求添加Watermark来解决网络延迟问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 创建流处理运行环境</span></span><br><span class="line"><span class="comment">2. 设置处理时间为EventTime，设置Watermark的周期间隔，定期生成Watermark的时间</span></span><br><span class="line"><span class="comment">3. 定义CarWc 样例类</span></span><br><span class="line"><span class="comment">4. 使用socketstream发送数据</span></span><br><span class="line"><span class="comment">5. 添加Watermark</span></span><br><span class="line"><span class="comment">   - 允许延迟2秒</span></span><br><span class="line"><span class="comment">   - 在获取Watermark方法中，打印Watermark时间、事件时间和当前系统时间</span></span><br><span class="line"><span class="comment">6. 按照用户进行分流</span></span><br><span class="line"><span class="comment">7. 设置5秒的时间窗口</span></span><br><span class="line"><span class="comment">8. 进行聚合计算</span></span><br><span class="line"><span class="comment">9. 打印结果数据</span></span><br><span class="line"><span class="comment">10. 启动执行流处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义CarWc 样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">id: <span class="type">String</span>, num: <span class="type">Int</span>, ts: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">WatermarkDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//创建流处理运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//设置处理时间为事件时间，</span></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">    <span class="comment">//生成Watermark的周期 默认200ms</span></span><br><span class="line">    env.getConfig.setAutoWatermarkInterval(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认程序并行度是机器的核数，8个并行度，注意在flink程序中如果是多并行度</span></span><br><span class="line">    <span class="comment">// Watermark时间是每个并行度下所有数据比较之后，最小的Watermark作为当前流的统一Watermark</span></span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加socketsource</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">    <span class="keyword">val</span> carWcDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketDs.map(</span><br><span class="line">      line =&gt; &#123;</span><br><span class="line">        <span class="comment">//按照逗号切分数据组成carwc</span></span><br><span class="line">        <span class="keyword">val</span> arr = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="type">CarWc</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>).trim.toInt, arr(<span class="number">2</span>).trim.toLong)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// ****添加Watermark****</span></span><br><span class="line">    <span class="comment">// 调用DataStream中assignTimestampsAndWatermarks添加Watermark</span></span><br><span class="line">    <span class="comment">// 分配周期性水位线的接口为AssignerWithPeriodicWatermarks </span></span><br><span class="line">    <span class="comment">// 使用其子类BoundedOutOfOrdernessTimestampExtractor</span></span><br><span class="line">    <span class="comment">// 该子类策略就是最大EventTime作为Watermark，构造参数：Watermark允许的延迟时间,泛型是stream中的数据类型</span></span><br><span class="line">    <span class="keyword">val</span> watermarkDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carWcDs.assignTimestampsAndWatermarks(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">CarWc</span>](<span class="type">Time</span>.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// Watermark机制是在eventtime基础之上减去一段时间，就是flink允许数据延迟的范围</span></span><br><span class="line">        <span class="comment">// eventtime是来自数据，flink是不知道eventtime是多少，以及是哪个字段</span></span><br><span class="line">        <span class="comment">// 这个方法就是告诉flink数据哪个字段是eventime</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">CarWc</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">          element.ts</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 设置窗口 5s的滚动窗口</span></span><br><span class="line">    <span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[<span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = </span><br><span class="line">      watermarkDs.keyBy(<span class="number">0</span>).</span><br><span class="line">      window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>)))</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用apply方法对窗口进行计算</span></span><br><span class="line">    <span class="keyword">val</span> windowDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = windowStream.apply(</span><br><span class="line">      <span class="comment">//泛型：1 carwc,2 carwc,3 tuple,4 timewindow</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">WindowFunction</span>[<span class="type">CarWc</span>, <span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">        <span class="comment">//key:tuple,window:当前触发计算的window对象，input:当前窗口的数据，out:计算结果收集器</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(key: <span class="type">Tuple</span>, window: <span class="type">TimeWindow</span>, input: <span class="type">Iterable</span>[<span class="type">CarWc</span>], out: <span class="type">Collector</span>[<span class="type">CarWc</span>]): 			<span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> wc: <span class="type">CarWc</span> = input.reduce(</span><br><span class="line">            (c1, c2) =&gt; &#123;</span><br><span class="line">              <span class="type">CarWc</span>(c1.id, c1.num + c2.num, c2.ts) <span class="comment">//累加出通过的汽车数量，关于时间在这里我们不关心</span></span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">          <span class="comment">//发送计算结果</span></span><br><span class="line">          out.collect(wc)</span><br><span class="line">          <span class="comment">//获取到窗口开始和结束时间</span></span><br><span class="line">          println(<span class="string">&quot;窗口开始时间》》&quot;</span> + window.getStart + <span class="string">&quot;=====;窗口结束时间》》&quot;</span> + window.getEnd + <span class="string">&quot;;窗口中的数					  据》》&quot;</span> + input.iterator.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    windowDs.print()</span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自定义定期水位线的分配器：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.<span class="type">AssignerWithPeriodicWatermarks</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">WindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.watermark.<span class="type">Watermark</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示使用周期性方式生成水印 -复杂版本--手动实现watermark机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">id: <span class="type">String</span>, num: <span class="type">Int</span>, ts: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">WatermarkDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建流处理运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 设置处理时间为事件时间，</span></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">    <span class="comment">// 生成水印的周期 默认200ms</span></span><br><span class="line">    env.getConfig.setAutoWatermarkInterval(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认程序并行度是机器的核数，8个并行度，注意在flink程序中如果是多并行度</span></span><br><span class="line">    <span class="comment">// Watermark时间是每个并行度下所有数据比较之后，最小的Watermark作为当前流的统一Watermark</span></span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加socketsource</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">// 数据处理</span></span><br><span class="line">    <span class="keyword">val</span> carWcDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketDs.map(</span><br><span class="line">      line =&gt; &#123;</span><br><span class="line">        <span class="comment">//按照逗号切分数据组成carwc</span></span><br><span class="line">        <span class="keyword">val</span> arr = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="type">CarWc</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>).trim.toInt, arr(<span class="number">2</span>).trim.toLong)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ****添加Watermark****</span></span><br><span class="line">    <span class="comment">// 添加周期性水位线  </span></span><br><span class="line">    <span class="comment">// new AssignerWithPeriodicWatermarks&#123;&#125; 通过匿名内部类方式实现这个这个接口</span></span><br><span class="line">    <span class="comment">//参照子类BoundedOutOfOrdernessTimestampExtractor的写法</span></span><br><span class="line">    <span class="keyword">val</span> watermarkDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carWcDs.assignTimestampsAndWatermarks(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">AssignerWithPeriodicWatermarks</span>[<span class="type">CarWc</span>] &#123;</span><br><span class="line">        <span class="comment">// watermark=eventtime -延迟时间</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 定义允许延迟的时间 2s</span></span><br><span class="line">        <span class="keyword">val</span> delayTime=<span class="number">2000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义当前最大的时间戳</span></span><br><span class="line">        <span class="keyword">var</span> currentMaxTimestamp=<span class="number">0</span>L</span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** The timestamp of the last emitted watermark. */</span></span><br><span class="line">         <span class="keyword">var</span> lastEmittedWatermark = <span class="type">Long</span>.<span class="type">MinValue</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// todo 获取watermark时间  实现watermark不会倒退</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">          <span class="comment">// 计算watermark</span></span><br><span class="line">          <span class="keyword">val</span> watermarkTime: <span class="type">Long</span> = currentMaxTimestamp - delayTime</span><br><span class="line">          <span class="keyword">if</span> (watermarkTime &gt;lastEmittedWatermark)&#123;</span><br><span class="line">            lastEmittedWatermark =watermarkTime</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">new</span> <span class="type">Watermark</span>(lastEmittedWatermark)</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//todo 抽取时间戳 element:新到达的元素，previousElementTimestamp：之前元素的时间戳</span></span><br><span class="line">        <span class="comment">// 抽取时间戳 计算watermark</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">CarWc</span>, previousElementTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">          <span class="comment">//获取到时间</span></span><br><span class="line">          <span class="comment">//注意的问题：时间倒退的问题：消息过来是乱序的，每次新来的消息时间戳不是一定变大的，所以会导致水印有可能倒退</span></span><br><span class="line">          <span class="keyword">var</span> eventTime = element.ts</span><br><span class="line">          <span class="keyword">if</span> (eventTime &gt;currentMaxTimestamp)&#123;  <span class="comment">//比较与之前最大的时间戳进行比较</span></span><br><span class="line">            currentMaxTimestamp =eventTime</span><br><span class="line">          &#125;</span><br><span class="line">          eventTime</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 设置窗口 5s的滚动窗口</span></span><br><span class="line">    <span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[<span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = </span><br><span class="line">      watermarkDs.keyBy(<span class="number">0</span>).</span><br><span class="line">      window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>)))</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用apply方法对窗口进行计算</span></span><br><span class="line">    <span class="keyword">val</span> windowDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = windowStream.apply(</span><br><span class="line">      <span class="comment">//泛型：1 carwc,2 carwc,3 tuple,4 timewindow</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">WindowFunction</span>[<span class="type">CarWc</span>, <span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">        <span class="comment">//key:tuple,window:当前触发计算的window对象，input:当前窗口的数据，out:计算结果收集器</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(key: <span class="type">Tuple</span>, window: <span class="type">TimeWindow</span>, input: <span class="type">Iterable</span>[<span class="type">CarWc</span>], out: <span class="type">Collector</span>[<span class="type">CarWc</span>]): 			<span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> wc: <span class="type">CarWc</span> = input.reduce(</span><br><span class="line">            (c1, c2) =&gt; &#123;</span><br><span class="line">              <span class="type">CarWc</span>(c1.id, c1.num + c2.num, c2.ts) <span class="comment">//累加出通过的汽车数量，关于时间在这里我们不关心</span></span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">          <span class="comment">//发送计算结果</span></span><br><span class="line">          out.collect(wc)</span><br><span class="line">          <span class="comment">//获取到窗口开始和结束时间</span></span><br><span class="line">          println(<span class="string">&quot;窗口开始时间》》&quot;</span> + window.getStart + <span class="string">&quot;=====;窗口结束时间》》&quot;</span> + window.getEnd + <span class="string">&quot;;窗口中的数					  据》》&quot;</span> + input.iterator.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    windowDs.print()</span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="watermark-源码">Watermark 源码</h5>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210515134823755.png" style="zoom: 67%;"></p>
<h4 id="allowedlateness与侧道输出">allowedLateness与侧道输出</h4>
<p>当数据的延迟太久的时候，即使存在Watermark也无法处理延迟到达的数据，因为窗口已经关闭了，此时数据被丢弃。因此通过如下两种策略进行数据延迟的更多处理：</p>
<ul>
<li><p>allowedLateness(lateness: Time)</p>
<p>这种方式设置的允许延迟时间与水印的延迟时间是一个累加的效果。</p>
<p>但是注意这个时间并不会影响窗口触发计算的标准，当Watermark &gt;= Window-EndTime依旧会触发计算。</p>
<p>只是如果这设置了这个时间，窗口不会关闭和销毁而是继续等待，直到到达总的延迟时间为止，窗口才会关闭。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置允许延迟时间  --》在Watermark基础上再次增加允许延迟时间</span></span><br><span class="line"><span class="type">WindowedStream</span>.allowedLateness(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>侧道输出</p>
<p>这种机制能够将极端延迟的数据（就是找不到对应窗口的那些数据）保存起来，之后可以再取出。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置侧道输出</span></span><br><span class="line"><span class="keyword">val</span> outputTag: <span class="type">OutputTag</span>[<span class="type">CarWc</span>] = <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">CarWc</span>](<span class="string">&quot;lateCarwc&quot;</span>)</span><br><span class="line"><span class="type">WindowedStream</span>.sideOutputLateData(outputTag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取侧道输出</span></span><br><span class="line"><span class="type">DataStream</span>.getSideOutput(outputTag)      </span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用allowedLateness与侧道输出的案例为：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.<span class="type">AssignerWithPeriodicWatermarks</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">WindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.watermark.<span class="type">Watermark</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示使用周期性方式生成水印 -复杂版本--手动实现watermark机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">id: <span class="type">String</span>, num: <span class="type">Int</span>, ts: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">WatermarkDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建流处理运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 设置处理时间为事件时间，</span></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">    <span class="comment">// 生成水印的周期 默认200ms</span></span><br><span class="line">    env.getConfig.setAutoWatermarkInterval(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认程序并行度是机器的核数，8个并行度，注意在flink程序中如果是多并行度</span></span><br><span class="line">    <span class="comment">// Watermark时间是每个并行度下所有数据比较之后，最小的Watermark作为当前流的统一Watermark</span></span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加socketsource</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">// 数据处理</span></span><br><span class="line">    <span class="keyword">val</span> carWcDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketDs.map(</span><br><span class="line">      line =&gt; &#123;</span><br><span class="line">        <span class="comment">//按照逗号切分数据组成carwc</span></span><br><span class="line">        <span class="keyword">val</span> arr = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="type">CarWc</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>).trim.toInt, arr(<span class="number">2</span>).trim.toLong)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ****添加Watermark****</span></span><br><span class="line">    <span class="comment">// 添加周期性水位线  </span></span><br><span class="line">    <span class="comment">// new AssignerWithPeriodicWatermarks&#123;&#125; 通过匿名内部类方式实现这个这个接口</span></span><br><span class="line">    <span class="comment">//参照子类BoundedOutOfOrdernessTimestampExtractor的写法</span></span><br><span class="line">    <span class="keyword">val</span> watermarkDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carWcDs.assignTimestampsAndWatermarks(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">AssignerWithPeriodicWatermarks</span>[<span class="type">CarWc</span>] &#123;</span><br><span class="line">        <span class="comment">// watermark=eventtime -延迟时间</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 定义允许延迟的时间 2s</span></span><br><span class="line">        <span class="keyword">val</span> delayTime=<span class="number">2000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义当前最大的时间戳</span></span><br><span class="line">        <span class="keyword">var</span> currentMaxTimestamp=<span class="number">0</span>L</span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** The timestamp of the last emitted watermark. */</span></span><br><span class="line">         <span class="keyword">var</span> lastEmittedWatermark = <span class="type">Long</span>.<span class="type">MinValue</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// todo 获取watermark时间  实现watermark不会倒退</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">          <span class="comment">// 计算watermark</span></span><br><span class="line">          <span class="keyword">val</span> watermarkTime: <span class="type">Long</span> = currentMaxTimestamp - delayTime</span><br><span class="line">          <span class="keyword">if</span> (watermarkTime &gt;lastEmittedWatermark)&#123;</span><br><span class="line">            lastEmittedWatermark =watermarkTime</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">new</span> <span class="type">Watermark</span>(lastEmittedWatermark)</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//todo 抽取时间戳 element:新到达的元素，previousElementTimestamp：之前元素的时间戳</span></span><br><span class="line">        <span class="comment">// 抽取时间戳 计算watermark</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">CarWc</span>, previousElementTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">          <span class="comment">//获取到时间</span></span><br><span class="line">          <span class="comment">//注意的问题：时间倒退的问题：消息过来是乱序的，每次新来的消息时间戳不是一定变大的，所以会导致水印有可能倒退</span></span><br><span class="line">          <span class="keyword">var</span> eventTime = element.ts</span><br><span class="line">          <span class="keyword">if</span> (eventTime &gt;currentMaxTimestamp)&#123;  <span class="comment">//比较与之前最大的时间戳进行比较</span></span><br><span class="line">            currentMaxTimestamp =eventTime</span><br><span class="line">          &#125;</span><br><span class="line">          eventTime</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 设置窗口</span></span><br><span class="line">    <span class="keyword">val</span> outputTag: <span class="type">OutputTag</span>[<span class="type">CarWc</span>] = <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">CarWc</span>](<span class="string">&quot;lateCarwc&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[<span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = </span><br><span class="line">      watermarkDs.keyBy(<span class="number">0</span>)</span><br><span class="line">      .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>)))</span><br><span class="line">      <span class="comment">//设置允许延迟时间  --》在Watermark基础上再次增加允许延迟时间</span></span><br><span class="line">      .allowedLateness(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">      <span class="comment">//设置侧道输出</span></span><br><span class="line">      .sideOutputLateData(outputTag)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用apply方法对窗口进行计算</span></span><br><span class="line">    <span class="keyword">val</span> windowDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = windowStream.apply(</span><br><span class="line">      <span class="comment">//泛型：1 carwc,2 carwc,3 tuple,4 timewindow</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">WindowFunction</span>[<span class="type">CarWc</span>, <span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">        <span class="comment">//key:tuple,window:当前触发计算的window对象，input:当前窗口的数据，out:计算结果收集器</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(key: <span class="type">Tuple</span>, window: <span class="type">TimeWindow</span>, input: <span class="type">Iterable</span>[<span class="type">CarWc</span>], out: <span class="type">Collector</span>[<span class="type">CarWc</span>]): 			<span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> wc: <span class="type">CarWc</span> = input.reduce(</span><br><span class="line">            (c1, c2) =&gt; &#123;</span><br><span class="line">              <span class="type">CarWc</span>(c1.id, c1.num + c2.num, c2.ts) <span class="comment">//累加出通过的汽车数量，关于时间在这里我们不关心</span></span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">          <span class="comment">//发送计算结果</span></span><br><span class="line">          out.collect(wc)</span><br><span class="line">          <span class="comment">//获取到窗口开始和结束时间</span></span><br><span class="line">          println(<span class="string">&quot;窗口开始时间》》&quot;</span> + window.getStart + <span class="string">&quot;=====;窗口结束时间》》&quot;</span> + window.getEnd + <span class="string">&quot;;窗口中的数					  据》》&quot;</span> + input.iterator.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    windowDs.print()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取侧道输出的数据</span></span><br><span class="line">    <span class="keyword">val</span> lateCarWc: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = windowDs.getSideOutput(outputTag)</span><br><span class="line">    lateCarWc.printToErr(<span class="string">&quot;侧道输出数据》》&quot;</span>)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://zhuanlan.zhihu.com/p/342854047 （CountWindow）</p>
<p>https://blog.csdn.net/xsdxs/article/details/82726031 （CountWindow）</p>
<p>https://zhuanlan.zhihu.com/p/102325190 （窗口）</p>
<p>https://blog.csdn.net/xsdxs/article/details/82415450 （窗口开始时间）</p>
<p>https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43864.pdf （Watermark图）</p>
<p>https://www.cnblogs.com/rossiXYZ/p/12286407.html</p>
<p>https://www.jianshu.com/p/a883262241ef</p>
<p>https://blog.csdn.net/lmalds/article/details/52704170</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive DML</title>
    <url>/2021/07/25/Hive_DML/</url>
    <content><![CDATA[<p>DML（Data Manipulation Language）数据操作语言用于定义数据的基本操作，SQL中处理数据等操作统称为数据操纵语言，简而言之就是实现了基本的“增删改查”操作。</p>
<a id="more"></a>
<h2 id="load">load</h2>
<h3 id="基础">基础</h3>
<p>当在Hive中创建好表之后，就会在HDFS上创建一个与之对应的文件夹，要想让hive的表和结构化的数据文件产生映射，就需要把文件移到到表对应的文件夹下面，当然，可以在建表的时候使用location语句指定数据文件的路径。但是不管路径在哪里，必须把数据文件移动到对应的路径下面。</p>
<p>最原始暴力直接的方式就是使用hadoop fs –put等方式将数据移动到路径下面。</p>
<p>Hive官方推荐<strong>使用Load命令将数据加载到表中</strong>。</p>
<h3 id="语法">语法</h3>
<p>在将数据load加载到表中时，Hive不会进行任何转换。</p>
<p><strong>加载操作是将数据文件移动到与Hive表对应的位置的纯复制/移动操作</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)]</span><br><span class="line"></span><br><span class="line">LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)] [INPUTFORMAT &#39;inputformat&#39; SERDE &#39;serde&#39;] (3.0 or later)</span><br></pre></td></tr></table></figure>
<h4 id="filepath">filepath</h4>
<p>filepath表示的待移动数据的路径，可以引用一个文件（在这种情况下，Hive将文件移动到表中），也可以是一个目录（在这种情况下，Hive将把该目录中的所有文件移动到表中）。</p>
<p>相对路径，例如：project/data1</p>
<p>绝对路径，例如：/user/hive/project/data1</p>
<p>具有schema的完整URI，例如：hdfs://namenode:9000/user/hive/project/data1</p>
<h4 id="local">local</h4>
<p>如果指定了LOCAL， <strong>load命令将在本地文件系统中查找文件路径</strong>。如果指定了相对路径，它将相对于用户的当前工作目录进行解释。用户也可以为本地文件指定完整的URI-例如：file:///user/hive/project/data1。</p>
<p>注意，如果对HiveServer2服务运行此命令。这里的本地文件系统指的是Hiveserver2<strong>服务所在机器的本地Linux文件系统</strong>，<strong>不是Hive客户端所在的本地文件系统</strong>。</p>
<p>如果没有指定LOCAL关键字，如果filepath指向的是一个完整的URI，hive会直接使用这个URI。 否则如果没有指定schema或者authority，Hive会使用在hadoop配置文件中定义的schema 和 authority，即参数fs.default.name指定（不出意外，都是HDFS）。</p>
<p><strong>overwrite</strong></p>
<p>如果使用了OVERWRITE关键字，则目标表（或者分区）中的内容会被删除，然后再将 filepath 指向的文件/目录中的内容添加到表/分区中。</p>
<h4 id="案例">案例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- ------Load Data From Local FS or HDFS------</span><br><span class="line">-- step1:建表</span><br><span class="line">-- 建表student_local 用于演示从本地加载数据</span><br><span class="line">create table student_local(</span><br><span class="line">    num int,name string,sex string,age int,dept string) </span><br><span class="line">    row format delimited fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">-- 建表student_HDFS  用于演示从HDFS加载数据</span><br><span class="line">create external table student_HDFS(</span><br><span class="line">    num int,name string,sex string,age int,dept string) </span><br><span class="line">    row format delimited fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">-- 建表student_HDFS_p 用于演示从HDFS加载数据到分区表</span><br><span class="line">create table student_HDFS_p(</span><br><span class="line">    num int,name string,sex string,age int,dept string) </span><br><span class="line">    partitioned by(country string) </span><br><span class="line">    row format delimited fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">-- 建议使用beeline客户端 可以显示出加载过程日志信息</span><br><span class="line">-- step2:加载数据</span><br><span class="line">-- 从本地加载数据  数据位于HS2（node1）本地文件系统  本质是hadoop fs -put上传操作</span><br><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;root&#x2F;hivedata&#x2F;students.txt&#39; INTO TABLE student_local;</span><br><span class="line"></span><br><span class="line">-- 从HDFS加载数据  数据位于HDFS文件系统根目录下  本质是hadoop fs -mv 移动操作</span><br><span class="line">-- 先把数据上传到HDFS上  hadoop fs -put &#x2F;root&#x2F;hivedata&#x2F;students.txt &#x2F;</span><br><span class="line">LOAD DATA INPATH &#39;&#x2F;students.txt&#39; INTO TABLE student_HDFS;</span><br><span class="line"></span><br><span class="line">-- --从HDFS加载数据到分区表中并制定分区  数据位于HDFS文件系统根目录下</span><br><span class="line">-- 先把数据上传到HDFS上 hadoop fs -put &#x2F;root&#x2F;hivedata&#x2F;students.txt &#x2F;</span><br><span class="line">LOAD DATA INPATH &#39;&#x2F;students.txt&#39; INTO TABLE student_HDFS_p partition(country &#x3D;&quot;CHina&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="新特性">3.0 新特性</h3>
<p>Hive 3.0及更高版本中，除了移动复制操作之外，还支持其他加载操作，因为Hive在内部在某些场合下会将加载重写为INSERT AS SELECT。</p>
<p>比如，如果表具有分区，则load命令没有指定分区，则将load转换为INSERT AS SELECT，并<strong>假定最后一组列为分区列</strong>。如果文件不符合预期的架构，它将引发错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- -----hive 3.0 load命令新特性------------------</span><br><span class="line">CREATE TABLE if not exists tab1 (col1 int, col2 int)</span><br><span class="line">PARTITIONED BY (col3 int)</span><br><span class="line">row format delimited fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;root&#x2F;hivedata&#x2F;tab1.txt&#39; INTO TABLE tab1;</span><br><span class="line"></span><br><span class="line">-- tab1.txt内容如下</span><br><span class="line">11,22,1</span><br><span class="line">33,44,2</span><br></pre></td></tr></table></figure>
<p>本来加载的时候没有指定分区，语句是报错的，但是文件的格式符合表的结构，前两个是col1,col2,最后一个是分区字段col3，则此时会将load语句转换成为insert as select语句。</p>
<p>在Hive3.0中，还支持使用inputformat、SerDe指定任何Hive输入格式，例如文本，ORC等。</p>
<h2 id="insert-select">insert + select</h2>
<h3 id="基础-1">基础</h3>
<p>Hive中insert主要是结合select查询语句使用，<strong>将查询结果插入到表中</strong>。</p>
<h3 id="语法-1">语法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT OVERWRITE TABLE tablename1 </span><br><span class="line">[PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...) [IF NOT EXISTS]] select_statement1 FROM from_statement;</span><br><span class="line"></span><br><span class="line">INSERT INTO TABLE tablename1 </span><br><span class="line">[PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)] select_statement1 FROM from_statement;</span><br></pre></td></tr></table></figure>
<p>INSERT OVERWRITE将覆盖表或分区中的任何现有数据。</p>
<p>需要保证查询结果列的数目和需要插入数据表格的列数目一致。如果查询出来的数据类型和插入表格对应的列数据类型不一致，将会进行转换，但是不能保证转换一定成功，转换失败的数据将会为NULL。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- step1:创建一张源表student</span><br><span class="line">drop table if exists student;</span><br><span class="line">create table student(</span><br><span class="line">    num int,name string,sex string,age int,dept string)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">-- 加载数据</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;students.txt&#39; into table student;</span><br><span class="line"></span><br><span class="line">-- step2：创建一张目标表  只有两个字段</span><br><span class="line">create table student_from_insert(sno int,sname string);</span><br><span class="line"></span><br><span class="line">-- 使用insert+select插入数据到新表中</span><br><span class="line">insert into table student_from_insert select num,name from student;</span><br><span class="line"></span><br><span class="line">select * from student_insert1;</span><br></pre></td></tr></table></figure>
<h3 id="多重插入">多重插入</h3>
<p>从一个表中，写多个查询逻辑，并将结果输出到多个不同表（分区）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- ----------multiple inserts----------------------</span><br><span class="line">-- 当前库下已有一张表student</span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line">-- 创建两张新表</span><br><span class="line">create table student_insert1(sno int);</span><br><span class="line">create table student_insert2(sname string);</span><br><span class="line"></span><br><span class="line">-- 多重插入</span><br><span class="line">from student</span><br><span class="line">insert overwrite table student_insert1</span><br><span class="line">select num</span><br><span class="line">insert overwrite table student_insert2</span><br><span class="line">select name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态分区插入">动态分区插入</h3>
<p>对于分区表的数据导入加载，最常见最基础的是通过load命令加载数据。假如说现在有全球224个国家的人员名单（每个国家名单单独一个文件），导入数据到分区表中，不同国家不同分区，不可能使用load语法导入224次。</p>
<p>为此，Hive提供了动态分区插入的语法。</p>
<p>所谓动态分区插入指的是：<strong>分区的值是由后续的select查询语句的结果来动态确定的。根据查询结果自动分区</strong>。</p>
<p>配置参数</p>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 6%">
<col style="width: 61%">
</colgroup>
<tbody>
<tr class="odd">
<td>hive.exec.dynamic.partition</td>
<td>true</td>
<td>需要设置true为启用动态分区插入</td>
</tr>
<tr class="even">
<td>hive.exec.dynamic.partition.mode</td>
<td>strict</td>
<td>在strict模式下，用户必须至少指定一个静态分区，以防用户意外覆盖所有分区；在nonstrict模式下，允许所有分区都是动态的</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM page_view_stg pvs</span><br><span class="line">INSERT OVERWRITE TABLE page_view PARTITION(dt&#x3D;&#39;2008-06-08&#39;, country)</span><br><span class="line">SELECT pvs.viewTime, pvs.userid, pvs.page_url, pvs.referrer_url, null, null, pvs.ip, pvs.cnt</span><br><span class="line"></span><br><span class="line">-- 在这里，country分区将由SELECT子句（即pvs.cnt）的最后一列动态创建。</span><br><span class="line">-- 而dt分区是手动指定写死的。</span><br><span class="line">-- 如果是nonstrict模式下，dt分区也可以动态创建。</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 动态分区插入</span><br><span class="line">-- 1、首先设置动态分区模式为非严格模式 默认已经开启了动态分区功能</span><br><span class="line">set hive.exec.dynamic.partition &#x3D; true;</span><br><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict;</span><br><span class="line"></span><br><span class="line">-- 2、当前库下已有一张表student</span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line">-- 3、创建分区表 以sdept作为分区字段</span><br><span class="line">-- 注意：分区字段名不能和表中的字段名重复。</span><br><span class="line">create table student_partition(</span><br><span class="line">    Sno int,Sname string,Sex string,Sage int) </span><br><span class="line">partitioned by(Sdept string);</span><br><span class="line"></span><br><span class="line">-- 4、执行动态分区插入操作</span><br><span class="line">insert into table student_partition partition(Sdept)</span><br><span class="line">select Sno,Sname,Sex,Sage,Sdept from student;</span><br><span class="line">-- 其中，Sno,Sname,Sex,Sage作为表的字段内容插入表中</span><br><span class="line">-- Sdept作为分区字段值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下，可以发现实现了自动分区：</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725172512400.png" alt="image-20210725172512400"><figcaption aria-hidden="true">image-20210725172512400</figcaption>
</figure>
<h2 id="insert-directory">insert + directory</h2>
<h3 id="基础-2">基础</h3>
<p>Hive支持将select查询的结果导出成文件存放在文件系统中。</p>
<h3 id="语法-2">语法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 标准语法:</span><br><span class="line">INSERT OVERWRITE [LOCAL] DIRECTORY directory1</span><br><span class="line">[ROW FORMAT row_format] </span><br><span class="line">[STORED AS file_format] (Note: Only available starting with Hive 0.11.0)</span><br><span class="line">SELECT ... FROM ...</span><br><span class="line"></span><br><span class="line">-- Hive extension (multiple inserts):</span><br><span class="line">FROM from_statement</span><br><span class="line">INSERT OVERWRITE [LOCAL] DIRECTORY directory1 select_statement1</span><br><span class="line">[INSERT OVERWRITE [LOCAL] DIRECTORY directory2 select_statement2] ...</span><br><span class="line"></span><br><span class="line">--row_format</span><br><span class="line">: DELIMITED [FIELDS TERMINATED BY char [ESCAPED BY char]] [COLLECTION ITEMS TERMINATED BY char]</span><br><span class="line">[MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，<strong>导出操作是一个OVERWRITE覆盖操作，慎重</strong>。</p>
<p>目录可以是完整的URI。如果未指定scheme或Authority，则Hive将使用hadoop配置变量fs.default.name中的方案和Authority，该变量指定Namenode URI。</p>
<p>如果使用LOCAL关键字，则Hive会将数据写入本地文件系统上的目录。</p>
<p>写入文件系统的数据被序列化为文本，列之间用^ A隔开，行之间用换行符隔开。如果任何列都不是原始类型，那么这些列将序列化为JSON格式。也可以在导出的时候指定分隔符换行符和文件格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 当前库下已有一张表student</span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line">-- 1、导出查询结果到HDFS指定目录下</span><br><span class="line">insert overwrite directory &#39;&#x2F;tmp&#x2F;hive_export&#x2F;e1&#39; select * from student;</span><br><span class="line"></span><br><span class="line">-- 2、导出时指定分隔符和文件存储格式</span><br><span class="line">insert overwrite directory &#39;&#x2F;tmp&#x2F;hive_export&#x2F;e2&#39; </span><br><span class="line">row format delimited fields terminated by &#39;,&#39;</span><br><span class="line">stored as orc</span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line">-- 3、导出数据到本地文件系统指定目录下</span><br><span class="line">insert overwrite local directory &#39;&#x2F;root&#x2F;hive_export&#x2F;e1&#39;</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure>
<p>导出结果：</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725175046839.png" alt="image-20210725175046839"><figcaption aria-hidden="true">image-20210725175046839</figcaption>
</figure>
<p>文件格式：</p>
<p><img src="/2021/07/25/Hive_DML/image-20210725175112816.png" alt="image-20210725175112816" style="zoom:67%;"></p>
<h2 id="hive事务updatedelete">Hive事务（update/delete）</h2>
<h3 id="背景">背景</h3>
<p>Hive本身从设计之初时，就是不支持事务的，因为<strong>Hive的核心目标是将已经存在的结构化数据文件映射成为表</strong>，<strong>然后提供基于表的SQL分析处理</strong>，是一款面向分析的工具。且映射的数据通常存储于HDFS上，而HDFS是不支持随机修改文件数据的。</p>
<p>这个定位就意味着在早期的Hive的SQL语法中是没有update，delete操作的，也就没有所谓的事务支持了，因为都是select查询分析操作。</p>
<p>从Hive0.14版本开始，具有ACID语义的事务已添加到Hive中，以解决以下场景下遇到的问题：</p>
<p>1、流式传输数据。使用如Apache Flume或Apache Kafka之类的工具将数据流式传输到Hadoop集群中。虽然这些工具可以每秒数百行或更多行的速度写入数据，但是Hive只能每隔15分钟到一个小时添加一次分区。频繁添加分区会很快导致表中大量的分区。因此通常使用这些工具将数据流式传输到现有分区中，但是这会使读者感到脏读（也就是说，他们将在开始查询后看到写入的数据），并将许多小文件留在目录中，这将给NameNode带来压力。<strong>通过事务功能，允许读者获得一致的数据视图并避免过多的文件</strong>。</p>
<p>2、尺寸变化缓慢。在典型的星型模式数据仓库中，维度表随时间缓慢变化。例如，零售商将开设新商店，需要将其添加到商店表中，或者现有商店可能会更改其平方英尺或某些其他跟踪的特征。这些更改导致插入单个记录或更新 记录（取决于所选策略）。</p>
<p>3、数据重述。有时发现收集的数据不正确，需要更正。从Hive 0.14开始，可以通过INSERT，UPDATE和 DELETE支持这些用例 。</p>
<h3 id="局限">局限</h3>
<p>虽然Hive支持了具有ACID语义的事务，但是在使用起来，并没有像在MySQL中使用那样方便，有很多局限性。原因很简单，毕竟Hive的设计目标不是为了支持事务操作，而是支持分析操作，且最终基于HDFS的底层存储机制使得文件的增加删除修改操作需要动一些小心思。具体限制如下：</p>
<p>1、尚不支持BEGIN，COMMIT和ROLLBACK。所有语言操作都是自动提交的。</p>
<p>2、仅支持ORC文件格式（STORED AS ORC）。</p>
<p>3、默认情况下事务配置为关闭。需要配置参数开启使用。</p>
<p>4、表必须是分桶表（Bucketed）才可以使用事务功能。</p>
<p>5、表<strong>参数transactional必须为true</strong>；</p>
<p>6、外部表不能成为ACID表，不允许从非ACID会话读取/写入ACID表。</p>
<h3 id="原理">原理</h3>
<h3 id="案例-1">案例</h3>
<p>如果不做任何配置修改，直接针对Hive中已有的表进行Update、Delete、Insert操作，可以发现，只有insert语句可以执行，Update和Delete操作会报错。Insert插入操作能够成功的原因在于，底层是直接把数据写在一个新的文件中的。</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725161008715.png" alt="image-20210725161008715"><figcaption aria-hidden="true">image-20210725161008715</figcaption>
</figure>
<p>事务案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Hive中事务表的创建使用</span><br><span class="line">-- 1、开启事务配置（可以使用set设置当前session生效 也可以配置在hive-site.xml中）</span><br><span class="line">set hive.support.concurrency &#x3D; true; --Hive是否支持并发</span><br><span class="line">set hive.enforce.bucketing &#x3D; true; --从Hive2.0开始不再需要  是否开启分桶功能</span><br><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict; --动态分区模式  非严格</span><br><span class="line">set hive.txn.manager &#x3D; org.apache.hadoop.hive.ql.lockmgr.DbTxnManager; --</span><br><span class="line">set hive.compactor.initiator.on &#x3D; true; --是否在Metastore实例上运行启动线程和清理线程</span><br><span class="line">set hive.compactor.worker.threads &#x3D; 1; --在此metastore实例上运行多少个压缩程序工作线程。</span><br><span class="line"></span><br><span class="line">-- 2、创建Hive事务表</span><br><span class="line">create table trans_student(</span><br><span class="line">    id int,</span><br><span class="line">    name String,</span><br><span class="line">    age int</span><br><span class="line">)clustered by (id) into 2 buckets stored as orc TBLPROPERTIES(&#39;transactional&#39;&#x3D;&#39;true&#39;);</span><br><span class="line"></span><br><span class="line">-- 3、针对事务表进行insert update delete操作</span><br><span class="line">insert into trans_student (id, name, age)</span><br><span class="line">values (1,&quot;allen&quot;,18);</span><br><span class="line"></span><br><span class="line">update trans_student</span><br><span class="line">set age &#x3D; 20</span><br><span class="line">where id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">delete from trans_student where id &#x3D;1;</span><br><span class="line"></span><br><span class="line">select * from trans_student;</span><br></pre></td></tr></table></figure>
<h2 id="select">select</h2>
<h3 id="基本语法">基本语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">WITH</span> CommonTableExpression (, CommonTableExpression)<span class="operator">*</span>] </span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] select_expr, select_expr, ...</span><br><span class="line">  <span class="keyword">FROM</span> table_reference</span><br><span class="line">  [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">  [<span class="keyword">GROUP</span> <span class="keyword">BY</span> col_list]</span><br><span class="line">  [<span class="keyword">ORDER</span> <span class="keyword">BY</span> col_list]</span><br><span class="line">  [CLUSTER <span class="keyword">BY</span> col_list</span><br><span class="line">    <span class="operator">|</span> [DISTRIBUTE <span class="keyword">BY</span> col_list] [SORT <span class="keyword">BY</span> col_list]</span><br><span class="line">  ]</span><br><span class="line"> [LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span>]</span><br></pre></td></tr></table></figure>
<p>查询的输入。它可以是普通物理表，视图，join查询结果或子查询结果。表名和列名不区分大小写。</p>
<p>每个select_expr表示要检索的列。必须至少有一个 select_expr。</p>
<p>ALL和DISTINCT选项指定是否应返回重复的行。如果没有给出这些选项，则默认值为ALL（返回所有匹配的行）。DISTINCT指定从结果集中删除重复的行。</p>
<p>WHERE条件是一个布尔表达式。在WHERE表达式中，可以使用Hive支持的任何函数和运算符，但聚合函数除外。</p>
<p>为什么不能在where子句中使用聚合函数？因为聚合函数要使用它的前提是结果集已经确定。而where子句还处于“确定”结果集的过程中，因而不能使用聚合函数。</p>
<p>GROUP BY 语句用于聚合函数，根据一个或多个字段对结果集进行分组。需要注意的是，<strong>出现在select_expr中的字段：要么是GROUP BY分组的字段；要么是被聚合函数应用的字段</strong>。原因很简单，避免出现一个字段多个值的歧义。比如基于category进行分组，相同颜色的分在同一组中，在select_expr中，如果出现category字段，则没有问题，因为同一组中category值一样，但是返回day就有问题了，day的结果不一样。</p>
<p>HAVING，WHERE关键字无法与聚合函数一起使用。HAVING子句可以让我们筛选分组后的各组数据,并且可以在Having中使用聚合函数，因为此时where，group by已经执行结束，结果集已经确定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 先where分组前过滤（此处是分区裁剪），再进行group by分组（含聚合）， 分组后每个分组结果集确定 再使用having过滤</span><br><span class="line">select state,sum(deaths)</span><br><span class="line">from t_usa_covid19_p</span><br><span class="line">where count_date &#x3D; &quot;2021-01-28&quot;</span><br><span class="line">group by state</span><br><span class="line">having sum(deaths) &gt; 10000;</span><br><span class="line"></span><br><span class="line">-- 这样写更好 即在group by的时候聚合函数已经作用得出结果 having直接引用结果过滤 不需要再单独计算一次了</span><br><span class="line">select state,sum(deaths) as cnts</span><br><span class="line">from t_usa_covid19_p</span><br><span class="line">where count_date &#x3D; &quot;2021-01-28&quot;</span><br><span class="line">group by state</span><br><span class="line">having cnts&gt; 10000;</span><br></pre></td></tr></table></figure>
<p>having与where的区别: 1、having是在分组后对数据进行过滤；where是在分组前对数据进行过滤 2、having后面可以使用聚合函数；where后面不可以使用聚合</p>
<p>LIMIT子句可用于约束SELECT语句返回的行数。LIMIT接受一个或两个数字参数，这两个参数都必须是非负整数常量。第一个参数指定要返回的第一行的偏移量（从 Hive 2.0.0开始），第二个参数指定要返回的最大行数。当给出单个参数时，它代表最大行数，并且偏移量默认为0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 返回结果集的前5条</span><br><span class="line">select * from t_usa_covid19_p</span><br><span class="line">where count_date &#x3D; &quot;2021-01-28&quot;</span><br><span class="line">  and state &#x3D;&quot;California&quot;</span><br><span class="line">limit 5;</span><br><span class="line"></span><br><span class="line">-- 返回结果集从第1行开始 共3行</span><br><span class="line">select * from t_usa_covid19_p</span><br><span class="line">where count_date &#x3D; &quot;2021-01-28&quot;</span><br><span class="line">  and state &#x3D;&quot;California&quot;</span><br><span class="line">limit 2,3; -- 注意 第一个参数偏移量是从0开始的</span><br></pre></td></tr></table></figure>
<h3 id="案例-2">案例</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- step1:创建普通表t_usa_covid19</span><br><span class="line">drop table itcast.t_usa_covid19;</span><br><span class="line">CREATE TABLE itcast.t_usa_covid19(</span><br><span class="line">       count_date string,</span><br><span class="line">       county string,</span><br><span class="line">       state string,</span><br><span class="line">       fips int,</span><br><span class="line">       cases int,</span><br><span class="line">       deaths int)</span><br><span class="line">row format delimited fields terminated by &quot;,&quot;;</span><br><span class="line">-- 将源数据load加载到t_usa_covid19表对应的路径下</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;us-covid19-counties.dat&#39; into table t_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- step2:创建一张分区表 基于count_date日期,state州进行分区</span><br><span class="line">CREATE TABLE itcast.t_usa_covid19_p(</span><br><span class="line">     county string,</span><br><span class="line">     fips int,</span><br><span class="line">     cases int,</span><br><span class="line">     deaths int)</span><br><span class="line">partitioned by(count_date string,state string)</span><br><span class="line">row format delimited fields terminated by &quot;,&quot;;</span><br><span class="line"></span><br><span class="line">-- step3:使用动态分区插入将数据导入t_usa_covid19_p中</span><br><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict;</span><br><span class="line"></span><br><span class="line">insert into table t_usa_covid19_p partition (count_date,state)</span><br><span class="line">select county,fips,cases,deaths,count_date,state from t_usa_covid19;</span><br></pre></td></tr></table></figure>
<p>查询结果：</p>
<p><img src="/2021/07/25/Hive_DML/image-20210725180419051.png" alt="image-20210725180419051" style="zoom:67%;"></p>
<p>通常，SELECT查询将扫描整个表（所谓的全表扫描）。如果使用PARTITIONED BY子句创建的分区表，则在查询时可以指定分区查询，减少全表扫描，也叫做分区裁剪。</p>
<p>所谓分区裁剪指的是：对分区表进行查询时，会检查WHERE子句或JOIN中的ON子句中是否存在对分区字段的过滤，如果存在，则<strong>仅访问查询符合条件的分区，即裁剪掉没必要访问的分区</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 找出来自加州，累计死亡人数大于1000的县 state字段就是分区字段 进行分区裁剪 避免全表扫描</span><br><span class="line">select * from t_usa_covid19_p where state &#x3D;&quot;California&quot; and deaths &gt; 1000;</span><br><span class="line"></span><br><span class="line">-- 多分区裁剪</span><br><span class="line">select * from t_usa_covid19_p where count_date &#x3D; &quot;2021-01-28&quot; and state &#x3D;&quot;California&quot; and deaths &gt; 1000;</span><br></pre></td></tr></table></figure>
<h3 id="高阶查询">高阶查询</h3>
<h4 id="排序">排序</h4>
<p>Hive SQL中的CLUSTER BY语法可以指定根据后面的字段将数据分组，每组内再根据这个字段正序排序（<strong>不允许指定倒序</strong>），概况起来就是：根据同一个字段，分且排序。</p>
<p>分组的规则hash散列。hash_func(col_name) % reduce task nums</p>
<p>分为几组取决于reduce task的个数。下面在Hive beeline客户端中针对student表为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- cluster by</span><br><span class="line">select * from student;</span><br><span class="line">-- 不指定reduce task个数</span><br><span class="line">-- 日志显示：Number of reduce tasks not specified. Estimated from input data size: 1</span><br><span class="line">select * from student cluster by sno;</span><br><span class="line"></span><br><span class="line">-- 手动设置reduce task个数</span><br><span class="line">set mapreduce.job.reduces &#x3D;2;</span><br><span class="line">select * from student cluster by sno;</span><br></pre></td></tr></table></figure>
<p>默认情况下，reduce task的个数由Hive在编译期间自己决定：</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725182147657.png" alt="image-20210725182147657"><figcaption aria-hidden="true">image-20210725182147657</figcaption>
</figure>
<p>手动设置reduce task个数：</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725182126594.png" alt="image-20210725182126594"><figcaption aria-hidden="true">image-20210725182126594</figcaption>
</figure>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725182207003.png" alt="image-20210725182207003"><figcaption aria-hidden="true">image-20210725182207003</figcaption>
</figure>
<p>执行结果如下：分为两个部分，每个部分内正序排序：</p>
<p><img src="/2021/07/25/Hive_DML/image-20210725182238798.png" alt="image-20210725182238798" style="zoom:80%;"></p>
<p>因为CLUSTER BY不允许指定倒序，因此若有倒序的需求则需要采用其他方法。</p>
<p>DISTRIBUTE BY +SORT BY就相当于把cluster by的功能一分为二：DISTRIBUTE BY负责分，SORT BY负责分组内排序，并且可以是不同的字段。如果DISTRIBUTE BY +SORT BY的字段一样，可以得出下列结论：CLUSTER BY=DISTRIBUTE BY +SORT BY（字段一样）</p>
<p>案例，把学生表数据根据性别分为两个部分，每个分组内根据年龄的倒序排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student distribute by sex sort by sage desc;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725182550180.png" alt="image-20210725182550180"><figcaption aria-hidden="true">image-20210725182550180</figcaption>
</figure>
<p>总结：</p>
<ul>
<li>order by会对输入做全局排序，因此只有一个reducer，会导致当输入规模较大时，需要较长的计算时间。</li>
<li>sort by不是全局排序，其在数据进入reducer前完成排序。因此，如果用sort by进行排序，并且设置mapred.reduce.tasks&gt;1，则sort by只保证每个reducer的输出有序，不保证全局有序。</li>
<li>distribute by(字段)根据指定字段将数据分到不同的reducer，分发算法是hash散列。</li>
<li>cluster by(字段) 除了具有Distribute by的功能外，还会对该字段进行排序。如果distribute和sort的字段是同一个时，此时，cluster by = distribute by + sort by</li>
</ul>
<h4 id="union">union</h4>
<p>UNION用于将来自多个SELECT语句的结果合并为一个结果集。</p>
<p>每个select_statement返回的<strong>列的数量和名称必须相同</strong>。</p>
<p>语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select_statement </span><br><span class="line">UNION [ALL | DISTINCT] select_statement </span><br><span class="line">UNION [ALL | DISTINCT] select_statement ...</span><br><span class="line"></span><br><span class="line">-- union</span><br><span class="line">-- 使用DISTINCT关键字与使用UNION默认值效果一样，都会删除重复行。</span><br><span class="line">select num,name from student_local</span><br><span class="line">UNION</span><br><span class="line">select num,name from student_hdfs;</span><br><span class="line">-- 和上面一样</span><br><span class="line">select num,name from student_local</span><br><span class="line">UNION DISTINCT</span><br><span class="line">select num,name from student_hdfs;</span><br><span class="line"></span><br><span class="line">-- 使用ALL关键字会保留重复行。</span><br><span class="line">select num,name from student_local</span><br><span class="line">UNION ALL</span><br><span class="line">select num,name from student_hdfs;</span><br><span class="line"></span><br><span class="line">-- 如果要将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT应用于单个SELECT</span><br><span class="line">-- 请将子句放在括住SELECT的括号内</span><br><span class="line">SELECT sno,sname FROM (select sno,sname from student_local LIMIT 2) subq1</span><br><span class="line">UNION</span><br><span class="line">SELECT sno,sname FROM (select sno,sname from student_hdfs LIMIT 3) subq2</span><br><span class="line"></span><br><span class="line">-- 如果要将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT子句应用于整个UNION结果</span><br><span class="line">-- 请将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT放在最后一个之后。</span><br><span class="line">select sno,sname from student_local</span><br><span class="line">UNION</span><br><span class="line">select sno,sname from student_hdfs</span><br><span class="line">order by sno desc;</span><br></pre></td></tr></table></figure>
<p>使用DISTINCT关键字与只使用UNION默认值效果一样，都会删除重复行。使用ALL关键字，不会删除重复行，结果集包括所有SELECT语句的匹配行（包括重复行）。</p>
<h4 id="子查询">子查询</h4>
<p>在Hive0.12版本，仅在FROM子句中支持子查询。<strong>必须要给子查询一个名称</strong>，<strong>因为FROM子句中的每个表都必须有一个名称</strong>。在Hive0.12版本，仅在FROM子句中支持子查询。而且必须要给子查询一个名称，因为FROM子句中的每个表都必须有一个名称。Hive 0.13.0和更高版本中的子查询名称之前可以包含可选关键字“ AS” 。</p>
<p>子查询返回结果中的列必须具有唯一的名称。子查询返回结果中的列在外部查询中可用，就像真实表的列一样。子查询也可以是带有UNION的查询表达式。Hive支持任意级别的子查询，也就是所谓的嵌套子查询。</p>
<p>从Hive 0.13开始，WHERE子句支持某些类型的子查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- where子句中子查询（Subqueries）</span><br><span class="line">-- 不相关子查询，相当于IN、NOT IN,子查询只能选择一个列。</span><br><span class="line">-- （1）执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。</span><br><span class="line">-- （2）执行外部查询，并显示整个结果。　　</span><br><span class="line">SELECT *</span><br><span class="line">FROM student_hdfs</span><br><span class="line">WHERE student_hdfs.num IN (select num from student_local limit 2);</span><br><span class="line"></span><br><span class="line">-- 相关子查询，指EXISTS和NOT EXISTS子查询</span><br><span class="line">-- 子查询的WHERE子句中支持对父查询的引用</span><br><span class="line">SELECT A</span><br><span class="line">FROM T1</span><br><span class="line">WHERE EXISTS (SELECT B FROM T2 WHERE T1.X &#x3D; T2.Y);</span><br></pre></td></tr></table></figure>
<h2 id="cte">CTE</h2>
<p>Common Table Expressions（CTE），即公用表表达式（CTE）是一个临时结果集，该结果集是从WITH子句中指定的简单查询派生而来的，该查询紧接在SELECT或INSERT关键字之前。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--选择语句中的CTE</span><br><span class="line">with q1 as (select sno,sname,sage from student where sno &#x3D; 95002)</span><br><span class="line">select *</span><br><span class="line">from q1;</span><br><span class="line"></span><br><span class="line">-- from风格</span><br><span class="line">with q1 as (select sno,sname,sage from student where sno &#x3D; 95002)</span><br><span class="line">from q1</span><br><span class="line">select *;</span><br><span class="line"></span><br><span class="line">-- chaining CTEs 链式</span><br><span class="line">with q1 as ( select * from student where sno &#x3D; 95002),</span><br><span class="line">     q2 as ( select sno,sname,sage from q1)</span><br><span class="line">select * from (select sno from q2) a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- union案例</span><br><span class="line">with q1 as (select * from student where sno &#x3D; 95002),</span><br><span class="line">     q2 as (select * from student where sno &#x3D; 95004)</span><br><span class="line">select * from q1 union all select * from q2;</span><br><span class="line"></span><br><span class="line">-- 视图，CTAS和插入语句中的CTE</span><br><span class="line">-- insert</span><br><span class="line">create table s1 like student;</span><br><span class="line"></span><br><span class="line">with q1 as ( select * from student where sno &#x3D; 95002)</span><br><span class="line">from q1</span><br><span class="line">insert overwrite table s1</span><br><span class="line">select *;</span><br><span class="line"></span><br><span class="line">select * from s1;</span><br><span class="line"></span><br><span class="line">-- ctas</span><br><span class="line">create table s2 as</span><br><span class="line">with q1 as ( select * from student where sno &#x3D; 95002)</span><br><span class="line">select * from q1;</span><br><span class="line"></span><br><span class="line">-- view</span><br><span class="line">create view v1 as</span><br><span class="line">with q1 as ( select * from student where sno &#x3D; 95002)</span><br><span class="line">select * from q1;</span><br><span class="line"></span><br><span class="line">select * from v1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="join">join</h2>
<h3 id="基础-3">基础</h3>
<p>根据数据库的三范式设计要求，<strong>通常不会设计一张大表把所有类型的数据都放在一起，而是不同类型的数据设计不同的表存储</strong>。比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726003928854.png" alt="image-20210726003928854" style="zoom:50%;"></p>
<p>在这种情况下，有时需要基于多张表查询才能得到最终完整的结果，SQL中<strong>join语法的出现是用于根据两个或多个表中的字段之间的关系，从这些表中共同组合查询数据</strong>，因此有时为了得到完整的结果，我们就需要执行 join。</p>
<p>Hive作为面向分析的数据仓库软件，为了更好的支持数据分析的功能丰富，也实现了join的语法，整体上来看和RDBMS中的join语法类似，只不过在某些点有自己的特色。需要特别注意。</p>
<h3 id="语法-3">语法</h3>
<p>在Hive中，当下版本3.1.2总共支持6种join语法。分别是：</p>
<p>inner join（内连接）、left join（左连接）、right join（右连接）、full outer join（全外连接）、left semi join（左半开连接）、cross join（交叉连接，也叫做笛卡尔乘积）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table_reference [INNER] JOIN table_factor [join_condition]</span><br><span class="line"> | table_reference &#123;LEFT|RIGHT|FULL&#125; [OUTER] JOIN table_reference join_condition</span><br><span class="line"> | table_reference LEFT SEMI JOIN table_reference join_condition</span><br><span class="line"> | table_reference CROSS JOIN table_reference [join_condition] (as of Hive 0.10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JOIN默认就是INNER JOIN。</p>
<p>table_reference：是join查询中使用的表名，也可以是子查询别名（查询结果当成表参与join）。</p>
<p>table_factor：与table_reference相同,是联接查询中使用的表名,也可以是子查询别名。</p>
<p>join_condition：join查询关联的条件， 如果在两个以上的表上需要连接，则使用AND关键字。</p>
<p>从Hive 0.13.0开始，支持隐式联接表示法（请参阅HIVE-5558）。这允许FROM子句连接以逗号分隔</p>
<p>的表列表，而省略JOIN关键字。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM table1 t1, table2 t2, table3 t3</span><br><span class="line">WHERE t1.id &#x3D; t2.id AND t2.id &#x3D; t3.id AND t1.zipcode &#x3D; &#39;02535&#39;;</span><br></pre></td></tr></table></figure>
<p>Hive 2.2.0开始，支持ON子句中的复杂表达式，<strong>支持不相等连接</strong>（请参阅HIVE-15211和HIVE-15251）。<strong>在此之前，Hive不支持非等值联接条件</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT a.* FROM a JOIN b ON (a.id &#x3D; b.id)</span><br><span class="line">SELECT a.* FROM a JOIN b ON (a.id &#x3D; b.id AND a.department &#x3D; b.department)</span><br><span class="line">SELECT a.* FROM a LEFT OUTER JOIN b ON (a.id &lt;&gt; b.id)</span><br></pre></td></tr></table></figure>
<h3 id="各种join">各种JOIN</h3>
<h4 id="inner-join">inner join</h4>
<p>内连接是最常见的一种连接，它也被称为普通连接，而关系模型提出者E.FCodd（埃德加•科德）最早称之为自然连接。其中inner可以省略。inner join == join 等价于早期的连接语法。</p>
<p>内连接，只有进行连接的两个表中都存在与连接条件相匹配的数据才会被留下来。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726005046850.png" alt="image-20210726005046850" style="zoom: 33%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1、inner join</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e </span><br><span class="line">inner join employee_address e_a</span><br><span class="line">on e.id &#x3D;e_a.id;</span><br><span class="line"></span><br><span class="line">-- 等价于 inner join&#x3D;join</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e </span><br><span class="line">join employee_address e_a</span><br><span class="line">on e.id &#x3D;e_a.id;</span><br><span class="line"></span><br><span class="line">-- 等价于 隐式连接表示法</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e , employee_address e_a</span><br><span class="line">where e.id &#x3D;e_a.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/25/Hive_DML/image-20210726005212922.png" alt="image-20210726005212922" style="zoom: 67%;"></p>
<h4 id="left-join">left join</h4>
<p>left join中文叫做是左外连接(Left Outer Jion)或者左连接，其中outer可以省略，left outer join是早期的写法。</p>
<p>left join的核心就在于left左。左指的是join关键字左边的表，简称左表。</p>
<p>join时以左表的全部数据为准，右边与之关联；左表数据全部返回，右表关联上的显示返回，关联不上的显示null返回。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726005345737.png" alt="image-20210726005345737" style="zoom: 33%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 2、left join</span><br><span class="line">select e.id,e.name,e_conn.phno,e_conn.email</span><br><span class="line">from employee e left join employee_connection e_conn</span><br><span class="line">on e.id &#x3D;e_conn.id;</span><br><span class="line"></span><br><span class="line">-- 等价于 left outer join</span><br><span class="line">select e.id,e.name,e_conn.phno,e_conn.email</span><br><span class="line">from employee e left outer join  employee_connection e_conn</span><br><span class="line">on e.id &#x3D;e_conn.id;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/25/Hive_DML/image-20210726005430913.png" alt="image-20210726005430913" style="zoom:67%;"></p>
<h4 id="right-join">right join</h4>
<p>right join中文叫做是右外连接(Right Outer Jion)或者右连接，其中outer可以省略。</p>
<p>right join的核心就在于Right右。右指的是join关键字右边的表，简称右表。</p>
<p>join时以右表的全部数据为准，左边与之关联；右表数据全部返回，左表关联上的显示返回，关联不上的显示null返回。</p>
<p>很明显，right join和left join之间很相似，重点在于以哪边为准，也就是一个方向的问题。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726005514782.png" alt="image-20210726005514782" style="zoom:33%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 3、right join</span><br><span class="line">select e.id,e.name,e_conn.phno,e_conn.email</span><br><span class="line">from employee e right join employee_connection e_conn</span><br><span class="line">on e.id &#x3D;e_conn.id;</span><br><span class="line"></span><br><span class="line">-- 等价于 right outer join</span><br><span class="line">select e.id,e.name,e_conn.phno,e_conn.email</span><br><span class="line">from employee e right outer join employee_connection e_conn</span><br><span class="line">on e.id &#x3D;e_conn.id;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/25/Hive_DML/image-20210726005548550.png" alt="image-20210726005548550" style="zoom:67%;"></p>
<h4 id="full-outer-join">full outer join</h4>
<p>full outer join 等价 full join ,中文叫做全外连接或者外连接。</p>
<p>包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。它等价于对这两个数据集合分别进行左外连接和右外连接，然后再使用消去重复行的操作将上述两个结果集合并为一个结果集。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726005716904.png" alt="image-20210726005716904" style="zoom:33%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 4、full outer join</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e full outer join employee_address e_a</span><br><span class="line">on e.id &#x3D;e_a.id;</span><br><span class="line"></span><br><span class="line">-- 等价于</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e full  join employee_address e_a</span><br><span class="line">on e.id &#x3D;e_a.id;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/25/Hive_DML/image-20210726005755307.png" alt="image-20210726005755307" style="zoom:67%;"></p>
<h4 id="left-semi-join">left semi join</h4>
<p>左半开连接（LEFT SEMI JOIN）会返回左边表的记录，前提是其记录对于右边的表满足ON语句中的判定条件。</p>
<p>从效果上来看即inner join之后只返回左表的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 5、left semi join</span><br><span class="line">select *</span><br><span class="line">from employee e left semi join employee_address e_addr</span><br><span class="line">on e.id &#x3D;e_addr.id;</span><br><span class="line"></span><br><span class="line">-- 相当于 inner join 只不过效率高一些</span><br><span class="line">select e.*</span><br><span class="line">from employee e inner join employee_address e_addr</span><br><span class="line">on e.id &#x3D;e_addr.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="cross-join笛卡尔积">cross join（笛卡尔积）</h4>
<p>交叉连接cross join，将会返回被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积。对于大表来说，cross join慎用。</p>
<p>在HiveSQL语法中，cross join 后面可以跟where子句进行过滤，或者on条件过滤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 6、cross join</span><br><span class="line">-- 下列A、B、C 执行结果相同，但是效率不一样：</span><br><span class="line">-- A:</span><br><span class="line">select a.*,b.* from employee a,employee_address b where a.id&#x3D;b.id;</span><br><span class="line">-- B:</span><br><span class="line">select * from employee a cross join employee_address b on a.id&#x3D;b.id;</span><br><span class="line">select * from employee a cross join employee_address b where a.id&#x3D;b.id;</span><br><span class="line"></span><br><span class="line">-- C:</span><br><span class="line">select * from employee a inner join employee_address b on a.id&#x3D;b.id;</span><br><span class="line"></span><br><span class="line">-- 一般不建议使用方法A和B，因为如果有WHERE子句的话，往往会先进行笛卡尔积返回数据然后才根据WHERE条件从中选择。</span><br><span class="line">-- 因此，如果两个表太大，将会非常非常慢，不建议使用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3>
<p>1、允许使用复杂的on联接表达式</p>
<p>2、同一查询中可以连接2个以上的表（！？多表关联原理）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM </span><br><span class="line">a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key2)</span><br></pre></td></tr></table></figure>
<p>3、如果每个表在联接子句中使用相同的列，则Hive将多个表上的联接转换为单个MR作业</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key1)</span><br><span class="line">-- 由于联接中仅涉及b的key1列，因此被转换为1个MR作业来执行</span><br><span class="line"></span><br><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key2)</span><br><span class="line">-- 会转换为两个MR作业，因为在第一个连接条件中使用了b中的key1列，而在第二个连接条件中使用了b中的key2列。第一个map &#x2F; reduce作业将a与b联接在一起，然后将结果与c联接到第二个map &#x2F; reduce作业中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、join时的最后一个表会通过reducer流式传输，并在其中缓存之前的其他表，因此，将大表放置在最后有助于减少reducer阶段缓存数据所需要的内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key1)</span><br><span class="line">-- 由于联接中仅涉及b的key1列，因此被转换为1个MR作业来执行，并且表a和b的键的特定值的值被缓存在reducer的内存中。然后，对于从c中检索的每一行，将使用缓存的行来计算联接。</span><br><span class="line"></span><br><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key2)</span><br><span class="line">-- 计算涉及两个MR作业。其中的第一个将a与b连接起来，并缓存a的值，同时在reducer中流式传输b的值。在第二个MR作业中，将缓存第一个连接的结果，同时将c的值通过reducer流式传输。</span><br></pre></td></tr></table></figure>
<p>5、在join的时候，可以通过语法STREAMTABLE提示指定要流式传输的表。如果省略STREAMTABLE提示，则Hive将流式传输最右边的表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#x2F;*+ STREAMTABLE(a) *&#x2F; a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key1)</span><br><span class="line">-- a,b,c三个表都在一个MR作业中联接，并且表b和c的键的特定值的值被缓存在reducer的内存中。然后，对于从a中检索到的每一行，将使用缓存的行来计算联接。如果省略STREAMTABLE提示，则Hive将流式传输最右边的表。</span><br></pre></td></tr></table></figure>
<p>6、如果除一个要连接的表之外的所有表都很小，则可以将其作为仅map作业执行（即map端join）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#x2F;*+ MAPJOIN(b) *&#x2F; a.key, a.value </span><br><span class="line">FROM a JOIN b ON a.key &#x3D; b.key</span><br><span class="line">-- 不需要reducer。对于A的每个Mapper，B都会被完全读取。限制是不能执行FULL &#x2F; RIGHT OUTER JOIN b。</span><br></pre></td></tr></table></figure>
<p>7、join在where条件之前进行。（执行顺序？？）</p>
<p>多表关联和join的执行顺序</p>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 动态规划</title>
    <url>/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>LeetCode中与动态规划有关的题目。</p>
<a id="more"></a>
<h3 id="最长回文子串">5 最长回文子串</h3>
<p><strong>题目描述</strong></p>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>示例 1：</p>
<p>输入：s = "babad" 输出："bab" 解释："aba" 同样是符合题意的答案。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：每个字符都要往后判断是否是回文串</p>
<p>空间复杂度O(<span class="math inline">\(n^2\)</span>)：二维dp数组</p>
<p>定义二维布尔数组dp[i][j]数组表示：字符串s[i⋯j]是否为回文子串，如果是，dp[i][j] = true，如果不是，dp[i][j] = false。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/0.png" style="zoom: 33%;"></p>
<p>首先需要寻找递推关系，如上图所示，如果现在已经知道了dp[i+1][j-1]了，那我们如何计算dp[i][j]呢？通过观察，我们发现：</p>
<ul>
<li>如果s[i] == s[j]那么说明只要<span class="math inline">\(dp[i+1][j-1]\)</span>是回文子串，那么是dp[i][j]也就是回文子串。</li>
<li>如果<span class="math inline">\(s[i]\ne s[j]\)</span>s[i] 那么说明dp[i][j]必定不是回文子串。</li>
</ul>
<p>接着需要寻找边界条件，由定义可知，i必须要在j的前面，且当i和j相同时，即只有一个字符时是回文字串，因此可以得到dp数组中，对角线处为true，对角线下方为fasle。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.png" style="zoom:50%;"></p>
<p>又由递推关系可以知道当前dp[i][j]和<span class="math inline">\(dp[i+1][j-1]\)</span>有关，因此数组是从下往上遍历，即对字符串来说从后往前判断。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.png" style="zoom:50%;"></p>
<p>注意递推式中假如i和j是相邻的两个字符，那么就没有i+1和j-1的比较，直接进行判断即可。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.png" style="zoom: 50%;"></p>
<p>最后，因为dp数组仅仅记录的是是否是回文串，因此需要用另外的变量记录长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> [][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对dp数组进行初始化，这里仅初始化对角线为true，只有一个字符必是回文</span></span><br><span class="line">        <span class="comment">//因为dp[i][j]表示的是从i到j的字符，因此j不能小于等于i，所以对角线下的位置全为false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录最长的回文子串的下标</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从右下角往上遍历，即对字符串来说从后往前判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; s.length(); j++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断当前dp[i][j]是否是回文子串</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i==<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//假如dp[i][j]是回文子串</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                    <span class="comment">//判断是不是最长的</span></span><br><span class="line">                    <span class="keyword">if</span>( j - i &gt; right - left )&#123;</span><br><span class="line">                        left = i;</span><br><span class="line">                        right = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>); <span class="comment">//substring方法不包括结束索引，因此+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不同路径">62 不同路径</h3>
<p><strong>题目描述</strong></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例：</p>
<p>输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向下</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(mn\)</span>)：每个位置都进行填充</p>
<p>空间复杂度O(<span class="math inline">\(mn\)</span>)：二维dp数组，可以优化为O(<span class="math inline">\(m\)</span>)（每次只由左边和上边值决定，上边的值就是当前存储的值，代表上一轮）</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.png" style="zoom: 50%;"></p>
<p>定义二维整型dp[i][j]数组表示坐标为（i，j）的点共有多少种不同的路径。</p>
<p>由于每次只能向右或者向下一步，因此有递推式：dp[i][j] = dp[i-1][j] + dp[i][j-1]。</p>
<p>接着寻找边界条件，由于每次只能向右或向下，因此矩阵第一行和第一列都只能拥有一种走法，则统一初始化为1。</p>
<p>递归会超时！除非把计算过的值使用一个map存储起来，用的时候先查看是否计算过，如果计算过就直接拿来用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义辅助数组</span></span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化矩阵第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行动态填充</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回存储的路径数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小路径和最大路径和">64 最小路径和（最大路径和）</h3>
<p><strong>题目描述</strong></p>
<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(mn\)</span>)：每个位置都进行填充</p>
<p>空间复杂度O(<span class="math inline">\(mn\)</span>)：二维dp数组，可以优化为O(<span class="math inline">\(m\)</span>)（每次只由左边和上边值决定，上边的值就是当前存储的值，代表上一轮）</p>
<p>定义二维整型dp[i][j]数组表示坐标为（i，j）的点，<strong>从左上角到这个位置，路径上的数字总和的最小值</strong>。</p>
<p>因为每次只能向右或向下走，因此可以得到递推式：<span class="math inline">\(dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1])+grid[i][j];\)</span></p>
<p>表示当前位置的最小总和，由左边或上边小的那个总和，再加上当前位置的矩阵值所得。</p>
<p>接着寻找边界条件，由于每次只能向右或向下，因此矩阵第一行和第一列都只能是其前面数值的累加，因此对其初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//dp第一行就是grid中第一行值累加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cols; i++)</span><br><span class="line">            	dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dp第一列就是grid中第一列值累加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)</span><br><span class="line">            	dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行进行动态填充</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++)</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回存储的最总和</span></span><br><span class="line">        <span class="keyword">return</span> dp[rows-<span class="number">1</span>][cols-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不同的二叉搜索树">96 不同的二叉搜索树</h3>
<p>题目描述</p>
<p>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p>输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<blockquote>
<p>1 3 3 2 1   / / /  <br>
3 2 1 1 3 2 / /  <br>
2 1 2 3</p>
</blockquote>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：<span class="math inline">\([0,i]\)</span>中，每个数字都当作根节点建树</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一维dp数组</p>
<p>定义一维整形数组<span class="math inline">\(dp[i]\)</span>表示有i个节点的二叉搜索树有多少种。</p>
<p>对于<span class="math inline">\([0,i]\)</span>中的某个数k，以<span class="math inline">\(k\)</span>为节点的二叉搜索树的种类 <span class="math inline">\(f(k) = dp[k-1]*dp[i-k]\)</span> ，即左子树的数量乘上右子树的数量，将以k为节点的二叉搜索树的种类用k-1和i-k个节点的二叉搜索树表示。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.png" style="zoom:67%;"></p>
<p>那么<span class="math inline">\(dp[i] = f(1)+f(2)+...f(i) = dp[0]*dp[i-1] + dp[1]*dp[i-2] + ... dp[i-1]*dp[0]\)</span></p>
<p>因此得到递推式，这是<strong>卡特兰数</strong>公式。</p>
<p>接着判断边界条件，由于可以存在某棵子树为空的情况，因此dp[0] = 1，同时dp[1] = 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) <span class="comment">//注意，这里j不能超过i</span></span><br><span class="line">                <span class="comment">//本质上，这里就是遍历1:i中，将每个数当作根节点建树的情况</span></span><br><span class="line">                dp[i] = dp[i] + dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单词拆分">139 单词拆分</h3>
<p><strong>题目描述</strong></p>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。</p>
<p>示例 1：</p>
<p>输入: s = "leetcode", wordDict = ["leet", "code"] 输出: true 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：<span class="math inline">\([0,n]\)</span>中，每个字符分成两半进行判断</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一维dp数组</p>
<p>定义一维布尔型数组dp[i]，表示长度为i的s[0:i-1]子串是否能拆分成单词。题目要我们求dp[s.length] 。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/7.png" style="zoom:50%;"></p>
<p>思考状态转移方程，s[0:i-1]子串是否能拆分成单词和i之前是否能拆分为单词的关系，用指针 j 去划分s[0:i] 子串，如下图：</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/6.png" style="zoom:50%;"></p>
<p>s[0:i] 子串的 dp[i+1] ，是否为真（是否可拆分成单词），取决于两点：</p>
<ul>
<li>它的<strong>前缀子串 s[0:j-1] 的 dp[j] ，是否为真</strong>。</li>
<li><strong>剩余子串 s[j:i]，是否是单个单词</strong>，即是否在wordDict中存在。</li>
</ul>
<p>则可以得到状态转移方程：<strong>dp[i] = dp[j] &amp;&amp; check(word[i,j] in wordDict)</strong>，只要任意一个j满足条件即可</p>
<p>接着判断边界条件，dp[0]需要等于true，因为由上图可知，当j从0开始时，右边的word如果在wordDict中存在也是可以满足条件的。</p>
<p>常见误区1：使用双指针</p>
<p>使用双指针left，right按顺序遍历字符串的子串，如果[left,right]之间子串在字典中，那么，以该子串之后的第一个位置作为下一个子串的开始，同样，遍历下一个子串，直到right到达s的末尾。但是这样是错误的，考虑s='leetcode'，假如wordDict = ['leet'，'leetcode']，如果我们先遍历到leet子串，剩余部分是code，字典中没有，就认为该单词无法拆分，实际上wordDict直接就有leetcode，显然，这种策略是不正确的。 为了避免上述这种字典中存在长的能覆盖短的情形，让right从字符串右端开始向左滑动，以保证最长的拆分子串以及最少的拆分次数。那么，right从后面开始遍历就对了么，事实上，也是不对的，考虑s='abcd'，假如wordDict = ["a","abc","b","cd"]，right从后边开始，我们先找到了abc，剩余的d就没有匹配的了，然而，我们是可以按照a+b+cd的组合匹配的，于是，right不管从头部还是从尾部开始，我们都无法解决问题，双指针是不行的。</p>
<p>常见误区2：使用递归</p>
<p>超时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//声明dp数组,dp[i]表示字符串s[0:i-1]是否能被拆分</span></span><br><span class="line">        <span class="keyword">boolean</span> [] dp = <span class="keyword">new</span> <span class="keyword">boolean</span> [s.length()+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行动态填充，i实际上表示s[0:i-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++ )&#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i-<span class="number">1</span>; j++)&#123;<span class="comment">//j是在字符串当中遍历的，由于s[0:i-1]，所以只能取到i-1 </span></span><br><span class="line">                <span class="keyword">if</span>( dp[j] &amp;&amp; wordDict.contains(s.substring(j,i)) )&#123; <span class="comment">//注意substring不能取到i</span></span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="乘积最大子数组">152 乘积最大子数组</h3>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>示例 1:</p>
<p>输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：只遍历一遍数组，记录最大和最小乘积</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一维dp数组，也可以优化为O(1)，由递推式可知当前值只与前一个值有关</p>
<p>这道题和<strong>连续子数组的最大和</strong>非常类似，</p>
<p><strong>定义一维整型数组dp[i]，表示以元素 array[i] 为结尾的连续子数组最大乘积</strong>。</p>
<p>思考状态转移方程，因为是整数数组，有正负之分，假如dp[i-1]表示以元素 array[i-1] 为结尾的连续子数组最大乘积，那么当array[i]为负数时，dp[i-1] * array[i]就会变成最小乘积，此时若 dp数组内保存的是连续最小乘积，则<strong>乘上负数就会变成最大乘积</strong>。</p>
<p>因此本质上需要维护两个dp数组，分别表示以元素 array[i] 为结尾的连续子数组<strong>最大和最小乘积</strong>。</p>
<p>dp_max[i] = Math.max( dp_max[i-1]*array[i]，array[i] )</p>
<p>dp_min[i] = Math.min( dp_min[i-1]*array[i]，array[i] )</p>
<p>当array[i]为负数时，首先<strong>swap( dp_max[i-1]， dp_min[i-1])</strong>，然后再乘上array[i]进行比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//若是负数，交换最大最小值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = max;</span><br><span class="line">                max = min;</span><br><span class="line">                min = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            max = Math.max(max*nums[i], nums[i]);</span><br><span class="line">            min = Math.min(min*nums[i], nums[i]);</span><br><span class="line">            </span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍">198 打家劫舍</h3>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：只遍历一遍数组，记录最大和</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一维dp数组，也可以优化为O(1)，由递推式可知当前值只与前两个值有关，相当于斐波那契数列</p>
<p>本题很容易想到纯奇数的和与纯偶数的和，并比较它们的大小，但这样会存在问题，如下所示：</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/8.png" style="zoom: 50%;"></p>
<p>偷[0]、[2]时的总和为2。偷[1]、[3]时总和为6，偷了[3]就不能偷[4]。</p>
<p>但是假如只偷[1]和[4]总和为103，就比偷[0]、[2]、[4]的总和102要高，这是因为[0]、[1]、[2]时，奇数的总和已经超过了偶数的总和，所以奇数和即使不需要加上[3]也已经超过偶数和。</p>
<p>因此，需要定义一维整形数组dp[i]，表示到array[i]时偷盗总和的最大值。</p>
<p>思考递推式，<strong>dp[i] = Math.max( dp[i-1]，dp[i-2]+ array[i]</strong>。即要么一直偷到i-1房间，不偷i房间，要么偷到i-2房间，且偷i房间。</p>
<p>由于涉及到 i-2，因此令dp[i]表示array[i-1]的情况，这样i从1开始，就可以表示array[0]。</p>
<p>因此dp[0] = 0，dp[1] = array[0]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dp[i]，表示到array[i]时偷盗总和的最大值。</span></span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//涉及到i-2，因此需要dp[0]</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//动态填充数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            dp[i] = Math.max( dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回最大总和</span></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大正方形">221 最大正方形</h3>
<p><strong>题目描述</strong></p>
<p>在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/13.png" style="zoom:33%;"></p>
<p>输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]] 输出：4</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(mn\)</span>)：</p>
<p>空间复杂度O($ mn$)：</p>
<p>暴力的方法就是找到每个由1组成的正方形，求出所有的面积，比较后拿出最大的。其实这个过程中存在重复的子问题。当知道子正方形的情况时，可以避免大量重复计算。</p>
<p>对矩阵中的某个点（i，j）来说，以（i，j）为正方形右下角节点，考虑它能组成多大的正方形，则它只能朝着左上角扩展。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/10.png" style="zoom:50%;"></p>
<p>这时可以发现，如果以（i，j）为右下角节点向左上角扩展正方形，那么必然会涉及到红、绿、蓝这三个方向的正方形。此时思考究竟能够扩展到多大的位置？可以发现，<strong>能够扩展的长度，是红绿蓝这三个正方形的最短边长</strong>。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/9.png" style="zoom: 67%;"></p>
<p>定义二维整形数组dp[i][j]，表示以（i，j）为右下角节点的最大正方形边长，则可以得到递推式：</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/11.png" style="zoom:67%;"></p>
<p>其中： dp[i-1][j-1]表示<strong>绿色</strong>的正方形的方向</p>
<p>dp[i-1][j]表示<strong>红色</strong>的正方形</p>
<p>dp[i][j-1]表示<strong>蓝色</strong>的正方形</p>
<p>然后，定义边界条件，矩阵中，第一行和第一列的点，以他们为右下角节点的最大正方形边长，如果它们本身是1，则可以组成一个最小正方形，否则它们是0，则不能组成正方形，其边长是1。</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/12.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123; <span class="comment">//注意这里给的是char数组！不是整形数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m_row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> m_col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义二维整形数组dp[i][j]，表示以（i，j）为右下角节点的最大正方形边长</span></span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m_row][m_col];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录最长边长</span></span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化矩阵边界，注意在这里就要记录最长边长！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_row; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            max_len = Math.max(max_len, dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_col; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            max_len = Math.max(max_len, dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//填充数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m_row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m_col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="comment">//如果当前位置是0，无论如何都不能形成正方形</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//否则，朝三个方向，找到能形成正方形的最短边长（只要三个方向有一个是0都不能形成正方形）</span></span><br><span class="line">                	dp[i][j] = Math.min( dp[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min( dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>] ) ) + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//记录最长的边长</span></span><br><span class="line">                max_len = Math.max(max_len, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len*max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全平方数">279 完全平方数</h3>
<p><strong>题目描述</strong></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>示例 1：</p>
<p>输入：n = 12 输出：3 解释：12 = 4 + 4 + 4</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：</p>
<p>空间复杂度O($ n$)：</p>
<p>解法一 回溯法 相当于一种暴力的方法，去考虑所有的分解方案，找出最小的解，举个例子。</p>
<blockquote>
<p>n = 12 先把 n 减去一个平方数，然后求剩下的数分解成平方数和所需的最小个数</p>
<p>把 n 减去 4, 然后求出 8 分解成平方数和所需的最小个数,记做 n2 那么当前方案总共需要 n2 + 1 个平方数</p>
<p>把 n 减去 9, 然后求出 3 分解成平方数和所需的最小个数,记做 n3 那么当前方案总共需要 n3 + 1 个平方数</p>
<p>下一个平方数是 16, 大于 12, 不能再分了。</p>
<p>接下来我们只需要从 (n1 + 1), (n2 + 1), (n3 + 1) 三种方案中选择最小的个数, 此时就是 12 分解成平方数和所需的最小个数了</p>
<p>至于求 11、8、3 分解成最小平方数和所需的最小个数继续用上边的方法去求</p>
<p>直到如果求 0 分解成最小平方数的和的个数, 返回 0 即可</p>
</blockquote>
<p>代码的话，就是回溯的写法，或者说是 DFS。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numSquaresHelper(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numSquaresHelper</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里很巧妙的一点是，假如最终这个数不能分解为完全平方数的和，就返回MAX_VALUE</span></span><br><span class="line">    <span class="keyword">int</span> count = Integer.MAX_VALUE; </span><br><span class="line">    <span class="comment">//依次减去一个平方数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//选最小的</span></span><br><span class="line">        count = Math.min(count, numSquaresHelper(n - i * i) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然上边的会造成超时，很多解会重复的计算，之前也遇到很多这种情况了。需要 memoization 技术，也就是把过程中的解利用 HashMap 全部保存起来即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numSquaresHelper(n, <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numSquaresHelper</span><span class="params">(<span class="keyword">int</span> n, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        count = Math.min(count, numSquaresHelper(n - i * i, map) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(n, count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，转换为动态规划的解法也是相同的。</p>
<p>定义一维整型数组dp[i]，表示给定正整数i，它能够被分解为完全平方数时，这些数最少的数量，并将它初始化为正无穷。</p>
<p>思考递推式，令 j 从 1：i，且 j^2&lt;=i（注意等号！） ，则 dp[i] = Math.min( dp[i]，dp[i-j^2]+1）</p>
<p>思考边界条件，让dp的下标和整数数字刚好对应，因此dp的大小为 i + 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义一维整型数组，让dp[i]刚好和数字i对应，代表能够被分解的最小个数</span></span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j*j &lt;= i; j++)&#123; <span class="comment">//注意这里是 &lt;= i，刚好等于i的时候可以被分解！</span></span><br><span class="line">                <span class="comment">//这里本质上就是将i拆分成多个完全平方数，并利用之前的结果</span></span><br><span class="line">                dp[i] = Math.min( dp[i], dp[ i - j*j ] + <span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长递增子序列">300 最长递增子序列</h3>
<p><strong>题目描述</strong></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1：</p>
<p>输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n^2\)</span>)：</p>
<p>空间复杂度O($ n$)：</p>
<p>这道题和<strong>连续子数组的最大和、乘积最大子数组</strong>非常类似，</p>
<p><strong>定义一维整型数组dp[i]，表示以元素 array[i] 为结尾的最长递增子序列的长度</strong>。</p>
<p>思考状态转移方程，此时要判断 array[i] 和之前的数字的关系，可以发现，假如 array[i] &gt; array[j]，j &lt; i，那么它可以扩展以array[j]为结尾的最长递增子序列的长度。因此可以得到状态转移方程：dp[i] = Math.max( dp[i]，dp[j] +1 )。</p>
<p>边界条件，可以发现dp[i]只和前面的数字大小有关，因此dp数组的长度和子序列长度一样即可。</p>
<p><strong>注意所有位置都初始化为1！</strong>因为其本身就可以构成1个递增子序列！如果不是1则会导致最后结果少1 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义一维整型数组dp[i]，表示以元素 array[i] 为结尾的最长递增子序列的长度</span></span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义边界条件，所有位置都初始化为1！因为其本身就可以构成1个递增子序列！</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历每一个数字，判断和前面所有数字的大小关系看是否能够构成子序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max( dp[i], dp[j]+<span class="number">1</span> );</span><br><span class="line">                    res = Math.max( res, dp[i]);</span><br><span class="line">                &#125;                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分查找法见题解。纸牌游戏。注意如果牌能够比堆顶元素小，则在数组中就直接覆盖掉堆顶元素。</p>
<h3 id="最佳买卖股票时机含冷冻期">309 最佳买卖股票时机含冷冻期</h3>
<p><strong>题目描述</strong></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例:</p>
<p>输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<p><strong>题解</strong></p>
<p>最开始可能考虑的是一维dp数组，但是发现令dp[i]表示到第i天为止所得的最大利润时，考虑array[i]中的值和之前值的关系，发现它取决于是否买入和是否卖出等多种状态，因此需要定义二维数组分别表示这些状态。</p>
<p><strong>令二维整型数组dp[i][j]表示第i天在第j种状态下，到目前为止所得利润的最大值。</strong>j有三种状态，在三种状态下分别讨论和之前array中值的关系：</p>
<ul>
<li><p>dp[i][0]：不持股，且今天没卖出</p>
<p>则对于前一天来说，可能不持股且当天卖出了，或者前一天同样不持股。</p>
<p>dp[i][0] = Math.max( dp[i-1][2], dp[i-1][0] )</p></li>
<li><p>dp[i][1]：持股</p>
<p>则对于前一天来说，可能是之前就买了股票，也就是一直都是持股的。或者是今天刚刚买入的，但是今天刚买入的话，前一天必须是不持股且没有卖出的（因为存在冷冻期），因此是第一种状态；并且买入后利润减少。</p>
<p>dp[i][1] = Math.max( dp[i-1][1], dp[i-1][0] - array[i] )</p></li>
<li><p>dp[i][2]：不持股，且当天卖出</p>
<p>则对于前一天来说，它必须是持股的，且今天卖出后利润增加。</p>
<p>dp[i][2] = dp[i-1][1] + array[i]</p></li>
</ul>
<p>则边界条件为第0天的时候：</p>
<p>dp[0][0] = 0</p>
<p>dp[0][1] = -array[0]：表示第0天的时候已经是买入状态</p>
<p>dp[0][2] = 0</p>
<p>注意，不用计算买入和卖出的差值，直接将价格从利润中减去即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理为空的输入情况</span></span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//三种状态分别考虑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max( dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>] );</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max( dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i][<span class="number">1</span>] + prices[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max( dp[prices.length-<span class="number">1</span>][<span class="number">0</span>], Math.max( dp[prices.length-<span class="number">1</span>][<span class="number">1</span>], dp[prices.length-<span class="number">1</span>][<span class="number">2</span>] ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="零钱兑换">322 零钱兑换</h3>
<p><strong>题目描述</strong></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1</p>
</blockquote>
<p><strong>题解</strong></p>
<p>最原始的方法是进行递归，对于amount，每次都减去coins中的所有数字，然后判断是否为0，这样一直到底即可。</p>
<p>但是这样可以发现，随着amount逐渐变小，中间有些数字会被重复计算，比如 11 -1 -2 和 11 -2 -1 是相同的结果。</p>
<p>因此存在含有重叠的子问题，这时候考虑动态规划。</p>
<p><strong>令一维整型数组dp[i]表示在金额为 amount = i 时的最少的硬币个数。</strong></p>
<p>考虑 dp[i] 和 之前状态的关系，可以发现对于金额为 i 的时候，<strong>考虑每一个coins是否能够组合成当前金额 i</strong> 。</p>
<p>dp[i] = Math.min( dp[i], dp[ i - coins[j] ] + 1 )</p>
<p>则边界条件为当金额为0的时候，使用的硬币个数也为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(coins.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//因为下面要用min来比较，所以这里取最大值</span></span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;coins.length; j++)&#123;</span><br><span class="line">            	<span class="keyword">if</span>( (i-coins[j]&gt;=<span class="number">0</span>) &amp;&amp; dp[ i-coins[j] ] != Integer.MAX_VALUE ) <span class="comment">//防止前一个位置是无法组成的情况</span></span><br><span class="line">                    dp[i] = Math.min( dp[i], dp[ i-coins[j] ]+<span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是无法组成的情况就返回-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列">1143 最长公共子序列</h3>
<p><strong>题目描述</strong></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>示例 1:</p>
<p>输入：text1 = "abcde", text2 = "ace" 输出：3<br>
解释：最长公共子序列是 "ace"，它的长度为 3。</p>
<p><strong>题解</strong></p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/14.png" style="zoom:50%;"></p>
<p><strong>定义二维整型数组dp[i][j]：表示长度为 [0, i - 1] 的字符串 text1 与长度为 [0, j - 1] 的字符串 text2 的最长公共子序列为 dp[i][j]。</strong></p>
<p>则思考状态转移方程：</p>
<ol type="1">
<li><p>若当前字符相同，则找到了一个公共元素，最长公共子序列长度可以往后推进：dp[i][j] = dp[i-1][j-1] + 1</p></li>
<li><p>若当前字符不同，则没有公共元素，最长公共子序列长度为text1或text2回退一个字符时的最大值：</p></li>
</ol>
<p>dp[i][j] = Math.max( dp[i - 1][j], dp[i][j - 1] )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>最长回文子串：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua-jie-/</p>
<p>不同路径：https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-di-gui-gong-shi-deng-3z-9mp1/</p>
<p>不同的二叉搜索树：https://leetcode-cn.com/problems/unique-binary-search-trees/solution/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/</p>
<p>单词拆分：https://leetcode-cn.com/problems/word-break/solution/shou-hui-tu-jie-san-chong-fang-fa-dfs-bfs-dong-tai/</p>
<p>https://leetcode-cn.com/problems/word-break/solution/wu-qu-chan-shu-by-tinylife/</p>
<p>打家劫舍：https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-ikaruga/</p>
<p>https://leetcode-cn.com/problems/house-robber/solution/hua-jie-suan-fa-198-da-jia-jie-she-by-guanpengchn/</p>
<p>最大正方形：https://leetcode-cn.com/problems/maximal-square/solution/221-zui-da-zheng-fang-xing-tu-jie-shi-pin-yan-shi-/</p>
<p>完全平方数：https://leetcode-cn.com/problems/perfect-squares/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--51/</p>
<p>最长递增子序列：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/</p>
<p>最佳买卖股票时机含冷冻期：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</p>
<p>零钱兑换：https://leetcode-cn.com/problems/coin-change/solution/javadi-gui-ji-yi-hua-sou-suo-dong-tai-gui-hua-by-s/</p>
<p>最长公共子序列：</p>
<p>https://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-dong-tai-g-fhyd/</p>
<p>https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-tu-wen-jie-xi-by-yijiaoqian/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 数组</title>
    <url>/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>剑指Offer中关于数组的题目解析。</p>
<a id="more"></a>
<h3 id="斐波那契数列">01 斐波那契数列</h3>
<p><strong>题目描述</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>斐波那契额数字的规律为，当<span class="math inline">\(n\geq2\)</span>时，<span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span></p>
<p><strong>方法一：递归法</strong></p>
<p>时间复杂度：O(<span class="math inline">\(2^n\)</span>) 空间复杂度：递归栈的空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>)+Fibonacci(n-<span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归法会产生大量的重复计算：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/0.png" style="zoom:50%;"></p>
<p><strong>方法二：存储法</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(<span class="math inline">\(1\)</span>)</p>
<p>每次仅用到了最近的两个数，所以可以只存储最近的两个数</p>
<p>sum 存储第 n 项的值，one 存储第 n-1 项的值，two 存储第 n-2 项的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            sum = one + two;</span><br><span class="line">            two = one;</span><br><span class="line">            one = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中出现次数超过一半的数字">02 数组中出现次数超过一半的数字</h3>
<p><strong>题目描述</strong> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,2,2,2,5,4,2]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p>若某个数字出现的次数超过数组长度的一半，则它可以<strong>抵消掉</strong>所有剩下的数字。</p>
<p>用一个变量记录数字，一个变量记录它出现的次数。当次数被其他数字抵消为0时，即可更换新的数字。那么最后变量中存储的数字，可能满足条件也可能不满足，因此需要检验它的次数是否超过数组长度的一半。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不断抵消</span></span><br><span class="line">        <span class="keyword">int</span> num = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;array.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">                    num = array[i];</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                </span><br><span class="line">                <span class="keyword">if</span>(array[i] == num)&#123;</span><br><span class="line">                	cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">            	&#125;                </span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//统计次数</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == num)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//超过一半则为满足条件的数字</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;array.length/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建乘积数组">03 构建乘积数组</h3>
<p><strong>题目描述</strong></p>
<p>给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]<em>A[1]...A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] </em> A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）</p>
<p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[120,60,40,30,24]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/1.png" style="zoom: 50%;"></p>
<p>先计算下三角，再计算上三角。下三角从上往下，下三角从下往上。因为按照这个顺序时，可以发现前一个值上多乘一个数就是后一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(A.length&lt;=<span class="number">1</span> || A==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下三角</span></span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.length; i++)</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上三角，用一个数纪录累乘结果</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">//i=0时，即B[0]也是要计算的</span></span><br><span class="line">            tmp = tmp*A[i+<span class="number">1</span>];</span><br><span class="line">            B[i] = B[i]*tmp;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">		<span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字在排序数组中出现的次数">04 数字在排序数组中出现的次数</h3>
<p><strong>题目描述</strong></p>
<p>统计一个数字在升序数组中出现的次数。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,3,3,3,4,5],3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(logn\)</span>) 空间复杂度：O(1)</p>
<p>使用二分法分别找到 左边界left和右边界right，易得数字target的数量为 right - left - 1。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/2.png" style="zoom: 67%;"></p>
<ol type="1">
<li>初始化： 左边界 i = 0，右边界 j = len(nums) - 1。</li>
<li>循环二分： 当闭区间 [i, j] 无元素时跳出（不满足i<span class="math inline">\(\leq\)</span>j时）；
<ol type="1">
<li>计算中点 m = (i + j) / 2（向下取整）；</li>
<li>若 nums[m] &lt; target ，则 target在闭区间 [m + 1, j] 中，因此执行 i = m + 1；</li>
<li>若 target &lt; nums[m] ，则 target在闭区间 [i, m - 1] 中，因此执行 j = m - 1;</li>
<li>若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；左边界 left 在闭区间 [i, m-1] 中。因此分为以下两种情况：
<ol type="1">
<li>若查找 右边界 right ，则执行 i = m + 1，可以并入nums[m] &lt; target的情况 ；（跳出时 i 指向右边界）</li>
<li>若查找 左边界 left ，则执行 j = m - 1，可以并入target &lt; nums[m] 的情况 ；（跳出时 j 指向左边界）</li>
</ol></li>
</ol></li>
<li>返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right - left - 1 即可。</li>
</ol>
<p>注意到，如果不存在target的时候，right就是最接近target的那个比target大的数，left亦然。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//寻找右边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&lt;=k)&#123; <span class="comment">//这里是将(nums[m] &lt; target) 和 (nums[m] == target &amp;&amp; 探寻右边界) 的情况合并在一起</span></span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rbound = i;</span><br><span class="line">        <span class="comment">//此时i指向右边界，j指向最右边的target</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//寻找左边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&lt;k)&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lbound = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rbound - lbound - <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种简化代码的方式就是只寻找右边界。</p>
<h3 id="和为s的两个数字">05 和为S的两个数字</h3>
<p><strong>题目描述</strong></p>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>返回值描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,4,7,11,15],15</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,11]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> small = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> large = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = Integer.MAX_VALUE; <span class="comment">//判断两数的乘积</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[left]+array[right]&lt;sum)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[left]+array[right]&gt;sum)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(array[left]*array[right]&lt;tmp)&#123;</span><br><span class="line">                    small = array[left];</span><br><span class="line">                    large = array[right];</span><br><span class="line">                    tmp = small*large;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                      </span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(tmp != Integer.MAX_VALUE)&#123;</span><br><span class="line">            res.add(small);</span><br><span class="line">            res.add(large);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中重复的数字">06 数组中重复的数字</h3>
<p><strong>题目描述</strong></p>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p>返回描述：</p>
<p>如果数组中有重复的数字，函数返回true，否则返回false。</p>
<p>如果数组中有重复的数字，把重复的数字放到参数duplication[0]中。（ps:duplication已经初始化，可以直接赋值使用。）</p>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>)：可以设想把交换数字、查找数字解耦，分开看。在此方法下，每访问数组的一个单元格 nums[i] ，就可以把一个数字填到属于它的位置；因此， 将 n 个数字填到正确的位置最多需要 N 次操作，复杂度为 O(N) 。而搜索重复数字的条件是 <code>nums[nums[i]] == nums[i]</code> ，找到这样的数字只需要遍历一遍数组，复杂度为 O(N)。这里只是将两个步骤合在一起写了。 空间复杂度：O(1)</p>
<p>原地交换</p>
<p><strong>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内</strong> 。 此说明含义：数组元素的 索引和 值 是 一对多 的关系。 因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/3.png" style="zoom:67%;"></p>
<p>nums[i]为当前遍历到的数组中的数字，它分为如下三种情况：</p>
<p>若 nums[i] = i： 说明此数字已在对应索引位置，无需交换，因此跳过； 若 nums[nums[i]] = nums[i]： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找到一组重复值，返回此值 nums[i]； 否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。</p>
<p>注意，每遍历到一个位置，都要交换到数组中的数字和下标相同为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发现数组中的值，和要交换的目标相同，即发现重复</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[ numbers[i] ])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前遍历到的数字交换到它所对应的下标上</span></span><br><span class="line">            <span class="keyword">int</span> tmp = numbers[numbers[i]];</span><br><span class="line">            numbers[numbers[i]] = numbers[i];</span><br><span class="line">            numbers[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找">07 二维数组中的查找</h3>
<p><strong>题目描述</strong></p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p>将矩阵旋转后可以发现类似二叉搜索树，根节点为左下角或右上角，选左下角较为方便。暴力遍历二维矩阵的复杂度为O(<span class="math inline">\(mn\)</span>)。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/4.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//令根节点为左下角</span></span><br><span class="line">        <span class="keyword">int</span> row = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( row &gt;= <span class="number">0</span> &amp;&amp; col &lt; array[<span class="number">0</span>].length )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[row][col] &lt; target)&#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[row][col] &gt; target)&#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整数组顺序使奇数位于偶数前面">08 调整数组顺序使奇数位于偶数前面</h3>
<p>题目描述</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(n^2\)</span>) 空间复杂度：O(1)</p>
<p>插入排序思想，从前往后遍历，不断地挪动位置来使得相对位置保持不变。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/5.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//基数继续移动，偶数停止移动</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; array.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">//偶数继续移动，基数停止移动</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找不到基数则可以停止</span></span><br><span class="line">            <span class="keyword">if</span>(j == array.length)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//此时将a[j]插入到a[i]的位置，即把基数插入到前面</span></span><br><span class="line">            <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j-<span class="number">1</span>; k&gt;=i ; k--)&#123;</span><br><span class="line">                array[k+<span class="number">1</span>] = array[k];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i] = tmp;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(<span class="math inline">\(n^2\)</span>) 空间复杂度：O(1)</p>
<p>冒泡排序思想，即每次将一个偶数交换到最后一个位置，同样可以保持相对顺序不变，冒泡排序稍微快一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123; <span class="comment">//第一个循环只是用来表明有几个数被交换了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123; <span class="comment">// -i是因为已经将i个偶数交换到最后了</span></span><br><span class="line">                <span class="keyword">if</span>(array[j]%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; array[j+<span class="number">1</span>]%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺时针打印矩阵">09 顺时针打印矩阵</h3>
<p>题目描述</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[1,2,3],[4,5,6],[7,8,9]][[1,2],[3,4]]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(mn\)</span>) 空间复杂度：O(1)</p>
<p>时间复杂度为遍历矩阵。直接模拟遍历，主要是设置四个边界，并将边界往中间缩减。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/6.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义边界</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在四个方向上移动</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 左右移动，在上边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r; j++) res.add( matrix[t][j] );</span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>; <span class="comment">//++t&gt;b 等价于先给t自增1 ，再判断。这里非常巧妙地避免了重复打印，又缩小边界</span></span><br><span class="line">            <span class="comment">// 上下移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j &lt;= b; j++) res.add( matrix[j][r] );</span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 右左移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = r; j &gt;= l; j--) res.add( matrix[b][j] );</span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 下上移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = b; j &gt;= t; j--) res.add( matrix[j][l] );</span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把数组排成最小的数">10 把数组排成最小的数</h3>
<p><strong>题目描述</strong></p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,32,321]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;321323&quot;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(nlogn\)</span>) 空间复杂度：O(<span class="math inline">\(n\)</span>)</p>
<p>自定义排序规则，将所有数字转为字符串（空间复杂度），若<code>a+b &lt; b+a</code>，为了使得组合数字尽可能小，因此得到规则<code>a&lt;b</code>，将a尽可能放到前面（排序，时间复杂度）。</p>
<p>Java中的compareto方法，返回参与比较的前后a、b两个字符串的asc码的差值，负数则说明a&lt;b。</p>
<p>Java编译器对String做了特殊处理，使得可以直接用+拼接字符串。在循环拼接字符串的过程中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转成字符串</span></span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(numbers[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义排序规则并排序</span></span><br><span class="line">        Arrays.sort(strs, (x,y)-&gt; (x+y).compareTo((y+x)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; numbers.length; i++)</span><br><span class="line">            res.append(strs[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="机器人的运动范围">11 机器人的运动范围</h3>
<p><strong>题目描述</strong></p>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5,10,10</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(mn\)</span>) 遍历整个矩阵计算是否可达 空间复杂度：O(<span class="math inline">\(mn\)</span>) 记录是否已经到达过</p>
<p>由于机器人从(0,0)开始走，因此可以只向右走和向下走，就能遍历到矩阵的所有元素，不会漏掉。</p>
<p>求数位和的方法就是不断地取模10，累加余数。</p>
<p>Java中布尔型(boolean)变量默认值为false。</p>
<p>采用DFS方法，回溯地遍历整个整个矩阵。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义求数位和的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x !=<span class="number">0</span> )&#123;</span><br><span class="line">            res = res + x % <span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">return</span> dfs(rows, cols, threshold, visited, <span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> threshold, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>( x &gt;= rows || y &gt;= cols || visited[x][y] || sums(x) + sums(y) &gt; threshold ) <span class="comment">//注意先判断是否越界，否则visited可能会导致数组越界异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归遍历</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(rows, cols, threshold, visited, x, y+<span class="number">1</span>) + dfs(rows, cols, threshold, visited, x+<span class="number">1</span>, y);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的逆序对">12 数组中的逆序对</h3>
<p><strong>题目描述</strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>对于50%的数据,<span class="math inline">\(size\leq 10^4\)</span> 对于75%的数据,<span class="math inline">\(size\leq 10^5\)</span> 对于100%的数据,<span class="math inline">\(size\leq 2*10^5\)</span></p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,0]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(nlogn\)</span>) 空间复杂度：O(<span class="math inline">\(n\)</span>)</p>
<p>利用归并排序的思想，在两个有序数组的归并过程中，统计逆序对的数量。这样就将蛮力法两次循环的复杂度（<span class="math inline">\(O(n^2)\)</span>），降低为归并排序的复杂度。</p>
<p>假设我们有两个已排序的序列等待合并，分别是$ L = { 8, 12, 16, 22, 100 }<span class="math inline">\(和\)</span>R={9,26,55,64,91}<span class="math inline">\(。一开始我们用指针\)</span>lPtr = 0<span class="math inline">\(指向\)</span>L<span class="math inline">\(的首部，\)</span>rPtr = 0$ 指向<span class="math inline">\(R\)</span>的头部。记已经合并好的部分为 M。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; []</span><br><span class="line">     |                          |</span><br><span class="line">   lPtr                       rPtr</span><br></pre></td></tr></table></figure>
<p>lPtr 指向的元素小于 rPtr 指向的元素，于是把 lPtr 指向的元素放入辅助数组，并把 lPtr 后移一位。这个时候把左边的 8 加入了辅助数组，可以发现发现右边没有数比 8 小，所以 8 对逆序对总数的「贡献」为 0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>
<p>接着继续合并，把 9 加入了辅助数组，此时 lPtr 指向 12，rPtr 指向 26。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8, 9]</span><br><span class="line">        |                          |</span><br><span class="line">       lPtr                       rPtr</span><br></pre></td></tr></table></figure>
<p>然后，继续合并，将左边的12加入辅助数组。此时 lPtr 比 rPtr 小，把 lPtr 对应的数加入答案，并考虑它对逆序对总数的贡献为 rPtr 相对 R 首位置的偏移 1（即右边只有一个数比 12 小，所以只有它和 12 构成逆序对），以此类推。</p>
<p>用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，只在 lPtr 右移的时候计算，当前 lPtr 指向的数字比 rPtr 小，但是比 R 中 [0 ... rPtr - 1] 的其他数字大，[0 ... rPtr - 1] 的其他数字本应当排在 lPtr 对应数字的左边，但是它排在了右边，所以这里就贡献了 rPtr 个逆序对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">//全局变量记录结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span> || array == <span class="keyword">null</span> || left == right) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//此时左右数组皆为有序</span></span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right) &#123;</span><br><span class="line">            </span><br><span class="line">            result = array[l]&lt;array[r]? (result+r-(mid+<span class="number">1</span>))%<span class="number">1000000007</span> : result; <span class="comment">//左指针数字更小，则发生判断表明右边产生逆序对，即右指针的偏移量</span></span><br><span class="line">            help[p++] = array[l]&lt;array[r]? array[l++] : array[r++]; <span class="comment">//进行排序，将小的数字放入辅助数组</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缺点就在这个位置</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid)&#123; </span><br><span class="line">            result = (result + right-mid)%<span class="number">1000000007</span>;</span><br><span class="line">            help[p++] = array[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right) help[p++] = array[r++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将辅助数组的值复制到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;help.length; i++)</span><br><span class="line">            array[left+i] = help[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到，统计右边数组的偏移量时，假如右边数组先偏移完成，会导致左边数组每次偏移的时候都要统计一遍，因为此时左数组中的每个值都比右数组大，因此左边数组剩下的每一个数都可以和右边数组产生逆序对。</p>
<p>因此做出如下改动，当右数组的值小于左数组的时候，将右数组的值加入辅助数组，左数组剩余的个数即为逆序对个数，因为此时左数组中剩余的数都可以和当前右数组的数构成逆序对。</p>
<p><strong>即当左数组偏移的时候，表明左数组的数小，不和右数组构成逆序对。当右数组偏移的时候，表明右数组的数小，左数组剩余的数每个都可以和当前右数组的值构成逆序对。因此，不会产生遗漏。</strong></p>
<p>例如此时，12比9大，因此将9加入辅助数组，此时可以发现，左数组中剩余的每个数，都可以和当前右数组中的值9构成逆序对，因此发生统计行为。所以此时是右数组发生偏移的时候，才产生统计操作，而非左数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>
<p>接着继续合并，把 9 加入了辅助数组，此时 lPtr 指向 12，rPtr 指向 26。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">//全局变量记录结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span> || array == <span class="keyword">null</span> || left == right) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//此时左右数组皆为有序</span></span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[l] &lt;= array[r])&#123;</span><br><span class="line">                help[p++] = array[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//右数组的数小，左数组每个剩余的数都可以和当前右数组数构成逆序对</span></span><br><span class="line">                result = (result + mid-l+<span class="number">1</span>)%<span class="number">1000000007</span>;</span><br><span class="line">                help[p++] = array[r++];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid) help[p++] = array[l++];   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right) help[p++] = array[r++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将辅助数组的值复制到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;help.length; i++)</span><br><span class="line">            array[left+i] = help[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最快的方法是不要每次都新开数组help，直接在一开始就开辟一个同样长度的数组，然后每次都在这个数组上进行操作。</p>
<h3 id="旋转数组的最小数字">013 旋转数组的最小数字</h3>
<p><strong>题目描述</strong></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,4,5,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(logn\)</span>)：二分法的复杂度，当数组中的数字全部相同时退化为O(<span class="math inline">\(n\)</span>) 空间复杂度O(1)：</p>
<p>排序数组的查找问题，首先想到二分法。旋转后数组可以分为两部分，前半部分比后半部分都要大，因此每次二分时有如下情况：</p>
<p>1、mid &gt; high，比后半部分数组大的情况，说明mid现在在前半部分数组中，要找的最小数字应该在mid之后，low = mid + 1。</p>
<p>2、mid &lt; high， 比后半部分数组小的情况，说明mid现在在后半部分数组中，要找的最小数字应该在mid之前，high = mid。注意！这里不是high = mid -1，因为要找的最小数字可能是mid！</p>
<p>3、当mid = high，无法判断mid所在位置，将high--缩小范围。</p>
<p>直到 low == high时，找到最小的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt; array[high])</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; array[high])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连续子数组的最大和">014 连续子数组的最大和</h3>
<p>题目描述</p>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,-2,3,10,-4,7,2,-5]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历一遍数组 空间复杂度O(<span class="math inline">\(n\)</span>)：使用辅助数组，或者直接在原数组上修改也可</p>
<p>首先，注意是<strong>连续子数组</strong>。</p>
<p>使用一维数组动态规划的方法，dp[i]代表以元素 array[i] 为结尾的连续子数组最大和。</p>
<p>讨论，dp[i]和dp[i-1]的关系，假如dp[i-1]为负数或者0，说明dp[i-1]对dp[i]没有产生贡献，即dp[i-1]+array[i]还不如array[i]本身要大。<strong>此时连续子数组的开头变更为array[i]</strong>。</p>
<p>因此，注意dp[array.length -1]，即到最后一个元素时，<strong>以最后一个元素为结尾的连续子数组最大和并不一定是最大的</strong>！可能是前面的某个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= array.length-<span class="number">1</span>; i++)&#123;            </span><br><span class="line">            dp[i] = Math.max( array[i], array[i]+dp[i-<span class="number">1</span>] );</span><br><span class="line">            max = Math.max( max, dp[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中只出现一次的数字及2">015 数组中只出现一次的数字（及2）</h3>
<p>题目描述</p>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历两遍数组 空间复杂度O(1)：不使用额外空间</p>
<p>异或运算：相同为0，不同为1</p>
<p>异或运算拥有如下性质：</p>
<p>任何数和0异或，仍为本身：a⊕0 = a 任何数和本身异或，为0：a⊕a = 0 异或运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b</p>
<p>则可以知道，当<strong>任何数出现两次之后，其异或值都为0，即可以消去</strong>。假如将数组中的所有数都异或，则剩下那两个只出现一次的数的异或结果，这是<strong>由异或的交换律和结合律</strong>决定的：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/7.png" style="zoom:33%;"></p>
<p>当得到两个数的异或结果时，由异或不同位置为1的计算可以知道，<strong>这两个数在有1的位置上，肯定是有一个是1，有一个是0</strong> 。那么，<strong>将剩余的数按照这个位置分成两组，两组内分别异或</strong>之后就可以消去出现两次的数，则分别只剩下只出现一次的数。</p>
<p>问题1：如何找到异或结果中为1的位置？</p>
<p>x &amp; (-x) 来保留最右边的 1。</p>
<p>一个数（x）的负数（-x），其二进制表示为反码+1（~x+1）。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/8.png" style="zoom: 43%;"></p>
<p>某个数最右边的1，反码之后为0，加1肯定是这个位置变成1（因为它是最右边，或者进位），因此x &amp; (-x) 的运算结果就是二进制下保留最右边的 1，其余位置皆为0。</p>
<p>问题2：如何将剩余的数按照某个位置分成组？</p>
<p>x &amp; 010 即可对 x 进行分组。</p>
<p>因为只有一位为1，因此&amp;就运算结果为0的就分为一组，不为0的就可以分为另一组。</p>
<p>最后，初始化两个变量为0，分别和不同分组的数做异或运算即可（初始化为0利用了a⊕0 = a的性质）。</p>
<p>因此，整个算法流程如下：</p>
<p>1、所有数做异或运算，得到仅出现一次的两个数的异或结果。</p>
<p>2、x &amp; (-x) 来保留异或结果最右边的 1</p>
<p>3、利用&amp;操作对数字进行分组，再次对所有数进行异或，即可得到两个结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//得到仅出现一次的两个数的异或结果</span></span><br><span class="line">        <span class="keyword">int</span> xorall = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)</span><br><span class="line">            xorall = xorall ^ i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//x &amp; (-x) 来保留异或结果最右边的 1</span></span><br><span class="line">        <span class="keyword">int</span> split = xorall &amp; (-xorall);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//利用&amp;操作对数字进行分组，并再次对所有数进行异或</span></span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>; num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)&#123;      </span><br><span class="line">            <span class="keyword">if</span>((i&amp;split) == <span class="number">0</span>)</span><br><span class="line">            	num1[<span class="number">0</span>] = num1[<span class="number">0</span>] ^ i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] = num2[<span class="number">0</span>] ^ i;         </span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目描述</strong></p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>输入: [2,2,3,2] 输出: 3</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(32n\)</span>)：整数二进制一共有32位，每一位都要遍历一遍数组，统计1的个数 空间复杂度O(1)：不使用额外空间</p>
<p>由于出现多次的数字变成了奇数，因此不能用异或进行消去。转为二进制<strong>考虑数组中所有数字，转为二进制后，每一位上面1个个数和</strong>：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/9.png" style="zoom:43%;"></p>
<p>如果其他数都出现 3 次，只有目标数出现 1 次，那么每一位的 1 的个数无非有这2种情况，为 3 的倍数（全为出现三次的数） 或 3 的倍数 +1（包含出现一次的数）。这个 3 的倍数 +1 的情况也就是我们的目标数的那一位。</p>
<p>因此算法首先将结果初始化为0，然后统计每一位上1的个数，并将%3!=0的位置修改为1。</p>
<p><strong>&lt;&lt;</strong> 左移动运算符：运算数的各二进位全部左移若干位，高位丢弃，低位补0。（将二进制的1挪动到需要的位置上）</p>
<p><strong>&gt;&gt;</strong> 右移动运算符：运算数的各二进位全部右移若干位，低位丢弃，高位补0。（判断每位的1的个数时，移动到该位置）</p>
<p>a &amp; 1：a &amp; 1 中 1 只有最后一位为 1，其余位皆为 0 ，因此 a &amp; 1的作用就是判断 a 的最后一位是否为 1。（判断每位的1的个数）</p>
<p>a | 1：只要对应的二个二进制位有一个为1时，结果位就为1。（将结果的某个位置修改为1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">              <span class="comment">//先将数右移，并求出最后一位为 1 的个数</span></span><br><span class="line">              <span class="comment">//比如 0 3 4，就会先判断4，再到3，再到0</span></span><br><span class="line">              <span class="keyword">if</span> ((nums[j] &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;             </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到某一位取余为 1 的数，把1左移到那个位置，再和结果取或，就可以把对应位置修改为1</span></span><br><span class="line">          <span class="keyword">if</span> (count % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">              res = <span class="number">1</span> &lt;&lt; i | res;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和为s的连续正数序列">016 和为s的连续正数序列</h3>
<p><strong>题目描述</strong></p>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<p>输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：</p>
<p>输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：最多循环n次（left和right都到达n/2） 空间复杂度O(1)：不使用额外空间</p>
<p>注意到题目中所说的连续序列，则联想到滑动窗口。</p>
<p>滑动窗口可以看成<strong>数组中框起来的一个部分</strong>。滑动窗口一般表示成一个<strong>左闭右开区间</strong>。在一开始，i=1, j=1，滑动窗口位于序列的最左侧，窗口大小为零。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/10.png" style="zoom:50%;"></p>
<p>则可以知道每次判断滑动窗口内数字的和，根据和的大小来判断左右端点的变化。</p>
<ul>
<li>当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li>
<li>当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li>
<li>当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i, j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动。</li>
</ul>
<p>左端点最多只能到target/2处，它加上后面的任何一个数都已经比target要大了。</p>
<p><strong>实际上，把题目中的正整数序列换成任意的递增整数序列，滑动窗口方法都可以解。</strong></p>
<p>滑动窗口的重要性质是：窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">       </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;<span class="comment">//注意右边是开区间，不能取到这个数</span></span><br><span class="line">        <span class="keyword">int</span> tmpsum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= sum/<span class="number">2</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tmpsum &lt; sum)&#123; <span class="comment">//扩展窗口右边界，增大tmpsum</span></span><br><span class="line">                tmpsum = tmpsum + right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &gt; sum)&#123; <span class="comment">//扩展窗口左边界，减小tmpsum</span></span><br><span class="line">                tmpsum = tmpsum - left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//记录结果</span></span><br><span class="line">                ArrayList&lt;Integer&gt; tmpres = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++)</span><br><span class="line">                    tmpres.add(i);</span><br><span class="line">                res.add(tmpres);</span><br><span class="line">                </span><br><span class="line">                tmpsum = tmpsum - left;<span class="comment">//扩展窗口左边界，减小tmpsum</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>数字在排序数组中出现的次数：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/</p>
<p>数组中重复的数字：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/</p>
<p>二维数组中的查找：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/</p>
<p>调整数组顺序使奇数位于偶数前面：牛客Ariser.cn</p>
<p>顺时针打印矩阵：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/</p>
<p>机器人的运动范围：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/jian-zhi-offerer-shua-javadfs-bfs-tu-jie-py05/</p>
<p>数组中的逆序对：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</p>
<p>旋转数组的最小数字：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</p>
<p>连续子数组的最大和：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</p>
<p>数组中只出现一次的数字（及2）：https://leetcode-cn.com/problems/single-number/solution/dong-hua-dong-tu-yi-ding-hui-by-yuan-chu-vs4p/</p>
<p>和为s的连续正数序列：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 树</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/</url>
    <content><![CDATA[<p>剑指Offer中关于树的题目解析。</p>
<a id="more"></a>
<h3 id="树的深度">01 树的深度</h3>
<p><strong>题目描述</strong></p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,#,6,#,#,7&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，计算树的深度需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下（当树平衡时），退化为链表，系统中同时存储 <span class="math inline">\(n/2\)</span>个节点。</p>
<p>分治法，为 max( 头结点左子树的最大深度, 头结点右子树的最大深度)+1。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/0.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(TreeDepth(root.left), TreeDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的镜像">02 二叉树的镜像</h3>
<p><strong>题目描述</strong></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，计算树的深度需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p>递归法，根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        TreeNode temp = root.left;  </span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        </span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡二叉树">03 平衡二叉树</h3>
<p>题目描述</p>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6,7&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，计算树的深度需要遍历所有节点。注意这里因为使用了提前阻断法，只要有任何子树不满足条件即可返回。否则，时间复杂度变为O(<span class="math inline">\(nlogn\)</span>)，判断每个节点的最大高度 depth(root) 需要遍历 各子树的所有节点 ，子树的节点数的复杂度为O(<span class="math inline">\(logn\)</span>)。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p>递归法，判断左右子树的高度差是否超过1即可，每次递归时返回的是最大子树的高度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//空树也是平衡的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> IsBalanced(root) == -<span class="number">1</span>? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IsBalanced</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如某个子树的高度不满足条件则立刻返回</span></span><br><span class="line">        <span class="keyword">int</span> left = IsBalanced(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right = IsBalanced(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right)+<span class="number">1</span>; <span class="comment">//返回的是最大子树的高度+1</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把二叉树打印成多行">04 把二叉树打印成多行</h3>
<p>题目描述</p>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[8],[6,10],[5,7,9,11]]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，广度优先搜索需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下，当二叉树是平衡的时候，最多有<span class="math inline">\(n/2\)</span>个节点同时在队列中。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/2.png" style="zoom:67%;"></p>
<p>二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。BFS 通常借助 队列 的先入先出特性来实现。队列中存储树的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储结果的ArrayList</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="comment">//利用队列数据结构（先进先出）来实现广度优先搜索</span></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">// Queue是个接口，不能实例化，用多态</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将根节点加入队列</span></span><br><span class="line">        que.add(pRoot);</span><br><span class="line">        <span class="comment">//当队列中有元素的时候</span></span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录这一层有多少个元素</span></span><br><span class="line">            <span class="keyword">int</span> quesize = que.size();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//弹出这一层的元素加入结果ArrayList，并将每个元素的左右子树加入队列Queue</span></span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            TreeNode tempnode;</span><br><span class="line">            <span class="keyword">while</span>(quesize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//弹出结果</span></span><br><span class="line">                tempnode = que.remove();</span><br><span class="line">                temp.add(tempnode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//左右子树加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(tempnode.left != <span class="keyword">null</span>)</span><br><span class="line">                	que.add(tempnode.left);</span><br><span class="line">                <span class="keyword">if</span>(tempnode.right != <span class="keyword">null</span>)</span><br><span class="line">                	que.add(tempnode.right);</span><br><span class="line">                              </span><br><span class="line">                quesize--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.add(temp);</span><br><span class="line">                            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对称的二叉树">05 对称的二叉树</h3>
<p>题目描述</p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,6,5,7,7,5&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，判断镜像需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为O(<span class="math inline">\(n\)</span>)。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/3.png" style="zoom:67%;"></p>
<p>判断二叉树是否对称</p>
<p>若 root == null, 直接返回 true；</p>
<p>否则，判断 root.left 与 root.right 这两棵子树是否对称：</p>
<p>​ 判断 root.left 与 root.right 这两个节点的值是否相等</p>
<p>​ 判断 root.left 的左子树与 root.right 的右子树是否对称。（递归）</p>
<p>​ 判断 root.left 的右子树与 root.right 的左子树是否对称。（递归）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSym(pRoot.left, pRoot.right); <span class="comment">//判断左右子树是否是镜像</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSym</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树都是空的</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树有一个是空的</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树不是空的，判断是否相等，相等返回true</span></span><br><span class="line">        <span class="comment">//left的左子树与right的右子树；left的右子树与right的右子树；是否相等</span></span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; isSym(left.left, right.right) &amp;&amp; isSym(left.right, right.left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的下一个结点">06 二叉树的下一个结点</h3>
<p><strong>题目描述</strong></p>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><strong>题解</strong></p>
<p>首先理解中序遍历，即按左根右顺序遍历。那么当前节点即为根节点，它只有两种情况，其一就是往右子树遍历，其二就是往父节点遍历。</p>
<p>当它存在右子树的时候，那么对右子树按照左根右的顺序，找到最左节点即可。</p>
<p>当它不存在右子树的时候，它只可能是父节点的左子节点或右子节点，此时向上遍历。</p>
<p>​ 若父节点为空，则到达根节点，找不到，已经完成遍历，直接返回。</p>
<p>​ 它是父节点的左子节点，左根右，则父节点为下一个节点。</p>
<p>​ 它是父节点的右子节点，左根右，继续向上遍历（直到满足它是父节点的左子节点）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存在右子树</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找到右子树的最左子树</span></span><br><span class="line">            TreeLinkNode tmp = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                tmp = tmp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//不存在右子树，此时向上遍历</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//父节点为空直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(pNode.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//它是左子节点</span></span><br><span class="line">                <span class="keyword">if</span>(pNode == pNode.next.left)</span><br><span class="line">                    <span class="keyword">return</span> pNode.next; <span class="comment">//返回其父节点作为下一个要遍历的节点</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//它是右子节点，继续向上遍历</span></span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                                                                       </span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从上往下打印二叉树bfs">07 从上往下打印二叉树（BFS）</h3>
<p>题目描述</p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;5,4,#,3,#,2,#,1&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>直接采用BFS广度优先搜索，用队列（先进先出）的数据结构实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            TreeNode tmp = que.remove();</span><br><span class="line">            res.add(tmp.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                que.add(tmp.left);</span><br><span class="line">            <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                que.add(tmp.right);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中和为某一值的路径前序遍历">08 二叉树中和为某一值的路径（前序遍历）</h3>
<p><strong>题目描述</strong></p>
<p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;10,5,12,4,7&#125;,22</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[10,5,7],[10,12]]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，判断深度需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下，退化为链表，最深处刚好满足路径和，同时存储<span class="math inline">\(n\)</span>个节点。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/4.png" style="zoom:67%;"></p>
<p>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 先序遍历 + 路径记录 两部分。</p>
<p>先序遍历： 按照 “根、左、右” 的顺序，遍历树的所有节点。 路径记录： 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 且 ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。</p>
<p>没说一定是正数，所以需要遍历完叶子节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两个全局变量，一个存储最终结果，一个时递归时的暂存变量</span></span><br><span class="line">    <span class="comment">//注意list中存储的是节点内的值，而非节点本身</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        Find(root, target);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        target = target - root.val;</span><br><span class="line">        tmp.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123; <span class="comment">//到达根节点</span></span><br><span class="line">            result.add( <span class="keyword">new</span> ArrayList&lt;&gt;(tmp) ); <span class="comment">//注意新建一个数组，&lt;&gt;泛型处填空   </span></span><br><span class="line">        &#125;</span><br><span class="line">                    </span><br><span class="line">        Find(root.left, target);<span class="comment">//继续遍历左子树</span></span><br><span class="line">        Find(root.right, target);<span class="comment">//继续遍历右子树</span></span><br><span class="line">        </span><br><span class="line">        tmp.remove(tmp.size() - <span class="number">1</span>);<span class="comment">//删除新加入的节点，返回上一层</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重建二叉树">09 重建二叉树</h3>
<p>题目描述</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,5,3,4,6,7&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中 <span class="math inline">\(n\)</span> 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(<span class="math inline">\(n\)</span>)。递归共建立 <span class="math inline">\(n\)</span>个节点，每层递归中的节点建立、搜索操作占用 O(1)，因此使用 O(<span class="math inline">\(n\)</span>)时间。 空间复杂度 O(<span class="math inline">\(n\)</span>)： HashMap 使用O(<span class="math inline">\(n\)</span>) 额外空间。最差情况下，树退化为链表，递归深度达到 <span class="math inline">\(n\)</span>，占用 O(N)O(N) 额外空间；最好情况下，树为满二叉树，递归深度为 <span class="math inline">\(logn\)</span>，占用 O(<span class="math inline">\(logn\)</span>) 额外空间。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/5.png" style="zoom:67%;"></p>
<p>前序遍历性质： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序。 中序遍历性质： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序。</p>
<p>例如：</p>
<p>前序遍历划分 [ 3 | 9 | 20 15 7 ] 中序遍历划分 [ 9 | 3 | 15 20 7 ] 根据以上性质，可得出以下推论：</p>
<p>前序遍历的首元素 为 树的根节点 node 的值。 在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。<strong>可得到左右子树的节点数量。</strong> 根据中序遍历中的左 / 右子树的节点数量，<strong>可将前序遍历划分为</strong> [ 根节点 | 左子树 | 右子树 ] 。</p>
<p>只要知道前序数组的根节点的下标。范围可以通过中序数组获得左右子树长度。</p>
<p>只要知道中序数组的范围。根节点下标可以通过值查找。</p>
<p>本质上就是<strong>根据前序遍历去构建一棵树</strong>，不断地在前序数组和中序数组中查找对应的值。</p>
<p>该方法只能解决<strong>无重复节点值</strong>的二叉树，否则中序数组无法划分左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先定义两个全局变量</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="comment">//查找中序遍历数组下标</span></span><br><span class="line">    <span class="keyword">int</span>[] gpre;<span class="comment">//前序数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对两个全局变量初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">            hm.put(in[i], i);</span><br><span class="line">        gpre = pre;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 传入根节点在前序数组中的下标，以及中序数组的范围；按照前序遍历的方式构建一棵树</span></span><br><span class="line">        <span class="keyword">return</span> reCons( <span class="number">0</span>, <span class="number">0</span>, in.length-<span class="number">1</span>); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序递归遍历建树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reCons</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> in_h, <span class="keyword">int</span> in_t)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(in_h &gt; in_t)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构建当前节点</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(gpre[root]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rindex = hm.get(gpre[root]);</span><br><span class="line">        node.left = reCons( root+<span class="number">1</span>, in_h, rindex-<span class="number">1</span>); <span class="comment">//左子树根节点在前序数组中的下标，中序数组范围</span></span><br><span class="line">        node.right = reCons( root+(rindex - in_h)+<span class="number">1</span>, rindex+<span class="number">1</span>, in_t); </span><br><span class="line">        <span class="comment">//右子树根节点在在前序数组中的下标，对应中序数组范围</span></span><br><span class="line">        <span class="comment">//右子树根节点下标 = 当前节点前序数组下标 + 左子树节点数量 + 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的后序遍历序列">10 二叉树的后序遍历序列</h3>
<p><strong>题目描述</strong></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,8,6,12,16,14,10]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n^2\)</span>)： 递归占用O(<span class="math inline">\(n\)</span>)，最差情况下，树退化为链表，每次递归中的循环都需要遍历所有节点O(<span class="math inline">\(n\)</span>)。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下，退化为链表，递归深度达到<span class="math inline">\(n\)</span>。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/6.png" style="zoom: 50%;"></p>
<p>后序遍历定义： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。 二叉搜索树定义： 左子树中所有节点的值 &lt;&lt; 根节点的值；右子树中所有节点的值 &gt;&gt; 根节点的值；其左、右子树也分别为二叉搜索树。</p>
<p>BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] gsequence;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        gsequence = sequence;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Verify(<span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Verify</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="comment">//注意这里是大于等于，等于表明这里只有一个数，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root = gsequence[right];</span><br><span class="line">        <span class="keyword">int</span> tmp = left;</span><br><span class="line">        <span class="keyword">for</span>(; tmp&lt;=right-<span class="number">1</span>; tmp++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gsequence[tmp]&gt;root)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = tmp; i &lt;= right-<span class="number">1</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(gsequence[i]&lt;root)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Verify( left, tmp-<span class="number">1</span>) &amp;&amp; Verify( tmp, right-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的子结构双重dfs">11 树的子结构（双重DFS）</h3>
<p><strong>题目描述</strong></p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,8,#,9,#,2,#,5&#125;,&#123;8,9,#,2&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(mn\)</span>)： <span class="math inline">\(m、n\)</span>分别是树A、B的节点数量。</p>
<p>空间复杂度 O(<span class="math inline">\(m\)</span>)： 最差情况下，两棵树都退化为链表，递归深度达到最大。当<span class="math inline">\(m\leq n\)</span>时，遍历树A与递归判断的总深度为<span class="math inline">\(m\)</span>；当<span class="math inline">\(m&gt;n\)</span>时，最差情况为遍历至树A的叶子节点，总的递归深度为<span class="math inline">\(m\)</span>。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/7.png" style="zoom: 67%;"></p>
<p>对A树DFS，如果B的根节点与A中某个节点值相同，那么以B为树根进行DFS，判断即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recurA( root1, root2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recurA</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//树1遍历完成都没有找到和树2相等的节点</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="comment">//遍历B</span></span><br><span class="line">            <span class="keyword">if</span>(recurB( root1, root2)) <span class="comment">//遍历树2时判定是子结构，即可直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recurA(root1.left, root2) || recurA(root1.right, root2); <span class="comment">//遍历树1的左右子树</span></span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recurB</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果树2为空，说明树2已经遍历完成，无论树1是否为空，都已经说明了树2是树1的子树</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//到这里就变成了树2不为空，树1为空时说明树1已经遍历完了，树2超过了树1，不是子树</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个都不为空的时候，若值相等即可继续遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> recurB(root1.left, root2.left) &amp;&amp; recurB(root1.right, root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的第k个结点">12 二叉搜索树的第k个结点</h3>
<p>题目描述</p>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;5,3,7,2,4,6,8&#125;,3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;4&#125;</span><br></pre></td></tr></table></figure>
<p>说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按结点数值大小顺序第三小结点的值为4 </span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），无论 k 的值大小，递归深度都为<span class="math inline">\(n\)</span>。 空间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），系统使用O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p>二叉搜索树按照中序遍历的结果，就是数组排序后的结果。</p>
<p>若是求解第k大，则按照右根左顺序遍历即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">//注意使用一个全局变量计数，只有前序遍历时可以直接操作k，否则中序遍历时前序k改变后传不到中序</span></span><br><span class="line">    TreeNode res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        count = k;</span><br><span class="line">        InRecur( pRoot, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InRecur</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || count &lt;=<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        InRecur(pRoot.left);</span><br><span class="line">        </span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            res = pRoot;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        InRecur(pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按之字形顺序打印二叉树">13 按之字形顺序打印二叉树</h3>
<p>题目描述</p>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[8],[10,6],[5,7,9,11]]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>使用Collections.revers方法将ArrayList在偶数行的时候反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        que.add(pRoot);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpSize = <span class="number">0</span>;</span><br><span class="line">        TreeNode tmp;</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            tmpSize = que.size();</span><br><span class="line">            ArrayList&lt;Integer&gt;  tmpAl = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//打印当前队列中的元素</span></span><br><span class="line">            <span class="keyword">while</span>(tmpSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                tmp = que.remove();</span><br><span class="line">                tmpAl.add(tmp.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmp.right);</span><br><span class="line">                </span><br><span class="line">                tmpSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从右往左</span></span><br><span class="line">            <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                Collections.reverse(tmpAl);</span><br><span class="line">            res.add(tmpAl);</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用LinkedList双端队列的性质。若要从右往左打印，则不断往双端队列头部增加元素，则最开始进入的元素会在最末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        TreeNode tmpNode;</span><br><span class="line">        que.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            LinkedList&lt;Integer&gt; tmpLl = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = que.size(); i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">                </span><br><span class="line">                tmpNode = que.remove();</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    tmpLl.addLast(tmpNode.val);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmpLl.addFirst(tmpNode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(tmpNode.left != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span>(tmpNode.right != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmpNode.right);</span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(tmpLl));</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化二叉树">14 序列化二叉树</h3>
<p>题目描述</p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 # 表示空节点，以 , 分隔各个节点。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//序列化，直接前序遍历</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root.val + <span class="string">&quot;,&quot;</span> + Serialize(root.left) + <span class="string">&quot;,&quot;</span> + Serialize(root.right);     </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反序列化，用一个全局index记录下标</span></span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String [] strs = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        index++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先判断下标是否越界，越界直接返回null表明已经超过数组，是最后的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt;= strs.length) <span class="comment">//注意是数组的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//然后判断当前值是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(strs[index].equals(<span class="string">&quot;#&quot;</span>)) <span class="comment">//要用equals比较字符串</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不是叶子节点就按照前序遍历法继续递归</span></span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[index])); <span class="comment">//将字符转为数字</span></span><br><span class="line">            node.left = Deserialize(str);</span><br><span class="line">            node.right = Deserialize(str);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">       </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树与双向链表">15 二叉搜索树与双向链表</h3>
<p><strong>题目描述</strong> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），递归深度都为<span class="math inline">\(n\)</span>。 空间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），系统使用O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/8.png" style="zoom: 50%;"></p>
<p>二叉搜索树的中序遍历结果，即为排序的链表。然后，需要设置一个全局节点pre，保存前一个节点的位置，并在当前根节点处，调整指针的指向。</p>
<p>同时，需要设置一个头节点head保存链表头节点的位置，如何知道头节点的位置？当pre为null时，即为头节点的位置。</p>
<p>如何知道尾节点的位置？当中序遍历完成后，pre指向的位置为尾节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        Recur(pRootOfTree);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后修改头节点和尾节点的指向（牛客网上不要修改，leetcode上要）</span></span><br><span class="line"><span class="comment">//         pre.right = head;</span></span><br><span class="line"><span class="comment">//         head.left = pre;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Recur</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        Recur(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;<span class="comment">//当前节点是链表头节点</span></span><br><span class="line">            head = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = pre;</span><br><span class="line">        pre = root;<span class="comment">//变更前驱节点</span></span><br><span class="line">        </span><br><span class="line">        Recur(root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>树的深度：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/solution/mian-shi-ti-55-i-er-cha-shu-de-shen-du-xian-xu-bia/ 二叉树的镜像：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/solution/mian-shi-ti-27-er-cha-shu-de-jing-xiang-di-gui-fu-/</p>
<p>平衡二叉树：https://leetcode-cn.com/problems/balanced-binary-tree/solution/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/</p>
<p>把二叉树打印成多行：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/</p>
<p>对称的二叉树：https://leetcode-cn.com/problems/symmetric-tree/solution/hua-jie-suan-fa-101-dui-cheng-er-cha-shu-by-guanpe/</p>
<p>https://leetcode-cn.com/problems/symmetric-tree/solution/di-gui-die-dai-bi-xu-miao-dong-by-sweetiee/</p>
<p>二叉树中和为某一值的路径：https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/</p>
<p>重建二叉树：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/</p>
<p>二叉树的后序遍历序列：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</p>
<p>树的子结构：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</p>
<p>序列化二叉树：https://blog.nowcoder.net/n/daadc4221f77479f968a9347af2a8380?f=comment</p>
<p>二叉搜索树与双向链表：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/28/Hexo%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<figure>
<img src="/2021/01/28/Hexo%E6%8C%87%E5%8D%97/0.png" alt="hello"><figcaption aria-hidden="true">hello</figcaption>
</figure>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
</search>
