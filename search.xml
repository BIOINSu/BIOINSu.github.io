<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<figure>
<img src="/2021/01/28/hello-world/0.png" alt="hello"><figcaption aria-hidden="true">hello</figcaption>
</figure>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>BasicVSR 论文阅读</title>
    <url>/2021/01/28/SR_Basicvsr/</url>
    <content><![CDATA[<p>《BasicVSR：The Search for Essential Components in Video Super-Resolution and Beyond》</p>
<h3 id="背景">背景</h3>
<p>相比图像超分任务，视频超分网络会设计更多模块，因为它多了一个时空维度。因此复杂的设计结构在视频超分网络中是常见的。本文重新分析了视频超分网络中的四大模块（对齐、聚合、传播和上采样）的作用，以及它们的优缺点。提出了一个视频超分框架baseline，即BasicVSR，并在Reds和Vimeo数据集上训练，验证了该框架的有效性。</p>
<p>另外，本文扩展BasicVSR框架，设计了信息重新填充机制和成对传播策略，促进信息聚合，即IconVSR网络。</p>
<a id="more"></a>
<h3 id="方法">方法</h3>
<p>该部分首先分析了视频超分网络中四大模块中不同选择的作用，并在每个模块中选择最好的组件构成BasicVSR网络，该网络可以作为设计其他视频超分网络的骨架backbone。然后，作者在backbone的基础上引入了两种新的组件信息重新填充机制和成对传播策略，略微提升了参数量和运行时间，并提高了网络性能。</p>
<h4 id="传播模块">传播模块</h4>
<p>本质上，传播模块定义了各个输入帧究竟是如何在网络中进行传播的，当前各个帧的传播方式主要有如下几种：</p>
<ul>
<li><p>Local</p>
<p>局部传播使用一个滑动窗口中的LR图像作为输入，然后利用这些局部信息完成重建任务。这是最常见的方式，也是TDAN、EDVR等方法的输入方式，例如一次性输入相邻的7帧，并选择重建第4帧，其他的作为参考帧。因此，网络能够访问的信息限制在这些局部相邻帧中。缺少远距离帧不可避免地限制了网络的表达能力。</p>
<p><img src="/2021/01/28/SR_Basicvsr/0.png" style="zoom:67%;"></p>
<p>如图所示，作者将测试集分成K个segments在BasicVSR网络中进行测试，可以看到当每个segments内的帧数越多的时候，其恢复的PSNR值越低，说明了帧的数量对网络有影响。</p>
<p>对于非recurrent形式的网络，滑动窗口内的帧数越多则会导致网络的参数量和占用显存都会大规模增加，这是一个主要的缺陷。</p></li>
<li><p>Unidirectional Propagation</p>
<p>单向传播形式，即如RLSP、RSDN等普通recurrent网络的形式，每次输入一帧和相邻帧，并利用重建的相邻帧及其中间产物来完成当前参考帧的重建过程。</p>
<p><img src="/2021/01/28/SR_Basicvsr/1.png" style="zoom:67%;"></p>
<p>然而，单向传播的方式会涉及到隐状态，即前一帧的中间产物的处理问题。本质上隐状态代表了前一帧或前n帧的特征，因此当输入的帧数越靠前时，隐状态含有的信息越少，对参考帧的重建效果越差，如上图所示。</p></li>
<li><p>Bidirectional Propagation</p>
<p>双向传播形式解决上述两种问题，本质上就是网络同时利用前一帧和后一帧的隐状态，来完成当前参考帧的重建。前一帧的隐状态包含当前参考帧之前的所有信息，后一帧的隐状态包含当前参考帧之后的所有信息，这相当于可以利用前后所有帧的信息。</p></li>
</ul>
<h4 id="对齐模块">对齐模块</h4>
<ul>
<li><p>无对齐</p>
<p>不对齐的特征或图像会影响聚合的效果，并最终导致性能降低。直接串联不对齐的特征以进行恢复，相邻帧的特征将不会与输入图像的特征在空间上对齐。由于卷积之类的局部操作具有相对较小的感受野，在相应位置集合信息时无法有效地利用相邻帧的信息，此时会导致较低的效率。</p></li>
<li><p>基于图像的对齐</p>
<p>基于图像的对齐使用光流估计相邻帧到参考帧的光流变化，然后利用光流的信息将相邻帧变形对齐到参考帧上。该过程是直接在图像上进行的，而非特征图上进行的。并且大部分的工作通常需要利用其他预训练的光流估计网络。</p></li>
<li><p>基于特征的对齐</p>
<p>基于特征的对齐最流行的方法是使用可变形卷积。然而本文使用的方式是基于光流的特征对齐，即先估计光流，然后根据光流将中间结果，即隐状态进行对齐，然后将对齐过后的特征和当前参考帧一起输入残差块进行重建。</p></li>
</ul>
<h4 id="聚合与上采样">聚合与上采样</h4>
<p>文章对聚合方式没有进行过多探讨，只采用最基础的聚合方式，即拼接特征图并输入多个卷积作为聚合模块。</p>
<p>上采样模块采用最经典有效的方式Pixel-shuffle。</p>
<h4 id="basicvsr">BasicVSR</h4>
<p><img src="/2021/01/28/SR_Basicvsr/2.png" style="zoom: 50%;"></p>
<p>本文提出的Backbone即BasicVSR，采用了上述探讨的最基础的几个模块。对齐模块采用基于光流的特征对齐，对齐的对象是隐状态和光流图。传播模块采用的是双向传播模式，当前参考帧需要利用前后一帧的隐状态。聚合模块是直接拼接，上采样模块则为Pixel-shuffle。</p>
<h4 id="iconvsr">IconVSR</h4>
<p>在BasicVSR的基础上引入了两种新的组件信息重新填充机制和成对传播策略来提升网络的性能。</p>
<ul>
<li><p>Information-Refill</p>
<p>信息重新填充机制是为了解决在图像边界和有遮挡区域的不精确对齐的问题。不精确对齐会导致误差的不断积加，特别是在网络中采用长距离传播的时候。为了解决特征不精确对齐带来的不利影响，本文提出了一个信息重新填充机制，以做特征修正。</p>
<p><img src="/2021/01/28/SR_Basicvsr/3.png" style="zoom:67%;"></p>
<p>如上图所示，E为特征提取模块，C为卷积单元。需要事先设定一些关键帧<span class="math inline">\(I_{key}\)</span>，当关键帧作为参考帧进行输入时，对齐的特征需要和前后帧的特征进行拼接，对当前的特征图进行修正，防止错误累加，最后才将对齐后的特征和参考帧一起输入重建模块。</p></li>
<li><p>Coupled Propagation</p>
<p>成对传播策略将后向传播的特征，即后向传播的隐状态，也作为正向传播模块的输入。而不是像BasicVSR中的那样，直接在U处融合前后两个传播分支的输出。</p>
<p><img src="/2021/01/28/SR_Basicvsr/4.png" style="zoom:67%;"></p>
<p>通过成对传播，前向传播分支从过去和将来的帧中接收信息，从而导致更高质量的特征，获得更好的输出。</p></li>
</ul>
<h3 id="实验结果">实验结果</h3>
<h4 id="与sota进行对比">与SOTA进行对比</h4>
<p><img src="/2021/01/28/SR_Basicvsr/5.png" style="zoom: 50%;"></p>
<p><img src="/2021/01/28/SR_Basicvsr/6.png" style="zoom: 50%;"></p>
<h4 id="信息重新填充机制和成对传播策略消融实验">信息重新填充机制和成对传播策略消融实验</h4>
<p><img src="/2021/01/28/SR_Basicvsr/7.png" style="zoom: 50%;"></p>
<h4 id="信息重新填充机制中的关键帧数量">信息重新填充机制中的关键帧数量</h4>
<p><img src="/2021/01/28/SR_Basicvsr/8.png" style="zoom: 50%;"></p>
<h3 id="总结">总结</h3>
<p>本文中提出的BasicVSR和IconVSR，利用recurrent的机制进行超分辨率。BasicVSR主要利用了双向传播机制，使得长距离信息能够得到利用，IconVSR在此基础上直接在前向传播分支中利用后向传播的特征，直接在特征维度上利用长距离信息。</p>
<p>同时注意到，双向传播机制的短板非常明显，无论是BasicVSR还是IconVSR都需要将所有视频帧全部输入到网络中之后才能够进行超分辨率，这是相比于滑动窗口最大的缺陷，这导致了基于双向传播的方法无法做到实时超分。并且，这需要保存大量的中间结果，即隐状态，这在训练时可能会导致大规模的显存占用情况存在。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>VSR</category>
      </categories>
      <tags>
        <tag>VSR</tag>
      </tags>
  </entry>
  <entry>
    <title>DSFN 论文阅读</title>
    <url>/2021/02/09/SR_DSFN/</url>
    <content><![CDATA[<p>《Dual-Stream Fusion Network for Spatiotemporal Video Super-Resolution》 WACV 2021</p>
<h3 id="背景">背景</h3>
<p>时空视频超分辨率，即在时间维度上提升帧率，在空间维度上提升分辨率。本文认为，直接级联已有空间和时间超分辨率的方法（没有另外设计）来实现时空上采样，改变它们的顺序能够使得结果具有互补性。 因此，本文提出了一种双流融合网络，以自适应地融合两个时空上采样流产生的中间结果，其中第一个流应用空间超分辨率，然后是时间超分辨率，而第二个流则先使用空间超分辨率再进行时间超分辨率。</p>
<a id="more"></a>
<h3 id="方法">方法</h3>
<p><img src="/2021/02/09/SR_DSFN/0.png" style="zoom:50%;"></p>
<h4 id="框架的组件">框架的组件</h4>
<ul>
<li><p><span class="math inline">\(M_S\)</span></p>
<p>空间超分辨率网络。本文使用的是单幅图像的超分辨率网络ESPCN、SAN。</p></li>
<li><p><span class="math inline">\(M_T\)</span></p>
<p>时间超分辨率网络。即插帧网络，本文使用SuperSloMo、DAIN。</p></li>
<li><p><span class="math inline">\(F\)</span></p>
<p>融合网络，负责将不同分支产生的结果进行融合。具体采用采用了U-Net，它包含五个具有跳跃连接的对称下采样和上采样卷积层。</p></li>
<li><p><span class="math inline">\(R\)</span></p>
<p>调整网络，增强细节。具体为三个残差块。</p></li>
</ul>
<h4 id="框架的执行">框架的执行</h4>
<p>整个网络的流程具体来说就是将时空超分辨率分为两个分支，一个是先超分再插帧，另一个是先插帧再超分，然后通过融合网络融合两个分支的结果，最后通过调整网络进行细节调整。</p>
<p>空间超分辨率网络接收单个输入帧，并进行超分，输出对应一帧的超分结果；时间超分辨率网络接收前后两帧，并预测中间帧的结果。</p>
<p>先超分再插帧的过程可以表示为：</p>
<p><img src="/2021/02/09/SR_DSFN/1.png" style="zoom:67%;"></p>
<p>先插帧再超分的过程可以表示为：</p>
<p><img src="/2021/02/09/SR_DSFN/2.png" style="zoom:67%;"></p>
<p>本文认为，这两个数据流在时空上采样方面表现出互补的结果，其中先超分再插帧在运动较小的区域产生更精细的细节，而先插帧再超分在运动较大的区域提供更好的重建。</p>
<p>将双分支预测得到的结果进行融合，融合的策略就是给两个分支的结果分别预测一个Mask，并将Mask和预测结果进行element-wise的乘法后相加，整个过程可以表示为：</p>
<p><img src="/2021/02/09/SR_DSFN/3.png" style="zoom:67%;"></p>
<p>注意到，两个Mask之间，假如给予约束 Mask1 + Mask2 = 1，则总的预测结果变成了两个分支结果的线性插值，否则总的预测结果是两个分支结果的线性组合。</p>
<p>最终，通过一个三个残差块的调整网络增强细节信息。</p>
<p><img src="/2021/02/09/SR_DSFN/4.png" style="zoom:67%;"></p>
<h4 id="损失函数">损失函数</h4>
<p>损失函数主要分为两个部分：重建损失、辅助损失。</p>
<p><img src="/2021/02/09/SR_DSFN/5.png" style="zoom:77%;"></p>
<ul>
<li><p>重建损失</p>
<p>各个中间预测结果和GT的L1距离，作为重建损失。</p>
<p><img src="/2021/02/09/SR_DSFN/6.png" style="zoom:67%;"></p></li>
<li><p>辅助损失</p>
<p>主要是先超分再插帧的超分部分，以及先插帧再超分的插帧部分，对中间结果计算L1损失。</p>
<p><img src="/2021/02/09/SR_DSFN/7.png" style="zoom: 60%;"></p></li>
</ul>
<h3 id="实验结果">实验结果</h3>
<p>batch size设置为24，使用优化器RAdam，学习率开始时设置为<span class="math inline">\(5e-5\)</span>。时间和空间超分辨率均为2x。使用数据集Vimeo-90K、UCF101、FISR dataset。训练过程，首先单独训练超分网络和插帧网络，然后冻结参数把它们和融合网络及调整网络拼接在一起训练，最终联合训练所有模块。</p>
<h4 id="时空超分的互补结果">时空超分的互补结果</h4>
<p><img src="/2021/02/09/SR_DSFN/8.png"></p>
<p>文章认为先超分再插帧在小动作区域有更好的细节，先插帧再超分能够在大动作区域有更好的重建效果。如图所示应该是1、3行表示小动作区域，先超分再插帧的效果更好，Error Map有更少的像素点有值；而2、4行则表示大动作区域，先插帧再超分的Error Map有更少的像素点有值。</p>
<h4 id="不同融合策略的比较">不同融合策略的比较</h4>
<p><img src="/2021/02/09/SR_DSFN/9.png" style="zoom:67%;"></p>
<p>One-mask表示Mask1 + Mask2 = 1，总的预测结果变成了两个分支结果的线性插值，Two-mask则表示总的预测结果是两个分支结果的线性组合，可以看出Two-mask更有优势。</p>
<h4 id="选择不同上采样网络">选择不同上采样网络</h4>
<p><img src="/2021/02/09/SR_DSFN/10.png" style="zoom: 67%;"></p>
<p>越新的方法作为backbone效果则越好。</p>
<h4 id="与sota结果相比">与SOTA结果相比</h4>
<p><img src="/2021/02/09/SR_DSFN/11.png" style="zoom:67%;"></p>
<p>并没有和最新的网络结果相比，例如Zooming Slow-Mo。</p>
<h3 id="结论">结论</h3>
<p>本文提出了一种融合双分支结果的网络来进行时空超分辨率。然而，该网络并不是end-to-end训练的，借用已有的网络进行多阶段训练，并且正文没有给出参数量和计算量，可能代价也比较高。其次，重建完全由中间和最终输出帧的像素级重建损失来指导，把超分和插帧的过程都看成是独立的过程，各个中间结果之间没有加上时序的联系，这必然导致了性能的降低。因此，在时空超分中如何有效地利用时序信息进行更好的重建值得进行探索。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>STVSR</category>
      </categories>
      <tags>
        <tag>STVSR</tag>
      </tags>
  </entry>
  <entry>
    <title>DualSR 论文阅读</title>
    <url>/2021/02/05/SR_DualSR/</url>
    <content><![CDATA[<p>《DualSR: Zero-Shot Dual Learning for Real-World Super-Resolution》 WACV 2021</p>
<h3 id="背景">背景</h3>
<p>许多基于深度学习的SR方法在庞大数据集上学习复杂的LR-HR上采样关系。但是，这些经过预训练的SR方法通常在直接从相机捕获的图像上表现差很多。它们接受了干净，无噪声，合成的LR图像进行训练，而真实LR图像的退化过程与理想条件不同。现实情况下，每个摄像机的采集参数，例如传感器的点扩展功能（PSF），也不同。即使是同一台摄像机拍摄的图像，也会因光线条件、景深以及抖动而产生的模糊等而有所不同。这些条件使得训练一个在所有不同图像退化条件下都能表现良好的CNN变得很困难。</p>
<a id="more"></a>
<p>许多盲SR方法在超分之前都会估算退化过程。 盲超分的SOTA使用深度学习来学习图像特定的下采样器（降级模型参数），上采样器使用该下采样器对输入的LR图像进行超分辨。 但是，从单个输入图像估计合适的下采样器很复杂。 尤其是在存在噪声或其他采集伪像的情况下，这些方法通常无法估算出良好的降级参数。 错误的降级会严重降低上采样器的效率，并降低SR性能。</p>
<p>受诸如CycleGAN 和 DualGAN 等最新无监督方法的启发，论文引入了Zero-Shot DualSR，一种双路径架构，用于在现实世界中的LR图像上实现超分辨率，并且是一种无监督的方案。</p>
<h3 id="方法">方法</h3>
<p><img src="/2021/02/05/SR_DualSR/0.png" style="zoom: 50%;"></p>
<h4 id="框架的组件">框架的组件</h4>
<ul>
<li><p><span class="math inline">\(G_{UP}\)</span></p>
<p>上采样器。与ZSSR类似，采用了简单的8层全卷积网络，并采用了ReLU激活。在输入和输出之间存在一个全局的残差连接。将LR图像放大到输出大小，然后才将其送入网络。</p></li>
<li><p><span class="math inline">\(G_{DN}\)</span> &amp; <span class="math inline">\(D_{DN}\)</span></p>
<p>下采样器和判别器。使用KernelGAN中的生成器和判别器。</p>
<p>生成器是一个深层线性网络（没有任何激活）。小的感受野强迫使网络仅使用LR图像的局部特征（例如边缘），而不是依赖于高级全局特征。 因此，生成器<span class="math inline">\(G_{DN}\)</span>学习能够生成图像的kernel，该图像在patch分布上与输入LR图像相似。</p>
<p><img src="/2021/02/05/SR_DualSR/1.png" style="zoom:55%;"></p>
<p>判别器是一个全卷积的PatchGAN，其感受野为7x7。</p>
<p><img src="/2021/02/05/SR_DualSR/2.png" style="zoom:60%;"></p></li>
</ul>
<h4 id="框架的执行">框架的执行</h4>
<p>在前向循环中，首先应用上采样器以生成2x的上采样图像。，然后应用下采样器并将上采样的图像转换回1x。</p>
<p>同样，在后向循环中，首先由<span class="math inline">\(G_{DN}\)</span>生成1/2x的图像，然后<span class="math inline">\(G_{UP}\)</span>将图像上采样回到原始比例。</p>
<h4 id="损失函数">损失函数</h4>
<p>损失函数主要分为三部分：对抗损失、循环一致性损失、掩码插值损失。</p>
<p><img src="/2021/02/05/SR_DualSR/3.png" style="zoom: 67%;"></p>
<ul>
<li><p>对抗损失</p>
<p>对于下采样器<span class="math inline">\(G_{DN}\)</span>，希望其能够生成和真实LR相同的图像，判别器尽可能认为它是真实的LR（标签为1），损失如下（正则化项<span class="math inline">\(R\)</span>具体见KernelGAN论文）：</p>
<p><img src="/2021/02/05/SR_DualSR/4.png" style="zoom:60%;"></p>
<p>对于判别器<span class="math inline">\(D_{DN}\)</span>,希望其能够判别哪些是真实的LR，即让真实的LR被判别为1，合成的LR被判别为0：</p>
<p><img src="/2021/02/05/SR_DualSR/5.png" style="zoom:60%;"></p></li>
<li><p>循环一致性损失</p>
<p>确保<span class="math inline">\(G_{UP}\)</span>和<span class="math inline">\(G_{DN}\)</span>可以还原由另一个执行的操作。</p>
<p><img src="/2021/02/05/SR_DualSR/6.png" style="zoom:60%;"></p></li>
<li><p>掩码插值损失</p>
<p>Bicubic上采样能够能够正确地对低频部分进行上采样，但是无法重构高频细节。对所有像素使用Bicubic能够产生无伪影但模糊的结果。因此，论文仅对图像低频部分应用插值损失。首先对Bicubic上采样的图像应用Sobel算子，它主要用作边缘检测，是一种离散性差分算子，用来计算图像亮度函数的灰度近似值。应用Sobel算子能够产生mask，该mask在低频区域的像素值较高，在图像的高频区域的像素值较低。</p>
<p><img src="/2021/02/05/SR_DualSR/7.png" style="zoom:60%;"></p>
<p>然后应用掩码插值损失使得<span class="math inline">\(G_{UP}\)</span>的结果和Bicubic上采样的结果仅在低频部分是相近的。</p>
<p><img src="/2021/02/05/SR_DualSR/8.png" style="zoom:60%;"></p></li>
</ul>
<h3 id="实验结果">实验结果</h3>
<p>训练使用的 patch size 为 64 x 64 以及 128 x 128。训练和测试时不使用任何数据增强（图像变换）。因为训练时间很少，所以可以用暴力搜索方法来获得<span class="math inline">\(\lambda_{cycle}=5,\lambda_{inter}=2\)</span>。</p>
<p>在RTX 2080 Ti GPU上，论文的方法平均训练+推理时间为233秒。 对于KernelGAN + ZSSR 的组合，运行时间为281秒，对于BlindSR，则为370秒。 像SAN这样的有监督深度学习SR方法具有很长的训练时间，并且图像大小显着影响其推理时间。对于SAN +，在DIV2KRK基准上测试每张图片平均需要298秒。</p>
<h4 id="合成的真实lr数据集">合成的真实LR数据集</h4>
<p><img src="/2021/02/05/SR_DualSR/9.png" style="zoom: 45%;"></p>
<h4 id="realsr数据集">RealSR数据集</h4>
<p>该数据集通过调整焦距获得不同尺度图像，但作者认为不同尺度间没有完全对齐，因此只放出视觉效果。</p>
<p><img src="/2021/02/05/SR_DualSR/10.png" style="zoom:40%;"></p>
<h4 id="掩码插值损失">掩码插值损失</h4>
<p><img src="/2021/02/05/SR_DualSR/11.png" style="zoom:50%;"></p>
<h3 id="结论">结论</h3>
<p>本文提出提出了DualSR，一个轻量级的dual架构，它学习每个图像特定的LR-HR关系。它由下采样器和上采样器组成，在训练中使用循环一致性损失来相互改进。此外，论文提出了掩码插值损失，消除了图像低频区域的伪影，而不会导致边缘过于平滑。</p>
<p>该方法是Zero-Shot的，无需HR图像进行监督，但本质上就是用了Bicubic上采样的低频部分来进行监督。之前的文章DynaVSR是用了元学习的思想，在测试时同样使用了类似循环一致性的方法，但在训练时为了更好的效果仍然使用了HR的图像。因此，可以思考如何将Zero-Shot的思想（目前来看还是想办法在Bicubic上采样的结果做文章），应用到VSR上，来达到完全无监督的效果。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>SISR</category>
      </categories>
      <tags>
        <tag>SISR</tag>
        <tag>RealSR</tag>
      </tags>
  </entry>
  <entry>
    <title>TPSTVSR 论文阅读</title>
    <url>/2021/02/26/SR_TPSTVSR/</url>
    <content><![CDATA[<p>《Space-Time Video Super-Resolution Using Temporal Profiles》 ACMMM 2020</p>
<h3 id="背景">背景</h3>
<p>在时空超分辨率中，直接将VFI（插帧）和VSR（超分）串联，不能充分利用视频的时空相关性，是一种次优做法。此外，在计算效率低的同时，也容易引入累积误差。Zooming Slow-Mo提出一种one-stage的做法，使用可变形的ConvLSTM来隐式对齐帧，这样可能会错过长依赖的时间上下文，因为当更多的帧融合时，需要设计更复杂的帧对齐规则。因此，本文提出利用 Temporal Profile (TP)来解决时空超分辨率问题。</p>
<a id="more"></a>
<p>视频帧在一个Patch上，可以转换为如下水平（vertical）TPs 和垂直（horizontal）TPs：</p>
<p><img src="/2021/02/26/SR_TPSTVSR/0.png" style="zoom: 50%;"></p>
<p>基于TP的时空超分辨率有以下几个好处：</p>
<p>（1）STVSR可以有效地建模为基于学习的恢复任务，聚焦于TPs的特定二维结构。</p>
<p>（2）TPs既包含空间维度又包含时间维度，可以更好地利用时空相关性。</p>
<p>（3）与现有的多帧对齐方法相比，TPs能够更灵活地融合长依赖的时间上下文信息。</p>
<h3 id="方法">方法</h3>
<p>首先将低帧率和低分辨率的视频转换成TPs，然后将其送入Temporal Profile超分辨率模块（TPSRM）提高帧率，然后将TPs转换为视频域，发送给特征洗牌模块（FSM）生成具有目标空间分辨率的视频，最后通过调整模块（RM）去除伪影，增强细节。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/1.png" style="zoom: 80%;"></p>
<ul>
<li><p>Temporal-Profile Super-Resolution Module</p>
<p>首先将输入视频帧 W x H x T 转换为垂直Temporal Profile T x H x W（转换为水平TP无太大区别），即在垂直方向上将视频帧切割成W个。然后输入TPSRM，将TP分辨率提高为 （2T-1）x 2H x W。TPSRM采用IMDN模型，用L1损失函数做监督，ground truth由高帧率高分辨率视频转换成TP得到。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/8.png" style="zoom:60%;"></p></li>
<li><p>Feature Shuffling Module</p>
<p>该模块的目的是提高空间分辨率。经过TPSRM后，帧率提升为原来的两倍，H提高为原来的两倍，而W不变，FSM的目的就是将H再次提高两倍，W直接提高四倍。注意到其中Feature Shuffling阶段会将通道数（也就是帧率）减半，来将W提升2倍，在后面的模块需要将空间分辨率和通道数同时提升。CSR同样使用IMDN模块。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/2.png" style="zoom: 67%;"></p></li>
<li><p>Refining Module</p>
<p>该模块目的是消除伪影和增强细节，采用U-Net结构。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/3.png" style="zoom: 67%;"></p></li>
</ul>
<p>损失函数采用 L1、SSIM、VGG和Cycle Consistency四种损失函数。采用循环一致性损失来保证重构视频与输入的时空一致性，同时可以避免过度增强。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/4.png" style="zoom:67%;"></p>
<p><img src="/2021/02/26/SR_TPSTVSR/5.png" style="zoom:67%;"></p>
<p><img src="/2021/02/26/SR_TPSTVSR/6.png" style="zoom:67%;"></p>
<p><img src="/2021/02/26/SR_TPSTVSR/7.png" style="zoom: 67%;"></p>
<h3 id="实验结果">实验结果</h3>
<p>使用Vimeo90K数据集进行训练，进行空间4倍超分，时间2倍超分，batch size设置为1，学习率每2个epoch下降0.2，在一张1080Ti GPU上进行训练。</p>
<h4 id="与sota对比">与SOTA对比</h4>
<p><img src="/2021/02/26/SR_TPSTVSR/9.png" style="zoom:80%;"></p>
<h4 id="参数量与运行时间">参数量与运行时间</h4>
<p><img src="/2021/02/26/SR_TPSTVSR/10.png" style="zoom:80%;"></p>
<h4 id="不同损失函数比较">不同损失函数比较</h4>
<p><img src="/2021/02/26/SR_TPSTVSR/11.png" style="zoom:67%;"></p>
<h4 id="真实场景老电影恢复">真实场景：老电影恢复</h4>
<p>由于相机设备的分辨率有限，老电影往往会出现严重的时空退化。另外，在不同的压缩程度下保存也会影响观感。因此时空超分有应用场景。从网络上直接下载老电影，并和Zooming Slow-Mo进行对比，两者同样在Vimeo90K上训练。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/12.png" style="zoom: 67%;"></p>
<h3 id="结论">结论</h3>
<p>本文从Temporal Profile的角度进行时空超分辨率，与Zooming Slow-Mo相比降低了参数量和运行时间。该网络利用的是滑动窗口的原理，当帧数过多时会造成显存大量占用的问题。此外，当一个移动的物体在视频中突然出现或消失时，由于快速的移动，TPs很难捕捉到全局信息，融合水平和垂直的TPs可能是一种解决方案。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/13.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>STVSR</category>
      </categories>
      <tags>
        <tag>STVSR</tag>
      </tags>
  </entry>
  <entry>
    <title>TriNAS 论文阅读</title>
    <url>/2021/01/29/SR_TriNAS/</url>
    <content><![CDATA[<p>《Trilevel Neural Architecture Search for Efficient Single Image Super-Resolution》</p>
<h3 id="背景">背景</h3>
<p>传统的基于深度学习的超分辨率方法通常会在三层神经结构设计上选择以下变化：网络级优化、单元（cell）级优化以及内核（kernel）级优化。为一个深层SR模型人工执行这些优化需要较高的代价。并且，人工设计的架构往往不是最优的，对于真实超分辨率来说，可能在计算上效率低下。因此，论文提出了一种用于高效单图像超分辨率（SR）的三级神经架构搜索（TriNAS）方法。</p>
<a id="more"></a>
<p>论文首先在三个级别（即网络级别，单元级别和内核级别（卷积内核））定义离散搜索空间。提出了基于树模型的搜索框架来替代网格型的搜索框架，减少节点之间的依赖性。</p>
<p>然后，与之前利用softmax进行连续松弛策略的NAS方法不同，论文利用排序的sparsestmax来使得三级搜索架构稀疏地起作用。因此，论文的NAS优化可以逐渐收敛到对超网起主要作用的神经架构。</p>
<p>此外，论文提出的方法可以在单个阶段中同时进行搜索和训练，与传统的NAS算法相比，这大大减少了搜索和训练时间。</p>
<p>在基准数据集上进行的实验表明，论文的的NAS算法所提供的SR模型在参数数量和FLOPS方面具有显着减轻的优势，其PSNR值可与当前的SOTA相媲美。</p>
<h3 id="方法">方法</h3>
<h4 id="搜索空间定义">搜索空间定义</h4>
<p><img src="/2021/01/29/SR_TriNAS/2.png" style="zoom: 60%;"></p>
<p>为了在模型容量和模型大小之间达到适当的平衡，同时保证最小的精度损失，论文提出在内核级、单元级和网络级结构上进行搜索，以得到高效的SR网络结构。</p>
<ul>
<li><p>网络级</p>
<p>论文遵循AGD和SRResNet来定义网络级搜索空间。他们的超网结构使大多数计算都在低分辨率特征空间中进行，从而提高了计算效率。</p>
<p>网络级架构搜索主要通过搜索五个残差块和两个上采样块。将Residual-in-Residual（RiR）模块中的dense block替换为包含可搜索单元级运算符和内核级运算的五个连续层。</p>
<p>为了进行高效的上采样模块设计，论文替换了两个最初设计的上采样模块。取代的是一个PixelShuffel块，其中包含一个卷积层以及一个PixelShuffel层，以达到上采样的目的。由于PixelShuffle块固定在网络的尾部，因此在网络级搜索空间中添加了两个常规卷积层。最终，论文仅关注堆叠的五个RiR块和两个用于网络路径搜索的标准卷积层。</p>
<p><img src="/2021/01/29/SR_TriNAS/0.png" style="zoom:80%;"></p>
<p>为了对网络级搜索空间建模，采用上图所示的AutoDeep-Lab网格状结构似乎是可行的解决方案。 但是，网格建模旨在遍历网络块的所有顺序路径。 每个节点表示这个位置的feature map，每个路径都从第一个节点开始，并沿着一组箭头到达最终的目标节点。 显然，所有路径共享大多数节点和箭头。 这种冗余共享导致路径，单元和内核之间的极端依赖，因为路径在层次上包括它们。 尽管这样的共享策略可以节省大量训练内存，但它极大地限制了搜索空间。 此外，紧密的结合可能会损害每条路径的贡献以及对某些冗余路径的修剪的学习。</p>
<p><img src="/2021/01/29/SR_TriNAS/1.png" style="zoom: 67%;"></p>
<p>论文提出了一种用于网络级路径搜索建模的树结构，来克服冗余共享的缺点。 如上图所示，树建模旨在遍历所有树结构路径。 在这里，每个节点仅连接到其父节点和子节点，因此，依赖性非常宽松。 但是，必须在训练时维护这样的关联，以降低内存消耗。 放宽不同路径的相关性可以实现灵活的网络级搜索空间。 对路径的较低依赖性可能会由于单元和内核之间的分层连接而导致它们之间可靠的关联，从而使它们的搜索空间更为通用。 此外，引入的树模型可以更好地解开路径之间的纠缠关系，从而能够对冗余路径进行修剪。</p></li>
<li><p>单元级</p>
<p>在单元级，论文搜索五个RiR块，每个块包含五个个可搜索的单元，即总共25个可搜索的单元。每个单元会选择如下操作符：</p>
<p>Conv 1×1；Residual Block (2 layers of Conv 3×3 + skip-connection)；Conv 3×3；Depthwise Block (Conv 1×1 + Depthwise Conv3×3 + Conv 1×1).</p></li>
<li><p>内核级</p>
<p>对于内核级搜索，论文遵循super-kernel框架对该搜索空间进行建模。 对于每个卷积内核，先设置一个具有完整通道的超级内核。 为了修剪超级内核的通道数，需要一组可搜索的扩展比<span class="math inline">\(\phi=[\frac{1}{3},\frac{1}{2},\frac{4}{5},\frac{5}{6},1]\)</span>。并且设置参数<span class="math inline">\(\gamma_i\)</span>控制选择第<span class="math inline">\(i\)</span>个扩展比的概率。</p></li>
</ul>
<h4 id="连续松弛策略">连续松弛策略</h4>
<p>为了使得NAS是可微的，关键思想是将离散的搜索空间的显式选择放宽为搜索空间中所有相关候选对象的的隐式选择。连续松弛使我们能够以完全可微的方式选择对超网贡献最大的候选者，然后就可以通过反向传播的方式优化整个超网，以实现高效的架构。流行的连续松弛策略之一是应用softmax来实现所有候选网络操作的混合。但是，softmax无法产生稀疏的分布，因此，它无法反映主导操作，这对于有效的结构设计而言至关重要。因此，使用softmax可以防止超级网络收敛到主要的候选架构。</p>
<p>为了解决这个问题，论文提出了sparsestmax，它在连续松弛过程中产生了良好的稀疏性，并且可以寻求具有优势的候选架构，同时具有诸如softmax之类的凸性和可微性。</p>
<p>具体来说，为了实现离散网络级搜索空间的连续松弛，论文使用一组连续组合权值来聚合所有的网络路径，构成一个超网络。网络级架构搜索的树模型中每个特征图（即节点）都可以用作其对应路径的输出，然后可以将输出送到上采样层以获得超分结果。 论文根据提出的树模型对来自相关网络路径的所有特征图定义了一组权重<span class="math inline">\(\beta\)</span>，因此，超网的输出是所有中间特征图的加权组合。</p>
<p>传统的连续松弛做法就是对所有的<span class="math inline">\(\beta\)</span>应用softmax函数来判断每个路径对总的网络的贡献。然而，softmax通常产生非零参数，即平滑变化的参数。因此，候选路径的贡献是相对均匀的，这防止超网络收敛到一个主要的候选结构。因此，利用sparsetmax来产生稀疏的分布，其中<span class="math inline">\(q\)</span>表示具有约束的单纯形：</p>
<p><img src="/2021/01/29/SR_TriNAS/3.png" style="zoom: 80%;"></p>
<p>sparsestmax的基本思想是将输入向量<span class="math inline">\(\beta\)</span>的欧几里德投影投射到概率单纯形上。该投射可能会触及单纯形边界，在这种情况下，sparsestmax会产生稀疏分布。为了获得更好的稀疏度，sparsestmax还引入了一个圆环约束，该圆环约束可以通过将单纯形外接圆的半径从零线性增加到某个阈值来逐步产生稀疏性。</p>
<p>前文提到的树模型搜索架构有助于对路径进行剪枝，然而直接使用sparsestmax可能会在节点上产生无序的非零组合权重（极端情况是它们全部分布在奇/偶数节点上）。 在这种情况下，除非排序稀疏度，否则无法很好地修剪路径。 换句话说，只要非零组合权重沿路径下降，以便所有零权重都出现在路径的尾部，就可以执行网络级修剪，直接删除尾部即可。因此，论文提出利用排序的sparsetmax方法。 对每个路径<span class="math inline">\(p_i\)</span>内的权重<span class="math inline">\(\beta_i\)</span>施加排序约束。 直观上，这有助于使得浅层的输出feature maps对超网趋于相同的贡献度。排序的sparsetmax可以表示为：</p>
<p><img src="/2021/01/29/SR_TriNAS/4.png" style="zoom: 77%;"></p>
<p>上述讨论了网络级的连续松弛策略，即使用了排序的sparsetmax方法。对于单元级的连续松弛策略，同样给每个单元的输出定义权重<span class="math inline">\(\alpha\)</span>，并采用非排序的sparsetmax的方式进行连续松弛。对于内核级的连续松弛策略，则采用gumbel-softmax方法。</p>
<h4 id="代理任务和优化">代理任务和优化</h4>
<p>对于本文的三级NAS任务，论文不是从头训练模型，而是通过知识蒸馏方法，从而利用预先训练的最先进的图像超分辨率模型的知识。将预训练的ESRGAN模型作为teacher model，搜索阶段的代理任务是通过最小化模型输出与教师模型输出之间的知识精馏距离来搜索模型G。此外，图像SR任务偏向于更有效率的模型，因此在目标函数中加入模型效率项。</p>
<p>由于架构搜索的参数的数量远远小于网络模型的参数的数量，因此在单个训练集上对它们进行联合优化容易出现过拟合。具体来说，将数据集分为训练集和验证集，分别在这两组数据上优化网络参数和架构搜索参数。</p>
<h4 id="算法流程">算法流程</h4>
<p><img src="/2021/01/29/SR_TriNAS/7.png"></p>
<h3 id="实验结果">实验结果</h3>
<h4 id="与sota进行对比">与SOTA进行对比</h4>
<p><img src="/2021/01/29/SR_TriNAS/5.png" style="zoom: 50%;"></p>
<h4 id="softmax与sparsetmax对比">softmax与sparsetmax对比</h4>
<p><img src="/2021/01/29/SR_TriNAS/6.png" style="zoom: 67%;"></p>
<h3 id="结论">结论</h3>
<p>本文介绍了用于单图像超分辨率任务的Trilevel NAS方法，主要是将排序的sparsetmax激活用于树模型的网络架构搜索中。树模型能够使得节点之间降低依赖性，提供灵活的搜索空间，并能够更好地进行剪枝优化；sparsetmax激活在连续松弛过程中产生了良好的稀疏性，使得超网能够收敛到一个主要的候选结构上；排序的sparsetmax同样能够更好地进行模型剪枝。</p>
<p>论文中提到的sparsetmax仅使用在了网络级和单元级架构搜索，可以同样利用排序的sparsetmax去进一步地优化内核级的搜索空间，来产生更高效的超分模型，以达到高PSNR和高感知质量的效果。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>SISR</category>
      </categories>
      <tags>
        <tag>SISR</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2021/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AEZookeeper/</url>
    <content><![CDATA[<p>Zookeeper（分布式协调服务）帮助Hadoop解决的问题</p>
<a id="more"></a>
<p>主要是为了实现高可用机制</p>
<p>首先所有的NN在启动的时候会竞争写一个zookeeper上的临时节点，所有的standby nn向这个节点注册一个观察器，当这个节点出现异常或挂掉时，起在zookeeper上创建的临时节点也会被删除，standy的nn节点检测到该节点发生变化时，会重新发起竞争，直到产生一个Active节点。</p>
<p>写入高可用。 集群中的写入操作都是先通知Leader，Leader再通知Follower写入，实际上当超过一半的机器写入成功后，就认为写入成功了，所以就算有些机器宕机，写入也是成功的。</p>
<p>读取高可用。 zookeeperk客户端读取数据时，可以读取集群中的任何一个机器。所以部分机器的宕机并不影响读取。 zookeeper服务器必须是奇数台，因为zookeeper有选举制度，角色有：领导者、跟随者、观察者，选举的目的是保证集群中数据的一致性。</p>
<p>https://blog.csdn.net/eric_sunah/article/details/46610167</p>
<p>https://www.jianshu.com/p/87976ec5f45f</p>
<p>kafka</p>
<p>分布式的发布-订阅消息系统。</p>
<p>Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡 和水平扩展。</p>
<p>一个分区可以有多个副本，这些副本保存在不同的broker上。每个分区的副本中都会有一个作为 Leader。当一个broker失败时，Leader在这台broker上的分区都会变得不可用，kafka会自动移除 Leader，再其他副本中选一个作为新的Leader。</p>
<p>消息同步：先写入到leader中，follower再同步。Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW（即offset）并且向Producer发送ACK。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>OR-Net 论文阅读</title>
    <url>/2021/02/16/SR_ORNet/</url>
    <content><![CDATA[<p>《Learning Omni-frequency Region-adaptive Representations for Real Image Super-Resolution》 2021</p>
<h3 id="背景">背景</h3>
<p>Real World数据包含不同的、复杂的退化方式，例如模糊、噪声和降采样，因此导致传统深度学习方法在真实数据集上表现不好。</p>
<p>RealSR和DRealSR不仅提出了两个真实数据集，还提出了两种真实超分方法 laplacian pyramid based kernel prediction network (LP-KPN) 和 component divide-and- conquer (CDC)。然而，它们都是在像素水平上进行重建（区域、边缘和角落），没有利用到频率信息。</p>
<a id="more"></a>
<p>图像的频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间上的梯度。图像的主要成分是低频信息，它形成了图像的基本灰度等级，对图像结构的决定作用较小；中频信息决定了图像的基本结构，形成了图像的主要边缘结构；高频信息形成了图像的边缘和细节，是在中频信息上对图像内容的进一步强化。</p>
<p><img src="/2021/02/16/SR_ORNet/0.png" style="zoom: 50%;"></p>
<p>作者观察到，对于图a可以看出，LR的退化在各个频率上都存在。对于图b可以看出，在不同区域中的不同频率组件内，真实LR的退化也是不同的。</p>
<p>因此，本文作者提出ORNet，在图像的不同频率上增强相应的频率因子，最终通过区域自适应频率聚合模块，结合动态卷积和空间注意力机制，针对HR图像的不同位置，有选择性地重建不同的频率分量。</p>
<h3 id="方法">方法</h3>
<p><img src="/2021/02/16/SR_ORNet/1.png" style="zoom: 67%;"></p>
<h4 id="框架的组件">框架的组件</h4>
<ul>
<li><p>Frequency Decomposition (FD) Module</p>
<p>对图像进行频率分离，可以在传统的信号处理方法中采用小波变换或离散余弦变换来实现。然而，由于数学运算的确定性和任务无关性，这种转换不可避免地为low-level恢复任务丢弃了一些关键、详细的信息。为了在模拟小波变换的同时避免关键信息丢失，作者提出通过可学习的隐空间下采样，来分解混合特征表示。类似的操作可以参考OctConv。</p>
<p>具体来说，作者首先利用步长较大的卷积层(如stride= 2)对特征表示进行下采样，提取粗特征，即低频分量。然后，从原始特征(下采样前)中减去这些相对低频的分量，以获得其余相对高频的特征表示。</p></li>
<li><p>Frequency Enhancement Unit (FEU)</p>
<p>该单元对不同频率的信息进行增强。如b种所示结构，将CA的结果和普通卷积的结果相拼接，并加入dense connection。目的是有助于各分支在不同阶段选择性融合相应的频率分量，从而提高各分支在不同频域的表示能力。</p></li>
<li><p>Region-adaptive Frequency Aggregation (RFA) Module</p>
<p>该模块对不同频率组件进行自适应聚合。</p>
<p><img src="/2021/02/16/SR_ORNet/4.png" style="zoom:50%;"></p>
<p>即预测多个动态卷积核，并设置一个可学习的权重向量，将多个卷积核组合在一起形成动态卷积核，通过它生成attention map并与原来的特征图做乘法。</p></li>
</ul>
<h4 id="框架的执行">框架的执行</h4>
<p>首先将输入图像进行频率分离。用大步长卷积提取低频特征，并不断减去低频特征获得高频特征。</p>
<p><img src="/2021/02/16/SR_ORNet/2.png" style="zoom: 67%;"></p>
<p>上箭头表示双线性插值上采样，下箭头表示带步长卷积进行下采样。</p>
<p>接着，通过FEU来增强不同频率的表示，以弥补低/中/高频信息的丢失，并将低频信息与不同高频信息相结合。</p>
<p><img src="/2021/02/16/SR_ORNet/3.png" style="zoom: 60%;"></p>
<p>真实LR图像中不同区域的频率信息丢失是不同的。因此，有必要对不同区域的全频分量进行自适应聚合，以恢复更真实、纹理细节更丰富的HR图像。通过作者提出的RFA模块，使用动态卷积核的方式生成attention map来组合多个频率下的组件，最终通过pixel shuffle提高分辨率。</p>
<p><img src="/2021/02/16/SR_ORNet/5.png" style="zoom:60%;"></p>
<h3 id="实验结果">实验结果</h3>
<p>是一种有监督方法，使用DRealSR进行训练，动态核的数量设置为5个，使用L1损失优化网络。</p>
<h4 id="不同频率的可视化">不同频率的可视化</h4>
<p><img src="/2021/02/16/SR_ORNet/6.png" style="zoom: 67%;"></p>
<p>对于FD模块，首先在图6(a)中对三个频率尺度的特征进行可视化，可以看到高频分支的特征包含更多的细节和纹理信息。然后根据图6(b)中的小波变换对低/中/高频特征进行分析。从左到右，频率范围从1增加到6中，低频特征的能量几乎完全集中在低频域，高频特征和中频特征的能量集中在相对更高的频率域。</p>
<h4 id="不同频率数量的比较">不同频率数量的比较</h4>
<p><img src="/2021/02/16/SR_ORNet/7.png" style="zoom:50%;"></p>
<p>提高频率分割的数量一定程度上能够提高效果。</p>
<h4 id="消融实验">消融实验</h4>
<p><img src="/2021/02/16/SR_ORNet/8.png" style="zoom: 50%;"></p>
<h4 id="与sota相比较">与SOTA相比较</h4>
<p><img src="/2021/02/16/SR_ORNet/9.png" style="zoom: 50%;"></p>
<p>其他方法除了CDC外均没有在DRealSR上训练，因此除了CDC外本质上无法证明该方法的有效性。</p>
<h3 id="结论">结论</h3>
<p>作者提出一种全频域自适应网络(OR-Net)来实现真实图像超分辨率。比较有贡献的地方在于分析了真实图像与图像频率的关系，以及频率在网络中的影响。然而现在RealSR大部分流行的方式是无监督学习（或unpaired的方式），而该文是完全的有监督学习。</p>
<p>有文章显示基于卷积的频率分离操作在PSNR和SSIM上稍高于基于小波变换的方法，但在视觉感知上（LPIPS指标）会稍差。对图像进行不同频率分离的方式会导致最终的重建效果有所不同。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>SISR</category>
      </categories>
      <tags>
        <tag>SISR</tag>
        <tag>RealSR</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络传输层</title>
    <url>/2021/04/13/%E8%AE%A1%E7%BD%91_%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h3 id="计算机网络传输层">计算机网络传输层</h3>
<p>TCP异常断开、TCP 粘包拆包</p>
<a id="more"></a>
<h4 id="tcp异常断开">TCP异常断开</h4>
<h5 id="服务器进程终止">服务器进程终止</h5>
<p>当服务器TCP接收到来自客户的数据时，既然先前打开那个套接口的进程已经终止，于是响应一个RST报文。</p>
<h5 id="服务器主机崩溃">服务器主机崩溃</h5>
<p>当服务器主机崩溃时，它不能发送任何东西，客户端TCP持续重传数据，试图从服务器上接受一个ACK。</p>
<ul>
<li>假设服务器已崩溃，从而对客户的数据分节根本没有响应，当客户端TCP最终放弃时，返回客户进程一个错误ETIMEDOUT。</li>
<li>如果某个中间路由器判定服务器主机已不可达，从而响应以一个“destination unreachable”，那么所返回的错误是EHOSTUNREACH或ENETUNREACH。</li>
</ul>
<p>为了快速检测出服务器已经不可达，有如下解决方案：</p>
<ul>
<li><p>给客户端设置一个超时时间，当超过这个时间后服务器还未响应数据时即认为服务器已经崩溃。</p></li>
<li><p>心跳检测机制，给双方设置一个守护进程，定期发送心跳检测数据包，另一方需要进行回应。</p></li>
<li><p>在Linux Socket编程中，开启SO_KEEPALIVE参数。</p>
<blockquote>
<p>SO_KEEPALIVE的过程？</p>
<p>1、如果通信两端超过2个小时没有交换数据，那么开启keep-alive的一端会自动发一个keep-alive包给对端。 2、如果对端正常的回应ACK包，那么一切都没问题，再等个2小时后发包(如果这两个小时仍然没有数据交换)。 3、如果对端回应RST包，表明对端程序崩溃或重启，这边socket产生ECONNRESET错误，并且关闭。 4、如果对端一直没回应，这边会每75秒再发包给对端，总共发8次共11分钟15秒。最后socket产生 ETIMEDOUT 错误，并且关闭。或者收到ICMP错误，表明主机不可到达，则会产生 EHOSTUNREACH 错误。</p>
<p>SO_KEEPALIVE和心跳机制的区别？</p>
<p>SO_KEEPALIVE是实现在传输层的TCP协议，心跳实现在应用层实现，本质没有任何区别，但应用层需要自己来定义心跳包格式。</p>
</blockquote></li>
</ul>
<h5 id="服务器主机崩溃后重启">服务器主机崩溃后重启</h5>
<p>当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接信息，因此服务器TCP对于所收到的来自客户的数据响应以一个RST，客户端进程返回ECONNRESET错误。</p>
<h5 id="服务器主机关机">服务器主机关机</h5>
<p>Unix系统关机时，init进程通常先给所有进程发送SIGTERM信号（该信号可被捕获），再等待一段固定的时间（一般在5~20秒之间），然后给所有仍在运行的进程发送SIGKILL信号（该信号不能被捕获）。</p>
<p>这么做是留给所有运行中的进程一小段时间来清除和终止。</p>
<p>如果不捕获SIGTERM信号并终止，服务器将由SIGKILL信号终止。当服务器进程终止时，它的所有打开着的描述字都被关闭，随后发生的步骤与服务器主机崩溃一样。</p>
<h4 id="tcp-粘包拆包">TCP 粘包、拆包</h4>
<p>产生的原因：</p>
<ul>
<li><p>粘包</p>
<p>1、发送端要发送的数据小于发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去</p>
<p>2、接收端应用层没有及时读取接收缓冲区中的数据</p></li>
<li><p>拆包</p>
<p>1、发送端要发送的数据大于发送缓冲区剩余空间大小</p>
<p>2、发送端待发送数据大于 MSS（最大报文长度）</p></li>
</ul>
<p>解决方案：</p>
<p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用层协议设计来解决。</p>
<ul>
<li><p>消息定长</p>
<p>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p></li>
<li><p>设置消息边界</p>
<p>接收端按消息边界分离出消息内容。比如可以在包尾增加特殊符号（回车换行符等）进行分割，例如 FTP 协议。</p></li>
<li><p>在消息头中设置消息的长度</p>
<p>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。</p></li>
<li><p>Netty协议</p></li>
</ul>
<h4 id="参考资料">参考资料</h4>
<p>https://zhuanlan.zhihu.com/p/108822858（粘包、拆包）</p>
<p>https://www.nowcoder.com/questionTerminal/72fa8f3cb67e4711ba8eee581f8be92b（TCP异常断开）</p>
<p>https://zhuanlan.zhihu.com/p/79957519 （异常断开）</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>传输层</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>传输层</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL日志</title>
    <url>/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>日志是MySQL数据库的重要组成部分，记录着数据库运行期间各种状态信息。</p>
<a id="more"></a>
<h4 id="binlog">binlog</h4>
<ul>
<li><p><strong>概念</strong></p>
<p>binlog属于逻辑日志，用于<strong>记录数据库执行的写入性操作</strong>(不包括查询)信息，以二进制的形式保存在磁盘中。binlog是MySQL的逻辑日志，并且由Server层进行记录，使用任何存储引擎的MySQL数据库都会记录binlog日志。</p>
<blockquote>
<p>逻辑日志：可以简单理解为记录的就是sql语句。但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</p>
<p>物理日志：因为MySQL数据最终是保存在数据页中的，物理日志记录的就是数据页变更，即数据本身的值。</p>
</blockquote></li>
<li><p><strong>使用场景</strong></p>
<p>binlog的主要使用场景有两个，分别是<strong>主从复制</strong>和<strong>数据恢复</strong>。</p>
<p>主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端重放binlog从而达到主从数据一致。</p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/3.png" style="zoom:50%;"></p>
<p>数据恢复：通过使用MySQL binlog工具来恢复数据。</p></li>
<li><p><strong>产生时机</strong></p>
<p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p></li>
<li><p><strong>释放时机</strong></p>
<p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p></li>
<li><p>binlog记录方式</p>
<p>binlog是通过追加的方式进行写入的，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p></li>
</ul>
<h4 id="redo-log">redo log</h4>
<ul>
<li><p><strong>概念</strong></p>
<p>redo log属于物理日志，记录事务<strong>对数据页做了哪些修改</strong>。</p>
<blockquote>
<p>InnoDB的修改数据的基本流程</p>
<p>当我们想要修改DB上某一行数据的时候，InnoDB是把数据从磁盘读取到内存的缓冲池上进行修改。</p>
<p>这个时候数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为<strong>脏页</strong>。</p>
<p>InnoDB对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，这样会产生海量的IO操作，严重影响InnoDB的处理性能。</p>
<p>既然脏页与磁盘中的数据存在差异，那么如果在这期间DB出现故障就会造成数据的丢失。为了解决这个问题，redo log就应运而生了。</p>
</blockquote>
<p>redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。</p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/1.png" style="zoom:67%;"></p>
<p>mysql每执行一条DML语句，先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file。这种先写日志，再写磁盘的技术就是MySQL里经常说到的WAL(Write-Ahead Logging) 技术。</p></li>
<li><p><strong>使用场景</strong></p>
<p>redo log <strong>防止DB出现故障造成数据的丢失</strong>。当出现故障导致脏页还未来得及保存进磁盘时，通过redo log进行重做，从而达到事务的持久性这一特性。</p></li>
<li><p><strong>产生时机</strong></p>
<p>事务开始之后就产生redo log。</p></li>
<li><p><strong>释放时机</strong></p>
<p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p></li>
<li><p><strong>redo log记录方式</strong></p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/0.png" style="zoom:50%;"></p>
<p>redo log实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此redo log实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。</p>
<p>checkpoint所做的事就是把脏页给刷新回磁盘。所以，当DB重启恢复时，只需要恢复checkpoint之后的数据。这样就能大大缩短恢复时间。</p>
<p>check point到write pos之间是redo log待落盘的数据页更改记录。</p>
<p>write pos到check point之间的部分是redo log空着的部分，用于记录新的记录。</p>
<p>当write pos追上check point时，会先推动check point向前移动，空出位置再记录新的日志。</p></li>
<li><p><strong>redo log写入磁盘的时机</strong>（buffer到file的时机）</p>
<p>MySQL支持三种将redo log buffer写入redo log file的时机，可以通过innodb_flush_log_at_trx_commit参数配置，各参数值含义如下：</p>
<p>0（延迟写）</p>
<p>事务提交时不会将redo log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到redo log file中。也就是说<strong>设置为0时是(大约)每秒刷新写入到磁盘中的</strong>，当系统崩溃，会丢失1秒钟的数据。</p>
<p>1（实时写，实时刷）</p>
<p>事务每次提交都会将redo log buffer中的日志写入os buffer并调用fsync()刷到redo log file中。这种方式即使系统崩溃也不会丢失任何数据，但是因为<strong>每次提交都写入磁盘</strong>，IO的性能较差。</p>
<p>2（实时写，延迟刷）</p>
<p>每次<strong>提交都仅写入</strong>到os buffer，然后是<strong>每秒调用</strong>fsync()将os buffer中的日志写入到redo log file。</p></li>
</ul>
<h4 id="undo-log">undo log</h4>
<ul>
<li><p>概念</p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/2.png" style="zoom: 67%;"></p>
<p>undo log属于逻辑日志，保存了事务发生之前的<strong>数据的一个版本</strong>，可以用于回滚。其实本质上，老旧的记录就形成了undo log。</p></li>
<li><p>使用场景</p>
<p>多版本并发控制协议MVCC中，通过undo log形成记录的多个版本，能执行快照读时能够判断读取的是哪个版本的记录。</p></li>
<li><p>产生时机</p>
<p>不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表。</p></li>
<li><p>释放时机</p>
<p>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo log上的旧版本，决定是否可以清理undo log的日志空间。</p></li>
</ul>
<h4 id="三者区别">三者区别</h4>
<table>
<colgroup>
<col style="width: 4%">
<col style="width: 31%">
<col style="width: 31%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>binlog</th>
<th>redo log</th>
<th>undo log</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>记录内容</td>
<td>用于<strong>记录数据库执行的写入性操作</strong>(不包括查询)信息，以二进制的形式保存在磁盘中。</td>
<td>记录事务<strong>对数据页做了哪些修改</strong>。</td>
<td>保存了事务发生之前的<strong>数据的一个版本</strong>，可以用于回滚。其实本质上，老旧的记录就形成了undo log。</td>
</tr>
<tr class="even">
<td>日志类型</td>
<td>逻辑日志</td>
<td>物理日志</td>
<td>逻辑日志</td>
</tr>
<tr class="odd">
<td>使用场景</td>
<td><strong>主从复制</strong>和<strong>数据恢复</strong>。主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端重放binlog从而达到主从数据一致。数据恢复：通过使用MySQL binlog工具来恢复数据。</td>
<td>redo log <strong>防止DB出现故障造成数据的丢失</strong>。当出现故障导致脏页还未来得及保存进磁盘时，通过redo log进行重做，从而达到事务的持久性这一特性。</td>
<td>多版本并发控制协议<strong>MVCC中的快照读</strong>，通过undo log形成记录的多个版本，能执行快照读时能够判断读取的是哪个版本的记录。</td>
</tr>
</tbody>
</table>
<p><strong>redo log 和 bin log 区别</strong></p>
<p>作用不同：redo log是保证事务的持久性的，binlog主要用于主从复制。</p>
<p>内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</p>
<p>产生时机不同：事务开始之后就产生redo log，事务提交的时候产生bin log。</p>
<p>释放时机不同：当对应事务的脏页写入到磁盘之后，redo log可以被移除，超过一定时间后，binlog被删除。</p>
<p>恢复效率：基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog。</p>
<p>先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<h4 id="参考资料">参考资料</h4>
<p>https://cloud.tencent.com/developer/article/1679325</p>
<p>https://www.cnblogs.com/wy123/p/8365234.html</p>
<p>https://zhuanlan.zhihu.com/p/35355751</p>
<p>https://www.cnblogs.com/xuwc/p/13873611.html</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>海量数据问题</title>
    <url>/2021/04/14/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>海量数据问题，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大导致无法一次性装入内存。</p>
<a id="more"></a>
<h3 id="基础">基础</h3>
<h4 id="换算单位">换算单位</h4>
<ul>
<li>1 byte = 8 bit</li>
<li>1 KB = <span class="math inline">\(2^{10}\)</span> byte = 1024 byte ≈ <span class="math inline">\(10^3\)</span> byte</li>
<li>1 MB = <span class="math inline">\(2^{20}\)</span> byte ≈ <span class="math inline">\(10^6\)</span> byte</li>
<li>1 GB = <span class="math inline">\(2^{30}\)</span> byte ≈ <span class="math inline">\(10^9\)</span> byte</li>
<li>1 千万 = <span class="math inline">\(10^7\)</span></li>
<li>1 亿 = <span class="math inline">\(10^8\)</span></li>
</ul>
<p>1 个整数占 4 byte，1 亿个整数占 4*<span class="math inline">\(10^8\)</span> byte ≈ 400 MB。</p>
<h4 id="位图bitmap">位图(bitmap)</h4>
<p>用一个bit位来标记某个元素对应的值。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p>
<p>想知道某个元素出现过没有。如果为每个所有可能的值分配1个bit。</p>
<p>但对于海量的、取值分布很均匀的集合进行<strong>去重</strong>，Bitmap极大地压缩了所需要的内存空间。于此同时，还额外地完成了对原始数组的<strong>排序工作</strong>。</p>
<p>统计数字出现的次数。</p>
<h4 id="bloom-filter布隆过滤器">Bloom Filter(布隆过滤器)</h4>
<h4 id="trie树">trie树</h4>
<p>前缀统计，词频统计。</p>
<h4 id="外部排序">外部排序</h4>
<p>大数据的排序，去重。</p>
<p>1、首先按内存大小，将外存上的文件分成若干子文件。</p>
<p>2、依次读入内存并利用有效的内部排序对他们进行排序，并将排序后得到的有序字文件重新写入外存，通常称这些子文件为归并段。</p>
<p>3、对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件。</p>
<p>外排序的优化方法：置换选择 败者树原理，最优归并树。</p>
<h3 id="常用解决方案">常用解决方案</h3>
<p>1、分而治之/hash映射 + hash统计 + 堆/快速/归并排序； 2、Bitmap去重；</p>
<p>当分而治之（hash映射）出现数据倾斜：改变hash函数再次进行映射。</p>
<p>找数字的去重用位图，字符串去重用HashSet。</p>
<h4 id="海量数据去重">海量数据去重</h4>
<p>数字去重使用位图bitmap，字符串去重HashSet。</p>
<h4 id="n个数求前k大">N个数求前K大</h4>
<p>1、排序算法。 2、计数排序，开辟一个大数组，记录每个整数是否出现，从大到小取。（bitmap） 3、维护一个大小为k的小顶堆。</p>
<h4 id="求文件a中没有但b中有的单词">求文件A中没有但B中有的单词</h4>
<p>遍历文件A，将文件hash到n个小文件中，对B文件同样操作。然后对于每一对文件，先将一个文件存入HashSet，对另一个文件遍历判断。</p>
<h4 id="海量数据排序问题">海量数据排序问题</h4>
<p>hash到小文件中（其实直接切分成若干小文件也行），然后先在小文件排序。</p>
<p>然后合并的时候，用堆，每个小文件取一个，然后最小的拿走再加入对应文件的数字，直到结束。</p>
<p>又或者直接对多个小文件进行归并排序。</p>
<h4 id="海量数据出现次数最多数据">海量数据出现次数最多数据</h4>
<p>分而治之/hash映射（相同数据被分到一起） + HashMap统计 + 堆/快速/归并排序；</p>
<h3 id="面试题">面试题</h3>
<h4 id="字符串统计次数海量日志数据提取出某日访问百度次数最多的那个ip">字符串统计次数：海量日志数据，提取出某日访问百度次数最多的那个IP</h4>
<p><strong>算法思想：分而治之+Hash统计+排序</strong></p>
<p>IP地址最多有<span class="math inline">\(2^{32}\)</span>种取值情况，即约40亿种取值。每个ip地址是32位，因此是一个ip地址大小为4 byte。所以所有ip地址的大小为 <span class="math inline">\(40*10^8*4 byte= 16GB\)</span>， 不能完全加载到内存中处理。</p>
<p>1、按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含<span class="math inline">\(2^{22}=4*2^{20}\)</span>个IP地址，即约400万个ip地址，每个小文件大小为<span class="math inline">\(4*2^{20}*4bytes=16MB\)</span>。</p>
<p>2、对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址。</p>
<p>3、可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP。</p>
<h4 id="top-k统计最热门的10个查询串">TOP K：统计最热门的10个查询串</h4>
<p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p><strong>算法思想：hashmap+堆</strong></p>
<p>去重后300万个查询串的大小最大为<span class="math inline">\(3*10^6*255byte = 765MB\)</span>，可以放入内存当中，构建HashMap统计次数时，value为整型，因此value所占的空间大小为<span class="math inline">\(3*10^6*4byte=12MB\)</span>，因此总内存可以装载这个HashMap。</p>
<p>1、先对这批海量数据预处理，在O(N)的时间内用Hash表完成统计； 2、借助堆这个数据结构，找出Top K，时间复杂度为O(N*logK)。</p>
<h4 id="数字找不重复数字统计次数海量数据找出不重复的整数">数字找不重复/数字统计次数：海量数据找出不重复的整数</h4>
<p>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</p>
<p><strong>算法思想：bitmap位图去重/统计次数</strong></p>
<p>1、2-Bitmap，每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义，共需内存<span class="math inline">\(2^{32} * 2 bit = 2^{32} * 0.25 byte =1 GB\)</span>内存。</p>
<p>2、然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。</p>
<p>3、扫描完成后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>如果需要统计数字出现的次数，则只需要增加bitmap中每一位的bit数即可。</p>
<h4 id="找重复找出ab文件共同的url">找重复：找出a、b文件共同的url</h4>
<p>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url。</p>
<p><strong>算法思想：分而治之 + HashSet去重</strong></p>
<p>每个文件的大小约为<span class="math inline">\(50*10^8*64byte=64*5GB\)</span>，无法放入内存种。</p>
<p>1、遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件。</p>
<p>2、这样处理后，所有可能相同的url都在对应的小文件中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p>
<p>3、求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p>
<h4 id="外部排序10个文件按照query频度排序">外部排序：10个文件，按照query频度排序</h4>
<p>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求按照query的频度排序。</p>
<p><strong>算法思想：分而治之 + hash统计 + 内外排序</strong></p>
<p>1、顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件中。这样新生成的文件每个的大小大约也1G，大于1G的更换哈希函数继续进行切分。</p>
<p>2、找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用排序算法按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件。</p>
<p>3、对这10个文件进行归并排序。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://wangpengcheng.github.io/2019/12/17/hailiangshuju_problems/</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>海量数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>海量数据</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL窗口函数</title>
    <url>/2021/04/13/MySQL_%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p>窗口指的是记录的集合。窗口函数也就是在满足某种条件的记录集合上执行的特殊函数。</p>
<a id="more"></a>
<h4 id="基本用法">基本用法</h4>
<blockquote>
<p>函数名 OVER (子句)</p>
</blockquote>
<p>函数名部分即表示窗口函数。</p>
<p>over关键字用来指定函数执行的窗口范围，若后面括号中什么都不写，则窗口函数基于所有行进行计算；如果不为空，则支持以下4中语法来设置窗口：</p>
<ul>
<li><p><code>PARTITION BY</code> 子句：窗口按照哪些字段进行分组，窗口函数在不同的分组上分别执行；</p></li>
<li><p><code>ORDER BY</code>子句：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号；</p></li>
<li><p><code>FRAME</code>子句：FRAME是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用</p></li>
<li><p>window_name：给窗口指定一个别名。如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">rank</span> ( ) <span class="keyword">over</span> w1 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee <span class="keyword">window</span> w1 <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> )</span><br><span class="line">    </span><br><span class="line"># <span class="keyword">from</span> <span class="keyword">table</span>后面加了一个关键字<span class="keyword">WINDOW</span>，后面跟了一个子句，这样在<span class="keyword">select</span>中就可以使用这个w1作为窗口了。</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="窗口函数">窗口函数</h4>
<p>窗口函数，在某些记录的集合上执行的函数。</p>
<h5 id="序号函数">序号函数</h5>
<p>row_number()/rank()/dense_rank()</p>
<p>作用：显示分区中的当前行号（排名是需要通过<code>ORDER BY</code>子句实现的）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,</span><br><span class="line">   <span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> ranking,</span><br><span class="line">   <span class="built_in">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> dese_rank,</span><br><span class="line">   <span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> row_num</span><br><span class="line"><span class="keyword">from</span> 班级;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/13/MySQL_%E7%AA%97%E5%8F%A3/0.png" style="zoom:67%;"></p>
<ul>
<li><p>rank函数：如果有并列名次的行，会占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，4。</p></li>
<li><p>dense_rank函数：如果有并列名次的行，不占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，2。</p></li>
<li><p>row_number函数：不考虑并列名次的情况。比如前3名是并列的名次，排名是正常的1，2，3，4。</p></li>
</ul>
<h5 id="分布函数">分布函数</h5>
<p>percent_rank()/cume_dist()</p>
<p>percent_rank()</p>
<p>用途：和之前的RANK()函数相关，每行按照公式进行计算：(rank - 1) / (rows - 1)</p>
<p>其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数该函数可以用来计算分位数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">percent_rank</span> ( ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ),</span><br><span class="line">    Company,</span><br><span class="line">    Salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Company <span class="operator">=</span> <span class="string">&#x27;Microsoft&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/13/MySQL_%E7%AA%97%E5%8F%A3/1.png" style="zoom:67%;"></p>
<p>cume_dist()</p>
<p>用途：分组内小于等于当前rank值的行数/分组内总行数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">cume_dist</span> ( ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ),</span><br><span class="line">    Company,</span><br><span class="line">    Salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Company <span class="operator">=</span> <span class="string">&#x27;Microsoft&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/13/MySQL_%E7%AA%97%E5%8F%A3/2.png" style="zoom:67%;"></p>
<h5 id="聚合函数">聚合函数</h5>
<p>sum/avg/max/min/count</p>
<p>用途：在窗口中每条记录动态应用聚合函数(sum/avg/max/min/count)，可以动态计算在指定的窗口内的各种聚合函数值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">avg</span>( Salary ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ),</span><br><span class="line">    Company,</span><br><span class="line">    Salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Company <span class="operator">=</span> <span class="string">&#x27;Microsoft&#x27;</span></span><br></pre></td></tr></table></figure>
<p>按照分组的每一行，求累计的平均值。根据over子句分组之后，挨个行进行select，并执行over前面的函数，因为over子句已经把记录变成了符合条件的一些行集，所以select的方式就改变了。</p>
<p><img src="/2021/04/13/MySQL_%E7%AA%97%E5%8F%A3/3.png" style="zoom:67%;"></p>
<h4 id="参考资料">参考资料</h4>
<p>https://leetcode-cn.com/problems/department-top-three-salaries/solution/tu-jie-sqlmian-shi-ti-jing-dian-topnwen-ti-by-houz/</p>
<p>https://www.jianshu.com/p/e5c5bfb1e28b</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>树结构</title>
    <url>/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/</url>
    <content><![CDATA[<p>B树、B+树、红黑树、满二叉树、完全二叉树</p>
<a id="more"></a>
<h3 id="b树">B树</h3>
<p>B树即平衡多路查找树。是一种自平衡的数据结构，能对存储的数据进行<span class="math inline">\(O(log n)\)</span>的时间复杂度进行查找、插入和删除。平衡的方式是插入和删除数据会对节点进行分裂和合并。每个节点内存储的就是真实的数据，数据是有序的。B树的特点（优点）是：</p>
<p>1、有<strong>自平衡</strong>的操作，能够解决树结构退化成链表的问题，降低树的深度，提高查询性能。</p>
<p>2、一个节点内部<strong>存储了多个数据</strong>，且数据有序，能够提高磁盘IO的性能。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/2.png" style="zoom: 80%;"></p>
<h4 id="b树的性质">B树的性质</h4>
<p>B树的阶数表示了一个节点最多有多少个孩子节点，用字母m表示阶数。 1、每个节点最多有m-1个值（可以存有的键值对）。 2、根节点最少可以只有1个值，非根节点至少有ceil(m/2)个值。 3、每个节点中的值都按照从小到大的顺序排列，每个值的左子树中的所有值都小于它，而右子树中的所有值都大于它。 4、所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 5、每个节点都存有索引和数据，也就是对应的key和value。</p>
<blockquote>
<p>2-3-4 树，就是阶为4的B树，其中节点和存储的元素符合如下性质要求： 任一节点只能是 2 度节点、3 度节点或 4 度节点，不存在元素数为 0 的节点。 2 度节点：如果节点只包含 1 个元素，那它将只能有 2 个子节点； 3 度节点：如果节点只包含 2 个元素，那它将只能有 3 个子节点； 4 度节点：如果节点只包含 3 个元素，那它将只能有 4 个子节点；</p>
</blockquote>
<h4 id="b树插入">B树插入</h4>
<p>判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，以节点的中间的key为标准，将这个节点分为左右两部分，中间的值放到父节点中即可。</p>
<h4 id="b树删除">B树删除</h4>
<p>1）如果当前需要删除的key位于非叶子结点上，则用后继key覆盖要删除的key（后继key指的是大于该数值的下一个值，比如27的后继就是28，28在叶子节点上）。然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上。删除这个记录后执行第2步</p>
<p>2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。</p>
<p>3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。</p>
<p>​ 否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了 一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。</p>
<h3 id="b树-1">B+树</h3>
<p>B+树是B树的改进，也是一种多路平衡查找树，内部的数据稳定有序，每个节点通常有多个孩子，所有叶子节点通过链表连接在一起。时间复杂度与树的高度有关，能对存储的数据以<span class="math inline">\(O(log n)\)</span>的时间复杂度进行查找、插入和删除。非叶子节点处存储的是索引，叶子节点处才存储真正的数据。B+树的特点（优点）是：</p>
<p>1、B+树的磁盘读写代价更低</p>
<p>B+的非叶子结点并没有存储真正的数据，而<strong>存储的是索引</strong>，因此其非叶子结点相对B树更小，能够容纳的索引数量越多，一次性读入内存中能够查找的数据也就越多，相对来说IO读写次数也就降低了。</p>
<p>2、B+树的数据信息遍历更加方便（基于范围的查询）</p>
<p>B+树只要通过<strong>叶子节点上的链表</strong>，就可以遍历所有叶子节点，从而实现整棵树的遍历，而B树不支持这样的操作（或者说效率太低），而且在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+树。</p>
<p>3、B+树的查询效率更加稳定</p>
<p>B+树中非叶子节点仅存储索引，B树中非叶子节点既存储索引，也存储指向真实数据的指针。所以B+树种任何查询必须走一条从根结点到叶子结点。所有查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/3.png" style="zoom: 50%;"></p>
<h4 id="b树的性质-1">B+树的性质</h4>
<p>B+数的高度h，假设当前数据表的数据为N，每个磁盘页可存放的数据项的数量是m，则树的高度约为<span class="math inline">\(log_{m+1} N\)</span>。</p>
<h3 id="红黑树">红黑树</h3>
<p>是二叉搜索树的一种，他并不是完美平衡的，而是黑色节点完美平衡的，也就是每个节点到叶子节点上都有数量相同的黑色节点。它可以在<span class="math inline">\(O(logn)\)</span>时间内做查找，插入和删除，这里的n是树中元素的数目。红黑树的特点（优点）是：</p>
<p>1、 红黑树的约束条件确保没有一条路径会比其他路径长2倍，使得红黑树大致上是一种平衡的树型结构。</p>
<p>2、相比于AVL树来说，红黑树的因为只需要保证黑色节点平衡，因此维护的代价比AVL树要低。</p>
<blockquote>
<p>为什么有AVL树还要红黑树？ 因为AVL树要求子树的高度差都小于等于1，太过严格的要求导致每次插入或删除几乎都要调整树的结构，大量操作时维护代价太高。</p>
</blockquote>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/4.png" style="zoom:67%;"></p>
<h4 id="红黑树的性质">红黑树的性质</h4>
<p>1、每个节点或者是黑色，或者是红色。 2、根节点是黑色。 3、每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！] 4、如果一个节点是红色的，则它的子节点必须是黑色的。 5、从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<h4 id="红黑树的插入">红黑树的插入</h4>
<p>自平衡的方法为变色、左旋、以及右旋。</p>
<p>插入节点必为红色，首先找到它在叶子节点的位置，若父为黑直接插入，若父为红则需要调整： if 叔叔存在且为红 红黑红，叔叔黑（变色） if 叔叔不存在或为黑： if 父为左孩子： if 子为左孩子： LL双红，变色红黑红，右旋 if 子为右孩子： LR双红，左旋变LL双红，变色红黑红，右旋 if 父为右孩子： 。。。镜像操作</p>
<h3 id="满二叉树">满二叉树</h3>
<p>满二叉树，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/5.png" style="zoom:50%;"></p>
<h4 id="满二叉树性质">满二叉树性质</h4>
<p>1、一个层数为k 的满二叉树总结点数为：<span class="math inline">\(2^k-1\)</span>，k从1开始，因此满二叉树节点数总是为奇数。</p>
<p>2、第i层上的节点数为：<span class="math inline">\(2^{i-1}\)</span>，i从1开始。</p>
<h3 id="完全二叉树">完全二叉树</h3>
<p>在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/6.png" style="zoom: 43%;"></p>
<h4 id="完全二叉树性质">完全二叉树性质</h4>
<p>具有n个节点的完全二叉树的深度为<span class="math inline">\(log_2n+1\)</span>。深度为k的完全二叉树，k从1开始，总的节点数至少有<span class="math inline">\(2^{k-1}\)</span>个，至多有<span class="math inline">\(2^k-1\)</span>个。</p>
<h3 id="avl树">AVL树</h3>
<p>平衡二叉树树，任意节点的子树的高度差都小于等于1，通过旋转操作来保证平衡性。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://www.cnblogs.com/nullzx/p/8729425.html （B树操作）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>可以按照复杂度将排序算法进行分类。<span class="math inline">\(O(nlogn)\)</span>：快速排序、归并排序、堆排序；<span class="math inline">\(O(n^2)\)</span> ：冒泡排序、简单选择排序、直接插入排序、希尔排序；<span class="math inline">\(O(n)\)</span>：计数排序、桶排序、基数排序。</p>
<a id="more"></a>
<h3 id="onlogn"><span class="math inline">\(O(nlogn)\)</span></h3>
<h4 id="快速排序">快速排序</h4>
<p>通过一趟排序将数值分隔成独立的两部分，其中一部分均比另一部分小，然后再分别对这两部分记录继续进行排序，以达到整个序列有序。改进方法之一是</p>
<ul>
<li><p>时间复杂度。</p>
<p>最优的情况下时间复杂度为<span class="math inline">\(O( nlogn )\)</span>：主元每次都刚好平分整个数组。</p>
<p>最差的情况下时间复杂度为<span class="math inline">\(O( n^2 )\)</span>：主元每次就是数组中最小/最大的，即冒泡排序。每一次都排好一个元素的顺序)</p></li>
<li><p>空间复杂度。</p>
<p>首先就地快速排序使用的空间是<span class="math inline">\(O(1)\)</span>的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据。</p>
<p>最优的情况下空间复杂度为：<span class="math inline">\(O(logn)\)</span>；每一次都平分数组的情况。</p>
<p>最差的情况下空间复杂度为：<span class="math inline">\(O( n )\)</span> ；退化为冒泡排序的情况。</p></li>
</ul>
<p>递归算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[low];</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[low] = arr[i];</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i的位置就是主元的位置</span></span><br><span class="line"></span><br><span class="line">    quickSort(arr, low, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>非递归 使用栈来实现，通过不断将left和right压入栈中，模拟递归的操作。双指针法部分不需要发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;;</span><br><span class="line">    </span><br><span class="line">    stack.push(left);</span><br><span class="line">    stack.push(right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        right = stakc.pop();</span><br><span class="line">        left = stack.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = partition(array, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &lt; pivot - <span class="number">1</span>)&#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">            stack.push(pivot - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &gt; pivot + <span class="number">1</span>)&#123;</span><br><span class="line">            stack.push(pivot+<span class="number">1</span>);</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序">归并排序</h4>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/0.png" style="zoom:67%;"></p>
<p>将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<ul>
<li><p>时间复杂度</p>
<p>归并排序平均时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最好时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> [] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        MergeSort(arr, low, mid);<span class="comment">//对左边排序</span></span><br><span class="line">        MergeSort(arr, mid+<span class="number">1</span>, high);<span class="comment">//对右边排序</span></span><br><span class="line"></span><br><span class="line">        merge(arr, low, high); <span class="comment">// 合并两个有序数组</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂存数组</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low +<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[j])&#123;</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制剩余的，注意是while！！</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) tmp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; tmp.length; l++)&#123;</span><br><span class="line">        arr[low+l] = tmp[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归 实际上就是每次将2个长度为k的子序列合并为1个。k从1开始，每次递增2倍，直到k超过数组长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k &lt; len)&#123;</span><br><span class="line">        <span class="comment">//每次将2个长度为k的子序列合并为1个</span></span><br><span class="line">        MergePass(array, k, len);</span><br><span class="line">        k = k*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次将2个长度为k的子序列合并为1个</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= len - <span class="number">2</span>*k; i = i + <span class="number">2</span>*k )&#123;</span><br><span class="line">        merge(array, i, i+ <span class="number">2</span>*k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果落单的元素数目超过k，但又不到2k，也是可以两两合并的</span></span><br><span class="line">    <span class="comment">//如果落单的元素数目不超过k，则已经有序</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; n - k)</span><br><span class="line">    &#123;</span><br><span class="line">        merge(array, i, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>]; <span class="comment">//新建一个数组用来暂存</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = (low+high)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//二路归并</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= (low+high)/<span class="number">2</span> || j &lt;= high )&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; array[j])&#123;</span><br><span class="line">            tmp[k] = array[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k] = array[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩余拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= (low+high)/<span class="number">2</span>) tmp[k++] = array[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) tmp[k++] = array[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; tmp.length; l++ )&#123;</span><br><span class="line">        array[low + l] = tmp[l];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序">堆排序</h4>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/1.png" style="zoom: 50%;"></p>
<p>堆，就是一个普通的二叉树，只不过它需要满足的条件是左右子节点都要大于或小于父节点，它复杂度不变的原因就在于它不会像二叉搜索树那样要求左小右大，且它能够调整元素位置，因此不会退化为链表。</p>
<ul>
<li><p>时间复杂度</p>
<p>堆排序平均时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最好时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。 堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树（不会退化为链表）的可以得出它在任何情况下时间复杂度均是<span class="math inline">\(O(nlogn)\)</span>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len;<span class="comment">//表示数组中堆的有效范围</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建最小堆</span></span><br><span class="line">    buildHeap(array);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不断地缩小</span></span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">//交换堆顶和最后一个元素，</span></span><br><span class="line">        <span class="keyword">int</span> tmp = array[len];</span><br><span class="line">        array[len] = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//缩短堆的范围</span></span><br><span class="line">        len--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从堆顶开始向下调整</span></span><br><span class="line">        adjustHeap(<span class="keyword">int</span>[] array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最终得到的结果是一个降序排列的数组！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断本节点，与左右子节点谁小，将小的交换到父节点位置，递归往下调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leastIndex = parent; <span class="comment">//记录最小值的下标</span></span><br><span class="line">    <span class="keyword">int</span> left = parrent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = parrent*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有左孩子，且小于父节点</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; len &amp;&amp; array[left] &lt; array[parent])</span><br><span class="line">        leastIndex = left;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; len &amp;&amp; array[right] &lt; array[parent])</span><br><span class="line">        leastIndex = right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="keyword">if</span>(leastIndex != parent)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tmp = array[parent];</span><br><span class="line">        array[parent] = array[leastIndex];</span><br><span class="line">        array[leastIndex] = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//继续往下调整</span></span><br><span class="line">        adjustHeap(array, leastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上构建最小堆，从第一个非叶子节点开始往上逐步调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        adjustHeap(array, i);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="on2"><span class="math inline">\(O(n^2)\)</span></h3>
<h4 id="冒泡排序">冒泡排序</h4>
<p>比较相邻的元素。如果前一个比后一个大，就交换它们两个；</p>
<ul>
<li><p>时间复杂度</p>
<p>冒泡排序平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最好时间复杂度为<span class="math inline">\(O(n)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p></li>
</ul>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/4.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BubbleSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示比较次数，实际上就已经是n-1趟</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> swap = <span class="keyword">false</span>; <span class="comment">//不再发生交换就可以退出        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123; <span class="comment">//注意-1-i</span></span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                 <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                 array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                 array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                 swap = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!swap)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单选择排序">简单选择排序</h4>
<p>每次都选择最大或最小的元素和起始位置交换</p>
<ul>
<li><p>时间复杂度</p>
<p>简单选择排序平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最好时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> minIndex = i;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length; j++)&#123; <span class="comment">//找到最小的元素</span></span><br><span class="line">             <span class="keyword">if</span>(array[j] &lt; array[minIndex])</span><br><span class="line">                 minIndex = j;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//和序列头部交换</span></span><br><span class="line">         <span class="keyword">int</span> tmp = array[i];</span><br><span class="line">         array[i] = array[minIndex];</span><br><span class="line">         array[minIndex] = array[i];</span><br><span class="line">         </span><br><span class="line">     &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="直接插入排序">直接插入排序</h4>
<p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。（从后往前）注意直接插入排序能够保持元素的相对顺序。</p>
<ul>
<li><p>时间复杂度</p>
<p>直接插入排序平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最好时间复杂度为<span class="math inline">\(O(n)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p></li>
</ul>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/3.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> current = array[i];<span class="comment">//未排序元素下标</span></span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;<span class="comment">//已经排序的元素下标</span></span><br><span class="line">       <span class="keyword">while</span>( preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; current)&#123; <span class="comment">//从小到大排序</span></span><br><span class="line">           array[preIndex+<span class="number">1</span>] = array[preIndex];</span><br><span class="line">           preIndex--;</span><br><span class="line">       &#125; </span><br><span class="line">        </span><br><span class="line">        array[preIndex + <span class="number">1</span>] = current; <span class="comment">//找到合适的位置插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array; <span class="comment">//改进方法是在有序区内使用二分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序">希尔排序</h4>
<p>直接插入排序的改进版，整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成），对子序列分别进行直接插入排序，然后缩减增量为之前的一半再进行排序。gap初始值一般取 len / 2。</p>
<ul>
<li><p>时间复杂度</p>
<p>希尔排序平均时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最好时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。</p></li>
</ul>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/2.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> gap = array.length / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; array.length; i++)</span><br><span class="line">            <span class="keyword">int</span> current = array[i];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; current)&#123;</span><br><span class="line">                array[preIndex + gap] = array[preIndex];</span><br><span class="line">                preIndex = preIndex - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            array[preIndex + gap] = current; <span class="comment">// 插入元素</span></span><br><span class="line">        &#125;        </span><br><span class="line">        gap = gap / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="on"><span class="math inline">\(O(n)\)</span></h3>
<h4 id="计数排序">计数排序</h4>
<p>将数值转化为键存储在额外的有序空间中，并统计各个元素出现多少次。</p>
<ul>
<li><p>时间复杂度</p>
<p>计数排序平均时间复杂度为<span class="math inline">\(O(n + k)\)</span>，最好时间复杂度为<span class="math inline">\(O(n + k)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n + k)\)</span>。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。</p></li>
<li><p>空间复杂度</p>
<p>计数排序空间复杂度为<span class="math inline">\(O(k)\)</span>，k为桶数组的长度。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span> [] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计最大值和最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; min)</span><br><span class="line">            min = array[i];</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; max)</span><br><span class="line">            max = array[i];    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用偏移量进行计数</span></span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length; i++)        </span><br><span class="line">        bucket[ array[i] - min ]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a_index = <span class="number">0</span>, b_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a_index &lt; array.length)&#123;</span><br><span class="line">        <span class="comment">//如果桶不是空的</span></span><br><span class="line">        <span class="keyword">if</span>(bucket[b_index] != <span class="number">0</span>)&#123;</span><br><span class="line">            array[a_index] = min+b_index;<span class="comment">//数组当前位置有值</span></span><br><span class="line">            bucket[b_index]--;</span><br><span class="line">            a_index++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b_index++;<span class="comment">//移动桶的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="桶排序">桶排序</h4>
<p>桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。 桶排序平均时间复杂度为O(n + k)</p>
<h4 id="基数排序-radix-sort">基数排序 radix sort</h4>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先统计最多有多少位</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        max = max/<span class="number">10</span>;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">1</span>;<span class="comment">//除数，每次去除最低位</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//给十进制每一位赋予一个桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        bucket.add( <span class="keyword">new</span> ArrayList&lt;Integer&gt;() );</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//从低位到高位遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++)&#123;</span><br><span class="line">        <span class="comment">//统计  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">             <span class="comment">//计算当前位数是几</span></span><br><span class="line">             <span class="keyword">int</span> num = (array[j]/div)%<span class="number">10</span>;</span><br><span class="line">             <span class="comment">//放入桶中</span></span><br><span class="line">             bucket.get(num).add(array[j]);   </span><br><span class="line">        &#125;</span><br><span class="line">        div = div * <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历桶，收集</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.size(); j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucket.get(j).size();k++)</span><br><span class="line">                array[index++] = bucket.get(j).get(k);</span><br><span class="line">            bucket.get(j).clear();<span class="comment">//清空    </span></span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/u013309870/article/details/68578011</p>
<p>https://www.jianshu.com/p/47170b1ced23</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL SQL</title>
    <url>/2021/04/17/MySQL_SQL/</url>
    <content><![CDATA[<p>SQL 是用于访问和处理数据库的标准的计算机语言。</p>
<a id="more"></a>
<h3 id="函数">函数</h3>
<h4 id="limit-offset函数">LIMIT OFFSET函数</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#选择排名第二高的工资</span><br><span class="line">select</span><br><span class="line">ifnull(</span><br><span class="line">(</span><br><span class="line">    select distinct Salary from Employee order by Salary desc limit 1 offset 1</span><br><span class="line">)</span><br><span class="line">,</span><br><span class="line">null</span><br><span class="line">)</span><br><span class="line">as SecondHighestSalary</span><br></pre></td></tr></table></figure>
<h4 id="窗口函数">窗口函数</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每个部门里面工资前三高的员工</span><br><span class="line">select d.name as department, a.name as employee, a.salary as salary</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    #利用排名函数 dense_rank() 获得分区下的排名</span><br><span class="line">    select *, dense_rank() over( partition by departmentid order by salary desc) as t</span><br><span class="line">    from Employee</span><br><span class="line">)</span><br><span class="line">as a </span><br><span class="line">inner join department as d # 用部门id连接</span><br><span class="line">on a.DepartmentId &#x3D; d.Id </span><br><span class="line">where t &lt;&#x3D; 3 #选择排名高的</span><br></pre></td></tr></table></figure>
<h4 id="case-when">CASE WHEN</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="type">Date</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">Result</span> <span class="keyword">when</span> <span class="string">&#x27;胜&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;胜&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">Result</span> <span class="keyword">when</span> <span class="string">&#x27;负&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;负&#x27;</span></span><br><span class="line"><span class="keyword">from</span> test</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="type">date</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    STUDENT_NAME,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> score <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">&#x27;及格&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">&#x27;优秀&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;缺席考试&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;异常&#x27;</span> <span class="keyword">END</span>) <span class="keyword">AS</span> REMARK</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure>
<h3 id="面试">面试</h3>
<h4 id="计算用户在线峰值">计算用户在线峰值</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(timestampe:String,uid:Int,logtype:Int)</span><br><span class="line">时间戳 用户ID 上线下线状态(-1下线，1上线)</span><br><span class="line"></span><br><span class="line">select</span><br><span class="line">    max(max_users)</span><br><span class="line">from </span><br><span class="line">(</span><br><span class="line">    select</span><br><span class="line">        sum(logtype) over(order by &#96;timestampe&#96;) as max_users #排序后第一行到本行的和，就统计了当前时刻究竟有多少人在线</span><br><span class="line">    from</span><br><span class="line">    (</span><br><span class="line">        select</span><br><span class="line">            uid,</span><br><span class="line">            unix_timestamp(timestampe) as &#96;timestampe&#96;, #unix_timestamp 自&#39;1970-01-01 00:00:00&#39;的到当前时间的秒数差</span><br><span class="line">            logtype</span><br><span class="line">        from</span><br><span class="line">            mytable</span><br><span class="line">    ) as a  #将登录时间和登出时间多列成多行</span><br><span class="line">)as b</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://www.codeleading.com/article/5399898432/ （在线峰值）</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark闭包、累加器和广播变量</title>
    <url>/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="总结">总结</h3>
<ul>
<li><p>闭包</p>
<p>闭包<strong>就是一个携带了外部作用域的函数</strong>，当它需要被分发到各个节点上执行的时候，需要外部作用域所在的对象是可序列化的。</p>
<p>使用这种外部变量的形式，会造成每个Task中都存在一个该变量的副本。</p></li>
</ul>
<a id="more"></a>
<ul>
<li><p>广播变量</p>
<p>广播变量是一种变量，广播变量允许开发者将一个 <code>Read-Only</code> 的变量<strong>缓存到集群中每个节点中</strong>，而不是传递给每一个 Task 一个副本，每个Executor中只会存在一个副本。</p>
<ul>
<li><p>解决了外部变量在每个Task中都存在副本的问题，每个Executor只会存在一份广播变量的副本，节省空间。</p></li>
<li><p>在Driver端可以修改广播变量的值，<strong>在Executor端无法修改广播变量的值。</strong></p></li>
<li><p>广播变量只能在Driver端定义，不能在Executor端定义。</p></li>
<li><p>不能将RDD广播，因为RDD是不存储数据的。可以将RDD的结果广播出去。</p></li>
</ul></li>
<li><p>累加器</p>
<p>累加器是一个<strong>支持添加操作的分布式变量</strong>，可以在分布式环境下保持一致性。</p>
<ul>
<li>累加器在Driver端定义赋初始值，累加器只能在Driver端读取最后的值，在Excutor端更新。</li>
<li>在Driver端可以修改广播变量的值，<strong>在Executor端可以修改累加器的值。</strong></li>
</ul></li>
</ul>
<h3 id="闭包">闭包</h3>
<p>如果一个函数<strong>携带了外部的作用域</strong>，这种<strong>函数称为闭包</strong>。</p>
<p>在Scala中，函数是一个对象，继承自FunctionN。</p>
<h4 id="问题引出">问题引出</h4>
<p>在spark中实现统计List(1,2,3)的和。如果使用下面的代码，程序打印的结果不是6，而是0。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">      <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> rdd = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">      <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">      <span class="comment">//warn: don&#x27;t do this</span></span><br><span class="line">      rdd.foreach(x =&gt; counter += x)</span><br><span class="line">      println(<span class="string">&quot;Counter value: &quot;</span>+counter) <span class="comment">//打印结果为0</span></span><br><span class="line"></span><br><span class="line">      sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题分析： counter是在foreach函数外部定义的，也就是在driver程序中定义，而foreach函数是属于rdd对象的，rdd函数的执行位置是各个worker节点（或者说worker进程），main函数是在driver节点上（或者说driver进程上）执行的。所以当counter变量在driver中定义，被在rdd中使用的时候，出现了变量的跨域问题，也就是闭包问题。</p>
<p>问题解释： 对于上面程序中的counter变量，由于在main函数和在rdd对象中foreach函数是属于不同作用域的，所以，传进foreach中的counter是一个副本，初始值都为0。foreach中叠加的是counter的副本，不管副本如何变化，都不会影响到main函数中的counter，所以最终打印出来的counter为0。</p>
<h4 id="解决方案">解决方案</h4>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>())</span><br><span class="line">    <span class="keyword">val</span> newRDD = sc.textFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    newRDD.map(data =&gt; &#123;</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      println(data.toString)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在RDD的函数中调用了在函数外部定义的对象，这些对象需要通过网络从driver所在节点传给其他的worker节点，所以<strong>要求这些类是可序列化的</strong>，比如在Java或者Scala中实现Serializable类。Worker节点接收到程序之后，在Spark资源管理器的指挥下运行RDD程序。不同Worker节点之间的运行操作是并行的。</p>
<p><img src="/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/0.png" style="zoom:67%;"></p>
<p>除了用外部定义的对象来实现类似的功能，Spark还另外提供了两种机制，分别是<strong>Broadcast</strong>和<strong>Accumulator</strong>。</p>
<p>相比于外部变量的方式，在一定场景下使用Broadcast比较有优势，因为所广播的数据在每一个Worker节点上面只存一个副本，而在Spark算子中使用到的外部变量会在每一个用到它的Task中保存一个副本，即使这些task在同一个节点上面。所以当数据量比较大的时候，建议使用广播而不是外部变量。</p>
<h3 id="广播变量">广播变量</h3>
<p>广播变量是一种变量，广播变量允许开发者将一个 <code>Read-Only</code> 的变量缓存到集群中每个节点中, 而不是传递给每一个 Task 一个副本，每个Executor中只会存在一个副本。</p>
<p>变量一旦被定义为一个广播变量，那么这个变量只能读，不能修改。</p>
<p><img src="/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/2.png" style="zoom:50%;"></p>
<h4 id="广播变量的使用">广播变量的使用</h4>
<h5 id="创建广播变量">创建广播变量</h5>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> b = sc.broadcast(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>如果 Log 级别为 DEBUG 的时候, 会打印如下信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEBUG BlockManager: Put block broadcast_0 locally took  430 ms</span><br><span class="line">DEBUG BlockManager: Putting block broadcast_0 without replication took  431 ms</span><br><span class="line">DEBUG BlockManager: Told master about block broadcast_0_piece0</span><br><span class="line">DEBUG BlockManager: Put block broadcast_0_piece0 locally took  4 ms</span><br><span class="line">DEBUG BlockManager: Putting block broadcast_0_piece0 without replication took  4 ms</span><br></pre></td></tr></table></figure>
<h5 id="使用-value-获取数据">使用 <code>value</code> 获取数据</h5>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">b.value</span><br></pre></td></tr></table></figure>
<p>获取数据的时候会打印如下信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEBUG BlockManager: Getting local block broadcast_0</span><br><span class="line">DEBUG BlockManager: Level for block broadcast_0 is StorageLevel(disk, memory, deserialized, 1 replicas)</span><br></pre></td></tr></table></figure>
<p>使用 <code>value</code> 方法的注意点</p>
<p>方法签名 <code>value: T</code></p>
<p>在destroy之前才能使用value：在 <code>value</code> 方法内部会确保使用获取数据的时候, 变量必须是可用状态, 所以必须在变量被 <code>destroy</code> 之前使用 <code>value</code> 方法, 如果使用 <code>value</code> 时变量已经失效, 则会报出以下错误：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.apache.spark.SparkException: Attempted to use Broadcast(0) after it was destroyed (destroy at &lt;console&gt;:27)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.assertValid(Broadcast.scala:144)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.value(Broadcast.scala:69)</span><br><span class="line">  ... 48 elided</span><br></pre></td></tr></table></figure>
<h5 id="使用-unpersist-删除数据">使用 <code>unpersist</code> 删除数据</h5>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">b.unpersist</span><br></pre></td></tr></table></figure>
<h5 id="使用-destroy-销毁变量">使用 <code>destroy</code> 销毁变量,</h5>
<p>释放内存空间</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">b.destroy</span><br></pre></td></tr></table></figure>
<p>销毁以后, 会打印如下信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEBUG BlockManager: Removing broadcast 0</span><br><span class="line">DEBUG BlockManager: Removing block broadcast_0_piece0</span><br><span class="line">DEBUG BlockManager: Told master about block broadcast_0_piece0</span><br><span class="line">DEBUG BlockManager: Removing block broadcast_0</span><br></pre></td></tr></table></figure>
<p>使用 <code>destroy</code> 方法的注意点</p>
<p>方法签名 <code>destroy(): Unit</code></p>
<p>不要多次删除广播变量：<code>destroy</code> 方法会移除广播变量, 彻底销毁掉, 但是如果你试图多次 <code>destroy</code> 广播变量, 则会报出以下错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.apache.spark.SparkException: Attempted to use Broadcast(0) after it was destroyed (destroy at &lt;console&gt;:27)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.assertValid(Broadcast.scala:144)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.destroy(Broadcast.scala:107)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.destroy(Broadcast.scala:98)</span><br><span class="line">  ... 48 elided</span><br></pre></td></tr></table></figure>
<h4 id="广播变量的使用场景">广播变量的使用场景</h4>
<p>正常情况下使用 Task 拉取数据的时候, 会将数据拷贝到 Executor 中多次, 但是使用广播变量的时候只会复制一份数据到 Executor 中, 所以在两种情况下特别适合使用广播变量</p>
<ul>
<li>一个 Executor 中有多个 Task 的时候</li>
<li>一个变量比较大的时候</li>
<li>大RDD和小RDD执行join操作时。当一个 RDD 很大并且还需要和另外一个 RDD 执行 <code>join</code> 的时候, 可以将较小的 RDD 广播出去, 然后使用大的 RDD 在算子 <code>map</code> 中直接 <code>join</code>, 从而实现在 Map 端 <code>join</code>。</li>
</ul>
<h3 id="累加器">累加器</h3>
<h4 id="通用累加器">通用累加器</h4>
<p>Accumulators(累加器) 是一个只支持 added(添加) 的分布式变量, 可以在分布式环境下保持一致性, 并且能够做到高效的并发。</p>
<p><img src="/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/1.png" style="zoom:50%;"></p>
<ul>
<li><p>Accumulator 是支持并发并行的, 在任何地方都可以通过 add 来修改数值, 无论是 Driver 还是 Executor</p></li>
<li><p>只能在 Driver 中才能调用 value 来获取数值</p></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;ip_ana&quot;</span>).setMaster(<span class="string">&quot;local[6]&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> counter = sc.longAccumulator(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line"></span><br><span class="line">sc.parallelize(<span class="type">Seq</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">  .foreach(counter.add(_))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果: 15</span></span><br><span class="line">println(counter.value)</span><br></pre></td></tr></table></figure>
<ul>
<li>累加器能保证在 Spark 任务出现问题被重启的时候不会出现重复计算</li>
<li>累加器只有在 Action 执行的时候才会被触发</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;ip_ana&quot;</span>).setMaster(<span class="string">&quot;local[6]&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> counter = sc.longAccumulator(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line"></span><br><span class="line">sc.parallelize(<span class="type">Seq</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">  .map(counter.add(_)) <span class="comment">// 这个地方不是 Action, 而是一个 Transformation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果是 0</span></span><br><span class="line">println(counter.value)</span><br></pre></td></tr></table></figure>
<h4 id="自定义累加器">自定义累加器</h4>
<p>可以通过自定义累加器来实现更多类型的累加器, 累加器的作用远远不只是累加, 比如可以实现一个累加器, 用于向里面添加一些运行信息。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承AccumulatorV2这个类，传入String类型，返回Set[String]类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, <span class="type">Set</span>[<span class="type">String</span>]] </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个可变长度的Set，即 mutable.Set[String]  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> infos: mutable.<span class="type">Set</span>[<span class="type">String</span>] = mutable.<span class="type">Set</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断累加器对象是否为空，这里就是判断这个Set是否为空</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">    infos.isEmpty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回一个拷贝的累加器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, <span class="type">Set</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> newAccumulator = <span class="keyword">new</span> <span class="type">InfoAccumulator</span>()</span><br><span class="line">    infos.synchronized &#123; <span class="comment">//使用synchronized关键字保证线程安全</span></span><br><span class="line">      newAccumulator.infos ++= infos <span class="comment">//把一个Set添加到另一个Set中使用++=</span></span><br><span class="line">    &#125;</span><br><span class="line">    newAccumulator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清空累加器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    infos.clear()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//往累加器中添加元素</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(v: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    infos += v</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//累加器在进行累加的时候，可能每个分布式节点都有一个实例</span></span><br><span class="line">  <span class="comment">//在最后的Driver中进行合并，通过调用这个merge方法把所有的实例内容合并起来，</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, <span class="type">Set</span>[<span class="type">String</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    infos ++= other.value <span class="comment">//这里的value就是下面这个方法返回的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//提供给外部累加结果，注意返回一个不可变的类型，防止外部进行修改</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Set</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    infos.toSet</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulator2</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;ip_ana&quot;</span>).setMaster(<span class="string">&quot;local[6]&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> infoAccumulator = <span class="keyword">new</span> <span class="type">InfoAccumulator</span>()</span><br><span class="line">  sc.register(infoAccumulator, <span class="string">&quot;infos&quot;</span>)</span><br><span class="line"></span><br><span class="line">  sc.parallelize(<span class="type">Seq</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>))</span><br><span class="line">    .foreach(item =&gt; infoAccumulator.add(item))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行结果: Set(3, 1, 2)</span></span><br><span class="line">  println(infoAccumulator.value)</span><br><span class="line"></span><br><span class="line">  sc.stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://knifefly.cn/2018/05/21/%E7%90%86%E8%A7%A3spark%E9%97%AD%E5%8C%85/（闭包）</p>
<p>https://blog.csdn.net/weixin_43854618/article/details/105680445（累加器）</p>
<p>https://www.cnblogs.com/qingyunzong/p/8890483.html#_label1（广播变量和累加器）</p>
]]></content>
      <categories>
        <category>Spark</category>
        <category>Spark Core</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>Spark Core</tag>
      </tags>
  </entry>
  <entry>
    <title>Java位运算</title>
    <url>/2021/04/12/Java_%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h3 id="位运算">位运算</h3>
<p>计算机里面任何数据本质上是用二进制（0 1）来保存的数字。位运算就是直接对二进制类型的数据进行计算。</p>
<a id="more"></a>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&amp;</td>
<td>与</td>
<td>两位都为1，结果为1</td>
</tr>
<tr class="even">
<td>|</td>
<td>或</td>
<td>有一位为1，结果为1</td>
</tr>
<tr class="odd">
<td>~</td>
<td>非</td>
<td>~0 = 1， ~1 = 0</td>
</tr>
<tr class="even">
<td>^</td>
<td>异或</td>
<td>两位不相同，结果为1</td>
</tr>
<tr class="odd">
<td>&lt;&lt;</td>
<td>左移</td>
<td>二进制位全部左移，高位丢弃，低位补0</td>
</tr>
<tr class="even">
<td>&gt;&gt;</td>
<td>右移</td>
<td>二进制位全部右移，无符号数高位补零，有符号数补符号位或零（根据编译器）</td>
</tr>
</tbody>
</table>
<h3 id="常用位操作">常用位操作</h3>
<ul>
<li><p>判断奇偶</p>
<p>(x &amp; 1) == 1 等价 (x % 2 == 1)</p>
<p>(x &amp; 1) == 0 等价 (x % 2 == 0)</p></li>
<li><p>除以二</p>
<p>x &gt;&gt; 1 等价 x / 2</p></li>
<li><p>把最低位的二进制1去掉</p>
<p>x &amp;= (x - 1)</p></li>
<li><p>得到最低位的1</p>
<p>x &amp; -x</p>
<blockquote>
<p>-x的运算是，所有位置取反，然后+1</p>
<p>保留二进制下最后出现的1的位置，其余位置置0</p>
<p>https://www.cnblogs.com/yzxag/p/12668034.html</p>
</blockquote></li>
<li><p>得到0</p>
<p>x &amp; ~x == 0</p></li>
</ul>
<h3 id="指定位置的位运算">指定位置的位运算</h3>
<p>https://leetcode-cn.com/problems/power-of-two/solution/5chong-jie-fa-ni-ying-gai-bei-xia-de-wei-6x9m/</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中char、int、String相互转换</title>
    <url>/2021/04/01/Java_char,int,String%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="char转int">char转int</h4>
<p>在Java中用2个字节，即16位，来表示一个char。</p>
<a id="more"></a>
<ul>
<li><p>当char为数字时</p>
<p>即'0'、'1'、'2'、'3'...、'9'时，则直接减去'0'可以得到对应的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> nine = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="string">&#x27;9&#x27;</span> - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//num即得到9</span></span><br></pre></td></tr></table></figure></li>
<li><p>当char为其他字符时</p>
<p>使用强制类型转换即可获得该字符表示的ASCII 编码。</p>
<p>字符<strong>0-9</strong>的ASCII码：48-57；</p>
<p>大写字母<strong>A-Z</strong>的ASCII码为：65-90；</p>
<p>小写字母<strong>a-z</strong>的ASCII码为：97-122；</p>
<p><strong>空字符</strong>的ASCII码为0；</p>
<p><strong>换行符</strong>的ASCII码为10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> tmp = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)tmp; <span class="comment">//num此时为&#x27;a&#x27;的ASCII 编码97</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="int转char">int转char</h4>
<ul>
<li><p>当int为两位以上的数字时，使用强制类型转换将变成该数字代表的ASCII码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">97</span>;</span><br><span class="line"><span class="keyword">char</span> ca = (<span class="keyword">char</span>)num; <span class="comment">//ca此时就代表了小写字母&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>当int为0到9的数字时，利用ASCII码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">char</span> ca = (<span class="keyword">char</span>)(num+<span class="number">48</span>) <span class="comment">//ca此时就代表了数字&#x27;9&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>先将int转为String，再转成char，可以将数字拆开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">4596</span>;</span><br><span class="line">String str = String.valueOf(num);</span><br><span class="line"><span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">	System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5 9 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="char转string">char转String</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = String.valueOf(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//char数组转String</span></span><br><span class="line"><span class="keyword">char</span>[] s=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">String st=String.valueOf(s);</span><br></pre></td></tr></table></figure>
<h4 id="string转char">String转char</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] array = str.toCharArray();</span><br></pre></td></tr></table></figure>
<h4 id="string转int">String转int</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;6666&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num = Integer.valueOf(str);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当str非数字时报出运行时异常</span></span><br><span class="line"><span class="comment">java.lang.NumberFormatException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stirng数组转int数组，利用Java 8中的stream方法</span></span><br><span class="line">String[] strings = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] array = Arrays.stream(strings).mapToInt(Integer::parseInt).toArray();</span><br></pre></td></tr></table></figure>
<h4 id="int转string">int转String</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">6666</span>;</span><br><span class="line">String str = String.valueOf(num);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合操作</title>
    <url>/2021/04/11/Java_%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="java集合操作">Java集合操作</h3>
<p>遍历集合、Map类型数据排序</p>
<a id="more"></a>
<h3 id="遍历集合">遍历集合</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map.Entry遍历</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : tempMap.entrySet()) &#123;</span><br><span class="line">   String key = entry.getKey().toString();</span><br><span class="line">   String value = entry.getValue().toString();</span><br><span class="line">   System.out.println(<span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot; value=&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//keySet()遍历</span></span><br><span class="line">  <span class="keyword">for</span> (Object o : tempMap.keySet()) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;key=&quot;</span> + o + <span class="string">&quot; value=&quot;</span> + tempMap.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map类型数据排序">Map类型数据排序</h3>
<p>注意TreeSet、TreeMap本身的Key就是按照字典序进行排序的。</p>
<h4 id="完整方法">完整方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapKeySort</span><span class="params">(HashMap&lt;Integer, String&gt; hm)</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//定义一个list装载key、value</span></span><br><span class="line">        List&lt;Map.Entry&lt;Integer, String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;Integer, String&gt;&gt;(hm.entrySet());</span><br><span class="line">        </span><br><span class="line">     	<span class="comment">//对list进行排序，自定义排序规则</span></span><br><span class="line">     	list.sort(<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Integer, String&gt; o1, Map.Entry&lt;Integer, String&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getKey() &lt; o2.getKey() ? <span class="number">1</span> : ((o1.getKey() == o2.getKey()) ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     </span><br><span class="line">     	<span class="comment">/*打印结果查看</span></span><br><span class="line"><span class="comment">        for (Map.Entry&lt;Integer, String&gt; mapping : list) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(mapping.getKey() + &quot;:&quot; + mapping.getValue());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后把这个List返回即可</span></span><br></pre></td></tr></table></figure>
<h4 id="简单方法">简单方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取key</span></span><br><span class="line">Object[] key_arr = hashmap.keySet().toArray();   </span><br><span class="line"><span class="comment">//对key排序</span></span><br><span class="line">Arrays.sort(key_arr);   </span><br><span class="line"><span class="comment">//通过key获取value</span></span><br><span class="line"><span class="keyword">for</span>(Object key : key_arr) &#123;   </span><br><span class="line">    Object value = hashmap.get(key);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程编程题</title>
    <url>/2021/04/18/Java_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
    <content><![CDATA[<p>交替打印奇偶数、十个线程实现1~100求和</p>
<a id="more"></a>
<h3 id="交替打印奇偶数">交替打印奇偶数</h3>
<h4 id="仅通过synchronized关键字实现">仅通过synchronized关键字实现</h4>
<p>创建两个线程，一个线程负责打印奇数，另一个线程打印偶数，两个线程竞争同一个对象锁，每次打印一个数字后释放锁，然后另一个线程拿到锁打印下一个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOddEven1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">						<span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;偶数线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">						<span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;奇数线程&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="synchronized关键字配合wait和notify方法">synchronized关键字配合wait和notify方法</h4>
<p>无需判断数字是否是奇偶数，两个线程通过等待唤醒机制，交替打印数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOddEven2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> printer(), <span class="string">&quot;偶数线程，&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> printer(), <span class="string">&quot;奇数线程，&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">					<span class="comment">// 打印数字，并立即释放锁</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印:&quot;</span> + count++);</span><br><span class="line">					object.notify();</span><br><span class="line">					<span class="comment">// 此处判断，是为了打印完了100个数字后，程序能够正常结束，否则程序将一直等待下去，耗费系统资源。</span></span><br><span class="line">					<span class="keyword">if</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							object.wait();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十个线程实现1100求和">十个线程实现1~100求和</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程都有一个startnum，0，10，20...90</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> startnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有线程共用一个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch latch; <span class="comment">//同步器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程初始化自己的startnum</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        startnum = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个线程不能同时执行这个加法（但是其实同时也无所谓？）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;    <span class="comment">// public static synchronized void add(int num)</span></span><br><span class="line">        sum = sum + num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//重写这个run方法执行累加操作</span></span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            tmp = tmp + (startnum + i); <span class="comment">//从startnum开始做加法，比如第二组：0 + （11+0） +（11+1）+（11+2）+...+(11+9) = 11 + 12 + 13 + ... + 20</span></span><br><span class="line">        &#125;</span><br><span class="line">        add(tmp); <span class="comment">//把结果加到总和中</span></span><br><span class="line"></span><br><span class="line">        latch.countDown(); <span class="comment">//递减计数器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程数量</span></span><br><span class="line">        <span class="keyword">int</span> tc = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//创建计数器</span></span><br><span class="line">        latch = <span class="keyword">new</span> CountDownLatch(tc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建线程数组</span></span><br><span class="line">        Thread[] threadArray = <span class="keyword">new</span> Thread[tc];</span><br><span class="line">        <span class="comment">//创建线程并运行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tc; i++)&#123;</span><br><span class="line">            threadArray[i] = <span class="keyword">new</span> ThreadTest(i*<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">            threadArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">//等待所有线程递减 CountDownLatch</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1 + 2 + 3 + ... + 100 = &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/x541211190/article/details/109402864（交替打印奇偶数）</p>
<p>//https://blog.csdn.net/jy_z11121/article/details/84490436?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs （十个线程实现1~100求和）</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>树算法</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>非递归遍历 https://www.jianshu.com/p/8efe8f281f22</p>
<p>二叉树递归非递归遍历、二叉树高度</p>
<a id="more"></a>
<h3 id="二叉树遍历">二叉树遍历</h3>
<h4 id="前序遍历">前序遍历</h4>
<p>前序遍历按照“根结点-左孩子-右孩子”的顺序进行访问。</p>
<h5 id="递归实现">递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">     	System.out.println(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归实现">非递归实现</h5>
<p>根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。</p>
<p>对于任一结点P：</p>
<p>1、访问结点P，并将结点P入栈;</p>
<p>2、判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1；若不为空，则将P的左孩子置为当前的结点P;</p>
<p>3、直到P为NULL并且栈为空，则遍历结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">		ArrayList&lt;TreeNode&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		TreeNode p = root;</span><br><span class="line">    	<span class="comment">//当栈内还存在元素</span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">			<span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">				alist.add(p.val);<span class="comment">//先访问根节点</span></span><br><span class="line">				stack.push(p);<span class="comment">//先访问根节点</span></span><br><span class="line">				p = p.left;<span class="comment">//再访问左子树</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line">				TreeNode temp = stack.pop();</span><br><span class="line">				p = temp.right;<span class="comment">//访问右子树</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> alist;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历">中序遍历</h4>
<p>中序遍历按照“左孩子-根结点-右孩子”的顺序进行访问。</p>
<h5 id="递归实现-1">递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">			inOrder(root.left);</span><br><span class="line">			System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			inOrder(root.right);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归实现-1">非递归实现</h5>
<p>根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。</p>
<p>对于任一结点P，</p>
<p>1、若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理；</p>
<p>2、若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子；</p>
<p>3、直到P为NULL并且栈为空则遍历结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ArrayList&lt;TreeNode&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;<span class="comment">//先访问左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line">            TreeNode tmp = stack.pop();</span><br><span class="line">            alist.add(tmp.val);<span class="comment">//再访问根节点</span></span><br><span class="line">            p = tmp.right;<span class="comment">//访问右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历">后序遍历</h4>
<p>后序遍历按照“左孩子-右孩子-根结点”的顺序进行访问。</p>
<h5 id="递归实现-2">递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">		postOrder(root.left);</span><br><span class="line">		postOrder(root.right);</span><br><span class="line">		System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归实现-2">非递归实现</h5>
<p>1、要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。</p>
<p>2、如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。</p>
<p>3、若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ArrayList&lt;TreeNode&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    TreeNode cur,pre = <span class="keyword">null</span>;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        cur = stack.peek();</span><br><span class="line">        <span class="comment">//当前节点不存在左右孩子，或者左右孩子都已经被访问过</span></span><br><span class="line">        <span class="keyword">if</span>( (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) || (pre != <span class="keyword">null</span> &amp;&amp; (cur.left == pre || cur.right == pre) ) )&#123;</span><br><span class="line">            <span class="comment">//访问当前节点</span></span><br><span class="line">            TreeNode tmp = stack.pop();</span><br><span class="line">            alist.add(tmp.val);</span><br><span class="line">            pre =tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//否则先将右子节点入栈，再将左子节点入栈，保证先访问左子树再访问右子树</span></span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">					stack.push(cur.right);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> alist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层序遍历">层序遍历</h4>
<p>使用队列实现层序遍历。</p>
<p>1、首先将根节点放入队列中。</p>
<p>2、当队列为非空时，循环执行步骤3到步骤5，否则执行6；</p>
<p>3、出队列取得一个结点，访问该结点；</p>
<p>4、若该结点的左子树为非空，则将该结点的左子树入队列；</p>
<p>5、若该结点的右子树为非空，则将该结点的右子树入队列；</p>
<p>6、结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	queue.offer(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		TreeNode temp  = queue.poll();</span><br><span class="line">		System.out.print(temp.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)</span><br><span class="line">			queue.offer(temp.left);</span><br><span class="line">		<span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)</span><br><span class="line">			queue.offer(temp.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/u011514810/article/details/75907170 （二叉树遍历）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 树</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E6%A0%91/</url>
    <content><![CDATA[<p>LeetCode中与树有关的题目。</p>
<a id="more"></a>
<h3 id="二叉树展开为链表">114 二叉树展开为链表</h3>
<p><strong>题目描述</strong></p>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><strong>题解</strong>：</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将左右子树展开</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        TreeNode tmp_right = root.right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将展开的左子树链表接到右子树链表的后面</span></span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            root = root.right;</span><br><span class="line">        root.right = tmp_right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中的最大路径和">124 二叉树中的最大路径和</h3>
<p><strong>题目描述</strong></p>
<p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E6%A0%91/0.png" style="zoom:67%;"></p>
<p>输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</p>
<p><strong>题解：</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>后续遍历得到左右子树的最大路径和，再和当前值进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE; <span class="comment">//记录全局最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后序遍历，返回左右子树的最大和，负数的就不要</span></span><br><span class="line">        <span class="keyword">int</span> max_left = Math.max(<span class="number">0</span>, dfs(root.left));</span><br><span class="line">        <span class="keyword">int</span> max_right = Math.max(<span class="number">0</span>, dfs(root.right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//和全局最大值判断</span></span><br><span class="line">        max = Math.max(max, (root.val + max_left + max_right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只能返回一条路径的最大值</span></span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(max_left, max_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证二叉搜索树">98 验证二叉搜索树</h3>
<p><strong>题目描述</strong></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>二叉搜索树的特点就是中序遍历是有序的，因此肯定是中序遍历，然后只要验证前一个节点是否小于等于当前节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历判断是否大于前一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int pre = Integer.MIN_VALUE; 不可以定义这个值！！有这个用例</span></span><br><span class="line">    TreeNode pre; <span class="comment">//前一个结点，全局的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) <span class="comment">//遍历左子树，为true表明左子树满足二叉搜索树条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val) <span class="comment">//当前节点是否大于前继节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pre = root; <span class="comment">//将前继节点记录为当前节点</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.right)) <span class="comment">//遍历右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//都满足条件，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的完全性检验">958 二叉树的完全性检验</h3>
<p>题目描述</p>
<p>验证一棵二叉树是否是完全二叉树</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>层序遍历，把一颗树的节点（包括空节点）按层序遍历排成一行，当且仅当存在两个相邻节点：前一个为null，后一个不为null时，才不是完全二叉树。</p>
<blockquote>
<pre><code>   1
  / \
 2   3
/ \   \</code></pre>
<p>4 5 6 层序遍历序列为：[1, 2, 3, 4, 5, null, 6]，其中 null 出现在了6前面，所以不合法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录前驱节点</span></span><br><span class="line">        TreeNode prev = root;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span> &amp;&amp; node != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/solution/hen-jian-dan-de-si-lu-dai-ma-hen-jian-ji-by-yuanyb/ （二叉树的完全性检验）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 链表</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>剑指Offer中关于链表的题目解析。</p>
<a id="more"></a>
<h3 id="两个链表的第一个公共节点">01 两个链表的第一个公共节点</h3>
<p><strong>题目描述</strong></p>
<p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(m+n\)</span>)：m，n分别为链表A，B的长度，最坏情况下，公共结点为最后一个，需要遍历m+n个结点。 空间复杂度：O(1)。</p>
<p>公共节点，定义为两个链表从某一节点开始，他们的next都指向同一个节点。由于是单向链表的节点，每个节点只有一个next，因此从第一个公共节点开始，之后他们的所有节点都是重合的，不可能再出现分叉。</p>
<p>所以可以先遍历两个链表得到他们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，<strong>在较长的链表上先走若干步</strong>，接着同时在两个链表上遍历，找到的第一个相同的结点就是他们的第一个公共结点。</p>
<p>一个巧妙的实现方式为如果A指针把链表A走完了，然后再从链表B开始走到相遇点就相当于把这两个链表的所有节点都走了一遍，同理如果B指针把链表B走完了，然后再从链表A开始一直走到相遇点也相当于把这两个链表的所有节点都走完了。这样它们的长度就是一致的，且同时会在相遇点结束。本质上同上述方法一样，代码实现更简单。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/0.png" style="zoom: 90%;"></p>
<p>注意当两个链表没有公共节点时候的死循环问题。（第一种解法就不会存在）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //当他们指向空指针的时候，有两种情况。</span></span><br><span class="line"><span class="comment">            其一是某个指针先走完了，此时应该换一个链表走。（只有一个指向null）</span></span><br><span class="line"><span class="comment">            其二是两个指针都走完了，链表没有任何公共节点，都指向null，这时它们是相等的，可以退出循环。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(p1 != p2)&#123; </span><br><span class="line">                <span class="keyword">if</span>(p1 == <span class="keyword">null</span>) p1 = pHead2;</span><br><span class="line">                <span class="keyword">if</span>(p2 == <span class="keyword">null</span>) p2 = pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            也可以写成这样，这样就已经先判断p1 != p2 ，此时如果还等于null，则就可以交换链表继续遍历</span></span><br><span class="line"><span class="comment">            p1= p1!=null? p1.next:pHead2;</span></span><br><span class="line"><span class="comment">            p2= p2!=null? p2.next:pHead1;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p1; <span class="comment">//若不存在公共节点，则返回null</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表双指针">02 反转链表（双指针）</h3>
<p><strong>题目描述</strong></p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(1)：</p>
<p>使用三个指针来调整指针的位置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode left = <span class="keyword">null</span>;<span class="comment">//指向前一个节点</span></span><br><span class="line">        ListNode right = head;<span class="comment">//指向当前节点</span></span><br><span class="line">        ListNode tmp;<span class="comment">//记录当前节点下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123; <span class="comment">//注意这里是right ！= null 而不是 right.next != null</span></span><br><span class="line">            tmp = right.next;<span class="comment">//记录下一个节点位置</span></span><br><span class="line">            right.next = left;<span class="comment">//调整指向下一个位置的指针</span></span><br><span class="line">            left = right;</span><br><span class="line">            right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">//注意返回的是left节点，因为此时right为null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从尾到头打印链表递归">03 从尾到头打印链表（递归）</h3>
<p><strong>题目描述</strong></p>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;67,0,24,58&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[58,24,0,67]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(<span class="math inline">\(n\)</span>)：递归栈内同时存储所有节点</p>
<p>可以采用递归解法。</p>
<p>递归终止条件为：当node == null时，表明到达链表最底端，什么都不做直接返回。</p>
<p>如何递归：先递归到最底端，然后向 ArrayList 添加值，再一层层返回不断添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        recur(listNode);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;        </span><br><span class="line">        recur(node.next);        </span><br><span class="line">        res.add(node.val);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种更直接、简单的解法是反转链表，然后打印，这样空间复杂度是O(1)，因为栈内不需要存储递归结果。但是这样的缺点就是会改变原来的链表状态，不符合某些题意。</p>
<h3 id="删除链表中重复的结点虚拟头">04 删除链表中重复的结点（虚拟头）</h3>
<p><strong>题目描述</strong></p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,3,4,4,5&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,5&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(<span class="math inline">\(1\)</span>)：不使用额外存储空间</p>
<p>双指针解法。首先创建一个<strong>虚拟的头节点</strong>。</p>
<p>left指向当前节点，right不停判断和right.next是否相等，并作出反应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建虚拟头节点</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        vhead.next = pHead;</span><br><span class="line">        </span><br><span class="line">        ListNode left = vhead;</span><br><span class="line">        ListNode right = vhead.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//处理right处有重复值的情况</span></span><br><span class="line">            <span class="keyword">if</span>(right.next != <span class="keyword">null</span> &amp;&amp; right.val == right.next.val)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(right.next != <span class="keyword">null</span> &amp;&amp; right.val == right.next.val) right = right.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">                left.next = right;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = left.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vhead.next; <span class="comment">//为null则说明链表中节点全部重复</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个排序链表虚拟头递归">05 合并两个排序链表（虚拟头|递归）</h3>
<p><strong>题目描述</strong></p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,3,5&#125;,&#123;2,4,6&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(m+n\)</span>)：分别遍历两个链表 空间复杂度O(<span class="math inline">\(1\)</span>)：不使用额外存储空间</p>
<p>一个直观的方法就是建立一个虚拟头节点，然后分别遍历两个链表加入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//新建虚拟头</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode res = vhead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当两个链表都没有到末尾</span></span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val )&#123;</span><br><span class="line">                vhead.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                vhead.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            vhead = vhead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将还有剩的链表直接赋值</span></span><br><span class="line">        vhead.next = list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(<span class="math inline">\(m+n\)</span>)：</p>
<p><span class="math inline">\(m、n\)</span>为两个链表的元素个数。递归函数每次去掉一个元素，直到两个链表都为空，因此需要调用 <span class="math inline">\(R=O(m + n)\)</span> 次。而在递归函数中我们只进行了 next 指针的赋值操作，复杂度为 <span class="math inline">\(\mathcal{O}(1)\)</span>，故递归的总时间复杂度为 <span class="math inline">\({\mathcal{O}(T) = R * \mathcal{O}(1)}={\mathcal{O}}(m + n)\)</span>。</p>
<p>空间复杂度O(<span class="math inline">\(m+n\)</span>)：</p>
<p>对于递归调用，当它遇到终止条件准备回溯时，已经递归调用了 m+n 次，使用了 m+n 个栈帧，故最后的空间复杂度为 <span class="math inline">\({\mathcal{O}}(m + n)\)</span>。</p>
<p>递归法。</p>
<p>递归的终止条件是：当两个链表都为空时，表示对链表已合并完成。</p>
<p>递归的过程是：判断 <code>l1</code> 和 <code>l2</code> 头结点哪个更小，然后较小结点的 <code>next</code> 指针指向<strong>其余结点的合并结果。（调用递归）</strong></p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/1.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">            list1.next = Merge(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1; <span class="comment">//注意这里要return给上一轮提供结果！</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2; <span class="comment">//注意这里要return给上一轮提供结果！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中倒数第k个结点快慢">06 链表中倒数第k个结点（快慢）</h3>
<p><strong>题目描述</strong></p>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,&#123;1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;5&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(<span class="math inline">\(1\)</span>)：不使用额外存储空间</p>
<p>快慢指针解法。先让快指针走k步，然后快慢指针同时走1步，当快指针达到终点null时，慢指针刚好指向该数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ListNode slow, fast = head; 这样写会导致slow没赋值</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先让快指针多走k</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span>) <span class="comment">//提前达到null说明链表不足k</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;            </span><br><span class="line">            fast = fast.next; <span class="comment">//刚好在第k步时走到null是不会有影响的</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//快慢各走1</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回慢指针</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中环的入口结点快慢">07 链表中环的入口结点（快慢）</h3>
<p><strong>题目描述</strong></p>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：线性复杂度，快慢指针走的步数与链表的长度有关 空间复杂度O(<span class="math inline">\(1\)</span>)：使用常数的额外空间</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/2.png" style="zoom: 50%;"></p>
<p>1、双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；</p>
<ul>
<li><p>第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；</p></li>
<li><p>第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：设链表共有 <code>a+b</code> 个节点，其中链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4, b=5）；设两指针分别走了 f，s 步，则有： <strong>fast 走的步数是slow步数的 2 倍，即 f = 2s；</strong>（解析： fast 每轮走 2 步） <strong>fast 比 slow多走了 n 个环的长度，即 f = s + nb；</strong>（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）； <strong>以上两式相减得：f = 2nb，s = nb，即fast和slow 指针分别走了 2n，n 个 环的周长</strong>（注意： n 是未知数，不同链表的情况不同）。</p></li>
</ul>
<p>2、目前情况分析：</p>
<ul>
<li>如果让指针从链表头部一直向前走并统计步数k，那么<strong>所有 走到链表入口节点时的步数 是：<code>k=a+nb</code></strong>（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。</li>
<li>而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。</li>
<li>但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。</li>
</ul>
<p>3、双指针第二次相遇：</p>
<ul>
<li>slow指针位置不变 ，将fast指针重新指向链表头部节点 ；slow和fast同时每轮向前走 1 步；此时 f = 0，s = nb ；</li>
<li>当 fast 指针走到f = a步时，slow 指针走到步s = a+nb，<strong>此时 两指针重合，并同时指向链表环入口</strong> 。</li>
</ul>
<p>4、返回slow指针指向的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode slow = pHead, fast = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)</span><br><span class="line">                fast = fast.next.next; <span class="comment">//走两步</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//没有环</span></span><br><span class="line">            &#125;            </span><br><span class="line">            slow = slow.next;                </span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast); <span class="comment">//先执行一次后判断，因为刚开始时是相等的</span></span><br><span class="line">        </span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂链表的复制">08 复杂链表的复制</h3>
<p>题目描述</p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：两次遍历链表进行复制 空间复杂度O(<span class="math inline">\(n\)</span>)：使用额外存储空间HashMap存储所有节点</p>
<p>使用哈希表，key是原链表中的元素，value是新链表中的new 出来的元素，key-value对中的node.val是相同的。</p>
<p>第一次遍历，构建这个哈希表。第二次遍历，构建新链表中的random指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashMap&lt; RandomListNode, RandomListNode&gt; hm = <span class="keyword">new</span> HashMap&lt; RandomListNode, RandomListNode&gt;();</span><br><span class="line">        </span><br><span class="line">        RandomListNode tmp = pHead;</span><br><span class="line">        <span class="comment">//第一次遍历</span></span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            hm.put( tmp, <span class="keyword">new</span> RandomListNode(tmp.label));</span><br><span class="line">            tmp =tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二次遍历</span></span><br><span class="line">        tmp = pHead;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//分别构建新链表中每个元素的next和random，注意为null的情况</span></span><br><span class="line">            hm.get(tmp).next = tmp.next == <span class="keyword">null</span>? <span class="keyword">null</span> : hm.get(tmp.next);</span><br><span class="line">            hm.get(tmp).random = tmp.random == <span class="keyword">null</span>? <span class="keyword">null</span> : hm.get(tmp.random);</span><br><span class="line">            tmp =tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hm.get(pHead);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种解法是构建，原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。最后将其拆开即可，这样空间复杂度为O(1)，因为不会使用额外的空间HashMap。</p>
<h3 id="题解来源">题解来源</h3>
<p>两个链表的第一个公共节点：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/ji-he-shuang-zhi-zhen-deng-3chong-jie-jue-fang-shi/</p>
<p>https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tab=answerKey</p>
<p>合并两个排序链表：https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/</p>
<p>环形链表：https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/</p>
<p>复杂链表的复制：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 树</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/</url>
    <content><![CDATA[<p>剑指Offer中关于树的题目解析。</p>
<a id="more"></a>
<h3 id="树的深度">01 树的深度</h3>
<p><strong>题目描述</strong></p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,#,6,#,#,7&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，计算树的深度需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下（当树平衡时），退化为链表，系统中同时存储 <span class="math inline">\(n/2\)</span>个节点。</p>
<p>分治法，为 max( 头结点左子树的最大深度, 头结点右子树的最大深度)+1。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/0.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(TreeDepth(root.left), TreeDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的镜像">02 二叉树的镜像</h3>
<p><strong>题目描述</strong></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，计算树的深度需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p>递归法，根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        TreeNode temp = root.left;  </span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        </span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡二叉树">03 平衡二叉树</h3>
<p>题目描述</p>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6,7&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，计算树的深度需要遍历所有节点。注意这里因为使用了提前阻断法，只要有任何子树不满足条件即可返回。否则，时间复杂度变为O(<span class="math inline">\(nlogn\)</span>)，判断每个节点的最大高度 depth(root) 需要遍历 各子树的所有节点 ，子树的节点数的复杂度为O(<span class="math inline">\(logn\)</span>)。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p>递归法，判断左右子树的高度差是否超过1即可，每次递归时返回的是最大子树的高度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//空树也是平衡的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> IsBalanced(root) == -<span class="number">1</span>? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IsBalanced</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如某个子树的高度不满足条件则立刻返回</span></span><br><span class="line">        <span class="keyword">int</span> left = IsBalanced(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right = IsBalanced(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right)+<span class="number">1</span>; <span class="comment">//返回的是最大子树的高度+1</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把二叉树打印成多行">04 把二叉树打印成多行</h3>
<p>题目描述</p>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[8],[6,10],[5,7,9,11]]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，广度优先搜索需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下，当二叉树是平衡的时候，最多有<span class="math inline">\(n/2\)</span>个节点同时在队列中。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/2.png" style="zoom:67%;"></p>
<p>二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。BFS 通常借助 队列 的先入先出特性来实现。队列中存储树的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储结果的ArrayList</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="comment">//利用队列数据结构（先进先出）来实现广度优先搜索</span></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">// Queue是个接口，不能实例化，用多态</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将根节点加入队列</span></span><br><span class="line">        que.add(pRoot);</span><br><span class="line">        <span class="comment">//当队列中有元素的时候</span></span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录这一层有多少个元素</span></span><br><span class="line">            <span class="keyword">int</span> quesize = que.size();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//弹出这一层的元素加入结果ArrayList，并将每个元素的左右子树加入队列Queue</span></span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            TreeNode tempnode;</span><br><span class="line">            <span class="keyword">while</span>(quesize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//弹出结果</span></span><br><span class="line">                tempnode = que.remove();</span><br><span class="line">                temp.add(tempnode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//左右子树加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(tempnode.left != <span class="keyword">null</span>)</span><br><span class="line">                	que.add(tempnode.left);</span><br><span class="line">                <span class="keyword">if</span>(tempnode.right != <span class="keyword">null</span>)</span><br><span class="line">                	que.add(tempnode.right);</span><br><span class="line">                              </span><br><span class="line">                quesize--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.add(temp);</span><br><span class="line">                            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对称的二叉树">05 对称的二叉树</h3>
<p>题目描述</p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,6,5,7,7,5&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，判断镜像需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为O(<span class="math inline">\(n\)</span>)。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/3.png" style="zoom:67%;"></p>
<p>判断二叉树是否对称</p>
<p>若 root == null, 直接返回 true；</p>
<p>否则，判断 root.left 与 root.right 这两棵子树是否对称：</p>
<p>​ 判断 root.left 与 root.right 这两个节点的值是否相等</p>
<p>​ 判断 root.left 的左子树与 root.right 的右子树是否对称。（递归）</p>
<p>​ 判断 root.left 的右子树与 root.right 的左子树是否对称。（递归）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSym(pRoot.left, pRoot.right); <span class="comment">//判断左右子树是否是镜像</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSym</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树都是空的</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树有一个是空的</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树不是空的，判断是否相等，相等返回true</span></span><br><span class="line">        <span class="comment">//left的左子树与right的右子树；left的右子树与right的右子树；是否相等</span></span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; isSym(left.left, right.right) &amp;&amp; isSym(left.right, right.left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的下一个结点">06 二叉树的下一个结点</h3>
<p><strong>题目描述</strong></p>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><strong>题解</strong></p>
<p>首先理解中序遍历，即按左根右顺序遍历。那么当前节点即为根节点，它只有两种情况，其一就是往右子树遍历，其二就是往父节点遍历。</p>
<p>当它存在右子树的时候，那么对右子树按照左根右的顺序，找到最左节点即可。</p>
<p>当它不存在右子树的时候，它只可能是父节点的左子节点或右子节点，此时向上遍历。</p>
<p>​ 若父节点为空，则到达根节点，找不到，已经完成遍历，直接返回。</p>
<p>​ 它是父节点的左子节点，左根右，则父节点为下一个节点。</p>
<p>​ 它是父节点的右子节点，左根右，继续向上遍历（直到满足它是父节点的左子节点）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存在右子树</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找到右子树的最左子树</span></span><br><span class="line">            TreeLinkNode tmp = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                tmp = tmp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//不存在右子树，此时向上遍历</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//父节点为空直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(pNode.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//它是左子节点</span></span><br><span class="line">                <span class="keyword">if</span>(pNode == pNode.next.left)</span><br><span class="line">                    <span class="keyword">return</span> pNode.next; <span class="comment">//返回其父节点作为下一个要遍历的节点</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//它是右子节点，继续向上遍历</span></span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                                                                       </span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从上往下打印二叉树bfs">07 从上往下打印二叉树（BFS）</h3>
<p>题目描述</p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;5,4,#,3,#,2,#,1&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>直接采用BFS广度优先搜索，用队列（先进先出）的数据结构实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            TreeNode tmp = que.remove();</span><br><span class="line">            res.add(tmp.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                que.add(tmp.left);</span><br><span class="line">            <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                que.add(tmp.right);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中和为某一值的路径前序遍历">08 二叉树中和为某一值的路径（前序遍历）</h3>
<p><strong>题目描述</strong></p>
<p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;10,5,12,4,7&#125;,22</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[10,5,7],[10,12]]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，判断深度需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下，退化为链表，最深处刚好满足路径和，同时存储<span class="math inline">\(n\)</span>个节点。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/4.png" style="zoom:67%;"></p>
<p>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 先序遍历 + 路径记录 两部分。</p>
<p>先序遍历： 按照 “根、左、右” 的顺序，遍历树的所有节点。 路径记录： 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 且 ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。</p>
<p>没说一定是正数，所以需要遍历完叶子节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两个全局变量，一个存储最终结果，一个时递归时的暂存变量</span></span><br><span class="line">    <span class="comment">//注意list中存储的是节点内的值，而非节点本身</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        Find(root, target);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        target = target - root.val;</span><br><span class="line">        tmp.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123; <span class="comment">//到达根节点</span></span><br><span class="line">            result.add( <span class="keyword">new</span> ArrayList&lt;&gt;(tmp) ); <span class="comment">//注意新建一个数组，&lt;&gt;泛型处填空   </span></span><br><span class="line">        &#125;</span><br><span class="line">                    </span><br><span class="line">        Find(root.left, target);<span class="comment">//继续遍历左子树</span></span><br><span class="line">        Find(root.right, target);<span class="comment">//继续遍历右子树</span></span><br><span class="line">        </span><br><span class="line">        tmp.remove(tmp.size() - <span class="number">1</span>);<span class="comment">//删除新加入的节点，返回上一层</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重建二叉树">09 重建二叉树</h3>
<p>题目描述</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,5,3,4,6,7&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中 <span class="math inline">\(n\)</span> 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(<span class="math inline">\(n\)</span>)。递归共建立 <span class="math inline">\(n\)</span>个节点，每层递归中的节点建立、搜索操作占用 O(1)，因此使用 O(<span class="math inline">\(n\)</span>)时间。 空间复杂度 O(<span class="math inline">\(n\)</span>)： HashMap 使用O(<span class="math inline">\(n\)</span>) 额外空间。最差情况下，树退化为链表，递归深度达到 <span class="math inline">\(n\)</span>，占用 O(N)O(N) 额外空间；最好情况下，树为满二叉树，递归深度为 <span class="math inline">\(logn\)</span>，占用 O(<span class="math inline">\(logn\)</span>) 额外空间。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/5.png" style="zoom:67%;"></p>
<p>前序遍历性质： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序。 中序遍历性质： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序。</p>
<p>例如：</p>
<p>前序遍历划分 [ 3 | 9 | 20 15 7 ] 中序遍历划分 [ 9 | 3 | 15 20 7 ] 根据以上性质，可得出以下推论：</p>
<p>前序遍历的首元素 为 树的根节点 node 的值。 在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。<strong>可得到左右子树的节点数量。</strong> 根据中序遍历中的左 / 右子树的节点数量，<strong>可将前序遍历划分为</strong> [ 根节点 | 左子树 | 右子树 ] 。</p>
<p>只要知道前序数组的根节点的下标。范围可以通过中序数组获得左右子树长度。</p>
<p>只要知道中序数组的范围。根节点下标可以通过值查找。</p>
<p>本质上就是<strong>根据前序遍历去构建一棵树</strong>，不断地在前序数组和中序数组中查找对应的值。</p>
<p>该方法只能解决<strong>无重复节点值</strong>的二叉树，否则中序数组无法划分左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先定义两个全局变量</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="comment">//查找中序遍历数组下标</span></span><br><span class="line">    <span class="keyword">int</span>[] gpre;<span class="comment">//前序数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对两个全局变量初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">            hm.put(in[i], i);</span><br><span class="line">        gpre = pre;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 传入根节点在前序数组中的下标，以及中序数组的范围；按照前序遍历的方式构建一棵树</span></span><br><span class="line">        <span class="keyword">return</span> reCons( <span class="number">0</span>, <span class="number">0</span>, in.length-<span class="number">1</span>); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序递归遍历建树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reCons</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> in_h, <span class="keyword">int</span> in_t)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(in_h &gt; in_t)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构建当前节点</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(gpre[root]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rindex = hm.get(gpre[root]);</span><br><span class="line">        node.left = reCons( root+<span class="number">1</span>, in_h, rindex-<span class="number">1</span>); <span class="comment">//左子树根节点在前序数组中的下标，中序数组范围</span></span><br><span class="line">        node.right = reCons( root+(rindex - in_h)+<span class="number">1</span>, rindex+<span class="number">1</span>, in_t); </span><br><span class="line">        <span class="comment">//右子树根节点在在前序数组中的下标，对应中序数组范围</span></span><br><span class="line">        <span class="comment">//右子树根节点下标 = 当前节点前序数组下标 + 左子树节点数量 + 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的后序遍历序列">10 二叉树的后序遍历序列</h3>
<p><strong>题目描述</strong></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,8,6,12,16,14,10]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n^2\)</span>)： 递归占用O(<span class="math inline">\(n\)</span>)，最差情况下，树退化为链表，每次递归中的循环都需要遍历所有节点O(<span class="math inline">\(n\)</span>)。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下，退化为链表，递归深度达到<span class="math inline">\(n\)</span>。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/6.png" style="zoom: 50%;"></p>
<p>后序遍历定义： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。 二叉搜索树定义： 左子树中所有节点的值 &lt;&lt; 根节点的值；右子树中所有节点的值 &gt;&gt; 根节点的值；其左、右子树也分别为二叉搜索树。</p>
<p>BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] gsequence;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        gsequence = sequence;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Verify(<span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Verify</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="comment">//注意这里是大于等于，等于表明这里只有一个数，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root = gsequence[right];</span><br><span class="line">        <span class="keyword">int</span> tmp = left;</span><br><span class="line">        <span class="keyword">for</span>(; tmp&lt;=right-<span class="number">1</span>; tmp++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gsequence[tmp]&gt;root)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = tmp; i &lt;= right-<span class="number">1</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(gsequence[i]&lt;root)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Verify( left, tmp-<span class="number">1</span>) &amp;&amp; Verify( tmp, right-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的子结构双重dfs">11 树的子结构（双重DFS）</h3>
<p><strong>题目描述</strong></p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,8,#,9,#,2,#,5&#125;,&#123;8,9,#,2&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(mn\)</span>)： <span class="math inline">\(m、n\)</span>分别是树A、B的节点数量。</p>
<p>空间复杂度 O(<span class="math inline">\(m\)</span>)： 最差情况下，两棵树都退化为链表，递归深度达到最大。当<span class="math inline">\(m\leq n\)</span>时，遍历树A与递归判断的总深度为<span class="math inline">\(m\)</span>；当<span class="math inline">\(m&gt;n\)</span>时，最差情况为遍历至树A的叶子节点，总的递归深度为<span class="math inline">\(m\)</span>。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/7.png" style="zoom: 67%;"></p>
<p>对A树DFS，如果B的根节点与A中某个节点值相同，那么以B为树根进行DFS，判断即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recurA( root1, root2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recurA</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//树1遍历完成都没有找到和树2相等的节点</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="comment">//遍历B</span></span><br><span class="line">            <span class="keyword">if</span>(recurB( root1, root2)) <span class="comment">//遍历树2时判定是子结构，即可直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recurA(root1.left, root2) || recurA(root1.right, root2); <span class="comment">//遍历树1的左右子树</span></span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recurB</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果树2为空，说明树2已经遍历完成，无论树1是否为空，都已经说明了树2是树1的子树</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//到这里就变成了树2不为空，树1为空时说明树1已经遍历完了，树2超过了树1，不是子树</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个都不为空的时候，若值相等即可继续遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> recurB(root1.left, root2.left) &amp;&amp; recurB(root1.right, root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的第k个结点">12 二叉搜索树的第k个结点</h3>
<p>题目描述</p>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;5,3,7,2,4,6,8&#125;,3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;4&#125;</span><br></pre></td></tr></table></figure>
<p>说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按结点数值大小顺序第三小结点的值为4 </span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），无论 k 的值大小，递归深度都为<span class="math inline">\(n\)</span>。 空间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），系统使用O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p>二叉搜索树按照中序遍历的结果，就是数组排序后的结果。</p>
<p>若是求解第k大，则按照右根左顺序遍历即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">//注意使用一个全局变量计数，只有前序遍历时可以直接操作k，否则中序遍历时前序k改变后传不到中序</span></span><br><span class="line">    TreeNode res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        count = k;</span><br><span class="line">        InRecur( pRoot, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InRecur</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || count &lt;=<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        InRecur(pRoot.left);</span><br><span class="line">        </span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            res = pRoot;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        InRecur(pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按之字形顺序打印二叉树">13 按之字形顺序打印二叉树</h3>
<p>题目描述</p>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[8],[10,6],[5,7,9,11]]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>使用Collections.revers方法将ArrayList在偶数行的时候反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        que.add(pRoot);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpSize = <span class="number">0</span>;</span><br><span class="line">        TreeNode tmp;</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            tmpSize = que.size();</span><br><span class="line">            ArrayList&lt;Integer&gt;  tmpAl = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//打印当前队列中的元素</span></span><br><span class="line">            <span class="keyword">while</span>(tmpSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                tmp = que.remove();</span><br><span class="line">                tmpAl.add(tmp.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmp.right);</span><br><span class="line">                </span><br><span class="line">                tmpSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从右往左</span></span><br><span class="line">            <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                Collections.reverse(tmpAl);</span><br><span class="line">            res.add(tmpAl);</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用LinkedList双端队列的性质。若要从右往左打印，则不断往双端队列头部增加元素，则最开始进入的元素会在最末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        TreeNode tmpNode;</span><br><span class="line">        que.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            LinkedList&lt;Integer&gt; tmpLl = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = que.size(); i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">                </span><br><span class="line">                tmpNode = que.remove();</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    tmpLl.addLast(tmpNode.val);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmpLl.addFirst(tmpNode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(tmpNode.left != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span>(tmpNode.right != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmpNode.right);</span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(tmpLl));</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化二叉树">14 序列化二叉树</h3>
<p>题目描述</p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 # 表示空节点，以 , 分隔各个节点。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//序列化，直接前序遍历</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root.val + <span class="string">&quot;,&quot;</span> + Serialize(root.left) + <span class="string">&quot;,&quot;</span> + Serialize(root.right);     </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反序列化，用一个全局index记录下标</span></span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String [] strs = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        index++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先判断下标是否越界，越界直接返回null表明已经超过数组，是最后的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt;= strs.length) <span class="comment">//注意是数组的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//然后判断当前值是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(strs[index].equals(<span class="string">&quot;#&quot;</span>)) <span class="comment">//要用equals比较字符串</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不是叶子节点就按照前序遍历法继续递归</span></span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[index])); <span class="comment">//将字符转为数字</span></span><br><span class="line">            node.left = Deserialize(str);</span><br><span class="line">            node.right = Deserialize(str);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">       </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树与双向链表">15 二叉搜索树与双向链表</h3>
<p><strong>题目描述</strong> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），递归深度都为<span class="math inline">\(n\)</span>。 空间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），系统使用O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/8.png" style="zoom: 50%;"></p>
<p>二叉搜索树的中序遍历结果，即为排序的链表。然后，需要设置一个全局节点pre，保存前一个节点的位置，并在当前根节点处，调整指针的指向。</p>
<p>同时，需要设置一个头节点head保存链表头节点的位置，如何知道头节点的位置？当pre为null时，即为头节点的位置。</p>
<p>如何知道尾节点的位置？当中序遍历完成后，pre指向的位置为尾节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        Recur(pRootOfTree);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后修改头节点和尾节点的指向（牛客网上不要修改，leetcode上要）</span></span><br><span class="line"><span class="comment">//         pre.right = head;</span></span><br><span class="line"><span class="comment">//         head.left = pre;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Recur</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        Recur(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;<span class="comment">//当前节点是链表头节点</span></span><br><span class="line">            head = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = pre;</span><br><span class="line">        pre = root;<span class="comment">//变更前驱节点</span></span><br><span class="line">        </span><br><span class="line">        Recur(root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>树的深度：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/solution/mian-shi-ti-55-i-er-cha-shu-de-shen-du-xian-xu-bia/ 二叉树的镜像：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/solution/mian-shi-ti-27-er-cha-shu-de-jing-xiang-di-gui-fu-/</p>
<p>平衡二叉树：https://leetcode-cn.com/problems/balanced-binary-tree/solution/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/</p>
<p>把二叉树打印成多行：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/</p>
<p>对称的二叉树：https://leetcode-cn.com/problems/symmetric-tree/solution/hua-jie-suan-fa-101-dui-cheng-er-cha-shu-by-guanpe/</p>
<p>https://leetcode-cn.com/problems/symmetric-tree/solution/di-gui-die-dai-bi-xu-miao-dong-by-sweetiee/</p>
<p>二叉树中和为某一值的路径：https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/</p>
<p>重建二叉树：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/</p>
<p>二叉树的后序遍历序列：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</p>
<p>树的子结构：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</p>
<p>序列化二叉树：https://blog.nowcoder.net/n/daadc4221f77479f968a9347af2a8380?f=comment</p>
<p>二叉搜索树与双向链表：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 数组</title>
    <url>/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>剑指Offer中关于数组的题目解析。</p>
<a id="more"></a>
<h3 id="斐波那契数列">01 斐波那契数列</h3>
<p><strong>题目描述</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>斐波那契额数字的规律为，当<span class="math inline">\(n\geq2\)</span>时，<span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span></p>
<p><strong>方法一：递归法</strong></p>
<p>时间复杂度：O(<span class="math inline">\(2^n\)</span>) 空间复杂度：递归栈的空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>)+Fibonacci(n-<span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归法会产生大量的重复计算：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/0.png" style="zoom:50%;"></p>
<p><strong>方法二：存储法</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(<span class="math inline">\(1\)</span>)</p>
<p>每次仅用到了最近的两个数，所以可以只存储最近的两个数</p>
<p>sum 存储第 n 项的值，one 存储第 n-1 项的值，two 存储第 n-2 项的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            sum = one + two;</span><br><span class="line">            two = one;</span><br><span class="line">            one = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中出现次数超过一半的数字">02 数组中出现次数超过一半的数字</h3>
<p><strong>题目描述</strong> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,2,2,2,5,4,2]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p>若某个数字出现的次数超过数组长度的一半，则它可以<strong>抵消掉</strong>所有剩下的数字。</p>
<p>用一个变量记录数字，一个变量记录它出现的次数。当次数被其他数字抵消为0时，即可更换新的数字。那么最后变量中存储的数字，可能满足条件也可能不满足，因此需要检验它的次数是否超过数组长度的一半。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不断抵消</span></span><br><span class="line">        <span class="keyword">int</span> num = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;array.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">                    num = array[i];</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                </span><br><span class="line">                <span class="keyword">if</span>(array[i] == num)&#123;</span><br><span class="line">                	cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">            	&#125;                </span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//统计次数</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == num)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//超过一半则为满足条件的数字</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;array.length/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建乘积数组">03 构建乘积数组</h3>
<p><strong>题目描述</strong></p>
<p>给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]<em>A[1]...A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] </em> A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）</p>
<p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[120,60,40,30,24]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/1.png" style="zoom: 50%;"></p>
<p>先计算下三角，再计算上三角。下三角从上往下，下三角从下往上。因为按照这个顺序时，可以发现前一个值上多乘一个数就是后一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(A.length&lt;=<span class="number">1</span> || A==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下三角</span></span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.length; i++)</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上三角，用一个数纪录累乘结果</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">//i=0时，即B[0]也是要计算的</span></span><br><span class="line">            tmp = tmp*A[i+<span class="number">1</span>];</span><br><span class="line">            B[i] = B[i]*tmp;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">		<span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字在排序数组中出现的次数">04 数字在排序数组中出现的次数</h3>
<p><strong>题目描述</strong></p>
<p>统计一个数字在升序数组中出现的次数。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,3,3,3,4,5],3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(logn\)</span>) 空间复杂度：O(1)</p>
<p>使用二分法分别找到 左边界left和右边界right，易得数字target的数量为 right - left - 1。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/2.png" style="zoom: 67%;"></p>
<ol type="1">
<li>初始化： 左边界 i = 0，右边界 j = len(nums) - 1。</li>
<li>循环二分： 当闭区间 [i, j] 无元素时跳出（不满足i<span class="math inline">\(\leq\)</span>j时）；
<ol type="1">
<li>计算中点 m = (i + j) / 2（向下取整）；</li>
<li>若 nums[m] &lt; target ，则 target在闭区间 [m + 1, j] 中，因此执行 i = m + 1；</li>
<li>若 target &lt; nums[m] ，则 target在闭区间 [i, m - 1] 中，因此执行 j = m - 1;</li>
<li>若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；左边界 left 在闭区间 [i, m-1] 中。因此分为以下两种情况：
<ol type="1">
<li>若查找 右边界 right ，则执行 i = m + 1，可以并入nums[m] &lt; target的情况 ；（跳出时 i 指向右边界）</li>
<li>若查找 左边界 left ，则执行 j = m - 1，可以并入target &lt; nums[m] 的情况 ；（跳出时 j 指向左边界）</li>
</ol></li>
</ol></li>
<li>返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right - left - 1 即可。</li>
</ol>
<p>注意到，如果不存在target的时候，right就是最接近target的那个比target大的数，left亦然。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//寻找右边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&lt;=k)&#123; <span class="comment">//这里是将(nums[m] &lt; target) 和 (nums[m] == target &amp;&amp; 探寻右边界) 的情况合并在一起</span></span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rbound = i;</span><br><span class="line">        <span class="comment">//此时i指向右边界，j指向最右边的target</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//寻找左边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&lt;k)&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lbound = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rbound - lbound - <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种简化代码的方式就是只寻找右边界。</p>
<h3 id="和为s的两个数字">05 和为S的两个数字</h3>
<p><strong>题目描述</strong></p>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>返回值描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,4,7,11,15],15</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,11]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> small = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> large = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = Integer.MAX_VALUE; <span class="comment">//判断两数的乘积</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[left]+array[right]&lt;sum)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[left]+array[right]&gt;sum)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(array[left]*array[right]&lt;tmp)&#123;</span><br><span class="line">                    small = array[left];</span><br><span class="line">                    large = array[right];</span><br><span class="line">                    tmp = small*large;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                      </span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(tmp != Integer.MAX_VALUE)&#123;</span><br><span class="line">            res.add(small);</span><br><span class="line">            res.add(large);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中重复的数字">06 数组中重复的数字</h3>
<p><strong>题目描述</strong></p>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p>返回描述：</p>
<p>如果数组中有重复的数字，函数返回true，否则返回false。</p>
<p>如果数组中有重复的数字，把重复的数字放到参数duplication[0]中。（ps:duplication已经初始化，可以直接赋值使用。）</p>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>)：可以设想把交换数字、查找数字解耦，分开看。在此方法下，每访问数组的一个单元格 nums[i] ，就可以把一个数字填到属于它的位置；因此， 将 n 个数字填到正确的位置最多需要 N 次操作，复杂度为 O(N) 。而搜索重复数字的条件是 <code>nums[nums[i]] == nums[i]</code> ，找到这样的数字只需要遍历一遍数组，复杂度为 O(N)。这里只是将两个步骤合在一起写了。 空间复杂度：O(1)</p>
<p>原地交换</p>
<p><strong>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内</strong> 。 此说明含义：数组元素的 索引和 值 是 一对多 的关系。 因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/3.png" style="zoom:67%;"></p>
<p>nums[i]为当前遍历到的数组中的数字，它分为如下三种情况：</p>
<p>若 nums[i] = i： 说明此数字已在对应索引位置，无需交换，因此跳过； 若 nums[nums[i]] = nums[i]： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找到一组重复值，返回此值 nums[i]； 否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。</p>
<p>注意，每遍历到一个位置，都要交换到数组中的数字和下标相同为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发现数组中的值，和要交换的目标相同，即发现重复</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[ numbers[i] ])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前遍历到的数字交换到它所对应的下标上</span></span><br><span class="line">            <span class="keyword">int</span> tmp = numbers[numbers[i]];</span><br><span class="line">            numbers[numbers[i]] = numbers[i];</span><br><span class="line">            numbers[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找">07 二维数组中的查找</h3>
<p><strong>题目描述</strong></p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p>将矩阵旋转后可以发现类似二叉搜索树，根节点为左下角或右上角，选左下角较为方便。暴力遍历二维矩阵的复杂度为O(<span class="math inline">\(mn\)</span>)。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/4.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//令根节点为左下角</span></span><br><span class="line">        <span class="keyword">int</span> row = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( row &gt;= <span class="number">0</span> &amp;&amp; col &lt; array[<span class="number">0</span>].length )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[row][col] &lt; target)&#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[row][col] &gt; target)&#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整数组顺序使奇数位于偶数前面">08 调整数组顺序使奇数位于偶数前面</h3>
<p>题目描述</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(n^2\)</span>) 空间复杂度：O(1)</p>
<p>插入排序思想，从前往后遍历，不断地挪动位置来使得相对位置保持不变。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/5.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//基数继续移动，偶数停止移动</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; array.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">//偶数继续移动，基数停止移动</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找不到基数则可以停止</span></span><br><span class="line">            <span class="keyword">if</span>(j == array.length)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//此时将a[j]插入到a[i]的位置，即把基数插入到前面</span></span><br><span class="line">            <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j-<span class="number">1</span>; k&gt;=i ; k--)&#123;</span><br><span class="line">                array[k+<span class="number">1</span>] = array[k];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i] = tmp;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(<span class="math inline">\(n^2\)</span>) 空间复杂度：O(1)</p>
<p>冒泡排序思想，即每次将一个偶数交换到最后一个位置，同样可以保持相对顺序不变，冒泡排序稍微快一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123; <span class="comment">//第一个循环只是用来表明有几个数被交换了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123; <span class="comment">// -i是因为已经将i个偶数交换到最后了</span></span><br><span class="line">                <span class="keyword">if</span>(array[j]%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; array[j+<span class="number">1</span>]%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺时针打印矩阵">09 顺时针打印矩阵</h3>
<p>题目描述</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[1,2,3],[4,5,6],[7,8,9]][[1,2],[3,4]]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(mn\)</span>) 空间复杂度：O(1)</p>
<p>时间复杂度为遍历矩阵。直接模拟遍历，主要是设置四个边界，并将边界往中间缩减。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/6.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义边界</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在四个方向上移动</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 左右移动，在上边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r; j++) res.add( matrix[t][j] );</span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>; <span class="comment">//++t&gt;b 等价于先给t自增1 ，再判断。这里非常巧妙地避免了重复打印，又缩小边界</span></span><br><span class="line">            <span class="comment">// 上下移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j &lt;= b; j++) res.add( matrix[j][r] );</span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 右左移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = r; j &gt;= l; j--) res.add( matrix[b][j] );</span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 下上移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = b; j &gt;= t; j--) res.add( matrix[j][l] );</span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把数组排成最小的数">10 把数组排成最小的数</h3>
<p><strong>题目描述</strong></p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,32,321]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;321323&quot;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(nlogn\)</span>) 空间复杂度：O(<span class="math inline">\(n\)</span>)</p>
<p>自定义排序规则，将所有数字转为字符串（空间复杂度），若<code>a+b &lt; b+a</code>，为了使得组合数字尽可能小，因此得到规则<code>a&lt;b</code>，将a尽可能放到前面（排序，时间复杂度）。</p>
<p>Java中的compareto方法，返回参与比较的前后a、b两个字符串的asc码的差值，负数则说明a&lt;b。</p>
<p>Java编译器对String做了特殊处理，使得可以直接用+拼接字符串。在循环拼接字符串的过程中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转成字符串</span></span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(numbers[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义排序规则并排序</span></span><br><span class="line">        Arrays.sort(strs, (x,y)-&gt; (x+y).compareTo((y+x)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; numbers.length; i++)</span><br><span class="line">            res.append(strs[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="机器人的运动范围">11 机器人的运动范围</h3>
<p><strong>题目描述</strong></p>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5,10,10</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(mn\)</span>) 遍历整个矩阵计算是否可达 空间复杂度：O(<span class="math inline">\(mn\)</span>) 记录是否已经到达过</p>
<p>由于机器人从(0,0)开始走，因此可以只向右走和向下走，就能遍历到矩阵的所有元素，不会漏掉。</p>
<p>求数位和的方法就是不断地取模10，累加余数。</p>
<p>Java中布尔型(boolean)变量默认值为false。</p>
<p>采用DFS方法，回溯地遍历整个整个矩阵。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义求数位和的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x !=<span class="number">0</span> )&#123;</span><br><span class="line">            res = res + x % <span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">return</span> dfs(rows, cols, threshold, visited, <span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> threshold, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>( x &gt;= rows || y &gt;= cols || visited[x][y] || sums(x) + sums(y) &gt; threshold ) <span class="comment">//注意先判断是否越界，否则visited可能会导致数组越界异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归遍历</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(rows, cols, threshold, visited, x, y+<span class="number">1</span>) + dfs(rows, cols, threshold, visited, x+<span class="number">1</span>, y);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的逆序对">12 数组中的逆序对</h3>
<p><strong>题目描述</strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>对于50%的数据,<span class="math inline">\(size\leq 10^4\)</span> 对于75%的数据,<span class="math inline">\(size\leq 10^5\)</span> 对于100%的数据,<span class="math inline">\(size\leq 2*10^5\)</span></p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,0]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(nlogn\)</span>) 空间复杂度：O(<span class="math inline">\(n\)</span>)</p>
<p>利用归并排序的思想，在两个有序数组的归并过程中，统计逆序对的数量。这样就将蛮力法两次循环的复杂度（<span class="math inline">\(O(n^2)\)</span>），降低为归并排序的复杂度。</p>
<p>假设我们有两个已排序的序列等待合并，分别是$ L = { 8, 12, 16, 22, 100 }<span class="math inline">\(和\)</span>R={9,26,55,64,91}<span class="math inline">\(。一开始我们用指针\)</span>lPtr = 0<span class="math inline">\(指向\)</span>L<span class="math inline">\(的首部，\)</span>rPtr = 0$ 指向<span class="math inline">\(R\)</span>的头部。记已经合并好的部分为 M。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; []</span><br><span class="line">     |                          |</span><br><span class="line">   lPtr                       rPtr</span><br></pre></td></tr></table></figure>
<p>lPtr 指向的元素小于 rPtr 指向的元素，于是把 lPtr 指向的元素放入辅助数组，并把 lPtr 后移一位。这个时候把左边的 8 加入了辅助数组，可以发现发现右边没有数比 8 小，所以 8 对逆序对总数的「贡献」为 0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>
<p>接着继续合并，把 9 加入了辅助数组，此时 lPtr 指向 12，rPtr 指向 26。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8, 9]</span><br><span class="line">        |                          |</span><br><span class="line">       lPtr                       rPtr</span><br></pre></td></tr></table></figure>
<p>然后，继续合并，将左边的12加入辅助数组。此时 lPtr 比 rPtr 小，把 lPtr 对应的数加入答案，并考虑它对逆序对总数的贡献为 rPtr 相对 R 首位置的偏移 1（即右边只有一个数比 12 小，所以只有它和 12 构成逆序对），以此类推。</p>
<p>用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，只在 lPtr 右移的时候计算，当前 lPtr 指向的数字比 rPtr 小，但是比 R 中 [0 ... rPtr - 1] 的其他数字大，[0 ... rPtr - 1] 的其他数字本应当排在 lPtr 对应数字的左边，但是它排在了右边，所以这里就贡献了 rPtr 个逆序对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">//全局变量记录结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span> || array == <span class="keyword">null</span> || left == right) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//此时左右数组皆为有序</span></span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right) &#123;</span><br><span class="line">            </span><br><span class="line">            result = array[l]&lt;array[r]? (result+r-(mid+<span class="number">1</span>))%<span class="number">1000000007</span> : result; <span class="comment">//左指针数字更小，则发生判断表明右边产生逆序对，即右指针的偏移量</span></span><br><span class="line">            help[p++] = array[l]&lt;array[r]? array[l++] : array[r++]; <span class="comment">//进行排序，将小的数字放入辅助数组</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缺点就在这个位置</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid)&#123; </span><br><span class="line">            result = (result + right-mid)%<span class="number">1000000007</span>;</span><br><span class="line">            help[p++] = array[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right) help[p++] = array[r++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将辅助数组的值复制到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;help.length; i++)</span><br><span class="line">            array[left+i] = help[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到，统计右边数组的偏移量时，假如右边数组先偏移完成，会导致左边数组每次偏移的时候都要统计一遍，因为此时左数组中的每个值都比右数组大，因此左边数组剩下的每一个数都可以和右边数组产生逆序对。</p>
<p>因此做出如下改动，当右数组的值小于左数组的时候，将右数组的值加入辅助数组，左数组剩余的个数即为逆序对个数，因为此时左数组中剩余的数都可以和当前右数组的数构成逆序对。</p>
<p><strong>即当左数组偏移的时候，表明左数组的数小，不和右数组构成逆序对。当右数组偏移的时候，表明右数组的数小，左数组剩余的数每个都可以和当前右数组的值构成逆序对。因此，不会产生遗漏。</strong></p>
<p>例如此时，12比9大，因此将9加入辅助数组，此时可以发现，左数组中剩余的每个数，都可以和当前右数组中的值9构成逆序对，因此发生统计行为。所以此时是右数组发生偏移的时候，才产生统计操作，而非左数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>
<p>接着继续合并，把 9 加入了辅助数组，此时 lPtr 指向 12，rPtr 指向 26。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">//全局变量记录结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span> || array == <span class="keyword">null</span> || left == right) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//此时左右数组皆为有序</span></span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[l] &lt;= array[r])&#123;</span><br><span class="line">                help[p++] = array[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//右数组的数小，左数组每个剩余的数都可以和当前右数组数构成逆序对</span></span><br><span class="line">                result = (result + mid-l+<span class="number">1</span>)%<span class="number">1000000007</span>;</span><br><span class="line">                help[p++] = array[r++];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid) help[p++] = array[l++];   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right) help[p++] = array[r++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将辅助数组的值复制到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;help.length; i++)</span><br><span class="line">            array[left+i] = help[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最快的方法是不要每次都新开数组help，直接在一开始就开辟一个同样长度的数组，然后每次都在这个数组上进行操作。</p>
<h3 id="旋转数组的最小数字">013 旋转数组的最小数字</h3>
<p><strong>题目描述</strong></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,4,5,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(logn\)</span>)：二分法的复杂度，当数组中的数字全部相同时退化为O(<span class="math inline">\(n\)</span>) 空间复杂度O(1)：</p>
<p>排序数组的查找问题，首先想到二分法。旋转后数组可以分为两部分，前半部分比后半部分都要大，因此每次二分时有如下情况：</p>
<p>1、mid &gt; high，比后半部分数组大的情况，说明mid现在在前半部分数组中，要找的最小数字应该在mid之后，low = mid + 1。</p>
<p>2、mid &lt; high， 比后半部分数组小的情况，说明mid现在在后半部分数组中，要找的最小数字应该在mid之前，high = mid。注意！这里不是high = mid -1，因为要找的最小数字可能是mid！</p>
<p>3、当mid = high，无法判断mid所在位置，将high--缩小范围。</p>
<p>直到 low == high时，找到最小的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt; array[high])</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; array[high])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连续子数组的最大和">014 连续子数组的最大和</h3>
<p>题目描述</p>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,-2,3,10,-4,7,2,-5]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历一遍数组 空间复杂度O(<span class="math inline">\(n\)</span>)：使用辅助数组，或者直接在原数组上修改也可</p>
<p>首先，注意是<strong>连续子数组</strong>。</p>
<p>使用一维数组动态规划的方法，dp[i]代表以元素 array[i] 为结尾的连续子数组最大和。</p>
<p>讨论，dp[i]和dp[i-1]的关系，假如dp[i-1]为负数或者0，说明dp[i-1]对dp[i]没有产生贡献，即dp[i-1]+array[i]还不如array[i]本身要大。<strong>此时连续子数组的开头变更为array[i]</strong>。</p>
<p>因此，注意dp[array.length -1]，即到最后一个元素时，<strong>以最后一个元素为结尾的连续子数组最大和并不一定是最大的</strong>！可能是前面的某个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= array.length-<span class="number">1</span>; i++)&#123;            </span><br><span class="line">            dp[i] = Math.max( array[i], array[i]+dp[i-<span class="number">1</span>] );</span><br><span class="line">            max = Math.max( max, dp[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中只出现一次的数字及2">015 数组中只出现一次的数字（及2）</h3>
<p>题目描述</p>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历两遍数组 空间复杂度O(1)：不使用额外空间</p>
<p>异或运算：相同为0，不同为1</p>
<p>异或运算拥有如下性质：</p>
<p>任何数和0异或，仍为本身：a⊕0 = a 任何数和本身异或，为0：a⊕a = 0 异或运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b</p>
<p>则可以知道，当<strong>任何数出现两次之后，其异或值都为0，即可以消去</strong>。假如将数组中的所有数都异或，则剩下那两个只出现一次的数的异或结果，这是<strong>由异或的交换律和结合律</strong>决定的：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/7.png" style="zoom:33%;"></p>
<p>当得到两个数的异或结果时，由异或不同位置为1的计算可以知道，<strong>这两个数在有1的位置上，肯定是有一个是1，有一个是0</strong> 。那么，<strong>将剩余的数按照这个位置分成两组，两组内分别异或</strong>之后就可以消去出现两次的数，则分别只剩下只出现一次的数。</p>
<p>问题1：如何找到异或结果中为1的位置？</p>
<p>x &amp; (-x) 来保留最右边的 1。</p>
<p>一个数（x）的负数（-x），其二进制表示为反码+1（~x+1）。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/8.png" style="zoom: 43%;"></p>
<p>某个数最右边的1，反码之后为0，加1肯定是这个位置变成1（因为它是最右边，或者进位），因此x &amp; (-x) 的运算结果就是二进制下保留最右边的 1，其余位置皆为0。</p>
<p>问题2：如何将剩余的数按照某个位置分成组？</p>
<p>x &amp; 010 即可对 x 进行分组。</p>
<p>因为只有一位为1，因此&amp;就运算结果为0的就分为一组，不为0的就可以分为另一组。</p>
<p>最后，初始化两个变量为0，分别和不同分组的数做异或运算即可（初始化为0利用了a⊕0 = a的性质）。</p>
<p>因此，整个算法流程如下：</p>
<p>1、所有数做异或运算，得到仅出现一次的两个数的异或结果。</p>
<p>2、x &amp; (-x) 来保留异或结果最右边的 1</p>
<p>3、利用&amp;操作对数字进行分组，再次对所有数进行异或，即可得到两个结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//得到仅出现一次的两个数的异或结果</span></span><br><span class="line">        <span class="keyword">int</span> xorall = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)</span><br><span class="line">            xorall = xorall ^ i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//x &amp; (-x) 来保留异或结果最右边的 1</span></span><br><span class="line">        <span class="keyword">int</span> split = xorall &amp; (-xorall);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//利用&amp;操作对数字进行分组，并再次对所有数进行异或</span></span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>; num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)&#123;      </span><br><span class="line">            <span class="keyword">if</span>((i&amp;split) == <span class="number">0</span>)</span><br><span class="line">            	num1[<span class="number">0</span>] = num1[<span class="number">0</span>] ^ i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] = num2[<span class="number">0</span>] ^ i;         </span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目描述</strong></p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>输入: [2,2,3,2] 输出: 3</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(32n\)</span>)：整数二进制一共有32位，每一位都要遍历一遍数组，统计1的个数 空间复杂度O(1)：不使用额外空间</p>
<p>由于出现多次的数字变成了奇数，因此不能用异或进行消去。转为二进制<strong>考虑数组中所有数字，转为二进制后，每一位上面1个个数和</strong>：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/9.png" style="zoom:43%;"></p>
<p>如果其他数都出现 3 次，只有目标数出现 1 次，那么每一位的 1 的个数无非有这2种情况，为 3 的倍数（全为出现三次的数） 或 3 的倍数 +1（包含出现一次的数）。这个 3 的倍数 +1 的情况也就是我们的目标数的那一位。</p>
<p>因此算法首先将结果初始化为0，然后统计每一位上1的个数，并将%3!=0的位置修改为1。</p>
<p><strong>&lt;&lt;</strong> 左移动运算符：运算数的各二进位全部左移若干位，高位丢弃，低位补0。（将二进制的1挪动到需要的位置上）</p>
<p><strong>&gt;&gt;</strong> 右移动运算符：运算数的各二进位全部右移若干位，低位丢弃，高位补0。（判断每位的1的个数时，移动到该位置）</p>
<p>a &amp; 1：a &amp; 1 中 1 只有最后一位为 1，其余位皆为 0 ，因此 a &amp; 1的作用就是判断 a 的最后一位是否为 1。（判断每位的1的个数）</p>
<p>a | 1：只要对应的二个二进制位有一个为1时，结果位就为1。（将结果的某个位置修改为1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">              <span class="comment">//先将数右移，并求出最后一位为 1 的个数</span></span><br><span class="line">              <span class="comment">//比如 0 3 4，就会先判断4，再到3，再到0</span></span><br><span class="line">              <span class="keyword">if</span> ((nums[j] &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;             </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到某一位取余为 1 的数，把1左移到那个位置，再和结果取或，就可以把对应位置修改为1</span></span><br><span class="line">          <span class="keyword">if</span> (count % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">              res = <span class="number">1</span> &lt;&lt; i | res;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和为s的连续正数序列">016 和为s的连续正数序列</h3>
<p><strong>题目描述</strong></p>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<p>输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：</p>
<p>输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：最多循环n次（left和right都到达n/2） 空间复杂度O(1)：不使用额外空间</p>
<p>注意到题目中所说的连续序列，则联想到滑动窗口。</p>
<p>滑动窗口可以看成<strong>数组中框起来的一个部分</strong>。滑动窗口一般表示成一个<strong>左闭右开区间</strong>。在一开始，i=1, j=1，滑动窗口位于序列的最左侧，窗口大小为零。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/10.png" style="zoom:50%;"></p>
<p>则可以知道每次判断滑动窗口内数字的和，根据和的大小来判断左右端点的变化。</p>
<ul>
<li>当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li>
<li>当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li>
<li>当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i, j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动。</li>
</ul>
<p>左端点最多只能到target/2处，它加上后面的任何一个数都已经比target要大了。</p>
<p><strong>实际上，把题目中的正整数序列换成任意的递增整数序列，滑动窗口方法都可以解。</strong></p>
<p>滑动窗口的重要性质是：窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">       </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;<span class="comment">//注意右边是开区间，不能取到这个数</span></span><br><span class="line">        <span class="keyword">int</span> tmpsum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= sum/<span class="number">2</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tmpsum &lt; sum)&#123; <span class="comment">//扩展窗口右边界，增大tmpsum</span></span><br><span class="line">                tmpsum = tmpsum + right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &gt; sum)&#123; <span class="comment">//扩展窗口左边界，减小tmpsum</span></span><br><span class="line">                tmpsum = tmpsum - left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//记录结果</span></span><br><span class="line">                ArrayList&lt;Integer&gt; tmpres = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++)</span><br><span class="line">                    tmpres.add(i);</span><br><span class="line">                res.add(tmpres);</span><br><span class="line">                </span><br><span class="line">                tmpsum = tmpsum - left;<span class="comment">//扩展窗口左边界，减小tmpsum</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>数字在排序数组中出现的次数：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/</p>
<p>数组中重复的数字：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/</p>
<p>二维数组中的查找：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/</p>
<p>调整数组顺序使奇数位于偶数前面：牛客Ariser.cn</p>
<p>顺时针打印矩阵：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/</p>
<p>机器人的运动范围：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/jian-zhi-offerer-shua-javadfs-bfs-tu-jie-py05/</p>
<p>数组中的逆序对：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</p>
<p>旋转数组的最小数字：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</p>
<p>连续子数组的最大和：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</p>
<p>数组中只出现一次的数字（及2）：https://leetcode-cn.com/problems/single-number/solution/dong-hua-dong-tu-yi-ding-hui-by-yuan-chu-vs4p/</p>
<p>和为s的连续正数序列：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 字符串</title>
    <url>/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>剑指Offer中关于字符串的题目解析。</p>
<a id="more"></a>
<h3 id="左旋转字符串">01 左旋转字符串</h3>
<p>题目描述</p>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;abcXYZdef&quot;,3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;XYZdefabc&quot;</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中<span class="math inline">\(n\)</span>为字符串<span class="math inline">\(s\)</span>的长度，字符串切片函数为线性时间复杂度 空间复杂度 O(<span class="math inline">\(n\)</span>)： 两个字符串切片的总长度为<span class="math inline">\(n\)</span></p>
<p>字符串切片：新建两切片字符串，并将两切片拼接为结果字符串，无冗余操作，效率最高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当n超过数组长度时，对n取模使得分割下标位于数组长度以内</span></span><br><span class="line">        <span class="keyword">int</span> sub_index = n % str.length() ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意切片时不包括末尾的下标</span></span><br><span class="line">        <span class="keyword">return</span> str.substring(sub_index, str.length())+str.substring(<span class="number">0</span>, sub_index); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>列表遍历拼接：先把后面的字符加入StringBuilder，再将前面的字符加入。列表(Python) 和 StringBuilder(Java) 都是可变对象，每轮遍历拼接字符时，只是向列表尾部添加一个新的字符元素。最终拼接转化为字符串时，系统 仅申请一次内存 。</p>
<p>字符串遍历拼接：也是先把后面的字符加入，但是用的是字符串拼接。string + string，在 Python 和 Java 中，字符串是 “不可变对象” 。因此，每轮遍历拼接字符时，都需要新建一个字符串；因此，系统 需申请 n 次内存 ，数据量较大时效率低下。</p>
<h3 id="反转单词序列">02 反转单词序列</h3>
<p>题目描述</p>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;nowcoder. a am I&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;I am a nowcoder.&quot;</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中<span class="math inline">\(n\)</span>为字符串<span class="math inline">\(s\)</span>的长度。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 因为给定的是不可变的String，因此需要额外开辟空间存储。</p>
<p>每个字母的顺序并没有反转，仅反转单词顺序。可以采用先反转每个单词，再将整个句子反转的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] cha = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= cha.length; i++)&#123; <span class="comment">//注意这里有个等号，用来处理最后一个单词</span></span><br><span class="line">            <span class="keyword">if</span>( i == cha.length || cha[i] == <span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">//注意这个位置，先判断是不是超过数组，否则cha[i]会发生越界</span></span><br><span class="line">                Reverse(cha, j, i-<span class="number">1</span>);</span><br><span class="line">                j = i+<span class="number">1</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        Reverse(cha, <span class="number">0</span>, cha.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        不可以用toString！！！</span></span><br><span class="line"><span class="comment">        一般类的toString()方法返回的是该类所在的地址值。</span></span><br><span class="line"><span class="comment">        而由于String类和Integer类已经重写了toString()方法，所以输出的是类对象中存储的内容</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(cha); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将一段数组内的字符全部反转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> [] str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            Swap(str, left++, right--);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> [] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = str[i];</span><br><span class="line">        str[i] = str[j];</span><br><span class="line">        str[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符流中第一个不重复的字符-及其位置">03 字符流中第一个不重复的字符 （及其位置）</h3>
<p><strong>题目描述</strong></p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。</p>
<p>返回值描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果当前字符流没有存在出现一次的字符，返回#字符。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong>：</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中<span class="math inline">\(n\)</span>为字符串<span class="math inline">\(s\)</span>的长度，遍历字符流和有序哈希表的复杂度是<span class="math inline">\(O(n)\)</span>，有序哈希表的查找操作是<span class="math inline">\(O(1)\)</span>，哈希表的插入操作复杂度是？？？？； 空间复杂度 O(<span class="math inline">\(1\)</span>)： 由于题目中指出的是字符流，LinkedHashMap 中字符的个数是有限的256个</p>
<p>Java 使用 LinkedHashMap 实现<strong>有序哈希表</strong>。有序哈希表中的<strong>键值对是按照插入顺序排序的</strong>。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为1的字符”。</p>
<p>LinkedHashMap中put方法参数为key和value，表示插入key与value。如果key存在，则旧值被替换。containsKey方法表示是否含有该key，含有则返回true。（本题中，含有则表示字符之前已经出现过了）</p>
<p>使用哈希表的本质原因是为了给每个字符进行统计。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Character, Boolean&gt; res = <span class="keyword">new</span> LinkedHashMap&lt;Character, Boolean&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.put(ch, res.containsKey(ch)); <span class="comment">//如果首次加入，则不包含该值，会返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//遍历有序哈希表，就是元素加入的顺序，找到第一个为false的即可</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d: res.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(d.getValue() == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">return</span> d.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种简单的方式是用HashMap的值储存元素出现的次数，遍历两次字符串即可，但是这样的问题是当字符串很长且前面有很多重复元素时，时间效率低下。</p>
<p><strong>第一个只出现一次的字符位置</strong></p>
<p><strong>题目描述</strong></p>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;google&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历两次字符数组的复杂度是<span class="math inline">\(O(n)\)</span>，有序哈希表的查找操作是<span class="math inline">\(O(1)\)</span> 空间复杂度 O(<span class="math inline">\(1\)</span>)： 由于题目中指出的是字符流，HashMap中字符的个数是有限的256个</p>
<p>若要求取位置，则就用HashMap，并且采用两次遍历的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Character, Boolean&gt; hm = <span class="keyword">new</span> HashMap&lt;Character, Boolean&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> [] array = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : array)&#123;</span><br><span class="line">            hm.put(c, hm.containsKey(c)); <span class="comment">//首次加入时因为没有而是false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hm.get(array[i]) == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="替换空格">04 替换空格</h3>
<p><strong>题目描述</strong> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历统计和遍历修改的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(1\)</span>)： 由于是原地扩展字符串的长度，因此使用<span class="math inline">\(O(1)\)</span>额外空间。</p>
<p>一种简单的思路是构建StringBuilder，然后遇到空格就添加%20，但是这样会额外使用O(<span class="math inline">\(n\)</span>)的空间，因此考虑直接在原字符串（StringBuffer类型，直接String类型则无法修改）上进行修改。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/0.png" style="zoom:67%;"></p>
<p>具体做法就是先统计空格的数量，然后增加原字符串的长度，并用双指针从后往前移动字符。因为后指针每次遇到空格都会比前指针多走，所以当两个指针相遇时，即表示前面已经无空格，可停止算法。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png" style="zoom:45%;"></p>
<p>Java中StringBuffer类型有方法setLength()、setCharAt()、toString()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">//统计空格数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//增加StringBuffer长度</span></span><br><span class="line">        <span class="keyword">int</span> ol = str.length();</span><br><span class="line">        <span class="keyword">int</span> nl = ol+count*<span class="number">2</span>;</span><br><span class="line">        str.setLength(nl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//双指针移动</span></span><br><span class="line">        <span class="keyword">int</span> left = ol - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nl - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果是空格，则right处填充符号</span></span><br><span class="line">            <span class="keyword">if</span>(str.charAt(left) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                str.setCharAt(right - <span class="number">2</span>, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                str.setCharAt(right - <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                str.setCharAt(right, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                right = right - <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//不是空格，则移动left处数值</span></span><br><span class="line">                str.setCharAt(right, str.charAt(left)); </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            left--;</span><br><span class="line">            right--;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表示数值的字符串">05 表示数值的字符串</h3>
<p><strong>题目描述</strong></p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;123.45e+6&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;1.2.3&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历字符串的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(1\)</span>)： 使用<span class="math inline">\(O(1)\)</span>额外空间。</p>
<p>表示数值的字符串可以分为A.B<strong>e</strong>C或A.B<strong>E</strong>C。整数部分为A，小数部分为B，指数部分为C，按顺序判断是否包含这三部分。如果符合条件，则指针可以指向字符串的末尾。</p>
<p>使用全局index遍历字符串。</p>
<p>scanInteger扫描有符号整数，用来匹配A和C部分。</p>
<p>scanUnsignedInteger扫描无符号整数，用来匹配B部分。</p>
<p>每次匹配元素时，都要判断下标是否发生越界，此问题可以用加入终止符号来解决，但是本例是数组，因此只能每次判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局下标</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//scanUnsignedInteger扫描无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> before = index; <span class="comment">//判断指针是否移动，成功移动才说明匹配成功       </span></span><br><span class="line">        <span class="keyword">while</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; (str[index]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; str[index]&lt;=<span class="string">&#x27;9&#x27;</span>) )</span><br><span class="line">            index++;        </span><br><span class="line">        <span class="keyword">return</span> index &gt; before;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//scanInteger扫描有符号整数（可能有也可能没有正负号）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; (str[index] == <span class="string">&#x27;+&#x27;</span> || str[index] == <span class="string">&#x27;-&#x27;</span>)) </span><br><span class="line">            index++;       </span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始匹配整个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">boolean</span> res;</span><br><span class="line">               </span><br><span class="line">        <span class="comment">//首先匹配A</span></span><br><span class="line">        res = scanInteger(str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如存在小数点</span></span><br><span class="line">        <span class="comment">//如果是a.xx这种，则index停留在非数值处，不会进入小数点匹配</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; str[index]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            index++; <span class="comment">//匹配小数点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*+.5、5.、.5都是可行的，即 scanInteger.scanUnsignedInteger 即为合法</span></span><br><span class="line"><span class="comment">             ||只要满足第一个条件，后面的条件就不再判断</span></span><br><span class="line"><span class="comment">             若为 res || scanUnsignedInteger(str) 则只要scanInteger部分为true则不再判断，这不可行，因为要判断</span></span><br><span class="line"><span class="comment">             小数点后是否存在非数字，如1.a</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            res = scanUnsignedInteger(str) || res;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如存在科学计数法e或E</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; (str[index] == <span class="string">&#x27;e&#x27;</span> || str[index] == <span class="string">&#x27;E&#x27;</span>))&#123;</span><br><span class="line">            </span><br><span class="line">            index++;</span><br><span class="line">            res = res &amp;&amp; scanInteger(str) ; <span class="comment">//&amp;&amp;只要第一个条件不满足，后面条件就不再判断，这里相当于提前返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指针成功移动到末尾则表明符合判断</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        需要res，比如12e，当进入有e时执行scanInteger(str)会返回false，因为没有数字没有发生移动</span></span><br><span class="line"><span class="comment">        但此时指针依然指向最后一位，所以不能光靠是否移动到结尾判断</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> (index == str.length ) &amp;&amp; res == <span class="keyword">true</span> ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种解法为有限状态自动机，正则表达式的内部实现即为有限状态自动机，不用正则表达式则需手动实现各种状态的转换。</p>
<h3 id="扑克牌顺子">06 扑克牌顺子</h3>
<p><strong>题目描述</strong></p>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历数组的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(n\)</span>)： 使用<span class="math inline">\(O(n)\)</span>额外空间，额外使用数据结构HashSet来保证无重复。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/2.png" style="zoom: 67%;"></p>
<p>顺子即不能出现重复的数字，并且顺子中最大值减去最小值的差距小于5。</p>
<p>Java中Set数据结构不允许出现重复元素，不保证集合中元素出现的顺序。</p>
<p>Set是一个接口，实例化Set可以采用HashSet， HashSet类按照哈希算法来存取集合中的对象，存取速度比较快 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先判断元素个数</span></span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length != <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用集合去重</span></span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">14</span>; <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//跳过0，因为0可以重复</span></span><br><span class="line">            min = Math.min(min, numbers[i]);</span><br><span class="line">            max = Math.max(max, numbers[i]);</span><br><span class="line">            <span class="keyword">if</span>(res.contains(numbers[i])) <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            res.add(numbers[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用空间复杂度低，时间复杂度高的方法，就是先排序，然后遍历数组的同时判断是否有重复，并记录最大最小值。</p>
<h3 id="把字符串转换成整数">07 把字符串转换成整数</h3>
<p><strong>题目描述</strong></p>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历字符串的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(n\)</span>)： 使用<span class="math inline">\(O(1)\)</span>额外空间，即结果处的整数。</p>
<p>首先是整数，因此不存在'.'和'E'、'e'等任何字符，只存在正负号这个特殊字符。</p>
<p>然后就是越界问题，整数的范围是<span class="math inline">\([-2^{31},2^{31}-1]\)</span>，即<span class="math inline">\([-2147483648,2147483647]\)</span>。整数最多只能是十位数，因此只需要判断每次转换一个数字时是否到达边界<span class="math inline">\(bndry = Integer.MAX\_VALUE /10 = 214748364\)</span>，以及该边界处的处理情况。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/3.png" style="zoom:67%;"></p>
<p>注意牛客网中超过该范围时返回的时非法情况，leetcode中则返回最大最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理符号</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">true</span>; <span class="comment">//表示正数</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            index++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            sign = <span class="keyword">false</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历字符串判断边界</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bndry = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt; str.length(); index++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//不是数字立刻返回</span></span><br><span class="line">            <span class="keyword">char</span> ca = str.charAt(index);</span><br><span class="line">            <span class="keyword">if</span>(ca &gt; <span class="string">&#x27;9&#x27;</span> || ca &lt; <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	判断加入该数后是否越界，越界则直接返回 </span></span><br><span class="line"><span class="comment">            	现在是214748364x，判断x，整数位数最多十位，因此在这里就要返回</span></span><br><span class="line"><span class="comment">            	若是 214748363 38，则此刻 res == 214748363 3依然超过bndry，可直接返回</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; bndry) <span class="comment">//这里其实有两种情况，一种是res的长度刚好是9位，另一种刚好是10位，然后判断下一位数字，10位时直接越界，因为还存在第11位</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( res == bndry)&#123;                </span><br><span class="line">                <span class="keyword">if</span>(sign)&#123;<span class="comment">//如果是正数越界直接返回,否则加入该数，到字符串尾部了就会跳出循环，否则下一轮res &gt; bndry越界</span></span><br><span class="line">                    <span class="keyword">if</span>( ca &gt; <span class="string">&#x27;7&#x27;</span> ) <span class="keyword">return</span>  <span class="number">0</span> ;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果是负数</span></span><br><span class="line">                    <span class="keyword">if</span>( ca &gt; <span class="string">&#x27;8&#x27;</span> ) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                            </span><br><span class="line">            <span class="comment">//加入该数</span></span><br><span class="line">            res = res * <span class="number">10</span> + (ca - <span class="string">&#x27;0&#x27;</span>);                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign == <span class="keyword">true</span> ? res : -res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串的排列-子串包含">08 字符串的排列 &amp; 子串包含</h3>
<p>题目描述</p>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;ab&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;ab&quot;,&quot;ba&quot;]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n!\)</span>)：比如3个字符的全排列有6种。 空间复杂度O(1)：原地交换。</p>
<p>字符串的全排列就是序列中的字符不断与后面的字符做交换，通过<strong>递归</strong>进行实现。字典序打印就是排列完成后进行排序即可。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/5.png" style="zoom:50%;"></p>
<p>注意到，假如当前元素和要交换的元素是重复元素时，不进行交换，来节省时间，除非是首个元素自己和自己交换。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/6.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局结果</span></span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> [] cha = str.toCharArray();</span><br><span class="line">        recurPermu(cha, <span class="number">0</span>);       </span><br><span class="line">        Collections.sort(res);<span class="comment">//注意这个sort是不返回东西的</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurPermu</span><span class="params">(<span class="keyword">char</span> [] cha, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(index == cha.length - <span class="number">1</span>) <span class="comment">//只剩最后一个char，不用交换</span></span><br><span class="line">            res.add(<span class="keyword">new</span> String(cha));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; cha.length; i++)&#123; <span class="comment">//将首个char和后面所有元素交换</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                cha[index] != cha[i] 防止重复元素交换浪费时间</span></span><br><span class="line"><span class="comment">                index == i 数组中首个元素必须能够进入进行递归</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span>( cha[index] != cha[i] || index == i  )&#123;</span><br><span class="line">                    swap(cha, index, i);</span><br><span class="line">                    recurPermu(cha, index+<span class="number">1</span>); <span class="comment">//将位置往后移动一个，进行递归交换</span></span><br><span class="line">                    swap(cha, index, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> [] cha, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = cha[i];</span><br><span class="line">        cha[i] = cha[j];</span><br><span class="line">        cha[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目描述</strong></p>
<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>
<p>示例1:</p>
<p>输入: s1 = "ab" s2 = "eidbaooo" 输出: True 解释: s2 包含 s1 的排列之一 ("ba").</p>
<p>注意：</p>
<p>输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(l_1 + 26*(l_2 - l1)\)</span>)： <span class="math inline">\(l_1、l_2\)</span>均为字符串长度，即初始化时间+遍历<span class="math inline">\(l_2\)</span>并判断的时间。 空间复杂度 O(<span class="math inline">\(1\)</span>)： 使用O<span class="math inline">\((1)\)</span>常数级额外空间，因为只有26个字符。</p>
<p>滑动窗口解法。</p>
<p>将排列转换为比较字母出现的次数是否相同。</p>
<p>求s2中是否存在s1的全排列，即窗口大小为s1的长度，在这个窗口长度内，两个字符串是否存在所有字母个数一一对应。</p>
<p>字母从a-z，所以可以使用两个长度为26的int数组来表示出现的个数，即哈希表的长度可以仅维持在26，并且滑动窗口始终维护同一个哈希表，而不是每次移动都要建立一个新的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//因为字符串都是a-z的字母，所以我们可以使用一个长度为26的int数组来存储每个字母出现的个数</span></span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//s2map实际上代表了字符串s2在窗口内所有字母的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="comment">//窗口大小为s1.length，索引从[0 —— s1.length-1]到[s2.length-s1.length —— s2.length-1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果匹配，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果不匹配，窗口向后移动一位</span></span><br><span class="line">            <span class="comment">//窗口加入下一个字母</span></span><br><span class="line">            s2map[s2.charAt(i + s1.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="comment">//窗口移除第一个字母</span></span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matches(s1map, s2map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配">09 正则表达式匹配</h3>
<p><strong>题目描述</strong></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</p>
<p>'.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(mn\)</span>)： 遍历两个字符串的复杂度。 空间复杂度 O(<span class="math inline">\(mn\)</span>)： dp数组的空间。</p>
<p>字符串匹配的题目可以使用动态规划的解法。</p>
<p>s表示string，p表示pattern。</p>
<p><span class="math inline">\(dp[i][j]\)</span> 表示字符串中s中的前i个字符与字符串p中的前j个字符是否能够匹配。因此当p[i-1]和s[i-1]能够发生匹配时，需要判断它们的状态从哪里转移过来，如果不能匹配则直接为false状态。以下情况都是发生匹配时的状态转移，这里假设数组的下标从1开始：</p>
<ul>
<li><p>当 s[i] == p[j] 或 p[j] == '.'时</p>
<p><span class="math inline">\(dp[i][j] = dp[i-1][j-1]\)</span>。</p>
<p>即包括当前两个字符的前i个字符和前j个字符的整个字符串的匹配状态，由前 i-1 个字符和 s 前 j-1 个字符的匹配状态决定，能匹配就匹配，不能匹配就不匹配。</p></li>
<li><p>p[j] == '*'时，有两种情况。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/4.png" style="zoom: 50%;"></p>
<ul>
<li><p>s[i] == p[j-1]（p[j-1] == '.'）</p>
<p>即'*'之前的字符能和当前string中的字符发生匹配。</p>
<p><span class="math inline">\(dp[i][j] = dp[i-1][j]\)</span>。</p>
<p>也是就相当于看string前一个字符和当前pattern中'*'的状态。（这个状态在确认的时候会检查条件s[i-1]和p[j-1]，如此递归下去。）</p>
<p>即使能发生匹配，也可以不使用这个匹配。（因为'*'表明可以是0次）</p>
<p><span class="math inline">\(dp[i][j] = dp[i][j-2]\)</span>。</p>
<p>直接删除'*'及其前一个字符，并检查s[i]和p[j-2]时的匹配情况。</p></li>
<li><p>s[i] != p[j-1]</p>
<p>即'*'之前的字符不能和当前string中的字符发生匹配。</p>
<p><span class="math inline">\(dp[i][j] = dp[i][j-2]\)</span>。</p>
<p>直接删除'*'及其前一个字符，并检查s[i]和p[j-2]时的匹配情况。</p></li>
</ul></li>
</ul>
<p>注意初始化的时候，当string为''时，pattern为'.*'也是可以匹配的，因为'*'可以表示不取。所以此时要单独初始化dp数组中的第一行，初始化的准则是，当dp数组第一行奇数位不管什么字符都是false（包括.，因为.指的是任意字符，必须存在），dp数组中偶数位为* 时则: dp[0][i] = dp[0][i - 2]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s_len = str.length;</span><br><span class="line">        <span class="keyword">int</span> p_len = pattern.length;</span><br><span class="line">        <span class="keyword">boolean</span> [][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s_len+<span class="number">1</span>][p_len+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化动态规划数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理 i = 0， j的情况，即string是空字符，pattern不为空</span></span><br><span class="line">        <span class="comment">//dp数组中奇数位不管什么字符都是false（包括.，因为.指的是任意字符，必须存在），dp数组中偶数位为* 时则: dp[0][i] = dp[0][i - 2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; p_len + <span class="number">1</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( pattern[i-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//双层循环遍历两个字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s_len+<span class="number">1</span>; i++ )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p_len + <span class="number">1</span>; j++ )&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(str[i-<span class="number">1</span>] == pattern[j-<span class="number">1</span>] || pattern[j-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(pattern[j-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;                    </span><br><span class="line">                    <span class="keyword">if</span>(str[i-<span class="number">1</span>] == pattern[j-<span class="number">2</span>] || pattern[j-<span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>];                                                            </span><br><span class="line">                &#125;</span><br><span class="line">                               </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直接返回最后一个位置的情况</span></span><br><span class="line">        <span class="keyword">return</span> dp[s_len][p_len];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>左旋转字符串：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/</p>
<p>字符流中第一个不重复的字符：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/mian-shi-ti-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-3/</p>
<p>替换空格：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/</p>
<p>表示数值的字符串：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/zui-jian-dan-si-lu-xiang-xi-zhu-shi-zheng-shu-xiao/</p>
<p>扑克牌顺子：https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solution/mian-shi-ti-61-bu-ke-pai-zhong-de-shun-zi-ji-he-se/</p>
<p>把字符串转为整数：https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/mian-shi-ti-67-ba-zi-fu-chuan-zhuan-huan-cheng-z-4/</p>
<p>字符串的排列 &amp; 字串：https://leetcode-cn.com/problems/permutation-in-string</p>
<p>https://leetcode-cn.com/problems/permutation-in-string/solution/hua-dong-chuang-kou-by-mu-da-bai-yi-ndu7/</p>
<p>https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/</p>
<p>正则表达式匹配：https://leetcode-cn.com/problems/regular-expression-matching/solution/10-zheng-ze-biao-da-shi-pi-pei-by-ming-zhi-shan-yo/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 堆栈</title>
    <url>/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>剑指Offer中关于堆栈的题目解析。</p>
<a id="more"></a>
<h3 id="用两个栈实现队列">01 用两个栈实现队列</h3>
<p><strong>题目描述</strong> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>题解</strong></p>
<p>Push：</p>
<p>时间复杂度O(<span class="math inline">\(1\)</span>)：stack1每次仅涉及一个元素的操作。</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：stack1中存储<span class="math inline">\(n\)</span>个元素。</p>
<p>Pop：</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：在最坏情况下，stack2 为空，算法需要从 stack1 中弹出 <span class="math inline">\(n\)</span> 个元素，然后再压入stack2中；最好情况下stack2不为空，则复杂度为O(1)。</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：stack2中存储<span class="math inline">\(n\)</span>个元素。</p>
<p>栈，是一种先进后出的数据结构。队列，是一种先进先出的数据结构。</p>
<p>有两个栈stack1和stack2，当队列进入元素时（Push），压入stack1中。</p>
<p>当需要出队时（Pop），若stack2中有元素，则先将stack2中元素弹出，直到为空，再将stack1中元素全部弹出压入stack2中，然后继续弹出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                stack2.push( stack1.pop() );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包含min函数的栈最小栈">02 包含min函数的栈/最小栈</h3>
<p><strong>题目描述</strong> 定义栈的数据结构，请在该类型中实现一个能够获得栈中所含最小元素的min函数（时间复杂度应为O(1)）。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(1)：所有操作的复杂度均为O(1)。</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一共有n个待入栈元素，最差情况下栈中存储所有待入栈元素。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/0.png" style="zoom:67%;"></p>
<p>可通过建立辅助栈实现； 数据栈 A： 栈 A用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。 辅助栈 B： 栈 B中存储栈 A中所有 非严格降序 的元素，则栈 A中的最小元素始终对应栈 B的栈顶元素，即 min() 函数只需返回栈 B的栈顶元素即可。 因此，只需设法维护好 栈 B的元素，使其保持非严格降序，即可实现 min() 函数的 O(1)复杂度。维护则分为push和pop，只有小于等于当前栈顶的才push，只有A pop的元素和栈顶相等才pop。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; master = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; slave = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        master.push(node);</span><br><span class="line">        <span class="keyword">if</span>(slave.size() == <span class="number">0</span>)</span><br><span class="line">            slave.push(node);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(slave.peek() &gt;= node)</span><br><span class="line">                slave.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node = master.pop();</span><br><span class="line">        <span class="keyword">if</span>(node == slave.peek())</span><br><span class="line">            slave.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> master.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> slave.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈的压入弹出序列">03 栈的压入、弹出序列</h3>
<p>题目描述</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5],[4,3,5,1,2]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2<span class="math inline">\(n\)</span> 次出入栈操作。 空间复杂度 O(<span class="math inline">\(n\)</span>) ： 辅助栈 stack 最多同时存储 <span class="math inline">\(n\)</span> 个元素。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/1.png" style="zoom: 50%;"></p>
<p>考虑借用一个辅助栈 stack，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p>
<p>入栈操作： 按照压栈序列的顺序执行。 出栈操作： <strong>每次</strong>入栈后，循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。</p>
<p>若最终能够全部弹出，则表明该弹出序列是满足条件的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//模拟栈</span></span><br><span class="line">        Stack&lt;Integer&gt; sta = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个指针，一个指向压入序列，一个指向弹出序列</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按照压入序列逐个压入</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; pushA.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            sta.push(pushA[i]);</span><br><span class="line">            <span class="comment">//每次压入后都判断是否能够弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!sta.isEmpty() &amp;&amp; sta.peek() == popA[j])&#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最终若能全部弹出则满足条件</span></span><br><span class="line">        <span class="keyword">return</span> sta.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流中的中位数">04 数据流中的中位数</h3>
<p>题目描述 如何得到一个数据流中的中位数？</p>
<p>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(logn\)</span>) ： 优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的。 空间复杂度 O(<span class="math inline">\(n\)</span>) ： 使用了三个辅助空间，其中两个堆的空间复杂度是 O(<span class="math inline">\(n/2\)</span>)， 一个表示数据流元素个数的计数器占用空间O(1)。</p>
<p>一种最容易想到的思路是，数据流新进来一个数，都把它与已经读出来的数进行一次排序，这样中位数就可以很容易得到。这样做不好的地方是：排序的时间复杂度为 O(<span class="math inline">\(nlogn\)</span>)，但事实上，对除了中位数以外的其它位置的元素并不关心。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/2.png" style="zoom:67%;"></p>
<p>通过维护一个大顶堆表示前有序数组，维护一个小顶堆表示后有序数组，解决求取中位数的问题。</p>
<p>堆可以通过java中的优先队列PriorityQueue实现。</p>
<p>注意到，大顶堆堆顶元素必须小于小顶堆堆顶元素，这可以通过先将数据加入大顶堆再加入小顶堆实现。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/3.png" style="zoom: 60%;"></p>
<p>大顶堆存储<span class="math inline">\(n\)</span>个或<span class="math inline">\(n+1\)</span>个数，取决于数据流的总数据量是偶数还是奇数，小顶堆存储<span class="math inline">\(n\)</span>个元素。</p>
<p>每当一个元素到来时，先将其添加到大顶堆，然后取出堆顶元素表示大顶堆中的最大值，加入小顶堆中。</p>
<p>若总数据量是偶数，则两边存储元素数目一样，不做任何操作。</p>
<p>若总数据量是奇数，则大顶堆应该多存储一个值表示中位数，因此将小顶堆堆顶元素取出表示堆中最小值，并加入大顶堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数可以优化成boolean</span></span><br><span class="line">    <span class="comment">//PriorityQueue&lt;Integer&gt; left = new PriorityQueue&lt;Integer&gt;((x, y)-&gt;(y-x)); //左边大顶堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;( <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125; ); <span class="comment">//传入lambda表达式会慢非常多    </span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();<span class="comment">//右边默认小顶堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        left.add(num);</span><br><span class="line">        right.add( left.remove() );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            left.add( right.remove() );</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        奇数情况下，可以先判断num是否大于小顶堆中的最小值，如果大于则需要插入并删除堆顶，</span></span><br><span class="line"><span class="comment">        否则直接插入大顶堆即可，这样就免去了维护小顶堆的时间</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        if(count%2 == 1)&#123;    </span></span><br><span class="line"><span class="comment">            if(right.size()&gt;0 &amp;&amp; num &gt; right.peek() )&#123;</span></span><br><span class="line"><span class="comment">                right.add(num);</span></span><br><span class="line"><span class="comment">                num = right.remove();</span></span><br><span class="line"><span class="comment">            &#125;      </span></span><br><span class="line"><span class="comment">            left.add( num );            </span></span><br><span class="line"><span class="comment">        &#125;else&#123;            </span></span><br><span class="line"><span class="comment">            left.add(num);</span></span><br><span class="line"><span class="comment">            right.add( left.remove() );            </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (left.peek()+right.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)left.peek(); <span class="comment">//注意数据类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口的最大值堆或双端队列">05 滑动窗口的最大值/堆或双端队列</h3>
<p>题目描述</p>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<p>窗口大于数组长度的时候，返回空</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2,3,4,2,6,2,5,1],3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,4,6,6,6,5]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(nlogk\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为数组长度，<span class="math inline">\(logk\)</span>为重建堆的时间复杂度。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 维护窗口中元素的堆。</p>
<p>对滑动窗口中的元素维护一个最大堆。堆通过java中的优先队列PriorityQueue实现。每次窗口移动时，先删除掉窗口上一个元素，然后将新元素加入堆，则堆顶就是窗口元素的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length == <span class="number">0</span> || num.length &lt; size || size == <span class="number">0</span>) <span class="comment">//注意size不能为0</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//声明最大堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;( <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;                 </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用第一个窗口初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">            pq.add(num[j]);</span><br><span class="line">        res.add(pq.peek());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//窗口移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i+size &lt;= num.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            pq.remove(num[i-<span class="number">1</span>]);</span><br><span class="line">            pq.add(num[i+size-<span class="number">1</span>]);</span><br><span class="line">            res.add(pq.peek());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>) ： 只需要遍历一次数组，同时每一个下标恰好被放入队列一次，并且最多被弹出队列一次。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 双端队列中存储的元素。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/4.png"></p>
<p>双端队列，既可以从队头出队，也可以从队尾出队，则不用遵循先进先出的规则。</p>
<p>双端队列中，本质上是维护了窗口中<strong>以最大值为开始的递减序列</strong>。非递减序列中的数值则被删除，不会出现在双端队列中。当窗口移动时，只有那些递减序列中的值才有可能被删除。</p>
<p>整个过程为：</p>
<p>1.想将我们第一个窗口的所有值存入单调双端队列中，单调队列里面的值为单调递减的。如果发现队尾元素小于要加入的元素，则将队尾元素出队，直到队尾元素大于新元素时，再让新元素入队，目的就是维护一个单调递减的队列。</p>
<p>2.我们将第一个窗口的所有值，按照单调队列的规则入队之后，因为队列为单调递减，所以队头元素必为当前窗口的最大值，则将队头元素添加到数组中。</p>
<p>3.移动窗口，<strong>判断当前窗口前的元素是否和队头元素相等，如果相等则出队</strong>。</p>
<p>4.继续然后按照规则进行入队，维护单调递减队列。</p>
<p>5.每次将队头元素存到返回数组里。</p>
<p>最终返回数组。</p>
<p>使用Java中的LinkedList类来实现双端队列，其中有offerFirst()、offerLast()、removeFirst()、removeLast()、peekFirst()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length == <span class="number">0</span> || size == <span class="number">0</span> || size &gt; num.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立一个双端队列</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化双端队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="comment">//当队列中的元素小于当前元素时，出队</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;num[i]) deque.removeLast();</span><br><span class="line">            <span class="comment">//将当前元素加入队列</span></span><br><span class="line">            deque.offerLast(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(deque.peekFirst());<span class="comment">//注意这里也要加入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始滑动窗口,注意此时新加入的元素是num[i+size-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num.length - size; i++ )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断是否要出队列</span></span><br><span class="line">            <span class="keyword">if</span>(num[i-<span class="number">1</span>] == deque.peekFirst()) deque.removeFirst();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当队列中的元素小于当前新加入的元素，出队</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;num[i+size-<span class="number">1</span>]) deque.removeLast();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前元素加入队列</span></span><br><span class="line">            deque.offerLast(num[i+size-<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            res.add(deque.peekFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小的k个数快速选择">06 最小的K个数/快速选择</h3>
<p><strong>题目描述</strong></p>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,5,1,6,2,7,3,8],4</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(nlogk\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为数组长度，每个元素都要进行一次入堆操作，<span class="math inline">\(logk\)</span>为重建堆的时间复杂度。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 维护窗口中元素的堆。</p>
<p>维护一个堆。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/5.png" style="zoom:67%;"></p>
<p>平均时间复杂度 O(<span class="math inline">\(n\)</span>)，最坏情况下为O(<span class="math inline">\(n^2\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为数组长度，时间复杂度根据不同主元的选择而不同。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 维护窗口中元素的堆。</p>
<p>“查找第 k 大的元素”是一类算法问题，称为<strong>选择问题</strong>。找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p>
<p>回顾快速排序的思路。快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边，如下图所示：</p>
<p>这个 partition 操作是原地进行的，需要 O(n)的时间，接下来，快速排序会递归地排序左右两侧的数组。</p>
<p>而快速选择（quick select）算法的不同之处在于，接下来只需要<strong>递归地选择一侧的数组</strong>。快速选择算法想当于一个“<strong>不完全</strong>”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并<strong>不需要知道它们的顺序</strong>。</p>
<p>目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p>
<ul>
<li>若 k=m，我们就找到了最小的 k 个数，就是左侧的数组；</li>
<li>若 k&lt;m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li>
<li>若 k&gt;m，则左侧数组中的 mm 个数都属于最小的 kk 个数，我们还需要在右侧数组中寻找最小的 k-mk−m 个数，对右侧数组递归地 partition 即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传入的全部是数组中的下标，所以传入k-1</span></span><br><span class="line">        recur(input, <span class="number">0</span>, input.length-<span class="number">1</span>, k-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将数组中的值进行复制</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left == right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = input[left];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; input[i] &lt; pivot) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; pivot &lt; input[j]) j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= j)&#123; <span class="comment">//++、--之后可能会不满足i&lt;=j的条件，需要进行判断</span></span><br><span class="line">                swap(input, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断递归条件，这里只会递归左数组或者右数组之一，此时 j+1 = i 或 i == j</span></span><br><span class="line">        <span class="keyword">if</span>( left &lt;= k &amp;&amp; k &lt;= j) recur(input, left, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( i &lt;= k &amp;&amp; k &lt;= right) recur(input, i, right, k);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = input[i];</span><br><span class="line">        input[i] = input[j];</span><br><span class="line">        input[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行划分</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = input.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = input[left];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">//注意这里不能等</span></span><br><span class="line">                                   </span><br><span class="line">            pivot = input[left]; i = left; j = right;</span><br><span class="line">             <span class="keyword">while</span>(i &lt;= j)&#123; <span class="comment">//进行多次交换</span></span><br><span class="line">                <span class="keyword">while</span>(i &lt;= j &amp;&amp; input[i] &lt; pivot) i++;</span><br><span class="line">            	<span class="keyword">while</span>(i &lt;= j &amp;&amp; pivot &lt; input[j] )  j--;           </span><br><span class="line">            	<span class="keyword">if</span>(i &lt;= j)&#123;</span><br><span class="line">                    swap(input, i, j);</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">//判断，并更改left、right的范围</span></span><br><span class="line">            <span class="comment">//注意这里只能if else，不能用if else if把递归的条件照搬（会导致同时满足条件？暂不清楚）</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt;= k-<span class="number">1</span> &amp;&amp; k-<span class="number">1</span> &lt;= j) right = j;</span><br><span class="line">            <span class="keyword">else</span> left = i;</span><br><span class="line">            </span><br><span class="line">        &#125;       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将数组中的值进行复制</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = input[i];</span><br><span class="line">        input[i] = input[j];</span><br><span class="line">        input[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考题解">参考题解</h3>
<p>包含min函数的栈：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/</p>
<p>栈的压入、弹出序列：https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/mian-shi-ti-31-zhan-de-ya-ru-dan-chu-xu-lie-mo-n-2/</p>
<p>https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/tan-xin-by-z1m/</p>
<p>数据流中的中位数：https://leetcode-cn.com/problems/find-median-from-data-stream/solution/you-xian-dui-lie-python-dai-ma-java-dai-ma-by-liwe/</p>
<p>滑动窗口的最大值：https://leetcode-cn.com/problems/sliding-window-maximum/solution/zhe-hui-yi-miao-dong-bu-liao-liao-de-hua-7fy5/</p>
<p>最小的k个数：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/tu-jie-top-k-wen-ti-de-liang-chong-jie-fa-you-lie-/</p>
<p>https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/wei-ruan-mian-shi-jiao-xun-x-by-jerry_nju/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/19/%E5%85%B6%E4%BB%96_%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<a id="more"></a>
<p>说一个你本科做过的印象最深的项目，难点</p>
<p>搭建大数据平台处理日志数量统计项目，需要统计的是uv，就是一段时间内访问的用户数量。主要是用十台普通计算机主机搭建了一个Hadoop集群，用HDFS存数据，用Yarn作为资源管理器，用Spark作为计算框架。难点在于大数据的组间比较多，首先要理解它们的关系，其次是容错性的问题，集群通常有机器检测不到或者突然间宕机的状态（解决方法，观察宕机原因，发现日志被存满，写一个脚本取删除日志），还有编程中可能会出现一些对象无法序列化的问题，可能是由于闭包问题引起的，需要修正代码。</p>
<p>说一个你研究生做过的印象最深的项目，难点</p>
<p>TCBB，难点：数据比较大，缺失值比较多，</p>
<p>遇到过的压力最大的事，如何缓解压力</p>
<p>ds离职，跑步，思考下一步到底要干嘛，列个计划</p>
<p>自身的优势</p>
<p>做事比较认真努力，有条理性，会把要做的事情列个计划，按计划完成任务，每个阶段清楚自己在干嘛；</p>
<p>缺点</p>
<p>内向、表达</p>
<p>你为什么要来xx</p>
<p>做实业、有创新能力的公司，不管是面向个人的产品还是一些商用产品，都是实实在在能够为人们带来便捷，能够促进人们生活发展，所以我希望加入华为，利用我的专业知识希在一个更大的平台来展示自己的能力。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
