<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<figure>
<img src="/2021/01/28/hello-world/0.png" alt="hello"><figcaption aria-hidden="true">hello</figcaption>
</figure>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>BasicVSR 论文阅读</title>
    <url>/2021/01/28/SR_Basicvsr/</url>
    <content><![CDATA[<p>《BasicVSR：The Search for Essential Components in Video Super-Resolution and Beyond》</p>
<h3 id="背景">背景</h3>
<p>相比图像超分任务，视频超分网络会设计更多模块，因为它多了一个时空维度。因此复杂的设计结构在视频超分网络中是常见的。本文重新分析了视频超分网络中的四大模块（对齐、聚合、传播和上采样）的作用，以及它们的优缺点。提出了一个视频超分框架baseline，即BasicVSR，并在Reds和Vimeo数据集上训练，验证了该框架的有效性。</p>
<p>另外，本文扩展BasicVSR框架，设计了信息重新填充机制和成对传播策略，促进信息聚合，即IconVSR网络。</p>
<a id="more"></a>
<h3 id="方法">方法</h3>
<p>该部分首先分析了视频超分网络中四大模块中不同选择的作用，并在每个模块中选择最好的组件构成BasicVSR网络，该网络可以作为设计其他视频超分网络的骨架backbone。然后，作者在backbone的基础上引入了两种新的组件信息重新填充机制和成对传播策略，略微提升了参数量和运行时间，并提高了网络性能。</p>
<h4 id="传播模块">传播模块</h4>
<p>本质上，传播模块定义了各个输入帧究竟是如何在网络中进行传播的，当前各个帧的传播方式主要有如下几种：</p>
<ul>
<li><p>Local</p>
<p>局部传播使用一个滑动窗口中的LR图像作为输入，然后利用这些局部信息完成重建任务。这是最常见的方式，也是TDAN、EDVR等方法的输入方式，例如一次性输入相邻的7帧，并选择重建第4帧，其他的作为参考帧。因此，网络能够访问的信息限制在这些局部相邻帧中。缺少远距离帧不可避免地限制了网络的表达能力。</p>
<p><img src="/2021/01/28/SR_Basicvsr/0.png" style="zoom:67%;"></p>
<p>如图所示，作者将测试集分成K个segments在BasicVSR网络中进行测试，可以看到当每个segments内的帧数越多的时候，其恢复的PSNR值越低，说明了帧的数量对网络有影响。</p>
<p>对于非recurrent形式的网络，滑动窗口内的帧数越多则会导致网络的参数量和占用显存都会大规模增加，这是一个主要的缺陷。</p></li>
<li><p>Unidirectional Propagation</p>
<p>单向传播形式，即如RLSP、RSDN等普通recurrent网络的形式，每次输入一帧和相邻帧，并利用重建的相邻帧及其中间产物来完成当前参考帧的重建过程。</p>
<p><img src="/2021/01/28/SR_Basicvsr/1.png" style="zoom:67%;"></p>
<p>然而，单向传播的方式会涉及到隐状态，即前一帧的中间产物的处理问题。本质上隐状态代表了前一帧或前n帧的特征，因此当输入的帧数越靠前时，隐状态含有的信息越少，对参考帧的重建效果越差，如上图所示。</p></li>
<li><p>Bidirectional Propagation</p>
<p>双向传播形式解决上述两种问题，本质上就是网络同时利用前一帧和后一帧的隐状态，来完成当前参考帧的重建。前一帧的隐状态包含当前参考帧之前的所有信息，后一帧的隐状态包含当前参考帧之后的所有信息，这相当于可以利用前后所有帧的信息。</p></li>
</ul>
<h4 id="对齐模块">对齐模块</h4>
<ul>
<li><p>无对齐</p>
<p>不对齐的特征或图像会影响聚合的效果，并最终导致性能降低。直接串联不对齐的特征以进行恢复，相邻帧的特征将不会与输入图像的特征在空间上对齐。由于卷积之类的局部操作具有相对较小的感受野，在相应位置集合信息时无法有效地利用相邻帧的信息，此时会导致较低的效率。</p></li>
<li><p>基于图像的对齐</p>
<p>基于图像的对齐使用光流估计相邻帧到参考帧的光流变化，然后利用光流的信息将相邻帧变形对齐到参考帧上。该过程是直接在图像上进行的，而非特征图上进行的。并且大部分的工作通常需要利用其他预训练的光流估计网络。</p></li>
<li><p>基于特征的对齐</p>
<p>基于特征的对齐最流行的方法是使用可变形卷积。然而本文使用的方式是基于光流的特征对齐，即先估计光流，然后根据光流将中间结果，即隐状态进行对齐，然后将对齐过后的特征和当前参考帧一起输入残差块进行重建。</p></li>
</ul>
<h4 id="聚合与上采样">聚合与上采样</h4>
<p>文章对聚合方式没有进行过多探讨，只采用最基础的聚合方式，即拼接特征图并输入多个卷积作为聚合模块。</p>
<p>上采样模块采用最经典有效的方式Pixel-shuffle。</p>
<h4 id="basicvsr">BasicVSR</h4>
<p><img src="/2021/01/28/SR_Basicvsr/2.png" style="zoom: 50%;"></p>
<p>本文提出的Backbone即BasicVSR，采用了上述探讨的最基础的几个模块。对齐模块采用基于光流的特征对齐，对齐的对象是隐状态和光流图。传播模块采用的是双向传播模式，当前参考帧需要利用前后一帧的隐状态。聚合模块是直接拼接，上采样模块则为Pixel-shuffle。</p>
<h4 id="iconvsr">IconVSR</h4>
<p>在BasicVSR的基础上引入了两种新的组件信息重新填充机制和成对传播策略来提升网络的性能。</p>
<ul>
<li><p>Information-Refill</p>
<p>信息重新填充机制是为了解决在图像边界和有遮挡区域的不精确对齐的问题。不精确对齐会导致误差的不断积加，特别是在网络中采用长距离传播的时候。为了解决特征不精确对齐带来的不利影响，本文提出了一个信息重新填充机制，以做特征修正。</p>
<p><img src="/2021/01/28/SR_Basicvsr/3.png" style="zoom:67%;"></p>
<p>如上图所示，E为特征提取模块，C为卷积单元。需要事先设定一些关键帧<span class="math inline">\(I_{key}\)</span>，当关键帧作为参考帧进行输入时，对齐的特征需要和前后帧的特征进行拼接，对当前的特征图进行修正，防止错误累加，最后才将对齐后的特征和参考帧一起输入重建模块。</p></li>
<li><p>Coupled Propagation</p>
<p>成对传播策略将后向传播的特征，即后向传播的隐状态，也作为正向传播模块的输入。而不是像BasicVSR中的那样，直接在U处融合前后两个传播分支的输出。</p>
<p><img src="/2021/01/28/SR_Basicvsr/4.png" style="zoom:67%;"></p>
<p>通过成对传播，前向传播分支从过去和将来的帧中接收信息，从而导致更高质量的特征，获得更好的输出。</p></li>
</ul>
<h3 id="实验结果">实验结果</h3>
<h4 id="与sota进行对比">与SOTA进行对比</h4>
<p><img src="/2021/01/28/SR_Basicvsr/5.png" style="zoom: 50%;"></p>
<p><img src="/2021/01/28/SR_Basicvsr/6.png" style="zoom: 50%;"></p>
<h4 id="信息重新填充机制和成对传播策略消融实验">信息重新填充机制和成对传播策略消融实验</h4>
<p><img src="/2021/01/28/SR_Basicvsr/7.png" style="zoom: 50%;"></p>
<h4 id="信息重新填充机制中的关键帧数量">信息重新填充机制中的关键帧数量</h4>
<p><img src="/2021/01/28/SR_Basicvsr/8.png" style="zoom: 50%;"></p>
<h3 id="总结">总结</h3>
<p>本文中提出的BasicVSR和IconVSR，利用recurrent的机制进行超分辨率。BasicVSR主要利用了双向传播机制，使得长距离信息能够得到利用，IconVSR在此基础上直接在前向传播分支中利用后向传播的特征，直接在特征维度上利用长距离信息。</p>
<p>同时注意到，双向传播机制的短板非常明显，无论是BasicVSR还是IconVSR都需要将所有视频帧全部输入到网络中之后才能够进行超分辨率，这是相比于滑动窗口最大的缺陷，这导致了基于双向传播的方法无法做到实时超分。并且，这需要保存大量的中间结果，即隐状态，这在训练时可能会导致大规模的显存占用情况存在。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>VSR</category>
      </categories>
      <tags>
        <tag>VSR</tag>
      </tags>
  </entry>
  <entry>
    <title>DSFN 论文阅读</title>
    <url>/2021/02/09/SR_DSFN/</url>
    <content><![CDATA[<p>《Dual-Stream Fusion Network for Spatiotemporal Video Super-Resolution》 WACV 2021</p>
<h3 id="背景">背景</h3>
<p>时空视频超分辨率，即在时间维度上提升帧率，在空间维度上提升分辨率。本文认为，直接级联已有空间和时间超分辨率的方法（没有另外设计）来实现时空上采样，改变它们的顺序能够使得结果具有互补性。 因此，本文提出了一种双流融合网络，以自适应地融合两个时空上采样流产生的中间结果，其中第一个流应用空间超分辨率，然后是时间超分辨率，而第二个流则先使用空间超分辨率再进行时间超分辨率。</p>
<a id="more"></a>
<h3 id="方法">方法</h3>
<p><img src="/2021/02/09/SR_DSFN/0.png" style="zoom:50%;"></p>
<h4 id="框架的组件">框架的组件</h4>
<ul>
<li><p><span class="math inline">\(M_S\)</span></p>
<p>空间超分辨率网络。本文使用的是单幅图像的超分辨率网络ESPCN、SAN。</p></li>
<li><p><span class="math inline">\(M_T\)</span></p>
<p>时间超分辨率网络。即插帧网络，本文使用SuperSloMo、DAIN。</p></li>
<li><p><span class="math inline">\(F\)</span></p>
<p>融合网络，负责将不同分支产生的结果进行融合。具体采用采用了U-Net，它包含五个具有跳跃连接的对称下采样和上采样卷积层。</p></li>
<li><p><span class="math inline">\(R\)</span></p>
<p>调整网络，增强细节。具体为三个残差块。</p></li>
</ul>
<h4 id="框架的执行">框架的执行</h4>
<p>整个网络的流程具体来说就是将时空超分辨率分为两个分支，一个是先超分再插帧，另一个是先插帧再超分，然后通过融合网络融合两个分支的结果，最后通过调整网络进行细节调整。</p>
<p>空间超分辨率网络接收单个输入帧，并进行超分，输出对应一帧的超分结果；时间超分辨率网络接收前后两帧，并预测中间帧的结果。</p>
<p>先超分再插帧的过程可以表示为：</p>
<p><img src="/2021/02/09/SR_DSFN/1.png" style="zoom:67%;"></p>
<p>先插帧再超分的过程可以表示为：</p>
<p><img src="/2021/02/09/SR_DSFN/2.png" style="zoom:67%;"></p>
<p>本文认为，这两个数据流在时空上采样方面表现出互补的结果，其中先超分再插帧在运动较小的区域产生更精细的细节，而先插帧再超分在运动较大的区域提供更好的重建。</p>
<p>将双分支预测得到的结果进行融合，融合的策略就是给两个分支的结果分别预测一个Mask，并将Mask和预测结果进行element-wise的乘法后相加，整个过程可以表示为：</p>
<p><img src="/2021/02/09/SR_DSFN/3.png" style="zoom:67%;"></p>
<p>注意到，两个Mask之间，假如给予约束 Mask1 + Mask2 = 1，则总的预测结果变成了两个分支结果的线性插值，否则总的预测结果是两个分支结果的线性组合。</p>
<p>最终，通过一个三个残差块的调整网络增强细节信息。</p>
<p><img src="/2021/02/09/SR_DSFN/4.png" style="zoom:67%;"></p>
<h4 id="损失函数">损失函数</h4>
<p>损失函数主要分为两个部分：重建损失、辅助损失。</p>
<p><img src="/2021/02/09/SR_DSFN/5.png" style="zoom:77%;"></p>
<ul>
<li><p>重建损失</p>
<p>各个中间预测结果和GT的L1距离，作为重建损失。</p>
<p><img src="/2021/02/09/SR_DSFN/6.png" style="zoom:67%;"></p></li>
<li><p>辅助损失</p>
<p>主要是先超分再插帧的超分部分，以及先插帧再超分的插帧部分，对中间结果计算L1损失。</p>
<p><img src="/2021/02/09/SR_DSFN/7.png" style="zoom: 60%;"></p></li>
</ul>
<h3 id="实验结果">实验结果</h3>
<p>batch size设置为24，使用优化器RAdam，学习率开始时设置为<span class="math inline">\(5e-5\)</span>。时间和空间超分辨率均为2x。使用数据集Vimeo-90K、UCF101、FISR dataset。训练过程，首先单独训练超分网络和插帧网络，然后冻结参数把它们和融合网络及调整网络拼接在一起训练，最终联合训练所有模块。</p>
<h4 id="时空超分的互补结果">时空超分的互补结果</h4>
<p><img src="/2021/02/09/SR_DSFN/8.png"></p>
<p>文章认为先超分再插帧在小动作区域有更好的细节，先插帧再超分能够在大动作区域有更好的重建效果。如图所示应该是1、3行表示小动作区域，先超分再插帧的效果更好，Error Map有更少的像素点有值；而2、4行则表示大动作区域，先插帧再超分的Error Map有更少的像素点有值。</p>
<h4 id="不同融合策略的比较">不同融合策略的比较</h4>
<p><img src="/2021/02/09/SR_DSFN/9.png" style="zoom:67%;"></p>
<p>One-mask表示Mask1 + Mask2 = 1，总的预测结果变成了两个分支结果的线性插值，Two-mask则表示总的预测结果是两个分支结果的线性组合，可以看出Two-mask更有优势。</p>
<h4 id="选择不同上采样网络">选择不同上采样网络</h4>
<p><img src="/2021/02/09/SR_DSFN/10.png" style="zoom: 67%;"></p>
<p>越新的方法作为backbone效果则越好。</p>
<h4 id="与sota结果相比">与SOTA结果相比</h4>
<p><img src="/2021/02/09/SR_DSFN/11.png" style="zoom:67%;"></p>
<p>并没有和最新的网络结果相比，例如Zooming Slow-Mo。</p>
<h3 id="结论">结论</h3>
<p>本文提出了一种融合双分支结果的网络来进行时空超分辨率。然而，该网络并不是end-to-end训练的，借用已有的网络进行多阶段训练，并且正文没有给出参数量和计算量，可能代价也比较高。其次，重建完全由中间和最终输出帧的像素级重建损失来指导，把超分和插帧的过程都看成是独立的过程，各个中间结果之间没有加上时序的联系，这必然导致了性能的降低。因此，在时空超分中如何有效地利用时序信息进行更好的重建值得进行探索。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>STVSR</category>
      </categories>
      <tags>
        <tag>STVSR</tag>
      </tags>
  </entry>
  <entry>
    <title>DualSR 论文阅读</title>
    <url>/2021/02/05/SR_DualSR/</url>
    <content><![CDATA[<p>《DualSR: Zero-Shot Dual Learning for Real-World Super-Resolution》 WACV 2021</p>
<h3 id="背景">背景</h3>
<p>许多基于深度学习的SR方法在庞大数据集上学习复杂的LR-HR上采样关系。但是，这些经过预训练的SR方法通常在直接从相机捕获的图像上表现差很多。它们接受了干净，无噪声，合成的LR图像进行训练，而真实LR图像的退化过程与理想条件不同。现实情况下，每个摄像机的采集参数，例如传感器的点扩展功能（PSF），也不同。即使是同一台摄像机拍摄的图像，也会因光线条件、景深以及抖动而产生的模糊等而有所不同。这些条件使得训练一个在所有不同图像退化条件下都能表现良好的CNN变得很困难。</p>
<a id="more"></a>
<p>许多盲SR方法在超分之前都会估算退化过程。 盲超分的SOTA使用深度学习来学习图像特定的下采样器（降级模型参数），上采样器使用该下采样器对输入的LR图像进行超分辨。 但是，从单个输入图像估计合适的下采样器很复杂。 尤其是在存在噪声或其他采集伪像的情况下，这些方法通常无法估算出良好的降级参数。 错误的降级会严重降低上采样器的效率，并降低SR性能。</p>
<p>受诸如CycleGAN 和 DualGAN 等最新无监督方法的启发，论文引入了Zero-Shot DualSR，一种双路径架构，用于在现实世界中的LR图像上实现超分辨率，并且是一种无监督的方案。</p>
<h3 id="方法">方法</h3>
<p><img src="/2021/02/05/SR_DualSR/0.png" style="zoom: 50%;"></p>
<h4 id="框架的组件">框架的组件</h4>
<ul>
<li><p><span class="math inline">\(G_{UP}\)</span></p>
<p>上采样器。与ZSSR类似，采用了简单的8层全卷积网络，并采用了ReLU激活。在输入和输出之间存在一个全局的残差连接。将LR图像放大到输出大小，然后才将其送入网络。</p></li>
<li><p><span class="math inline">\(G_{DN}\)</span> &amp; <span class="math inline">\(D_{DN}\)</span></p>
<p>下采样器和判别器。使用KernelGAN中的生成器和判别器。</p>
<p>生成器是一个深层线性网络（没有任何激活）。小的感受野强迫使网络仅使用LR图像的局部特征（例如边缘），而不是依赖于高级全局特征。 因此，生成器<span class="math inline">\(G_{DN}\)</span>学习能够生成图像的kernel，该图像在patch分布上与输入LR图像相似。</p>
<p><img src="/2021/02/05/SR_DualSR/1.png" style="zoom:55%;"></p>
<p>判别器是一个全卷积的PatchGAN，其感受野为7x7。</p>
<p><img src="/2021/02/05/SR_DualSR/2.png" style="zoom:60%;"></p></li>
</ul>
<h4 id="框架的执行">框架的执行</h4>
<p>在前向循环中，首先应用上采样器以生成2x的上采样图像。，然后应用下采样器并将上采样的图像转换回1x。</p>
<p>同样，在后向循环中，首先由<span class="math inline">\(G_{DN}\)</span>生成1/2x的图像，然后<span class="math inline">\(G_{UP}\)</span>将图像上采样回到原始比例。</p>
<h4 id="损失函数">损失函数</h4>
<p>损失函数主要分为三部分：对抗损失、循环一致性损失、掩码插值损失。</p>
<p><img src="/2021/02/05/SR_DualSR/3.png" style="zoom: 67%;"></p>
<ul>
<li><p>对抗损失</p>
<p>对于下采样器<span class="math inline">\(G_{DN}\)</span>，希望其能够生成和真实LR相同的图像，判别器尽可能认为它是真实的LR（标签为1），损失如下（正则化项<span class="math inline">\(R\)</span>具体见KernelGAN论文）：</p>
<p><img src="/2021/02/05/SR_DualSR/4.png" style="zoom:60%;"></p>
<p>对于判别器<span class="math inline">\(D_{DN}\)</span>,希望其能够判别哪些是真实的LR，即让真实的LR被判别为1，合成的LR被判别为0：</p>
<p><img src="/2021/02/05/SR_DualSR/5.png" style="zoom:60%;"></p></li>
<li><p>循环一致性损失</p>
<p>确保<span class="math inline">\(G_{UP}\)</span>和<span class="math inline">\(G_{DN}\)</span>可以还原由另一个执行的操作。</p>
<p><img src="/2021/02/05/SR_DualSR/6.png" style="zoom:60%;"></p></li>
<li><p>掩码插值损失</p>
<p>Bicubic上采样能够能够正确地对低频部分进行上采样，但是无法重构高频细节。对所有像素使用Bicubic能够产生无伪影但模糊的结果。因此，论文仅对图像低频部分应用插值损失。首先对Bicubic上采样的图像应用Sobel算子，它主要用作边缘检测，是一种离散性差分算子，用来计算图像亮度函数的灰度近似值。应用Sobel算子能够产生mask，该mask在低频区域的像素值较高，在图像的高频区域的像素值较低。</p>
<p><img src="/2021/02/05/SR_DualSR/7.png" style="zoom:60%;"></p>
<p>然后应用掩码插值损失使得<span class="math inline">\(G_{UP}\)</span>的结果和Bicubic上采样的结果仅在低频部分是相近的。</p>
<p><img src="/2021/02/05/SR_DualSR/8.png" style="zoom:60%;"></p></li>
</ul>
<h3 id="实验结果">实验结果</h3>
<p>训练使用的 patch size 为 64 x 64 以及 128 x 128。训练和测试时不使用任何数据增强（图像变换）。因为训练时间很少，所以可以用暴力搜索方法来获得<span class="math inline">\(\lambda_{cycle}=5,\lambda_{inter}=2\)</span>。</p>
<p>在RTX 2080 Ti GPU上，论文的方法平均训练+推理时间为233秒。 对于KernelGAN + ZSSR 的组合，运行时间为281秒，对于BlindSR，则为370秒。 像SAN这样的有监督深度学习SR方法具有很长的训练时间，并且图像大小显着影响其推理时间。对于SAN +，在DIV2KRK基准上测试每张图片平均需要298秒。</p>
<h4 id="合成的真实lr数据集">合成的真实LR数据集</h4>
<p><img src="/2021/02/05/SR_DualSR/9.png" style="zoom: 45%;"></p>
<h4 id="realsr数据集">RealSR数据集</h4>
<p>该数据集通过调整焦距获得不同尺度图像，但作者认为不同尺度间没有完全对齐，因此只放出视觉效果。</p>
<p><img src="/2021/02/05/SR_DualSR/10.png" style="zoom:40%;"></p>
<h4 id="掩码插值损失">掩码插值损失</h4>
<p><img src="/2021/02/05/SR_DualSR/11.png" style="zoom:50%;"></p>
<h3 id="结论">结论</h3>
<p>本文提出提出了DualSR，一个轻量级的dual架构，它学习每个图像特定的LR-HR关系。它由下采样器和上采样器组成，在训练中使用循环一致性损失来相互改进。此外，论文提出了掩码插值损失，消除了图像低频区域的伪影，而不会导致边缘过于平滑。</p>
<p>该方法是Zero-Shot的，无需HR图像进行监督，但本质上就是用了Bicubic上采样的低频部分来进行监督。之前的文章DynaVSR是用了元学习的思想，在测试时同样使用了类似循环一致性的方法，但在训练时为了更好的效果仍然使用了HR的图像。因此，可以思考如何将Zero-Shot的思想（目前来看还是想办法在Bicubic上采样的结果做文章），应用到VSR上，来达到完全无监督的效果。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>SISR</category>
      </categories>
      <tags>
        <tag>SISR</tag>
        <tag>RealSR</tag>
      </tags>
  </entry>
  <entry>
    <title>TPSTVSR 论文阅读</title>
    <url>/2021/02/26/SR_TPSTVSR/</url>
    <content><![CDATA[<p>《Space-Time Video Super-Resolution Using Temporal Profiles》 ACMMM 2020</p>
<h3 id="背景">背景</h3>
<p>在时空超分辨率中，直接将VFI（插帧）和VSR（超分）串联，不能充分利用视频的时空相关性，是一种次优做法。此外，在计算效率低的同时，也容易引入累积误差。Zooming Slow-Mo提出一种one-stage的做法，使用可变形的ConvLSTM来隐式对齐帧，这样可能会错过长依赖的时间上下文，因为当更多的帧融合时，需要设计更复杂的帧对齐规则。因此，本文提出利用 Temporal Profile (TP)来解决时空超分辨率问题。</p>
<a id="more"></a>
<p>视频帧在一个Patch上，可以转换为如下水平（vertical）TPs 和垂直（horizontal）TPs：</p>
<p><img src="/2021/02/26/SR_TPSTVSR/0.png" style="zoom: 50%;"></p>
<p>基于TP的时空超分辨率有以下几个好处：</p>
<p>（1）STVSR可以有效地建模为基于学习的恢复任务，聚焦于TPs的特定二维结构。</p>
<p>（2）TPs既包含空间维度又包含时间维度，可以更好地利用时空相关性。</p>
<p>（3）与现有的多帧对齐方法相比，TPs能够更灵活地融合长依赖的时间上下文信息。</p>
<h3 id="方法">方法</h3>
<p>首先将低帧率和低分辨率的视频转换成TPs，然后将其送入Temporal Profile超分辨率模块（TPSRM）提高帧率，然后将TPs转换为视频域，发送给特征洗牌模块（FSM）生成具有目标空间分辨率的视频，最后通过调整模块（RM）去除伪影，增强细节。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/1.png" style="zoom: 80%;"></p>
<ul>
<li><p>Temporal-Profile Super-Resolution Module</p>
<p>首先将输入视频帧 W x H x T 转换为垂直Temporal Profile T x H x W（转换为水平TP无太大区别），即在垂直方向上将视频帧切割成W个。然后输入TPSRM，将TP分辨率提高为 （2T-1）x 2H x W。TPSRM采用IMDN模型，用L1损失函数做监督，ground truth由高帧率高分辨率视频转换成TP得到。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/8.png" style="zoom:60%;"></p></li>
<li><p>Feature Shuffling Module</p>
<p>该模块的目的是提高空间分辨率。经过TPSRM后，帧率提升为原来的两倍，H提高为原来的两倍，而W不变，FSM的目的就是将H再次提高两倍，W直接提高四倍。注意到其中Feature Shuffling阶段会将通道数（也就是帧率）减半，来将W提升2倍，在后面的模块需要将空间分辨率和通道数同时提升。CSR同样使用IMDN模块。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/2.png" style="zoom: 67%;"></p></li>
<li><p>Refining Module</p>
<p>该模块目的是消除伪影和增强细节，采用U-Net结构。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/3.png" style="zoom: 67%;"></p></li>
</ul>
<p>损失函数采用 L1、SSIM、VGG和Cycle Consistency四种损失函数。采用循环一致性损失来保证重构视频与输入的时空一致性，同时可以避免过度增强。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/4.png" style="zoom:67%;"></p>
<p><img src="/2021/02/26/SR_TPSTVSR/5.png" style="zoom:67%;"></p>
<p><img src="/2021/02/26/SR_TPSTVSR/6.png" style="zoom:67%;"></p>
<p><img src="/2021/02/26/SR_TPSTVSR/7.png" style="zoom: 67%;"></p>
<h3 id="实验结果">实验结果</h3>
<p>使用Vimeo90K数据集进行训练，进行空间4倍超分，时间2倍超分，batch size设置为1，学习率每2个epoch下降0.2，在一张1080Ti GPU上进行训练。</p>
<h4 id="与sota对比">与SOTA对比</h4>
<p><img src="/2021/02/26/SR_TPSTVSR/9.png" style="zoom:80%;"></p>
<h4 id="参数量与运行时间">参数量与运行时间</h4>
<p><img src="/2021/02/26/SR_TPSTVSR/10.png" style="zoom:80%;"></p>
<h4 id="不同损失函数比较">不同损失函数比较</h4>
<p><img src="/2021/02/26/SR_TPSTVSR/11.png" style="zoom:67%;"></p>
<h4 id="真实场景老电影恢复">真实场景：老电影恢复</h4>
<p>由于相机设备的分辨率有限，老电影往往会出现严重的时空退化。另外，在不同的压缩程度下保存也会影响观感。因此时空超分有应用场景。从网络上直接下载老电影，并和Zooming Slow-Mo进行对比，两者同样在Vimeo90K上训练。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/12.png" style="zoom: 67%;"></p>
<h3 id="结论">结论</h3>
<p>本文从Temporal Profile的角度进行时空超分辨率，与Zooming Slow-Mo相比降低了参数量和运行时间。该网络利用的是滑动窗口的原理，当帧数过多时会造成显存大量占用的问题。此外，当一个移动的物体在视频中突然出现或消失时，由于快速的移动，TPs很难捕捉到全局信息，融合水平和垂直的TPs可能是一种解决方案。</p>
<p><img src="/2021/02/26/SR_TPSTVSR/13.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>STVSR</category>
      </categories>
      <tags>
        <tag>STVSR</tag>
      </tags>
  </entry>
  <entry>
    <title>TriNAS 论文阅读</title>
    <url>/2021/01/29/SR_TriNAS/</url>
    <content><![CDATA[<p>《Trilevel Neural Architecture Search for Efficient Single Image Super-Resolution》</p>
<h3 id="背景">背景</h3>
<p>传统的基于深度学习的超分辨率方法通常会在三层神经结构设计上选择以下变化：网络级优化、单元（cell）级优化以及内核（kernel）级优化。为一个深层SR模型人工执行这些优化需要较高的代价。并且，人工设计的架构往往不是最优的，对于真实超分辨率来说，可能在计算上效率低下。因此，论文提出了一种用于高效单图像超分辨率（SR）的三级神经架构搜索（TriNAS）方法。</p>
<a id="more"></a>
<p>论文首先在三个级别（即网络级别，单元级别和内核级别（卷积内核））定义离散搜索空间。提出了基于树模型的搜索框架来替代网格型的搜索框架，减少节点之间的依赖性。</p>
<p>然后，与之前利用softmax进行连续松弛策略的NAS方法不同，论文利用排序的sparsestmax来使得三级搜索架构稀疏地起作用。因此，论文的NAS优化可以逐渐收敛到对超网起主要作用的神经架构。</p>
<p>此外，论文提出的方法可以在单个阶段中同时进行搜索和训练，与传统的NAS算法相比，这大大减少了搜索和训练时间。</p>
<p>在基准数据集上进行的实验表明，论文的的NAS算法所提供的SR模型在参数数量和FLOPS方面具有显着减轻的优势，其PSNR值可与当前的SOTA相媲美。</p>
<h3 id="方法">方法</h3>
<h4 id="搜索空间定义">搜索空间定义</h4>
<p><img src="/2021/01/29/SR_TriNAS/2.png" style="zoom: 60%;"></p>
<p>为了在模型容量和模型大小之间达到适当的平衡，同时保证最小的精度损失，论文提出在内核级、单元级和网络级结构上进行搜索，以得到高效的SR网络结构。</p>
<ul>
<li><p>网络级</p>
<p>论文遵循AGD和SRResNet来定义网络级搜索空间。他们的超网结构使大多数计算都在低分辨率特征空间中进行，从而提高了计算效率。</p>
<p>网络级架构搜索主要通过搜索五个残差块和两个上采样块。将Residual-in-Residual（RiR）模块中的dense block替换为包含可搜索单元级运算符和内核级运算的五个连续层。</p>
<p>为了进行高效的上采样模块设计，论文替换了两个最初设计的上采样模块。取代的是一个PixelShuffel块，其中包含一个卷积层以及一个PixelShuffel层，以达到上采样的目的。由于PixelShuffle块固定在网络的尾部，因此在网络级搜索空间中添加了两个常规卷积层。最终，论文仅关注堆叠的五个RiR块和两个用于网络路径搜索的标准卷积层。</p>
<p><img src="/2021/01/29/SR_TriNAS/0.png" style="zoom:80%;"></p>
<p>为了对网络级搜索空间建模，采用上图所示的AutoDeep-Lab网格状结构似乎是可行的解决方案。 但是，网格建模旨在遍历网络块的所有顺序路径。 每个节点表示这个位置的feature map，每个路径都从第一个节点开始，并沿着一组箭头到达最终的目标节点。 显然，所有路径共享大多数节点和箭头。 这种冗余共享导致路径，单元和内核之间的极端依赖，因为路径在层次上包括它们。 尽管这样的共享策略可以节省大量训练内存，但它极大地限制了搜索空间。 此外，紧密的结合可能会损害每条路径的贡献以及对某些冗余路径的修剪的学习。</p>
<p><img src="/2021/01/29/SR_TriNAS/1.png" style="zoom: 67%;"></p>
<p>论文提出了一种用于网络级路径搜索建模的树结构，来克服冗余共享的缺点。 如上图所示，树建模旨在遍历所有树结构路径。 在这里，每个节点仅连接到其父节点和子节点，因此，依赖性非常宽松。 但是，必须在训练时维护这样的关联，以降低内存消耗。 放宽不同路径的相关性可以实现灵活的网络级搜索空间。 对路径的较低依赖性可能会由于单元和内核之间的分层连接而导致它们之间可靠的关联，从而使它们的搜索空间更为通用。 此外，引入的树模型可以更好地解开路径之间的纠缠关系，从而能够对冗余路径进行修剪。</p></li>
<li><p>单元级</p>
<p>在单元级，论文搜索五个RiR块，每个块包含五个个可搜索的单元，即总共25个可搜索的单元。每个单元会选择如下操作符：</p>
<p>Conv 1×1；Residual Block (2 layers of Conv 3×3 + skip-connection)；Conv 3×3；Depthwise Block (Conv 1×1 + Depthwise Conv3×3 + Conv 1×1).</p></li>
<li><p>内核级</p>
<p>对于内核级搜索，论文遵循super-kernel框架对该搜索空间进行建模。 对于每个卷积内核，先设置一个具有完整通道的超级内核。 为了修剪超级内核的通道数，需要一组可搜索的扩展比<span class="math inline">\(\phi=[\frac{1}{3},\frac{1}{2},\frac{4}{5},\frac{5}{6},1]\)</span>。并且设置参数<span class="math inline">\(\gamma_i\)</span>控制选择第<span class="math inline">\(i\)</span>个扩展比的概率。</p></li>
</ul>
<h4 id="连续松弛策略">连续松弛策略</h4>
<p>为了使得NAS是可微的，关键思想是将离散的搜索空间的显式选择放宽为搜索空间中所有相关候选对象的的隐式选择。连续松弛使我们能够以完全可微的方式选择对超网贡献最大的候选者，然后就可以通过反向传播的方式优化整个超网，以实现高效的架构。流行的连续松弛策略之一是应用softmax来实现所有候选网络操作的混合。但是，softmax无法产生稀疏的分布，因此，它无法反映主导操作，这对于有效的结构设计而言至关重要。因此，使用softmax可以防止超级网络收敛到主要的候选架构。</p>
<p>为了解决这个问题，论文提出了sparsestmax，它在连续松弛过程中产生了良好的稀疏性，并且可以寻求具有优势的候选架构，同时具有诸如softmax之类的凸性和可微性。</p>
<p>具体来说，为了实现离散网络级搜索空间的连续松弛，论文使用一组连续组合权值来聚合所有的网络路径，构成一个超网络。网络级架构搜索的树模型中每个特征图（即节点）都可以用作其对应路径的输出，然后可以将输出送到上采样层以获得超分结果。 论文根据提出的树模型对来自相关网络路径的所有特征图定义了一组权重<span class="math inline">\(\beta\)</span>，因此，超网的输出是所有中间特征图的加权组合。</p>
<p>传统的连续松弛做法就是对所有的<span class="math inline">\(\beta\)</span>应用softmax函数来判断每个路径对总的网络的贡献。然而，softmax通常产生非零参数，即平滑变化的参数。因此，候选路径的贡献是相对均匀的，这防止超网络收敛到一个主要的候选结构。因此，利用sparsetmax来产生稀疏的分布，其中<span class="math inline">\(q\)</span>表示具有约束的单纯形：</p>
<p><img src="/2021/01/29/SR_TriNAS/3.png" style="zoom: 80%;"></p>
<p>sparsestmax的基本思想是将输入向量<span class="math inline">\(\beta\)</span>的欧几里德投影投射到概率单纯形上。该投射可能会触及单纯形边界，在这种情况下，sparsestmax会产生稀疏分布。为了获得更好的稀疏度，sparsestmax还引入了一个圆环约束，该圆环约束可以通过将单纯形外接圆的半径从零线性增加到某个阈值来逐步产生稀疏性。</p>
<p>前文提到的树模型搜索架构有助于对路径进行剪枝，然而直接使用sparsestmax可能会在节点上产生无序的非零组合权重（极端情况是它们全部分布在奇/偶数节点上）。 在这种情况下，除非排序稀疏度，否则无法很好地修剪路径。 换句话说，只要非零组合权重沿路径下降，以便所有零权重都出现在路径的尾部，就可以执行网络级修剪，直接删除尾部即可。因此，论文提出利用排序的sparsetmax方法。 对每个路径<span class="math inline">\(p_i\)</span>内的权重<span class="math inline">\(\beta_i\)</span>施加排序约束。 直观上，这有助于使得浅层的输出feature maps对超网趋于相同的贡献度。排序的sparsetmax可以表示为：</p>
<p><img src="/2021/01/29/SR_TriNAS/4.png" style="zoom: 77%;"></p>
<p>上述讨论了网络级的连续松弛策略，即使用了排序的sparsetmax方法。对于单元级的连续松弛策略，同样给每个单元的输出定义权重<span class="math inline">\(\alpha\)</span>，并采用非排序的sparsetmax的方式进行连续松弛。对于内核级的连续松弛策略，则采用gumbel-softmax方法。</p>
<h4 id="代理任务和优化">代理任务和优化</h4>
<p>对于本文的三级NAS任务，论文不是从头训练模型，而是通过知识蒸馏方法，从而利用预先训练的最先进的图像超分辨率模型的知识。将预训练的ESRGAN模型作为teacher model，搜索阶段的代理任务是通过最小化模型输出与教师模型输出之间的知识精馏距离来搜索模型G。此外，图像SR任务偏向于更有效率的模型，因此在目标函数中加入模型效率项。</p>
<p>由于架构搜索的参数的数量远远小于网络模型的参数的数量，因此在单个训练集上对它们进行联合优化容易出现过拟合。具体来说，将数据集分为训练集和验证集，分别在这两组数据上优化网络参数和架构搜索参数。</p>
<h4 id="算法流程">算法流程</h4>
<p><img src="/2021/01/29/SR_TriNAS/7.png"></p>
<h3 id="实验结果">实验结果</h3>
<h4 id="与sota进行对比">与SOTA进行对比</h4>
<p><img src="/2021/01/29/SR_TriNAS/5.png" style="zoom: 50%;"></p>
<h4 id="softmax与sparsetmax对比">softmax与sparsetmax对比</h4>
<p><img src="/2021/01/29/SR_TriNAS/6.png" style="zoom: 67%;"></p>
<h3 id="结论">结论</h3>
<p>本文介绍了用于单图像超分辨率任务的Trilevel NAS方法，主要是将排序的sparsetmax激活用于树模型的网络架构搜索中。树模型能够使得节点之间降低依赖性，提供灵活的搜索空间，并能够更好地进行剪枝优化；sparsetmax激活在连续松弛过程中产生了良好的稀疏性，使得超网能够收敛到一个主要的候选结构上；排序的sparsetmax同样能够更好地进行模型剪枝。</p>
<p>论文中提到的sparsetmax仅使用在了网络级和单元级架构搜索，可以同样利用排序的sparsetmax去进一步地优化内核级的搜索空间，来产生更高效的超分模型，以达到高PSNR和高感知质量的效果。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>SISR</category>
      </categories>
      <tags>
        <tag>SISR</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2021/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AEZookeeper/</url>
    <content><![CDATA[<p>Zookeeper（分布式协调服务）帮助Hadoop解决的问题</p>
<a id="more"></a>
<p>主要是为了实现高可用机制</p>
<p>首先所有的NN在启动的时候会竞争写一个zookeeper上的临时节点，所有的standby nn向这个节点注册一个观察器，当这个节点出现异常或挂掉时，起在zookeeper上创建的临时节点也会被删除，standy的nn节点检测到该节点发生变化时，会重新发起竞争，直到产生一个Active节点。</p>
<p>写入高可用。 集群中的写入操作都是先通知Leader，Leader再通知Follower写入，实际上当超过一半的机器写入成功后，就认为写入成功了，所以就算有些机器宕机，写入也是成功的。</p>
<p>读取高可用。 zookeeperk客户端读取数据时，可以读取集群中的任何一个机器。所以部分机器的宕机并不影响读取。 zookeeper服务器必须是奇数台，因为zookeeper有选举制度，角色有：领导者、跟随者、观察者，选举的目的是保证集群中数据的一致性。</p>
<p>https://blog.csdn.net/eric_sunah/article/details/46610167</p>
<p>https://www.jianshu.com/p/87976ec5f45f</p>
<p>kafka</p>
<p>分布式的发布-订阅消息系统。</p>
<p>Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡 和水平扩展。</p>
<p>一个分区可以有多个副本，这些副本保存在不同的broker上。每个分区的副本中都会有一个作为 Leader。当一个broker失败时，Leader在这台broker上的分区都会变得不可用，kafka会自动移除 Leader，再其他副本中选一个作为新的Leader。</p>
<p>消息同步：先写入到leader中，follower再同步。Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW（即offset）并且向Producer发送ACK。</p>
<p>数据库与数据仓库的区别</p>
<p>数据库是面向事务型，用户较为关心操作的响应时间。数据仓库是面向分析型的，一般针对历史数据进行分析，允许一定的冗余存在便于挖掘数据。</p>
<p>HIVE SQL与SQL的区别</p>
<p>HIVE就是利用SQL语句在HDFS上执行map reduce操作。</p>
<p>4.Hive不支持将数据插入现有的表或分区中 Hive仅支持覆盖重写整个表。 insert overwrite 表 （重写覆盖）</p>
<p>Hive不支持等值连接：</p>
<p>SQL中内关联可以这样写： select * from a , b where a.key = b.key Hive中应该这样写： select * from a join b on a.key = b.key</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>OR-Net 论文阅读</title>
    <url>/2021/02/16/SR_ORNet/</url>
    <content><![CDATA[<p>《Learning Omni-frequency Region-adaptive Representations for Real Image Super-Resolution》 2021</p>
<h3 id="背景">背景</h3>
<p>Real World数据包含不同的、复杂的退化方式，例如模糊、噪声和降采样，因此导致传统深度学习方法在真实数据集上表现不好。</p>
<p>RealSR和DRealSR不仅提出了两个真实数据集，还提出了两种真实超分方法 laplacian pyramid based kernel prediction network (LP-KPN) 和 component divide-and- conquer (CDC)。然而，它们都是在像素水平上进行重建（区域、边缘和角落），没有利用到频率信息。</p>
<a id="more"></a>
<p>图像的频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间上的梯度。图像的主要成分是低频信息，它形成了图像的基本灰度等级，对图像结构的决定作用较小；中频信息决定了图像的基本结构，形成了图像的主要边缘结构；高频信息形成了图像的边缘和细节，是在中频信息上对图像内容的进一步强化。</p>
<p><img src="/2021/02/16/SR_ORNet/0.png" style="zoom: 50%;"></p>
<p>作者观察到，对于图a可以看出，LR的退化在各个频率上都存在。对于图b可以看出，在不同区域中的不同频率组件内，真实LR的退化也是不同的。</p>
<p>因此，本文作者提出ORNet，在图像的不同频率上增强相应的频率因子，最终通过区域自适应频率聚合模块，结合动态卷积和空间注意力机制，针对HR图像的不同位置，有选择性地重建不同的频率分量。</p>
<h3 id="方法">方法</h3>
<p><img src="/2021/02/16/SR_ORNet/1.png" style="zoom: 67%;"></p>
<h4 id="框架的组件">框架的组件</h4>
<ul>
<li><p>Frequency Decomposition (FD) Module</p>
<p>对图像进行频率分离，可以在传统的信号处理方法中采用小波变换或离散余弦变换来实现。然而，由于数学运算的确定性和任务无关性，这种转换不可避免地为low-level恢复任务丢弃了一些关键、详细的信息。为了在模拟小波变换的同时避免关键信息丢失，作者提出通过可学习的隐空间下采样，来分解混合特征表示。类似的操作可以参考OctConv。</p>
<p>具体来说，作者首先利用步长较大的卷积层(如stride= 2)对特征表示进行下采样，提取粗特征，即低频分量。然后，从原始特征(下采样前)中减去这些相对低频的分量，以获得其余相对高频的特征表示。</p></li>
<li><p>Frequency Enhancement Unit (FEU)</p>
<p>该单元对不同频率的信息进行增强。如b种所示结构，将CA的结果和普通卷积的结果相拼接，并加入dense connection。目的是有助于各分支在不同阶段选择性融合相应的频率分量，从而提高各分支在不同频域的表示能力。</p></li>
<li><p>Region-adaptive Frequency Aggregation (RFA) Module</p>
<p>该模块对不同频率组件进行自适应聚合。</p>
<p><img src="/2021/02/16/SR_ORNet/4.png" style="zoom:50%;"></p>
<p>即预测多个动态卷积核，并设置一个可学习的权重向量，将多个卷积核组合在一起形成动态卷积核，通过它生成attention map并与原来的特征图做乘法。</p></li>
</ul>
<h4 id="框架的执行">框架的执行</h4>
<p>首先将输入图像进行频率分离。用大步长卷积提取低频特征，并不断减去低频特征获得高频特征。</p>
<p><img src="/2021/02/16/SR_ORNet/2.png" style="zoom: 67%;"></p>
<p>上箭头表示双线性插值上采样，下箭头表示带步长卷积进行下采样。</p>
<p>接着，通过FEU来增强不同频率的表示，以弥补低/中/高频信息的丢失，并将低频信息与不同高频信息相结合。</p>
<p><img src="/2021/02/16/SR_ORNet/3.png" style="zoom: 60%;"></p>
<p>真实LR图像中不同区域的频率信息丢失是不同的。因此，有必要对不同区域的全频分量进行自适应聚合，以恢复更真实、纹理细节更丰富的HR图像。通过作者提出的RFA模块，使用动态卷积核的方式生成attention map来组合多个频率下的组件，最终通过pixel shuffle提高分辨率。</p>
<p><img src="/2021/02/16/SR_ORNet/5.png" style="zoom:60%;"></p>
<h3 id="实验结果">实验结果</h3>
<p>是一种有监督方法，使用DRealSR进行训练，动态核的数量设置为5个，使用L1损失优化网络。</p>
<h4 id="不同频率的可视化">不同频率的可视化</h4>
<p><img src="/2021/02/16/SR_ORNet/6.png" style="zoom: 67%;"></p>
<p>对于FD模块，首先在图6(a)中对三个频率尺度的特征进行可视化，可以看到高频分支的特征包含更多的细节和纹理信息。然后根据图6(b)中的小波变换对低/中/高频特征进行分析。从左到右，频率范围从1增加到6中，低频特征的能量几乎完全集中在低频域，高频特征和中频特征的能量集中在相对更高的频率域。</p>
<h4 id="不同频率数量的比较">不同频率数量的比较</h4>
<p><img src="/2021/02/16/SR_ORNet/7.png" style="zoom:50%;"></p>
<p>提高频率分割的数量一定程度上能够提高效果。</p>
<h4 id="消融实验">消融实验</h4>
<p><img src="/2021/02/16/SR_ORNet/8.png" style="zoom: 50%;"></p>
<h4 id="与sota相比较">与SOTA相比较</h4>
<p><img src="/2021/02/16/SR_ORNet/9.png" style="zoom: 50%;"></p>
<p>其他方法除了CDC外均没有在DRealSR上训练，因此除了CDC外本质上无法证明该方法的有效性。</p>
<h3 id="结论">结论</h3>
<p>作者提出一种全频域自适应网络(OR-Net)来实现真实图像超分辨率。比较有贡献的地方在于分析了真实图像与图像频率的关系，以及频率在网络中的影响。然而现在RealSR大部分流行的方式是无监督学习（或unpaired的方式），而该文是完全的有监督学习。</p>
<p>有文章显示基于卷积的频率分离操作在PSNR和SSIM上稍高于基于小波变换的方法，但在视觉感知上（LPIPS指标）会稍差。对图像进行不同频率分离的方式会导致最终的重建效果有所不同。</p>
]]></content>
      <categories>
        <category>超分辨率</category>
        <category>SISR</category>
      </categories>
      <tags>
        <tag>SISR</tag>
        <tag>RealSR</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络传输层</title>
    <url>/2021/04/13/%E8%AE%A1%E7%BD%91_%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h3 id="计算机网络传输层">计算机网络传输层</h3>
<p>TCP异常断开、TCP 粘包拆包</p>
<a id="more"></a>
<h4 id="tcp异常断开">TCP异常断开</h4>
<h5 id="服务器进程终止">服务器进程终止</h5>
<p>当服务器TCP接收到来自客户的数据时，既然先前打开那个套接口的进程已经终止，于是响应一个RST报文。</p>
<h5 id="服务器主机崩溃">服务器主机崩溃</h5>
<p>当服务器主机崩溃时，它不能发送任何东西，客户端TCP持续重传数据，试图从服务器上接受一个ACK。</p>
<ul>
<li>假设服务器已崩溃，从而对客户的数据分节根本没有响应，当客户端TCP最终放弃时，返回客户进程一个错误ETIMEDOUT。</li>
<li>如果某个中间路由器判定服务器主机已不可达，从而响应以一个“destination unreachable”，那么所返回的错误是EHOSTUNREACH或ENETUNREACH。</li>
</ul>
<p>为了快速检测出服务器已经不可达，有如下解决方案：</p>
<ul>
<li><p>给客户端设置一个超时时间，当超过这个时间后服务器还未响应数据时即认为服务器已经崩溃。</p></li>
<li><p>心跳检测机制，给双方设置一个守护进程，定期发送心跳检测数据包，另一方需要进行回应。</p></li>
<li><p>在Linux Socket编程中，开启SO_KEEPALIVE参数。</p>
<blockquote>
<p>SO_KEEPALIVE的过程？</p>
<p>1、如果通信两端超过2个小时没有交换数据，那么开启keep-alive的一端会自动发一个keep-alive包给对端。 2、如果对端正常的回应ACK包，那么一切都没问题，再等个2小时后发包(如果这两个小时仍然没有数据交换)。 3、如果对端回应RST包，表明对端程序崩溃或重启，这边socket产生ECONNRESET错误，并且关闭。 4、如果对端一直没回应，这边会每75秒再发包给对端，总共发8次共11分钟15秒。最后socket产生 ETIMEDOUT 错误，并且关闭。或者收到ICMP错误，表明主机不可到达，则会产生 EHOSTUNREACH 错误。</p>
<p>SO_KEEPALIVE和心跳机制的区别？</p>
<p>SO_KEEPALIVE是实现在传输层的TCP协议，心跳实现在应用层实现，本质没有任何区别，但应用层需要自己来定义心跳包格式。</p>
</blockquote></li>
</ul>
<h5 id="服务器主机崩溃后重启">服务器主机崩溃后重启</h5>
<p>当服务器主机崩溃后重启时，它的TCP丢失了崩溃前的所有连接信息，因此服务器TCP对于所收到的来自客户的数据响应以一个RST，客户端进程返回ECONNRESET错误。</p>
<h5 id="服务器主机关机">服务器主机关机</h5>
<p>Unix系统关机时，init进程通常先给所有进程发送SIGTERM信号（该信号可被捕获），再等待一段固定的时间（一般在5~20秒之间），然后给所有仍在运行的进程发送SIGKILL信号（该信号不能被捕获）。</p>
<p>这么做是留给所有运行中的进程一小段时间来清除和终止。</p>
<p>如果不捕获SIGTERM信号并终止，服务器将由SIGKILL信号终止。当服务器进程终止时，它的所有打开着的描述字都被关闭，随后发生的步骤与服务器主机崩溃一样。</p>
<h4 id="tcp-粘包拆包">TCP 粘包、拆包</h4>
<p>产生的原因：</p>
<ul>
<li><p>粘包</p>
<p>1、发送端要发送的数据小于发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去</p>
<p>2、接收端应用层没有及时读取接收缓冲区中的数据</p></li>
<li><p>拆包</p>
<p>1、发送端要发送的数据大于发送缓冲区剩余空间大小</p>
<p>2、发送端待发送数据大于 MSS（最大报文长度）</p></li>
</ul>
<p>解决方案：</p>
<p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用层协议设计来解决。</p>
<ul>
<li><p>消息定长</p>
<p>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p></li>
<li><p>设置消息边界</p>
<p>接收端按消息边界分离出消息内容。比如可以在包尾增加特殊符号（回车换行符等）进行分割，例如 FTP 协议。</p></li>
<li><p>在消息头中设置消息的长度</p>
<p>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段。</p></li>
<li><p>Netty协议</p></li>
</ul>
<h4 id="参考资料">参考资料</h4>
<p>https://zhuanlan.zhihu.com/p/108822858（粘包、拆包）</p>
<p>https://www.nowcoder.com/questionTerminal/72fa8f3cb67e4711ba8eee581f8be92b（TCP异常断开）</p>
<p>https://zhuanlan.zhihu.com/p/79957519 （异常断开）</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>传输层</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>传输层</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL日志</title>
    <url>/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>日志是MySQL数据库的重要组成部分，记录着数据库运行期间各种状态信息。</p>
<a id="more"></a>
<h4 id="binlog">binlog</h4>
<ul>
<li><p><strong>概念</strong></p>
<p>binlog属于逻辑日志，用于<strong>记录数据库执行的写入性操作</strong>(不包括查询)信息，以二进制的形式保存在磁盘中。binlog是MySQL的逻辑日志，并且由Server层进行记录，使用任何存储引擎的MySQL数据库都会记录binlog日志。</p>
<blockquote>
<p>逻辑日志：可以简单理解为记录的就是sql语句。但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</p>
<p>物理日志：因为MySQL数据最终是保存在数据页中的，物理日志记录的就是数据页变更，即数据本身的值。</p>
</blockquote></li>
<li><p><strong>使用场景</strong></p>
<p>binlog的主要使用场景有两个，分别是<strong>主从复制</strong>和<strong>数据恢复</strong>。</p>
<p>主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端重放binlog从而达到主从数据一致。</p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/3.png" style="zoom:50%;"></p>
<p>数据恢复：通过使用MySQL binlog工具来恢复数据。</p></li>
<li><p><strong>产生时机</strong></p>
<p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p></li>
<li><p><strong>释放时机</strong></p>
<p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p></li>
<li><p>binlog记录方式</p>
<p>binlog是通过追加的方式进行写入的，可以通过max_binlog_size参数设置每个binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p></li>
</ul>
<h4 id="redo-log">redo log</h4>
<ul>
<li><p><strong>概念</strong></p>
<p>redo log属于物理日志，记录事务<strong>对数据页做了哪些修改</strong>。</p>
<blockquote>
<p>InnoDB的修改数据的基本流程</p>
<p>当我们想要修改DB上某一行数据的时候，InnoDB是把数据从磁盘读取到内存的缓冲池上进行修改。</p>
<p>这个时候数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为<strong>脏页</strong>。</p>
<p>InnoDB对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，这样会产生海量的IO操作，严重影响InnoDB的处理性能。</p>
<p>既然脏页与磁盘中的数据存在差异，那么如果在这期间DB出现故障就会造成数据的丢失。为了解决这个问题，redo log就应运而生了。</p>
</blockquote>
<p>redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。</p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/1.png" style="zoom:67%;"></p>
<p>mysql每执行一条DML语句，先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file。这种先写日志，再写磁盘的技术就是MySQL里经常说到的WAL(Write-Ahead Logging) 技术。</p></li>
<li><p><strong>使用场景</strong></p>
<p>redo log <strong>防止DB出现故障造成数据的丢失</strong>。当出现故障导致脏页还未来得及保存进磁盘时，通过redo log进行重做，从而达到事务的持久性这一特性。</p></li>
<li><p><strong>产生时机</strong></p>
<p>事务开始之后就产生redo log。</p></li>
<li><p><strong>释放时机</strong></p>
<p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p></li>
<li><p><strong>redo log记录方式</strong></p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/0.png" style="zoom:50%;"></p>
<p>redo log实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此redo log实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。</p>
<p>checkpoint所做的事就是把脏页给刷新回磁盘。所以，当DB重启恢复时，只需要恢复checkpoint之后的数据。这样就能大大缩短恢复时间。</p>
<p>check point到write pos之间是redo log待落盘的数据页更改记录。</p>
<p>write pos到check point之间的部分是redo log空着的部分，用于记录新的记录。</p>
<p>当write pos追上check point时，会先推动check point向前移动，空出位置再记录新的日志。</p></li>
<li><p><strong>redo log写入磁盘的时机</strong>（buffer到file的时机）</p>
<p>MySQL支持三种将redo log buffer写入redo log file的时机，可以通过innodb_flush_log_at_trx_commit参数配置，各参数值含义如下：</p>
<p>0（延迟写）</p>
<p>事务提交时不会将redo log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到redo log file中。也就是说<strong>设置为0时是(大约)每秒刷新写入到磁盘中的</strong>，当系统崩溃，会丢失1秒钟的数据。</p>
<p>1（实时写，实时刷）</p>
<p>事务每次提交都会将redo log buffer中的日志写入os buffer并调用fsync()刷到redo log file中。这种方式即使系统崩溃也不会丢失任何数据，但是因为<strong>每次提交都写入磁盘</strong>，IO的性能较差。</p>
<p>2（实时写，延迟刷）</p>
<p>每次<strong>提交都仅写入</strong>到os buffer，然后是<strong>每秒调用</strong>fsync()将os buffer中的日志写入到redo log file。</p></li>
</ul>
<h4 id="undo-log">undo log</h4>
<ul>
<li><p>概念</p>
<p><img src="/2021/04/02/MySQL_%E6%97%A5%E5%BF%97/2.png" style="zoom: 67%;"></p>
<p>undo log属于逻辑日志，保存了事务发生之前的<strong>数据的一个版本</strong>，可以用于回滚。其实本质上，老旧的记录就形成了undo log。</p></li>
<li><p>使用场景</p>
<p>多版本并发控制协议MVCC中，通过undo log形成记录的多个版本，能执行快照读时能够判断读取的是哪个版本的记录。</p></li>
<li><p>产生时机</p>
<p>不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表。</p></li>
<li><p>释放时机</p>
<p>当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo log上的旧版本，决定是否可以清理undo log的日志空间。</p></li>
</ul>
<h4 id="三者区别">三者区别</h4>
<table>
<colgroup>
<col style="width: 4%">
<col style="width: 31%">
<col style="width: 31%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>binlog</th>
<th>redo log</th>
<th>undo log</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>记录内容</td>
<td>用于<strong>记录数据库执行的写入性操作</strong>(不包括查询)信息，以二进制的形式保存在磁盘中。</td>
<td>记录事务<strong>对数据页做了哪些修改</strong>。</td>
<td>保存了事务发生之前的<strong>数据的一个版本</strong>，可以用于回滚。其实本质上，老旧的记录就形成了undo log。</td>
</tr>
<tr class="even">
<td>日志类型</td>
<td>逻辑日志</td>
<td>物理日志</td>
<td>逻辑日志</td>
</tr>
<tr class="odd">
<td>使用场景</td>
<td><strong>主从复制</strong>和<strong>数据恢复</strong>。主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端重放binlog从而达到主从数据一致。数据恢复：通过使用MySQL binlog工具来恢复数据。</td>
<td>redo log <strong>防止DB出现故障造成数据的丢失</strong>。当出现故障导致脏页还未来得及保存进磁盘时，通过redo log进行重做，从而达到事务的持久性这一特性。</td>
<td>多版本并发控制协议<strong>MVCC中的快照读</strong>，通过undo log形成记录的多个版本，能执行快照读时能够判断读取的是哪个版本的记录。</td>
</tr>
</tbody>
</table>
<p><strong>redo log 和 bin log 区别</strong></p>
<p>作用不同：redo log是保证事务的持久性的，binlog主要用于主从复制。</p>
<p>内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</p>
<p>产生时机不同：事务开始之后就产生redo log，事务提交的时候产生bin log。</p>
<p>释放时机不同：当对应事务的脏页写入到磁盘之后，redo log可以被移除，超过一定时间后，binlog被删除。</p>
<p>恢复效率：基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog。</p>
<p>先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<h4 id="参考资料">参考资料</h4>
<p>https://cloud.tencent.com/developer/article/1679325</p>
<p>https://www.cnblogs.com/wy123/p/8365234.html</p>
<p>https://zhuanlan.zhihu.com/p/35355751</p>
<p>https://www.cnblogs.com/xuwc/p/13873611.html</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>海量数据问题</title>
    <url>/2021/04/14/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>海量数据问题，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大导致无法一次性装入内存。</p>
<a id="more"></a>
<h3 id="基础">基础</h3>
<h4 id="换算单位">换算单位</h4>
<ul>
<li>1 byte = 8 bit</li>
<li>1 KB = <span class="math inline">\(2^{10}\)</span> byte = 1024 byte ≈ <span class="math inline">\(10^3\)</span> byte</li>
<li>1 MB = <span class="math inline">\(2^{20}\)</span> byte ≈ <span class="math inline">\(10^6\)</span> byte</li>
<li>1 GB = <span class="math inline">\(2^{30}\)</span> byte ≈ <span class="math inline">\(10^9\)</span> byte</li>
<li>1 千万 = <span class="math inline">\(10^7\)</span></li>
<li>1 亿 = <span class="math inline">\(10^8\)</span></li>
</ul>
<p>1 个整数占 4 byte，1 亿个整数占 4*<span class="math inline">\(10^8\)</span> byte ≈ 400 MB。</p>
<h4 id="位图bitmap">位图(bitmap)</h4>
<p>用一个bit位来标记某个元素对应的值。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p>
<p>想知道某个元素出现过没有。如果为每个所有可能的值分配1个bit。</p>
<p>但对于海量的、取值分布很均匀的集合进行<strong>去重</strong>，Bitmap极大地压缩了所需要的内存空间。于此同时，还额外地完成了对原始数组的<strong>排序工作</strong>。</p>
<p>统计数字出现的次数。</p>
<h4 id="bloom-filter布隆过滤器">Bloom Filter(布隆过滤器)</h4>
<h4 id="trie树">trie树</h4>
<p>前缀统计，词频统计。</p>
<h4 id="外部排序">外部排序</h4>
<p>大数据的排序，去重。</p>
<p>1、首先按内存大小，将外存上的文件分成若干子文件。</p>
<p>2、依次读入内存并利用有效的内部排序对他们进行排序，并将排序后得到的有序字文件重新写入外存，通常称这些子文件为归并段。</p>
<p>3、对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件。</p>
<p>外排序的优化方法：置换选择 败者树原理，最优归并树。</p>
<h3 id="常用解决方案">常用解决方案</h3>
<p>1、分而治之/hash映射 + hash统计 + 堆/快速/归并排序； 2、Bitmap去重；</p>
<p>当分而治之（hash映射）出现数据倾斜：改变hash函数再次进行映射。</p>
<p>找数字的去重用位图，字符串去重用HashSet。</p>
<h4 id="海量数据去重">海量数据去重</h4>
<p>数字去重使用位图bitmap，字符串去重HashSet。</p>
<h4 id="n个数求前k大">N个数求前K大</h4>
<p>1、排序算法。 2、计数排序，开辟一个大数组，记录每个整数是否出现，从大到小取。（bitmap） 3、维护一个大小为k的小顶堆。</p>
<h4 id="求文件a中没有但b中有的单词">求文件A中没有但B中有的单词</h4>
<p>遍历文件A，将文件hash到n个小文件中，对B文件同样操作。然后对于每一对文件，先将一个文件存入HashSet，对另一个文件遍历判断。</p>
<h4 id="海量数据排序问题">海量数据排序问题</h4>
<p>hash到小文件中（其实直接切分成若干小文件也行），然后先在小文件排序。</p>
<p>然后合并的时候，用堆，每个小文件取一个，然后最小的拿走再加入对应文件的数字，直到结束。</p>
<p>又或者直接对多个小文件进行归并排序。</p>
<h4 id="海量数据出现次数最多数据">海量数据出现次数最多数据</h4>
<p>分而治之/hash映射（相同数据被分到一起） + HashMap统计 + 堆/快速/归并排序；</p>
<h3 id="面试题">面试题</h3>
<h4 id="字符串统计次数海量日志数据提取出某日访问百度次数最多的那个ip">字符串统计次数：海量日志数据，提取出某日访问百度次数最多的那个IP</h4>
<p><strong>算法思想：分而治之+Hash统计+排序</strong></p>
<p>IP地址最多有<span class="math inline">\(2^{32}\)</span>种取值情况，即约40亿种取值。每个ip地址是32位，因此是一个ip地址大小为4 byte。所以所有ip地址的大小为 <span class="math inline">\(40*10^8*4 byte= 16GB\)</span>， 不能完全加载到内存中处理。</p>
<p>1、按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含<span class="math inline">\(2^{22}=4*2^{20}\)</span>个IP地址，即约400万个ip地址，每个小文件大小为<span class="math inline">\(4*2^{20}*4bytes=16MB\)</span>。</p>
<p>2、对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址。</p>
<p>3、可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP。</p>
<h4 id="top-k统计最热门的10个查询串">TOP K：统计最热门的10个查询串</h4>
<p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p><strong>算法思想：hashmap+堆</strong></p>
<p>去重后300万个查询串的大小最大为<span class="math inline">\(3*10^6*255byte = 765MB\)</span>，可以放入内存当中，构建HashMap统计次数时，value为整型，因此value所占的空间大小为<span class="math inline">\(3*10^6*4byte=12MB\)</span>，因此总内存可以装载这个HashMap。</p>
<p>1、先对这批海量数据预处理，在O(N)的时间内用Hash表完成统计； 2、借助堆这个数据结构，找出Top K，时间复杂度为O(N*logK)。</p>
<h4 id="数字找不重复数字统计次数海量数据找出不重复的整数">数字找不重复/数字统计次数：海量数据找出不重复的整数</h4>
<p>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</p>
<p><strong>算法思想：bitmap位图去重/统计次数</strong></p>
<p>1、2-Bitmap，每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义，共需内存<span class="math inline">\(2^{32} * 2 bit = 2^{32} * 0.25 byte =1 GB\)</span>内存。</p>
<p>2、然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。</p>
<p>3、扫描完成后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>如果需要统计数字出现的次数，则只需要增加bitmap中每一位的bit数即可。</p>
<h4 id="找重复找出ab文件共同的url">找重复：找出a、b文件共同的url</h4>
<p>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url。</p>
<p><strong>算法思想：分而治之 + HashSet去重</strong></p>
<p>每个文件的大小约为<span class="math inline">\(50*10^8*64byte=64*5GB\)</span>，无法放入内存种。</p>
<p>1、遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件。</p>
<p>2、这样处理后，所有可能相同的url都在对应的小文件中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p>
<p>3、求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p>
<h4 id="外部排序10个文件按照query频度排序">外部排序：10个文件，按照query频度排序</h4>
<p>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求按照query的频度排序。</p>
<p><strong>算法思想：分而治之 + hash统计 + 内外排序</strong></p>
<p>1、顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件中。这样新生成的文件每个的大小大约也1G，大于1G的更换哈希函数继续进行切分。</p>
<p>2、找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用排序算法按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件。</p>
<p>3、对这10个文件进行归并排序。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://wangpengcheng.github.io/2019/12/17/hailiangshuju_problems/</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>海量数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>海量数据</tag>
      </tags>
  </entry>
  <entry>
    <title>树结构</title>
    <url>/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/</url>
    <content><![CDATA[<p>B树、B+树、红黑树、满二叉树、完全二叉树</p>
<a id="more"></a>
<h3 id="b树">B树</h3>
<p>B树即平衡多路查找树。是一种自平衡的数据结构，能对存储的数据进行<span class="math inline">\(O(log n)\)</span>的时间复杂度进行查找、插入和删除。平衡的方式是插入和删除数据会对节点进行分裂和合并。每个节点内存储的就是真实的数据，数据是有序的。B树的特点（优点）是：</p>
<p>1、有<strong>自平衡</strong>的操作，能够解决树结构退化成链表的问题，降低树的深度，提高查询性能。</p>
<p>2、一个节点内部<strong>存储了多个数据</strong>，且数据有序，能够提高磁盘IO的性能。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/2.png" style="zoom: 80%;"></p>
<h4 id="b树的性质">B树的性质</h4>
<p>B树的阶数表示了一个节点最多有多少个孩子节点，用字母m表示阶数。 1、每个节点最多有m-1个值（可以存有的键值对）。 2、根节点最少可以只有1个值，非根节点至少有ceil(m/2)个值。 3、每个节点中的值都按照从小到大的顺序排列，每个值的左子树中的所有值都小于它，而右子树中的所有值都大于它。 4、所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 5、每个节点都存有索引和数据，也就是对应的key和value。</p>
<blockquote>
<p>2-3-4 树，就是阶为4的B树，其中节点和存储的元素符合如下性质要求： 任一节点只能是 2 度节点、3 度节点或 4 度节点，不存在元素数为 0 的节点。 2 度节点：如果节点只包含 1 个元素，那它将只能有 2 个子节点； 3 度节点：如果节点只包含 2 个元素，那它将只能有 3 个子节点； 4 度节点：如果节点只包含 3 个元素，那它将只能有 4 个子节点；</p>
</blockquote>
<h4 id="b树插入">B树插入</h4>
<p>判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，以节点的中间的key为标准，将这个节点分为左右两部分，中间的值放到父节点中即可。</p>
<h4 id="b树删除">B树删除</h4>
<p>1）如果当前需要删除的key位于非叶子结点上，则用后继key覆盖要删除的key（后继key指的是大于该数值的下一个值，比如27的后继就是28，28在叶子节点上）。然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上。删除这个记录后执行第2步</p>
<p>2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。</p>
<p>3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。</p>
<p>​ 否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了 一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。</p>
<h3 id="b树-1">B+树</h3>
<p>B+树是B树的改进，也是一种多路平衡查找树，内部的数据稳定有序，每个节点通常有多个孩子，所有叶子节点通过链表连接在一起。时间复杂度与树的高度有关，能对存储的数据以<span class="math inline">\(O(log n)\)</span>的时间复杂度进行查找、插入和删除。非叶子节点处存储的是索引，叶子节点处才存储真正的数据。B+树的特点（优点）是：</p>
<p>1、B+树的磁盘读写代价更低</p>
<p>B+的非叶子结点并没有存储真正的数据，而<strong>存储的是索引</strong>，因此其非叶子结点相对B树更小，能够容纳的索引数量越多，一次性读入内存中能够查找的数据也就越多，相对来说IO读写次数也就降低了。</p>
<p>2、B+树的数据信息遍历更加方便（基于范围的查询）</p>
<p>B+树只要通过<strong>叶子节点上的链表</strong>，就可以遍历所有叶子节点，从而实现整棵树的遍历，而B树不支持这样的操作（或者说效率太低），而且在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+树。</p>
<p>3、B+树的查询效率更加稳定</p>
<p>B+树中非叶子节点仅存储索引，B树中非叶子节点既存储索引，也存储指向真实数据的指针。所以B+树种任何查询必须走一条从根结点到叶子结点。所有查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/3.png" style="zoom: 50%;"></p>
<h4 id="b树的性质-1">B+树的性质</h4>
<p>B+数的高度h，假设当前数据表的数据为N，每个磁盘页可存放的数据项的数量是m，则树的高度约为<span class="math inline">\(log_{m+1} N\)</span>。</p>
<h3 id="红黑树">红黑树</h3>
<p>是二叉搜索树的一种，他并不是完美平衡的，而是黑色节点完美平衡的，也就是每个节点到叶子节点上都有数量相同的黑色节点。它可以在<span class="math inline">\(O(logn)\)</span>时间内做查找，插入和删除，这里的n是树中元素的数目。红黑树的特点（优点）是：</p>
<p>1、 红黑树的约束条件确保没有一条路径会比其他路径长2倍，使得红黑树大致上是一种平衡的树型结构。</p>
<p>2、相比于AVL树来说，红黑树的因为只需要保证黑色节点平衡，因此维护的代价比AVL树要低。</p>
<blockquote>
<p>为什么有AVL树还要红黑树？ 因为AVL树要求子树的高度差都小于等于1，太过严格的要求导致每次插入或删除几乎都要调整树的结构，大量操作时维护代价太高。</p>
</blockquote>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/4.png" style="zoom:67%;"></p>
<h4 id="红黑树的性质">红黑树的性质</h4>
<p>1、每个节点或者是黑色，或者是红色。 2、根节点是黑色。 3、每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！] 4、如果一个节点是红色的，则它的子节点必须是黑色的。 5、从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<h4 id="红黑树的插入">红黑树的插入</h4>
<p>自平衡的方法为变色、左旋、以及右旋。</p>
<p>插入节点必为红色，首先找到它在叶子节点的位置，若父为黑直接插入，若父为红则需要调整： if 叔叔存在且为红 红黑红，叔叔黑（变色） if 叔叔不存在或为黑： if 父为左孩子： if 子为左孩子： LL双红，变色红黑红，右旋 if 子为右孩子： LR双红，左旋变LL双红，变色红黑红，右旋 if 父为右孩子： 。。。镜像操作</p>
<h3 id="满二叉树">满二叉树</h3>
<p>满二叉树，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/5.png" style="zoom:50%;"></p>
<h4 id="满二叉树性质">满二叉树性质</h4>
<p>1、一个层数为k 的满二叉树总结点数为：<span class="math inline">\(2^k-1\)</span>，k从1开始，因此满二叉树节点数总是为奇数。</p>
<p>2、第i层上的节点数为：<span class="math inline">\(2^{i-1}\)</span>，i从1开始。</p>
<h3 id="完全二叉树">完全二叉树</h3>
<p>在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/6.png" style="zoom: 43%;"></p>
<h4 id="完全二叉树性质">完全二叉树性质</h4>
<p>具有n个节点的完全二叉树的深度为<span class="math inline">\(log_2n+1\)</span>。深度为k的完全二叉树，k从1开始，总的节点数至少有<span class="math inline">\(2^{k-1}\)</span>个，至多有<span class="math inline">\(2^k-1\)</span>个。</p>
<h3 id="avl树">AVL树</h3>
<p>平衡二叉树树，任意节点的子树的高度差都小于等于1，通过旋转操作来保证平衡性。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://www.cnblogs.com/nullzx/p/8729425.html （B树操作）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>可以按照复杂度将排序算法进行分类。<span class="math inline">\(O(nlogn)\)</span>：快速排序、归并排序、堆排序；<span class="math inline">\(O(n^2)\)</span> ：冒泡排序、简单选择排序、直接插入排序、希尔排序；<span class="math inline">\(O(n)\)</span>：计数排序、桶排序、基数排序。</p>
<a id="more"></a>
<h3 id="onlogn"><span class="math inline">\(O(nlogn)\)</span></h3>
<h4 id="快速排序">快速排序</h4>
<p>通过一趟排序将数值分隔成独立的两部分，其中一部分均比另一部分小，然后再分别对这两部分记录继续进行排序，以达到整个序列有序。改进方法之一是</p>
<ul>
<li><p>时间复杂度。</p>
<p>最优的情况下时间复杂度为<span class="math inline">\(O( nlogn )\)</span>：主元每次都刚好平分整个数组。</p>
<p>最差的情况下时间复杂度为<span class="math inline">\(O( n^2 )\)</span>：主元每次就是数组中最小/最大的，即冒泡排序。每一次都排好一个元素的顺序)</p></li>
<li><p>空间复杂度。</p>
<p>首先就地快速排序使用的空间是<span class="math inline">\(O(1)\)</span>的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据。</p>
<p>最优的情况下空间复杂度为：<span class="math inline">\(O(logn)\)</span>；每一次都平分数组的情况。</p>
<p>最差的情况下空间复杂度为：<span class="math inline">\(O( n )\)</span> ；退化为冒泡排序的情况。</p></li>
</ul>
<p>递归算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[low];</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[low] = arr[i];</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i的位置就是主元的位置</span></span><br><span class="line"></span><br><span class="line">    quickSort(arr, low, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, i+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>非递归 使用栈来实现，通过不断将left和right压入栈中，模拟递归的操作。双指针法部分不需要发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;;</span><br><span class="line">    </span><br><span class="line">    stack.push(left);</span><br><span class="line">    stack.push(right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        right = stakc.pop();</span><br><span class="line">        left = stack.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = partition(array, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &lt; pivot - <span class="number">1</span>)&#123;</span><br><span class="line">            stack.push(left);</span><br><span class="line">            stack.push(pivot - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &gt; pivot + <span class="number">1</span>)&#123;</span><br><span class="line">            stack.push(pivot+<span class="number">1</span>);</span><br><span class="line">            stack.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序">归并排序</h4>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/0.png" style="zoom:67%;"></p>
<p>将已有序的子序列合并，得到完全有序的序列。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<ul>
<li><p>时间复杂度</p>
<p>归并排序平均时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最好时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> [] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        MergeSort(arr, low, mid);<span class="comment">//对左边排序</span></span><br><span class="line">        MergeSort(arr, mid+<span class="number">1</span>, high);<span class="comment">//对右边排序</span></span><br><span class="line"></span><br><span class="line">        merge(arr, low, high); <span class="comment">// 合并两个有序数组</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂存数组</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low +<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[j])&#123;</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制剩余的，注意是while！！</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) tmp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; tmp.length; l++)&#123;</span><br><span class="line">        arr[low+l] = tmp[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归 实际上就是每次将2个长度为k的子序列合并为1个。k从1开始，每次递增2倍，直到k超过数组长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k &lt; len)&#123;</span><br><span class="line">        <span class="comment">//每次将2个长度为k的子序列合并为1个</span></span><br><span class="line">        MergePass(array, k, len);</span><br><span class="line">        k = k*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次将2个长度为k的子序列合并为1个</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= len - <span class="number">2</span>*k; i = i + <span class="number">2</span>*k )&#123;</span><br><span class="line">        merge(array, i, i+ <span class="number">2</span>*k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果落单的元素数目超过k，但又不到2k，也是可以两两合并的</span></span><br><span class="line">    <span class="comment">//如果落单的元素数目不超过k，则已经有序</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; n - k)</span><br><span class="line">    &#123;</span><br><span class="line">        merge(array, i, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>]; <span class="comment">//新建一个数组用来暂存</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = (low+high)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//二路归并</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= (low+high)/<span class="number">2</span> || j &lt;= high )&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; array[j])&#123;</span><br><span class="line">            tmp[k] = array[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k] = array[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩余拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= (low+high)/<span class="number">2</span>) tmp[k++] = array[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) tmp[k++] = array[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; tmp.length; l++ )&#123;</span><br><span class="line">        array[low + l] = tmp[l];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序">堆排序</h4>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/1.png" style="zoom: 50%;"></p>
<p>堆，就是一个普通的二叉树，只不过它需要满足的条件是左右子节点都要大于或小于父节点，它复杂度不变的原因就在于它不会像二叉搜索树那样要求左小右大，且它能够调整元素位置，因此不会退化为链表。</p>
<ul>
<li><p>时间复杂度</p>
<p>堆排序平均时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最好时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。 堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树（不会退化为链表）的可以得出它在任何情况下时间复杂度均是<span class="math inline">\(O(nlogn)\)</span>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len;<span class="comment">//表示数组中堆的有效范围</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建最小堆</span></span><br><span class="line">    buildHeap(array);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不断地缩小</span></span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">//交换堆顶和最后一个元素，</span></span><br><span class="line">        <span class="keyword">int</span> tmp = array[len];</span><br><span class="line">        array[len] = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//缩短堆的范围</span></span><br><span class="line">        len--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从堆顶开始向下调整</span></span><br><span class="line">        adjustHeap(<span class="keyword">int</span>[] array, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最终得到的结果是一个降序排列的数组！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断本节点，与左右子节点谁小，将小的交换到父节点位置，递归往下调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parent)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leastIndex = parent; <span class="comment">//记录最小值的下标</span></span><br><span class="line">    <span class="keyword">int</span> left = parrent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = parrent*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有左孩子，且小于父节点</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; len &amp;&amp; array[left] &lt; array[parent])</span><br><span class="line">        leastIndex = left;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; len &amp;&amp; array[right] &lt; array[parent])</span><br><span class="line">        leastIndex = right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="keyword">if</span>(leastIndex != parent)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tmp = array[parent];</span><br><span class="line">        array[parent] = array[leastIndex];</span><br><span class="line">        array[leastIndex] = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//继续往下调整</span></span><br><span class="line">        adjustHeap(array, leastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上构建最小堆，从第一个非叶子节点开始往上逐步调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        adjustHeap(array, i);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="on2"><span class="math inline">\(O(n^2)\)</span></h3>
<h4 id="冒泡排序">冒泡排序</h4>
<p>比较相邻的元素。如果前一个比后一个大，就交换它们两个；</p>
<ul>
<li><p>时间复杂度</p>
<p>冒泡排序平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最好时间复杂度为<span class="math inline">\(O(n)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p></li>
</ul>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/4.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BubbleSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示比较次数，实际上就已经是n-1趟</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> swap = <span class="keyword">false</span>; <span class="comment">//不再发生交换就可以退出        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123; <span class="comment">//注意-1-i</span></span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                 <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                 array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                 array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                 swap = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!swap)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单选择排序">简单选择排序</h4>
<p>每次都选择最大或最小的元素和起始位置交换</p>
<ul>
<li><p>时间复杂度</p>
<p>简单选择排序平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最好时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> minIndex = i;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; array.length; j++)&#123; <span class="comment">//找到最小的元素</span></span><br><span class="line">             <span class="keyword">if</span>(array[j] &lt; array[minIndex])</span><br><span class="line">                 minIndex = j;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//和序列头部交换</span></span><br><span class="line">         <span class="keyword">int</span> tmp = array[i];</span><br><span class="line">         array[i] = array[minIndex];</span><br><span class="line">         array[minIndex] = array[i];</span><br><span class="line">         </span><br><span class="line">     &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="直接插入排序">直接插入排序</h4>
<p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。（从后往前）注意直接插入排序能够保持元素的相对顺序。</p>
<ul>
<li><p>时间复杂度</p>
<p>直接插入排序平均时间复杂度为<span class="math inline">\(O(n^2)\)</span>，最好时间复杂度为<span class="math inline">\(O(n)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p></li>
</ul>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/3.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> current = array[i];<span class="comment">//未排序元素下标</span></span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;<span class="comment">//已经排序的元素下标</span></span><br><span class="line">       <span class="keyword">while</span>( preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; current)&#123; <span class="comment">//从小到大排序</span></span><br><span class="line">           array[preIndex+<span class="number">1</span>] = array[preIndex];</span><br><span class="line">           preIndex--;</span><br><span class="line">       &#125; </span><br><span class="line">        </span><br><span class="line">        array[preIndex + <span class="number">1</span>] = current; <span class="comment">//找到合适的位置插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array; <span class="comment">//改进方法是在有序区内使用二分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序onlogn">希尔排序(<span class="math inline">\(O(nlogn)\)</span>)</h4>
<p>直接插入排序的改进版，整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成），对子序列分别进行直接插入排序，然后缩减增量为之前的一半再进行排序。gap初始值一般取 len / 2。</p>
<ul>
<li><p>时间复杂度</p>
<p>希尔排序平均时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最好时间复杂度为<span class="math inline">\(O(nlogn)\)</span>，最坏时间复杂度为<span class="math inline">\(O(nlogn)\)</span>。</p></li>
</ul>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/2.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> gap = array.length / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; array.length; i++)</span><br><span class="line">            <span class="keyword">int</span> current = array[i];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; current)&#123;</span><br><span class="line">                array[preIndex + gap] = array[preIndex];</span><br><span class="line">                preIndex = preIndex - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            array[preIndex + gap] = current; <span class="comment">// 插入元素</span></span><br><span class="line">        &#125;        </span><br><span class="line">        gap = gap / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="on"><span class="math inline">\(O(n)\)</span></h3>
<h4 id="计数排序">计数排序</h4>
<p>将数值转化为键存储在额外的有序空间中，并统计各个元素出现多少次。</p>
<ul>
<li><p>时间复杂度</p>
<p>计数排序平均时间复杂度为<span class="math inline">\(O(n + k)\)</span>，最好时间复杂度为<span class="math inline">\(O(n + k)\)</span>，最坏时间复杂度为<span class="math inline">\(O(n + k)\)</span>。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。</p></li>
<li><p>空间复杂度</p>
<p>计数排序空间复杂度为<span class="math inline">\(O(k)\)</span>，k为桶数组的长度。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span> [] array)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计最大值和最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; min)</span><br><span class="line">            min = array[i];</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; max)</span><br><span class="line">            max = array[i];    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用偏移量进行计数</span></span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.length; i++)        </span><br><span class="line">        bucket[ array[i] - min ]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a_index = <span class="number">0</span>, b_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a_index &lt; array.length)&#123;</span><br><span class="line">        <span class="comment">//如果桶不是空的</span></span><br><span class="line">        <span class="keyword">if</span>(bucket[b_index] != <span class="number">0</span>)&#123;</span><br><span class="line">            array[a_index] = min+b_index;<span class="comment">//数组当前位置有值</span></span><br><span class="line">            bucket[b_index]--;</span><br><span class="line">            a_index++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b_index++;<span class="comment">//移动桶的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="桶排序">桶排序</h4>
<p>桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。 桶排序平均时间复杂度为O(n + k)</p>
<h4 id="基数排序-radix-sort">基数排序 radix sort</h4>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先统计最多有多少位</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        max = max/<span class="number">10</span>;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">1</span>;<span class="comment">//除数，每次去除最低位</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//给十进制每一位赋予一个桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        bucket.add( <span class="keyword">new</span> ArrayList&lt;Integer&gt;() );</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//从低位到高位遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++)&#123;</span><br><span class="line">        <span class="comment">//统计  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++)&#123;</span><br><span class="line">             <span class="comment">//计算当前位数是几</span></span><br><span class="line">             <span class="keyword">int</span> num = (array[j]/div)%<span class="number">10</span>;</span><br><span class="line">             <span class="comment">//放入桶中</span></span><br><span class="line">             bucket.get(num).add(array[j]);   </span><br><span class="line">        &#125;</span><br><span class="line">        div = div * <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历桶，收集</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.size(); j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucket.get(j).size();k++)</span><br><span class="line">                array[index++] = bucket.get(j).get(k);</span><br><span class="line">            bucket.get(j).clear();<span class="comment">//清空    </span></span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="稳定性">稳定性</h3>
<p>假定在待排序的序列中，存在多个具有相同数值的记录，若经过排序，这些记录的相对次序保持不变，则排序算法是稳定的。</p>
<p><img src="/2021/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F/5.png" style="zoom:50%;"></p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/u013309870/article/details/68578011</p>
<p>https://www.jianshu.com/p/47170b1ced23</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark闭包、累加器和广播变量</title>
    <url>/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="总结">总结</h3>
<ul>
<li><p>闭包</p>
<p>闭包<strong>就是一个携带了外部作用域的函数</strong>，当它需要被分发到各个节点上执行的时候，需要外部作用域所在的对象是可序列化的。</p>
<p>使用这种外部变量的形式，会造成每个Task中都存在一个该变量的副本。</p></li>
</ul>
<a id="more"></a>
<ul>
<li><p>广播变量</p>
<p>广播变量是一种变量，广播变量允许开发者将一个 <code>Read-Only</code> 的变量<strong>缓存到集群中每个节点中</strong>，而不是传递给每一个 Task 一个副本，每个Executor中只会存在一个副本。</p>
<ul>
<li><p>解决了外部变量在每个Task中都存在副本的问题，每个Executor只会存在一份广播变量的副本，节省空间。</p></li>
<li><p>在Driver端可以修改广播变量的值，<strong>在Executor端无法修改广播变量的值。</strong></p></li>
<li><p>广播变量只能在Driver端定义，不能在Executor端定义。</p></li>
<li><p>不能将RDD广播，因为RDD是不存储数据的。可以将RDD的结果广播出去。</p></li>
</ul></li>
<li><p>累加器</p>
<p>累加器是一个<strong>支持添加操作的分布式变量</strong>，可以在分布式环境下保持一致性。</p>
<ul>
<li>累加器在Driver端定义赋初始值，累加器只能在Driver端读取最后的值，在Excutor端更新。</li>
<li>在Driver端可以修改广播变量的值，<strong>在Executor端可以修改累加器的值。</strong></li>
</ul></li>
</ul>
<h3 id="闭包">闭包</h3>
<p>如果一个函数<strong>携带了外部的作用域</strong>，这种<strong>函数称为闭包</strong>。</p>
<p>在Scala中，函数是一个对象，继承自FunctionN。</p>
<h4 id="问题引出">问题引出</h4>
<p>在spark中实现统计List(1,2,3)的和。如果使用下面的代码，程序打印的结果不是6，而是0。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">      <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> rdd = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">      <span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line">      <span class="comment">//warn: don&#x27;t do this</span></span><br><span class="line">      rdd.foreach(x =&gt; counter += x)</span><br><span class="line">      println(<span class="string">&quot;Counter value: &quot;</span>+counter) <span class="comment">//打印结果为0</span></span><br><span class="line"></span><br><span class="line">      sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题分析： counter是在foreach函数外部定义的，也就是在driver程序中定义，而foreach函数是属于rdd对象的，rdd函数的执行位置是各个worker节点（或者说worker进程），main函数是在driver节点上（或者说driver进程上）执行的。所以当counter变量在driver中定义，被在rdd中使用的时候，出现了变量的跨域问题，也就是闭包问题。</p>
<p>问题解释： 对于上面程序中的counter变量，由于在main函数和在rdd对象中foreach函数是属于不同作用域的，所以，传进foreach中的counter是一个副本，初始值都为0。foreach中叠加的是counter的副本，不管副本如何变化，都不会影响到main函数中的counter，所以最终打印出来的counter为0。</p>
<h4 id="解决方案">解决方案</h4>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>())</span><br><span class="line">    <span class="keyword">val</span> newRDD = sc.textFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    newRDD.map(data =&gt; &#123;</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      println(data.toString)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在RDD的函数中调用了在函数外部定义的对象，这些对象需要通过网络从driver所在节点传给其他的worker节点，所以<strong>要求这些类是可序列化的</strong>，比如在Java或者Scala中实现Serializable类。Worker节点接收到程序之后，在Spark资源管理器的指挥下运行RDD程序。不同Worker节点之间的运行操作是并行的。</p>
<p><img src="/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/0.png" style="zoom:67%;"></p>
<p>除了用外部定义的对象来实现类似的功能，Spark还另外提供了两种机制，分别是<strong>Broadcast</strong>和<strong>Accumulator</strong>。</p>
<p>相比于外部变量的方式，在一定场景下使用Broadcast比较有优势，因为所广播的数据在每一个Worker节点上面只存一个副本，而在Spark算子中使用到的外部变量会在每一个用到它的Task中保存一个副本，即使这些task在同一个节点上面。所以当数据量比较大的时候，建议使用广播而不是外部变量。</p>
<h3 id="广播变量">广播变量</h3>
<p>广播变量是一种变量，广播变量允许开发者将一个 <code>Read-Only</code> 的变量缓存到集群中每个节点中, 而不是传递给每一个 Task 一个副本，每个Executor中只会存在一个副本。</p>
<p>变量一旦被定义为一个广播变量，那么这个变量只能读，不能修改。</p>
<p><img src="/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/2.png" style="zoom:50%;"></p>
<h4 id="广播变量的使用">广播变量的使用</h4>
<h5 id="创建广播变量">创建广播变量</h5>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> b = sc.broadcast(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>如果 Log 级别为 DEBUG 的时候, 会打印如下信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEBUG BlockManager: Put block broadcast_0 locally took  430 ms</span><br><span class="line">DEBUG BlockManager: Putting block broadcast_0 without replication took  431 ms</span><br><span class="line">DEBUG BlockManager: Told master about block broadcast_0_piece0</span><br><span class="line">DEBUG BlockManager: Put block broadcast_0_piece0 locally took  4 ms</span><br><span class="line">DEBUG BlockManager: Putting block broadcast_0_piece0 without replication took  4 ms</span><br></pre></td></tr></table></figure>
<h5 id="使用-value-获取数据">使用 <code>value</code> 获取数据</h5>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">b.value</span><br></pre></td></tr></table></figure>
<p>获取数据的时候会打印如下信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEBUG BlockManager: Getting local block broadcast_0</span><br><span class="line">DEBUG BlockManager: Level for block broadcast_0 is StorageLevel(disk, memory, deserialized, 1 replicas)</span><br></pre></td></tr></table></figure>
<p>使用 <code>value</code> 方法的注意点</p>
<p>方法签名 <code>value: T</code></p>
<p>在destroy之前才能使用value：在 <code>value</code> 方法内部会确保使用获取数据的时候, 变量必须是可用状态, 所以必须在变量被 <code>destroy</code> 之前使用 <code>value</code> 方法, 如果使用 <code>value</code> 时变量已经失效, 则会报出以下错误：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.apache.spark.SparkException: Attempted to use Broadcast(0) after it was destroyed (destroy at &lt;console&gt;:27)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.assertValid(Broadcast.scala:144)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.value(Broadcast.scala:69)</span><br><span class="line">  ... 48 elided</span><br></pre></td></tr></table></figure>
<h5 id="使用-unpersist-删除数据">使用 <code>unpersist</code> 删除数据</h5>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">b.unpersist</span><br></pre></td></tr></table></figure>
<h5 id="使用-destroy-销毁变量">使用 <code>destroy</code> 销毁变量,</h5>
<p>释放内存空间</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">b.destroy</span><br></pre></td></tr></table></figure>
<p>销毁以后, 会打印如下信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEBUG BlockManager: Removing broadcast 0</span><br><span class="line">DEBUG BlockManager: Removing block broadcast_0_piece0</span><br><span class="line">DEBUG BlockManager: Told master about block broadcast_0_piece0</span><br><span class="line">DEBUG BlockManager: Removing block broadcast_0</span><br></pre></td></tr></table></figure>
<p>使用 <code>destroy</code> 方法的注意点</p>
<p>方法签名 <code>destroy(): Unit</code></p>
<p>不要多次删除广播变量：<code>destroy</code> 方法会移除广播变量, 彻底销毁掉, 但是如果你试图多次 <code>destroy</code> 广播变量, 则会报出以下错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.apache.spark.SparkException: Attempted to use Broadcast(0) after it was destroyed (destroy at &lt;console&gt;:27)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.assertValid(Broadcast.scala:144)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.destroy(Broadcast.scala:107)</span><br><span class="line">  at org.apache.spark.broadcast.Broadcast.destroy(Broadcast.scala:98)</span><br><span class="line">  ... 48 elided</span><br></pre></td></tr></table></figure>
<h4 id="广播变量的使用场景">广播变量的使用场景</h4>
<p>正常情况下使用 Task 拉取数据的时候, 会将数据拷贝到 Executor 中多次, 但是使用广播变量的时候只会复制一份数据到 Executor 中, 所以在两种情况下特别适合使用广播变量</p>
<ul>
<li>一个 Executor 中有多个 Task 的时候</li>
<li>一个变量比较大的时候</li>
<li>大RDD和小RDD执行join操作时。当一个 RDD 很大并且还需要和另外一个 RDD 执行 <code>join</code> 的时候, 可以将较小的 RDD 广播出去, 然后使用大的 RDD 在算子 <code>map</code> 中直接 <code>join</code>, 从而实现在 Map 端 <code>join</code>。</li>
</ul>
<h3 id="累加器">累加器</h3>
<h4 id="通用累加器">通用累加器</h4>
<p>Accumulators(累加器) 是一个只支持 added(添加) 的分布式变量, 可以在分布式环境下保持一致性, 并且能够做到高效的并发。</p>
<p><img src="/2021/04/11/Spark_%E9%97%AD%E5%8C%85%E7%B4%AF%E5%8A%A0%E5%99%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/1.png" style="zoom:50%;"></p>
<ul>
<li><p>Accumulator 是支持并发并行的, 在任何地方都可以通过 add 来修改数值, 无论是 Driver 还是 Executor</p></li>
<li><p>只能在 Driver 中才能调用 value 来获取数值</p></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;ip_ana&quot;</span>).setMaster(<span class="string">&quot;local[6]&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> counter = sc.longAccumulator(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line"></span><br><span class="line">sc.parallelize(<span class="type">Seq</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">  .foreach(counter.add(_))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果: 15</span></span><br><span class="line">println(counter.value)</span><br></pre></td></tr></table></figure>
<ul>
<li>累加器能保证在 Spark 任务出现问题被重启的时候不会出现重复计算</li>
<li>累加器只有在 Action 执行的时候才会被触发</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;ip_ana&quot;</span>).setMaster(<span class="string">&quot;local[6]&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> counter = sc.longAccumulator(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line"></span><br><span class="line">sc.parallelize(<span class="type">Seq</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">  .map(counter.add(_)) <span class="comment">// 这个地方不是 Action, 而是一个 Transformation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果是 0</span></span><br><span class="line">println(counter.value)</span><br></pre></td></tr></table></figure>
<h4 id="自定义累加器">自定义累加器</h4>
<p>可以通过自定义累加器来实现更多类型的累加器, 累加器的作用远远不只是累加, 比如可以实现一个累加器, 用于向里面添加一些运行信息。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承AccumulatorV2这个类，传入String类型，返回Set[String]类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, <span class="type">Set</span>[<span class="type">String</span>]] </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个可变长度的Set，即 mutable.Set[String]  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> infos: mutable.<span class="type">Set</span>[<span class="type">String</span>] = mutable.<span class="type">Set</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断累加器对象是否为空，这里就是判断这个Set是否为空</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">    infos.isEmpty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回一个拷贝的累加器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, <span class="type">Set</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> newAccumulator = <span class="keyword">new</span> <span class="type">InfoAccumulator</span>()</span><br><span class="line">    infos.synchronized &#123; <span class="comment">//使用synchronized关键字保证线程安全</span></span><br><span class="line">      newAccumulator.infos ++= infos <span class="comment">//把一个Set添加到另一个Set中使用++=</span></span><br><span class="line">    &#125;</span><br><span class="line">    newAccumulator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清空累加器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    infos.clear()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//往累加器中添加元素</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(v: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    infos += v</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//累加器在进行累加的时候，可能每个分布式节点都有一个实例</span></span><br><span class="line">  <span class="comment">//在最后的Driver中进行合并，通过调用这个merge方法把所有的实例内容合并起来，</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, <span class="type">Set</span>[<span class="type">String</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    infos ++= other.value <span class="comment">//这里的value就是下面这个方法返回的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//提供给外部累加结果，注意返回一个不可变的类型，防止外部进行修改</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Set</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    infos.toSet</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulator2</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> config = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;ip_ana&quot;</span>).setMaster(<span class="string">&quot;local[6]&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(config)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> infoAccumulator = <span class="keyword">new</span> <span class="type">InfoAccumulator</span>()</span><br><span class="line">  sc.register(infoAccumulator, <span class="string">&quot;infos&quot;</span>)</span><br><span class="line"></span><br><span class="line">  sc.parallelize(<span class="type">Seq</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>))</span><br><span class="line">    .foreach(item =&gt; infoAccumulator.add(item))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行结果: Set(3, 1, 2)</span></span><br><span class="line">  println(infoAccumulator.value)</span><br><span class="line"></span><br><span class="line">  sc.stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://knifefly.cn/2018/05/21/%E7%90%86%E8%A7%A3spark%E9%97%AD%E5%8C%85/（闭包）</p>
<p>https://blog.csdn.net/weixin_43854618/article/details/105680445（累加器）</p>
<p>https://www.cnblogs.com/qingyunzong/p/8890483.html#_label1（广播变量和累加器）</p>
]]></content>
      <categories>
        <category>Spark</category>
        <category>Spark Core</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>Spark Core</tag>
      </tags>
  </entry>
  <entry>
    <title>Java位运算</title>
    <url>/2021/04/12/Java_%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h3 id="位运算">位运算</h3>
<p>计算机里面任何数据本质上是用二进制（0 1）来保存的数字。位运算就是直接对二进制类型的数据进行计算。</p>
<a id="more"></a>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&amp;</td>
<td>与</td>
<td>两位都为1，结果为1</td>
</tr>
<tr class="even">
<td>|</td>
<td>或</td>
<td>有一位为1，结果为1</td>
</tr>
<tr class="odd">
<td>~</td>
<td>非</td>
<td>~0 = 1， ~1 = 0</td>
</tr>
<tr class="even">
<td>^</td>
<td>异或</td>
<td>两位不相同，结果为1</td>
</tr>
<tr class="odd">
<td>&lt;&lt;</td>
<td>左移</td>
<td>二进制位全部左移，高位丢弃，低位补0</td>
</tr>
<tr class="even">
<td>&gt;&gt;</td>
<td>右移</td>
<td>二进制位全部右移，无符号数高位补零，有符号数补符号位或零（根据编译器）</td>
</tr>
</tbody>
</table>
<h3 id="常用位操作">常用位操作</h3>
<ul>
<li><p>判断奇偶</p>
<p>(x &amp; 1) == 1 等价 (x % 2 == 1)</p>
<p>(x &amp; 1) == 0 等价 (x % 2 == 0)</p></li>
<li><p>除以二</p>
<p>x &gt;&gt; 1 等价 x / 2</p></li>
<li><p>把最低位的二进制1去掉</p>
<p>x &amp;= (x - 1)</p></li>
<li><p>得到最低位的1</p>
<p>x &amp; -x</p>
<blockquote>
<p>-x的运算是，所有位置取反，然后+1</p>
<p>保留二进制下最后出现的1的位置，其余位置置0</p>
<p>https://www.cnblogs.com/yzxag/p/12668034.html</p>
</blockquote></li>
<li><p>得到0</p>
<p>x &amp; ~x == 0</p></li>
</ul>
<h3 id="指定位置的位运算">指定位置的位运算</h3>
<p>https://leetcode-cn.com/problems/power-of-two/solution/5chong-jie-fa-ni-ying-gai-bei-xia-de-wei-6x9m/</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合操作</title>
    <url>/2021/04/11/Java_%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="java集合操作">Java集合操作</h3>
<p>遍历集合、Map类型数据排序</p>
<a id="more"></a>
<h3 id="遍历集合">遍历集合</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map.Entry遍历</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : tempMap.entrySet()) &#123;</span><br><span class="line">   String key = entry.getKey().toString();</span><br><span class="line">   String value = entry.getValue().toString();</span><br><span class="line">   System.out.println(<span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot; value=&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//keySet()遍历</span></span><br><span class="line">  <span class="keyword">for</span> (Object o : tempMap.keySet()) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;key=&quot;</span> + o + <span class="string">&quot; value=&quot;</span> + tempMap.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map类型数据排序">Map类型数据排序</h3>
<p>注意TreeSet、TreeMap本身的Key就是按照字典序进行排序的。</p>
<h4 id="完整方法">完整方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapKeySort</span><span class="params">(HashMap&lt;Integer, String&gt; hm)</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//定义一个list装载key、value</span></span><br><span class="line">        List&lt;Map.Entry&lt;Integer, String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;Integer, String&gt;&gt;(hm.entrySet());</span><br><span class="line">        </span><br><span class="line">     	<span class="comment">//对list进行排序，自定义排序规则</span></span><br><span class="line">     	list.sort(<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Integer, String&gt; o1, Map.Entry&lt;Integer, String&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getKey() &lt; o2.getKey() ? <span class="number">1</span> : ((o1.getKey() == o2.getKey()) ? <span class="number">0</span> : -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     </span><br><span class="line">     	<span class="comment">/*打印结果查看</span></span><br><span class="line"><span class="comment">        for (Map.Entry&lt;Integer, String&gt; mapping : list) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(mapping.getKey() + &quot;:&quot; + mapping.getValue());</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后把这个List返回即可</span></span><br></pre></td></tr></table></figure>
<h4 id="简单方法">简单方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取key</span></span><br><span class="line">Object[] key_arr = hashmap.keySet().toArray();   </span><br><span class="line"><span class="comment">//对key排序</span></span><br><span class="line">Arrays.sort(key_arr);   </span><br><span class="line"><span class="comment">//通过key获取value</span></span><br><span class="line"><span class="keyword">for</span>(Object key : key_arr) &#123;   </span><br><span class="line">    Object value = hashmap.get(key);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="arraylist中remove">ArrayList中Remove</h3>
<p>泛型类的类型必须为引用类型，而不能为基础类型。所以传int的时候，会被当做下标值，传Integer的时候，会被视为泛型类。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remove(1) 　　&#x2F;&#x2F;是删除索引为1的元素</span><br><span class="line">remove(new Integer(1))　　&#x2F;&#x2F;则删除元素1</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程编程题</title>
    <url>/2021/04/18/Java_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
    <content><![CDATA[<p>交替打印奇偶数、十个线程实现1~100求和</p>
<a id="more"></a>
<h3 id="交替打印奇偶数">交替打印奇偶数</h3>
<h4 id="仅通过synchronized关键字实现">仅通过synchronized关键字实现</h4>
<p>创建两个线程，一个线程负责打印奇数，另一个线程打印偶数，两个线程竞争同一个对象锁，每次打印一个数字后释放锁，然后另一个线程拿到锁打印下一个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOddEven1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">						<span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;偶数线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">						<span class="keyword">if</span> ((count &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;奇数线程&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="synchronized关键字配合wait和notify方法">synchronized关键字配合wait和notify方法</h4>
<p>无需判断数字是否是奇偶数，两个线程通过等待唤醒机制，交替打印数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOddEven2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> printer(), <span class="string">&quot;偶数线程，&quot;</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> printer(), <span class="string">&quot;奇数线程，&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">					<span class="comment">// 打印数字，并立即释放锁</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印:&quot;</span> + count++);</span><br><span class="line">					object.notify();</span><br><span class="line">					<span class="comment">// 此处判断，是为了打印完了100个数字后，程序能够正常结束，否则程序将一直等待下去，耗费系统资源。</span></span><br><span class="line">					<span class="keyword">if</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							object.wait();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十个线程实现1100求和">十个线程实现1~100求和</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程都有一个startnum，0，10，20...90</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> startnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有线程共用一个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//求和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch latch; <span class="comment">//同步器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程初始化自己的startnum</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        startnum = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多个线程不能同时执行这个加法（但是其实同时也无所谓？）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;    <span class="comment">// public static synchronized void add(int num)</span></span><br><span class="line">        sum = sum + num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//重写这个run方法执行累加操作</span></span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            tmp = tmp + (startnum + i); <span class="comment">//从startnum开始做加法，比如第二组：0 + （11+0） +（11+1）+（11+2）+...+(11+9) = 11 + 12 + 13 + ... + 20</span></span><br><span class="line">        &#125;</span><br><span class="line">        add(tmp); <span class="comment">//把结果加到总和中</span></span><br><span class="line"></span><br><span class="line">        latch.countDown(); <span class="comment">//递减计数器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程数量</span></span><br><span class="line">        <span class="keyword">int</span> tc = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//创建计数器</span></span><br><span class="line">        latch = <span class="keyword">new</span> CountDownLatch(tc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建线程数组</span></span><br><span class="line">        Thread[] threadArray = <span class="keyword">new</span> Thread[tc];</span><br><span class="line">        <span class="comment">//创建线程并运行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tc; i++)&#123;</span><br><span class="line">            threadArray[i] = <span class="keyword">new</span> ThreadTest(i*<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">            threadArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">//等待所有线程递减 CountDownLatch</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1 + 2 + 3 + ... + 100 = &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环打印abc">循环打印ABC</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.javatest.theardTest.MultiThreadAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编写一个程序，启动三个线程，三个线程的ID分别是A，B，C；，每个线程将自己的ID值在屏幕上打印5遍，打印顺序是ABCABC...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABCABCABC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ABCABCABC abcabcabc = <span class="keyword">new</span> ABCABCABC();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                abcabcabc.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                abcabcabc.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                abcabcabc.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/x541211190/article/details/109402864（交替打印奇偶数）</p>
<p>//https://blog.csdn.net/jy_z11121/article/details/84490436?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs （十个线程实现1~100求和）</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>树算法</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>非递归遍历 https://www.jianshu.com/p/8efe8f281f22</p>
<p>二叉树递归非递归遍历、二叉树高度</p>
<a id="more"></a>
<h3 id="二叉树遍历">二叉树遍历</h3>
<h4 id="前序遍历">前序遍历</h4>
<p>前序遍历按照“根结点-左孩子-右孩子”的顺序进行访问。</p>
<h5 id="递归实现">递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">     	System.out.println(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归实现">非递归实现</h5>
<p>根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。</p>
<p>对于任一结点P：</p>
<p>1、访问结点P，并将结点P入栈;</p>
<p>2、判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1；若不为空，则将P的左孩子置为当前的结点P;</p>
<p>3、直到P为NULL并且栈为空，则遍历结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">		ArrayList&lt;TreeNode&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		TreeNode p = root;</span><br><span class="line">    	<span class="comment">//当栈内还存在元素</span></span><br><span class="line">		<span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">			<span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">				alist.add(p.val);<span class="comment">//先访问根节点</span></span><br><span class="line">				stack.push(p);<span class="comment">//先访问根节点</span></span><br><span class="line">				p = p.left;<span class="comment">//再访问左子树</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line">				TreeNode temp = stack.pop();</span><br><span class="line">				p = temp.right;<span class="comment">//访问右子树</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> alist;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历">中序遍历</h4>
<p>中序遍历按照“左孩子-根结点-右孩子”的顺序进行访问。</p>
<h5 id="递归实现-1">递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">			inOrder(root.left);</span><br><span class="line">			System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			inOrder(root.right);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归实现-1">非递归实现</h5>
<p>根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。</p>
<p>对于任一结点P，</p>
<p>1、若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理；</p>
<p>2、若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子；</p>
<p>3、直到P为NULL并且栈为空则遍历结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ArrayList&lt;TreeNode&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;<span class="comment">//先访问左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line">            TreeNode tmp = stack.pop();</span><br><span class="line">            alist.add(tmp.val);<span class="comment">//再访问根节点</span></span><br><span class="line">            p = tmp.right;<span class="comment">//访问右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历">后序遍历</h4>
<p>后序遍历按照“左孩子-右孩子-根结点”的顺序进行访问。</p>
<h5 id="递归实现-2">递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">		postOrder(root.left);</span><br><span class="line">		postOrder(root.right);</span><br><span class="line">		System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归实现-2">非递归实现</h5>
<p>1、要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。</p>
<p>2、如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。</p>
<p>3、若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ArrayList&lt;TreeNode&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    TreeNode cur,pre = <span class="keyword">null</span>;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        </span><br><span class="line">        cur = stack.peek();</span><br><span class="line">        <span class="comment">//当前节点不存在左右孩子，或者左右孩子都已经被访问过</span></span><br><span class="line">        <span class="keyword">if</span>( (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) || (pre != <span class="keyword">null</span> &amp;&amp; (cur.left == pre || cur.right == pre) ) )&#123;</span><br><span class="line">            <span class="comment">//访问当前节点</span></span><br><span class="line">            TreeNode tmp = stack.pop();</span><br><span class="line">            alist.add(tmp.val);</span><br><span class="line">            pre =tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//否则先将右子节点入栈，再将左子节点入栈，保证先访问左子树再访问右子树</span></span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">					stack.push(cur.right);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> alist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层序遍历">层序遍历</h4>
<p>使用队列实现层序遍历。</p>
<p>1、首先将根节点放入队列中。</p>
<p>2、当队列为非空时，循环执行步骤3到步骤5，否则执行6；</p>
<p>3、出队列取得一个结点，访问该结点；</p>
<p>4、若该结点的左子树为非空，则将该结点的左子树入队列；</p>
<p>5、若该结点的右子树为非空，则将该结点的右子树入队列；</p>
<p>6、结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	queue.offer(root);</span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">		TreeNode temp  = queue.poll();</span><br><span class="line">		System.out.print(temp.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)</span><br><span class="line">			queue.offer(temp.left);</span><br><span class="line">		<span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)</span><br><span class="line">			queue.offer(temp.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/u011514810/article/details/75907170 （二叉树遍历）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 树</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E6%A0%91/</url>
    <content><![CDATA[<p>LeetCode中与树有关的题目。</p>
<a id="more"></a>
<h3 id="二叉树展开为链表">114 二叉树展开为链表</h3>
<p><strong>题目描述</strong></p>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><strong>题解</strong>：</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将左右子树展开</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        TreeNode tmp_right = root.right;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将展开的左子树链表接到右子树链表的后面</span></span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            root = root.right;</span><br><span class="line">        root.right = tmp_right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中的最大路径和">124 二叉树中的最大路径和</h3>
<p><strong>题目描述</strong></p>
<p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_LeetCode_%E6%A0%91/0.png" style="zoom:67%;"></p>
<p>输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</p>
<p><strong>题解：</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>后续遍历得到左右子树的最大路径和，再和当前值进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE; <span class="comment">//记录全局最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后序遍历，返回左右子树的最大和，负数的就不要</span></span><br><span class="line">        <span class="keyword">int</span> max_left = Math.max(<span class="number">0</span>, dfs(root.left));</span><br><span class="line">        <span class="keyword">int</span> max_right = Math.max(<span class="number">0</span>, dfs(root.right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//和全局最大值判断</span></span><br><span class="line">        max = Math.max(max, (root.val + max_left + max_right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只能返回一条路径的最大值</span></span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(max_left, max_right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证二叉搜索树">98 验证二叉搜索树</h3>
<p><strong>题目描述</strong></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>二叉搜索树的特点就是中序遍历是有序的，因此肯定是中序遍历，然后只要验证前一个节点是否小于等于当前节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历判断是否大于前一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int pre = Integer.MIN_VALUE; 不可以定义这个值！！有这个用例</span></span><br><span class="line">    TreeNode pre; <span class="comment">//前一个结点，全局的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.left)) <span class="comment">//遍历左子树，为true表明左子树满足二叉搜索树条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val) <span class="comment">//当前节点是否大于前继节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pre = root; <span class="comment">//将前继节点记录为当前节点</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root.right)) <span class="comment">//遍历右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//都满足条件，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的完全性检验">958 二叉树的完全性检验</h3>
<p>题目描述</p>
<p>验证一棵二叉树是否是完全二叉树</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：</p>
<p>层序遍历，把一颗树的节点（包括空节点）按层序遍历排成一行，当且仅当存在两个相邻节点：前一个为null，后一个不为null时，才不是完全二叉树。</p>
<blockquote>
<pre><code>   1
  / \
 2   3
/ \   \</code></pre>
<p>4 5 6 层序遍历序列为：[1, 2, 3, 4, 5, null, 6]，其中 null 出现在了6前面，所以不合法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录前驱节点</span></span><br><span class="line">        TreeNode prev = root;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span> &amp;&amp; node != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/solution/hen-jian-dan-de-si-lu-dai-ma-hen-jian-ji-by-yuanyb/ （二叉树的完全性检验）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 链表</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>剑指Offer中关于链表的题目解析。</p>
<a id="more"></a>
<h3 id="两个链表的第一个公共节点">01 两个链表的第一个公共节点</h3>
<p><strong>题目描述</strong></p>
<p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(m+n\)</span>)：m，n分别为链表A，B的长度，最坏情况下，公共结点为最后一个，需要遍历m+n个结点。 空间复杂度：O(1)。</p>
<p>公共节点，定义为两个链表从某一节点开始，他们的next都指向同一个节点。由于是单向链表的节点，每个节点只有一个next，因此从第一个公共节点开始，之后他们的所有节点都是重合的，不可能再出现分叉。</p>
<p>所以可以先遍历两个链表得到他们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，<strong>在较长的链表上先走若干步</strong>，接着同时在两个链表上遍历，找到的第一个相同的结点就是他们的第一个公共结点。</p>
<p>一个巧妙的实现方式为如果A指针把链表A走完了，然后再从链表B开始走到相遇点就相当于把这两个链表的所有节点都走了一遍，同理如果B指针把链表B走完了，然后再从链表A开始一直走到相遇点也相当于把这两个链表的所有节点都走完了。这样它们的长度就是一致的，且同时会在相遇点结束。本质上同上述方法一样，代码实现更简单。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/0.png" style="zoom: 90%;"></p>
<p>注意当两个链表没有公共节点时候的死循环问题。（第一种解法就不会存在）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //当他们指向空指针的时候，有两种情况。</span></span><br><span class="line"><span class="comment">            其一是某个指针先走完了，此时应该换一个链表走。（只有一个指向null）</span></span><br><span class="line"><span class="comment">            其二是两个指针都走完了，链表没有任何公共节点，都指向null，这时它们是相等的，可以退出循环。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(p1 != p2)&#123; </span><br><span class="line">                <span class="keyword">if</span>(p1 == <span class="keyword">null</span>) p1 = pHead2;</span><br><span class="line">                <span class="keyword">if</span>(p2 == <span class="keyword">null</span>) p2 = pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            也可以写成这样，这样就已经先判断p1 != p2 ，此时如果还等于null，则就可以交换链表继续遍历</span></span><br><span class="line"><span class="comment">            p1= p1!=null? p1.next:pHead2;</span></span><br><span class="line"><span class="comment">            p2= p2!=null? p2.next:pHead1;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p1; <span class="comment">//若不存在公共节点，则返回null</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表双指针">02 反转链表（双指针）</h3>
<p><strong>题目描述</strong></p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(1)：</p>
<p>使用三个指针来调整指针的位置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode left = <span class="keyword">null</span>;<span class="comment">//指向前一个节点</span></span><br><span class="line">        ListNode right = head;<span class="comment">//指向当前节点</span></span><br><span class="line">        ListNode tmp;<span class="comment">//记录当前节点下一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123; <span class="comment">//注意这里是right ！= null 而不是 right.next != null</span></span><br><span class="line">            tmp = right.next;<span class="comment">//记录下一个节点位置</span></span><br><span class="line">            right.next = left;<span class="comment">//调整指向下一个位置的指针</span></span><br><span class="line">            left = right;</span><br><span class="line">            right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">//注意返回的是left节点，因为此时right为null</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从尾到头打印链表递归">03 从尾到头打印链表（递归）</h3>
<p><strong>题目描述</strong></p>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;67,0,24,58&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[58,24,0,67]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(<span class="math inline">\(n\)</span>)：递归栈内同时存储所有节点</p>
<p>可以采用递归解法。</p>
<p>递归终止条件为：当node == null时，表明到达链表最底端，什么都不做直接返回。</p>
<p>如何递归：先递归到最底端，然后向 ArrayList 添加值，再一层层返回不断添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        recur(listNode);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;        </span><br><span class="line">        recur(node.next);        </span><br><span class="line">        res.add(node.val);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种更直接、简单的解法是反转链表，然后打印，这样空间复杂度是O(1)，因为栈内不需要存储递归结果。但是这样的缺点就是会改变原来的链表状态，不符合某些题意。</p>
<h3 id="删除链表中重复的结点虚拟头">04 删除链表中重复的结点（虚拟头）</h3>
<p><strong>题目描述</strong></p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,3,4,4,5&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,5&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(<span class="math inline">\(1\)</span>)：不使用额外存储空间</p>
<p>双指针解法。首先创建一个<strong>虚拟的头节点</strong>。</p>
<p>left指向当前节点，right不停判断和right.next是否相等，并作出反应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建虚拟头节点</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        vhead.next = pHead;</span><br><span class="line">        </span><br><span class="line">        ListNode left = vhead;</span><br><span class="line">        ListNode right = vhead.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//处理right处有重复值的情况</span></span><br><span class="line">            <span class="keyword">if</span>(right.next != <span class="keyword">null</span> &amp;&amp; right.val == right.next.val)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(right.next != <span class="keyword">null</span> &amp;&amp; right.val == right.next.val) right = right.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">                left.next = right;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = left.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vhead.next; <span class="comment">//为null则说明链表中节点全部重复</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个排序链表虚拟头递归">05 合并两个排序链表（虚拟头|递归）</h3>
<p><strong>题目描述</strong></p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,3,5&#125;,&#123;2,4,6&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(m+n\)</span>)：分别遍历两个链表 空间复杂度O(<span class="math inline">\(1\)</span>)：不使用额外存储空间</p>
<p>一个直观的方法就是建立一个虚拟头节点，然后分别遍历两个链表加入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//新建虚拟头</span></span><br><span class="line">        ListNode vhead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode res = vhead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当两个链表都没有到末尾</span></span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val )&#123;</span><br><span class="line">                vhead.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                vhead.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            vhead = vhead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将还有剩的链表直接赋值</span></span><br><span class="line">        vhead.next = list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(<span class="math inline">\(m+n\)</span>)：</p>
<p><span class="math inline">\(m、n\)</span>为两个链表的元素个数。递归函数每次去掉一个元素，直到两个链表都为空，因此需要调用 <span class="math inline">\(R=O(m + n)\)</span> 次。而在递归函数中我们只进行了 next 指针的赋值操作，复杂度为 <span class="math inline">\(\mathcal{O}(1)\)</span>，故递归的总时间复杂度为 <span class="math inline">\({\mathcal{O}(T) = R * \mathcal{O}(1)}={\mathcal{O}}(m + n)\)</span>。</p>
<p>空间复杂度O(<span class="math inline">\(m+n\)</span>)：</p>
<p>对于递归调用，当它遇到终止条件准备回溯时，已经递归调用了 m+n 次，使用了 m+n 个栈帧，故最后的空间复杂度为 <span class="math inline">\({\mathcal{O}}(m + n)\)</span>。</p>
<p>递归法。</p>
<p>递归的终止条件是：当两个链表都为空时，表示对链表已合并完成。</p>
<p>递归的过程是：判断 <code>l1</code> 和 <code>l2</code> 头结点哪个更小，然后较小结点的 <code>next</code> 指针指向<strong>其余结点的合并结果。（调用递归）</strong></p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/1.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">            list1.next = Merge(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1; <span class="comment">//注意这里要return给上一轮提供结果！</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2; <span class="comment">//注意这里要return给上一轮提供结果！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中倒数第k个结点快慢">06 链表中倒数第k个结点（快慢）</h3>
<p><strong>题目描述</strong></p>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,&#123;1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;5&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：遍历一次链表 空间复杂度O(<span class="math inline">\(1\)</span>)：不使用额外存储空间</p>
<p>快慢指针解法。先让快指针走k步，然后快慢指针同时走1步，当快指针达到终点null时，慢指针刚好指向该数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ListNode slow, fast = head; 这样写会导致slow没赋值</span></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先让快指针多走k</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span>) <span class="comment">//提前达到null说明链表不足k</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;            </span><br><span class="line">            fast = fast.next; <span class="comment">//刚好在第k步时走到null是不会有影响的</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//快慢各走1</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回慢指针</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中环的入口结点快慢">07 链表中环的入口结点（快慢）</h3>
<p><strong>题目描述</strong></p>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：线性复杂度，快慢指针走的步数与链表的长度有关 空间复杂度O(<span class="math inline">\(1\)</span>)：使用常数的额外空间</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E9%93%BE%E8%A1%A8/2.png" style="zoom: 50%;"></p>
<p>1、双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；</p>
<ul>
<li><p>第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；</p></li>
<li><p>第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：设链表共有 <code>a+b</code> 个节点，其中链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4, b=5）；设两指针分别走了 f，s 步，则有： <strong>fast 走的步数是slow步数的 2 倍，即 f = 2s；</strong>（解析： fast 每轮走 2 步） <strong>fast 比 slow多走了 n 个环的长度，即 f = s + nb；</strong>（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）； <strong>以上两式相减得：f = 2nb，s = nb，即fast和slow 指针分别走了 2n，n 个 环的周长</strong>（注意： n 是未知数，不同链表的情况不同）。</p></li>
</ul>
<p>2、目前情况分析：</p>
<ul>
<li>如果让指针从链表头部一直向前走并统计步数k，那么<strong>所有 走到链表入口节点时的步数 是：<code>k=a+nb</code></strong>（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。</li>
<li>而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。</li>
<li>但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。</li>
</ul>
<p>3、双指针第二次相遇：</p>
<ul>
<li>slow指针位置不变 ，将fast指针重新指向链表头部节点 ；slow和fast同时每轮向前走 1 步；此时 f = 0，s = nb ；</li>
<li>当 fast 指针走到f = a步时，slow 指针走到步s = a+nb，<strong>此时 两指针重合，并同时指向链表环入口</strong> 。</li>
</ul>
<p>4、返回slow指针指向的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode slow = pHead, fast = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)</span><br><span class="line">                fast = fast.next.next; <span class="comment">//走两步</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//没有环</span></span><br><span class="line">            &#125;            </span><br><span class="line">            slow = slow.next;                </span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast); <span class="comment">//先执行一次后判断，因为刚开始时是相等的</span></span><br><span class="line">        </span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂链表的复制">08 复杂链表的复制</h3>
<p>题目描述</p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：两次遍历链表进行复制 空间复杂度O(<span class="math inline">\(n\)</span>)：使用额外存储空间HashMap存储所有节点</p>
<p>使用哈希表，key是原链表中的元素，value是新链表中的new 出来的元素，key-value对中的node.val是相同的。</p>
<p>第一次遍历，构建这个哈希表。第二次遍历，构建新链表中的random指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashMap&lt; RandomListNode, RandomListNode&gt; hm = <span class="keyword">new</span> HashMap&lt; RandomListNode, RandomListNode&gt;();</span><br><span class="line">        </span><br><span class="line">        RandomListNode tmp = pHead;</span><br><span class="line">        <span class="comment">//第一次遍历</span></span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            hm.put( tmp, <span class="keyword">new</span> RandomListNode(tmp.label));</span><br><span class="line">            tmp =tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二次遍历</span></span><br><span class="line">        tmp = pHead;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//分别构建新链表中每个元素的next和random，注意为null的情况</span></span><br><span class="line">            hm.get(tmp).next = tmp.next == <span class="keyword">null</span>? <span class="keyword">null</span> : hm.get(tmp.next);</span><br><span class="line">            hm.get(tmp).random = tmp.random == <span class="keyword">null</span>? <span class="keyword">null</span> : hm.get(tmp.random);</span><br><span class="line">            tmp =tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hm.get(pHead);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种解法是构建，原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。最后将其拆开即可，这样空间复杂度为O(1)，因为不会使用额外的空间HashMap。</p>
<h3 id="题解来源">题解来源</h3>
<p>两个链表的第一个公共节点：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/ji-he-shuang-zhi-zhen-deng-3chong-jie-jue-fang-shi/</p>
<p>https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tab=answerKey</p>
<p>合并两个排序链表：https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/</p>
<p>环形链表：https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/</p>
<p>复杂链表的复制：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 树</title>
    <url>/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/</url>
    <content><![CDATA[<p>剑指Offer中关于树的题目解析。</p>
<a id="more"></a>
<h3 id="树的深度">01 树的深度</h3>
<p><strong>题目描述</strong></p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,#,6,#,#,7&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，计算树的深度需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下（当树平衡时），退化为链表，系统中同时存储 <span class="math inline">\(n/2\)</span>个节点。</p>
<p>分治法，为 max( 头结点左子树的最大深度, 头结点右子树的最大深度)+1。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/0.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(TreeDepth(root.left), TreeDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的镜像">02 二叉树的镜像</h3>
<p><strong>题目描述</strong></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，计算树的深度需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p>递归法，根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        TreeNode temp = root.left;  </span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        </span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡二叉树">03 平衡二叉树</h3>
<p>题目描述</p>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,4,5,6,7&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，计算树的深度需要遍历所有节点。注意这里因为使用了提前阻断法，只要有任何子树不满足条件即可返回。否则，时间复杂度变为O(<span class="math inline">\(nlogn\)</span>)，判断每个节点的最大高度 depth(root) 需要遍历 各子树的所有节点 ，子树的节点数的复杂度为O(<span class="math inline">\(logn\)</span>)。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p>递归法，判断左右子树的高度差是否超过1即可，每次递归时返回的是最大子树的高度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//空树也是平衡的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> IsBalanced(root) == -<span class="number">1</span>? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IsBalanced</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如某个子树的高度不满足条件则立刻返回</span></span><br><span class="line">        <span class="keyword">int</span> left = IsBalanced(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right = IsBalanced(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right)&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right)+<span class="number">1</span>; <span class="comment">//返回的是最大子树的高度+1</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把二叉树打印成多行">04 把二叉树打印成多行</h3>
<p>题目描述</p>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[8],[6,10],[5,7,9,11]]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，广度优先搜索需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下，当二叉树是平衡的时候，最多有<span class="math inline">\(n/2\)</span>个节点同时在队列中。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/2.png" style="zoom:67%;"></p>
<p>二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。BFS 通常借助 队列 的先入先出特性来实现。队列中存储树的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储结果的ArrayList</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="comment">//利用队列数据结构（先进先出）来实现广度优先搜索</span></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">// Queue是个接口，不能实例化，用多态</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将根节点加入队列</span></span><br><span class="line">        que.add(pRoot);</span><br><span class="line">        <span class="comment">//当队列中有元素的时候</span></span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//记录这一层有多少个元素</span></span><br><span class="line">            <span class="keyword">int</span> quesize = que.size();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//弹出这一层的元素加入结果ArrayList，并将每个元素的左右子树加入队列Queue</span></span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            TreeNode tempnode;</span><br><span class="line">            <span class="keyword">while</span>(quesize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//弹出结果</span></span><br><span class="line">                tempnode = que.remove();</span><br><span class="line">                temp.add(tempnode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//左右子树加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(tempnode.left != <span class="keyword">null</span>)</span><br><span class="line">                	que.add(tempnode.left);</span><br><span class="line">                <span class="keyword">if</span>(tempnode.right != <span class="keyword">null</span>)</span><br><span class="line">                	que.add(tempnode.right);</span><br><span class="line">                              </span><br><span class="line">                quesize--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.add(temp);</span><br><span class="line">                            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对称的二叉树">05 对称的二叉树</h3>
<p>题目描述</p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,6,5,7,7,5&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，判断镜像需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为O(<span class="math inline">\(n\)</span>)。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/3.png" style="zoom:67%;"></p>
<p>判断二叉树是否对称</p>
<p>若 root == null, 直接返回 true；</p>
<p>否则，判断 root.left 与 root.right 这两棵子树是否对称：</p>
<p>​ 判断 root.left 与 root.right 这两个节点的值是否相等</p>
<p>​ 判断 root.left 的左子树与 root.right 的右子树是否对称。（递归）</p>
<p>​ 判断 root.left 的右子树与 root.right 的左子树是否对称。（递归）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSym(pRoot.left, pRoot.right); <span class="comment">//判断左右子树是否是镜像</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSym</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树都是空的</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树有一个是空的</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树不是空的，判断是否相等，相等返回true</span></span><br><span class="line">        <span class="comment">//left的左子树与right的右子树；left的右子树与right的右子树；是否相等</span></span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; isSym(left.left, right.right) &amp;&amp; isSym(left.right, right.left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的下一个结点">06 二叉树的下一个结点</h3>
<p><strong>题目描述</strong></p>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><strong>题解</strong></p>
<p>首先理解中序遍历，即按左根右顺序遍历。那么当前节点即为根节点，它只有两种情况，其一就是往右子树遍历，其二就是往父节点遍历。</p>
<p>当它存在右子树的时候，那么对右子树按照左根右的顺序，找到最左节点即可。</p>
<p>当它不存在右子树的时候，它只可能是父节点的左子节点或右子节点，此时向上遍历。</p>
<p>​ 若父节点为空，则到达根节点，找不到，已经完成遍历，直接返回。</p>
<p>​ 它是父节点的左子节点，左根右，则父节点为下一个节点。</p>
<p>​ 它是父节点的右子节点，左根右，继续向上遍历（直到满足它是父节点的左子节点）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存在右子树</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找到右子树的最左子树</span></span><br><span class="line">            TreeLinkNode tmp = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                tmp = tmp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//不存在右子树，此时向上遍历</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//父节点为空直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(pNode.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//它是左子节点</span></span><br><span class="line">                <span class="keyword">if</span>(pNode == pNode.next.left)</span><br><span class="line">                    <span class="keyword">return</span> pNode.next; <span class="comment">//返回其父节点作为下一个要遍历的节点</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//它是右子节点，继续向上遍历</span></span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                                                                       </span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从上往下打印二叉树bfs">07 从上往下打印二叉树（BFS）</h3>
<p>题目描述</p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;5,4,#,3,#,2,#,1&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>直接采用BFS广度优先搜索，用队列（先进先出）的数据结构实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            TreeNode tmp = que.remove();</span><br><span class="line">            res.add(tmp.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                que.add(tmp.left);</span><br><span class="line">            <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                que.add(tmp.right);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树中和为某一值的路径前序遍历">08 二叉树中和为某一值的路径（前序遍历）</h3>
<p><strong>题目描述</strong></p>
<p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;10,5,12,4,7&#125;,22</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[10,5,7],[10,12]]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 为树的节点数量，判断深度需要遍历所有节点。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下，退化为链表，最深处刚好满足路径和，同时存储<span class="math inline">\(n\)</span>个节点。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/4.png" style="zoom:67%;"></p>
<p>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 先序遍历 + 路径记录 两部分。</p>
<p>先序遍历： 按照 “根、左、右” 的顺序，遍历树的所有节点。 路径记录： 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 且 ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。</p>
<p>没说一定是正数，所以需要遍历完叶子节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两个全局变量，一个存储最终结果，一个时递归时的暂存变量</span></span><br><span class="line">    <span class="comment">//注意list中存储的是节点内的值，而非节点本身</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        Find(root, target);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        target = target - root.val;</span><br><span class="line">        tmp.add(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123; <span class="comment">//到达根节点</span></span><br><span class="line">            result.add( <span class="keyword">new</span> ArrayList&lt;&gt;(tmp) ); <span class="comment">//注意新建一个数组，&lt;&gt;泛型处填空   </span></span><br><span class="line">        &#125;</span><br><span class="line">                    </span><br><span class="line">        Find(root.left, target);<span class="comment">//继续遍历左子树</span></span><br><span class="line">        Find(root.right, target);<span class="comment">//继续遍历右子树</span></span><br><span class="line">        </span><br><span class="line">        tmp.remove(tmp.size() - <span class="number">1</span>);<span class="comment">//删除新加入的节点，返回上一层</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重建二叉树">09 重建二叉树</h3>
<p>题目描述</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,5,3,4,6,7&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中 <span class="math inline">\(n\)</span> 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(<span class="math inline">\(n\)</span>)。递归共建立 <span class="math inline">\(n\)</span>个节点，每层递归中的节点建立、搜索操作占用 O(1)，因此使用 O(<span class="math inline">\(n\)</span>)时间。 空间复杂度 O(<span class="math inline">\(n\)</span>)： HashMap 使用O(<span class="math inline">\(n\)</span>) 额外空间。最差情况下，树退化为链表，递归深度达到 <span class="math inline">\(n\)</span>，占用 O(N)O(N) 额外空间；最好情况下，树为满二叉树，递归深度为 <span class="math inline">\(logn\)</span>，占用 O(<span class="math inline">\(logn\)</span>) 额外空间。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/5.png" style="zoom:67%;"></p>
<p>前序遍历性质： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序。 中序遍历性质： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序。</p>
<p>例如：</p>
<p>前序遍历划分 [ 3 | 9 | 20 15 7 ] 中序遍历划分 [ 9 | 3 | 15 20 7 ] 根据以上性质，可得出以下推论：</p>
<p>前序遍历的首元素 为 树的根节点 node 的值。 在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。<strong>可得到左右子树的节点数量。</strong> 根据中序遍历中的左 / 右子树的节点数量，<strong>可将前序遍历划分为</strong> [ 根节点 | 左子树 | 右子树 ] 。</p>
<p>只要知道前序数组的根节点的下标。范围可以通过中序数组获得左右子树长度。</p>
<p>只要知道中序数组的范围。根节点下标可以通过值查找。</p>
<p>本质上就是<strong>根据前序遍历去构建一棵树</strong>，不断地在前序数组和中序数组中查找对应的值。</p>
<p>该方法只能解决<strong>无重复节点值</strong>的二叉树，否则中序数组无法划分左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先定义两个全局变量</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();<span class="comment">//查找中序遍历数组下标</span></span><br><span class="line">    <span class="keyword">int</span>[] gpre;<span class="comment">//前序数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对两个全局变量初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">            hm.put(in[i], i);</span><br><span class="line">        gpre = pre;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 传入根节点在前序数组中的下标，以及中序数组的范围；按照前序遍历的方式构建一棵树</span></span><br><span class="line">        <span class="keyword">return</span> reCons( <span class="number">0</span>, <span class="number">0</span>, in.length-<span class="number">1</span>); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//前序递归遍历建树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reCons</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> in_h, <span class="keyword">int</span> in_t)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(in_h &gt; in_t)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构建当前节点</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(gpre[root]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rindex = hm.get(gpre[root]);</span><br><span class="line">        node.left = reCons( root+<span class="number">1</span>, in_h, rindex-<span class="number">1</span>); <span class="comment">//左子树根节点在前序数组中的下标，中序数组范围</span></span><br><span class="line">        node.right = reCons( root+(rindex - in_h)+<span class="number">1</span>, rindex+<span class="number">1</span>, in_t); </span><br><span class="line">        <span class="comment">//右子树根节点在在前序数组中的下标，对应中序数组范围</span></span><br><span class="line">        <span class="comment">//右子树根节点下标 = 当前节点前序数组下标 + 左子树节点数量 + 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的后序遍历序列">10 二叉树的后序遍历序列</h3>
<p><strong>题目描述</strong></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,8,6,12,16,14,10]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n^2\)</span>)： 递归占用O(<span class="math inline">\(n\)</span>)，最差情况下，树退化为链表，每次递归中的循环都需要遍历所有节点O(<span class="math inline">\(n\)</span>)。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 最差情况下，退化为链表，递归深度达到<span class="math inline">\(n\)</span>。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/6.png" style="zoom: 50%;"></p>
<p>后序遍历定义： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。 二叉搜索树定义： 左子树中所有节点的值 &lt;&lt; 根节点的值；右子树中所有节点的值 &gt;&gt; 根节点的值；其左、右子树也分别为二叉搜索树。</p>
<p>BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] gsequence;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        gsequence = sequence;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Verify(<span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Verify</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="comment">//注意这里是大于等于，等于表明这里只有一个数，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root = gsequence[right];</span><br><span class="line">        <span class="keyword">int</span> tmp = left;</span><br><span class="line">        <span class="keyword">for</span>(; tmp&lt;=right-<span class="number">1</span>; tmp++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gsequence[tmp]&gt;root)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = tmp; i &lt;= right-<span class="number">1</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(gsequence[i]&lt;root)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Verify( left, tmp-<span class="number">1</span>) &amp;&amp; Verify( tmp, right-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树的子结构双重dfs">11 树的子结构（双重DFS）</h3>
<p><strong>题目描述</strong></p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,8,#,9,#,2,#,5&#125;,&#123;8,9,#,2&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(mn\)</span>)： <span class="math inline">\(m、n\)</span>分别是树A、B的节点数量。</p>
<p>空间复杂度 O(<span class="math inline">\(m\)</span>)： 最差情况下，两棵树都退化为链表，递归深度达到最大。当<span class="math inline">\(m\leq n\)</span>时，遍历树A与递归判断的总深度为<span class="math inline">\(m\)</span>；当<span class="math inline">\(m&gt;n\)</span>时，最差情况为遍历至树A的叶子节点，总的递归深度为<span class="math inline">\(m\)</span>。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/7.png" style="zoom: 67%;"></p>
<p>对A树DFS，如果B的根节点与A中某个节点值相同，那么以B为树根进行DFS，判断即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recurA( root1, root2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recurA</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//树1遍历完成都没有找到和树2相等的节点</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="comment">//遍历B</span></span><br><span class="line">            <span class="keyword">if</span>(recurB( root1, root2)) <span class="comment">//遍历树2时判定是子结构，即可直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recurA(root1.left, root2) || recurA(root1.right, root2); <span class="comment">//遍历树1的左右子树</span></span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recurB</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果树2为空，说明树2已经遍历完成，无论树1是否为空，都已经说明了树2是树1的子树</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//到这里就变成了树2不为空，树1为空时说明树1已经遍历完了，树2超过了树1，不是子树</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个都不为空的时候，若值相等即可继续遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> recurB(root1.left, root2.left) &amp;&amp; recurB(root1.right, root2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的第k个结点">12 二叉搜索树的第k个结点</h3>
<p>题目描述</p>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;5,3,7,2,4,6,8&#125;,3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;4&#125;</span><br></pre></td></tr></table></figure>
<p>说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按结点数值大小顺序第三小结点的值为4 </span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），无论 k 的值大小，递归深度都为<span class="math inline">\(n\)</span>。 空间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），系统使用O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p>二叉搜索树按照中序遍历的结果，就是数组排序后的结果。</p>
<p>若是求解第k大，则按照右根左顺序遍历即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">//注意使用一个全局变量计数，只有前序遍历时可以直接操作k，否则中序遍历时前序k改变后传不到中序</span></span><br><span class="line">    TreeNode res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        count = k;</span><br><span class="line">        InRecur( pRoot, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InRecur</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || count &lt;=<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        InRecur(pRoot.left);</span><br><span class="line">        </span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            res = pRoot;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        InRecur(pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按之字形顺序打印二叉树">13 按之字形顺序打印二叉树</h3>
<p>题目描述</p>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[8],[10,6],[5,7,9,11]]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>使用Collections.revers方法将ArrayList在偶数行的时候反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        que.add(pRoot);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpSize = <span class="number">0</span>;</span><br><span class="line">        TreeNode tmp;</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            tmpSize = que.size();</span><br><span class="line">            ArrayList&lt;Integer&gt;  tmpAl = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//打印当前队列中的元素</span></span><br><span class="line">            <span class="keyword">while</span>(tmpSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                tmp = que.remove();</span><br><span class="line">                tmpAl.add(tmp.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmp.left);</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmp.right);</span><br><span class="line">                </span><br><span class="line">                tmpSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从右往左</span></span><br><span class="line">            <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                Collections.reverse(tmpAl);</span><br><span class="line">            res.add(tmpAl);</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用LinkedList双端队列的性质。若要从右往左打印，则不断往双端队列头部增加元素，则最开始进入的元素会在最末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        TreeNode tmpNode;</span><br><span class="line">        que.add(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(que.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            LinkedList&lt;Integer&gt; tmpLl = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = que.size(); i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">                </span><br><span class="line">                tmpNode = que.remove();</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    tmpLl.addLast(tmpNode.val);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmpLl.addFirst(tmpNode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(tmpNode.left != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmpNode.left);</span><br><span class="line">                <span class="keyword">if</span>(tmpNode.right != <span class="keyword">null</span>)</span><br><span class="line">                    que.add(tmpNode.right);</span><br><span class="line">  </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(tmpLl));</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化二叉树">14 序列化二叉树</h3>
<p>题目描述</p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 # 表示空节点，以 , 分隔各个节点。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//序列化，直接前序遍历</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root.val + <span class="string">&quot;,&quot;</span> + Serialize(root.left) + <span class="string">&quot;,&quot;</span> + Serialize(root.right);     </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反序列化，用一个全局index记录下标</span></span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String [] strs = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        index++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先判断下标是否越界，越界直接返回null表明已经超过数组，是最后的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt;= strs.length) <span class="comment">//注意是数组的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//然后判断当前值是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(strs[index].equals(<span class="string">&quot;#&quot;</span>)) <span class="comment">//要用equals比较字符串</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不是叶子节点就按照前序遍历法继续递归</span></span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[index])); <span class="comment">//将字符转为数字</span></span><br><span class="line">            node.left = Deserialize(str);</span><br><span class="line">            node.right = Deserialize(str);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">       </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树与双向链表">15 二叉搜索树与双向链表</h3>
<p><strong>题目描述</strong> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），递归深度都为<span class="math inline">\(n\)</span>。 空间复杂度 O(<span class="math inline">\(n\)</span>)：当树退化为链表时（全部为左子节点），系统使用O(<span class="math inline">\(n\)</span>)大小的栈空间。</p>
<p><img src="/2021/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%A0%91/8.png" style="zoom: 50%;"></p>
<p>二叉搜索树的中序遍历结果，即为排序的链表。然后，需要设置一个全局节点pre，保存前一个节点的位置，并在当前根节点处，调整指针的指向。</p>
<p>同时，需要设置一个头节点head保存链表头节点的位置，如何知道头节点的位置？当pre为null时，即为头节点的位置。</p>
<p>如何知道尾节点的位置？当中序遍历完成后，pre指向的位置为尾节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        Recur(pRootOfTree);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后修改头节点和尾节点的指向（牛客网上不要修改，leetcode上要）</span></span><br><span class="line"><span class="comment">//         pre.right = head;</span></span><br><span class="line"><span class="comment">//         head.left = pre;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Recur</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        Recur(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;<span class="comment">//当前节点是链表头节点</span></span><br><span class="line">            head = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = pre;</span><br><span class="line">        pre = root;<span class="comment">//变更前驱节点</span></span><br><span class="line">        </span><br><span class="line">        Recur(root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>树的深度：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/solution/mian-shi-ti-55-i-er-cha-shu-de-shen-du-xian-xu-bia/ 二叉树的镜像：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/solution/mian-shi-ti-27-er-cha-shu-de-jing-xiang-di-gui-fu-/</p>
<p>平衡二叉树：https://leetcode-cn.com/problems/balanced-binary-tree/solution/balanced-binary-tree-di-gui-fang-fa-by-jin40789108/</p>
<p>把二叉树打印成多行：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/</p>
<p>对称的二叉树：https://leetcode-cn.com/problems/symmetric-tree/solution/hua-jie-suan-fa-101-dui-cheng-er-cha-shu-by-guanpe/</p>
<p>https://leetcode-cn.com/problems/symmetric-tree/solution/di-gui-die-dai-bi-xu-miao-dong-by-sweetiee/</p>
<p>二叉树中和为某一值的路径：https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/</p>
<p>重建二叉树：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/</p>
<p>二叉树的后序遍历序列：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</p>
<p>树的子结构：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/</p>
<p>序列化二叉树：https://blog.nowcoder.net/n/daadc4221f77479f968a9347af2a8380?f=comment</p>
<p>二叉搜索树与双向链表：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 数组</title>
    <url>/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>剑指Offer中关于数组的题目解析。</p>
<a id="more"></a>
<h3 id="斐波那契数列">01 斐波那契数列</h3>
<p><strong>题目描述</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>斐波那契额数字的规律为，当<span class="math inline">\(n\geq2\)</span>时，<span class="math inline">\(f(n)=f(n-1)+f(n-2)\)</span></p>
<p><strong>方法一：递归法</strong></p>
<p>时间复杂度：O(<span class="math inline">\(2^n\)</span>) 空间复杂度：递归栈的空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">2</span>)+Fibonacci(n-<span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归法会产生大量的重复计算：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/0.png" style="zoom:50%;"></p>
<p><strong>方法二：存储法</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(<span class="math inline">\(1\)</span>)</p>
<p>每次仅用到了最近的两个数，所以可以只存储最近的两个数</p>
<p>sum 存储第 n 项的值，one 存储第 n-1 项的值，two 存储第 n-2 项的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            sum = one + two;</span><br><span class="line">            two = one;</span><br><span class="line">            one = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中出现次数超过一半的数字">02 数组中出现次数超过一半的数字</h3>
<p><strong>题目描述</strong> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,2,2,2,5,4,2]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p>若某个数字出现的次数超过数组长度的一半，则它可以<strong>抵消掉</strong>所有剩下的数字。</p>
<p>用一个变量记录数字，一个变量记录它出现的次数。当次数被其他数字抵消为0时，即可更换新的数字。那么最后变量中存储的数字，可能满足条件也可能不满足，因此需要检验它的次数是否超过数组长度的一半。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不断抵消</span></span><br><span class="line">        <span class="keyword">int</span> num = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;array.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">                    num = array[i];</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                </span><br><span class="line">                <span class="keyword">if</span>(array[i] == num)&#123;</span><br><span class="line">                	cnt++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">            	&#125;                </span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//统计次数</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == num)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//超过一半则为满足条件的数字</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;array.length/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建乘积数组">03 构建乘积数组</h3>
<p><strong>题目描述</strong></p>
<p>给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]<em>A[1]...A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] </em> A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）</p>
<p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[120,60,40,30,24]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/1.png" style="zoom: 50%;"></p>
<p>先计算下三角，再计算上三角。下三角从上往下，下三角从下往上。因为按照这个顺序时，可以发现前一个值上多乘一个数就是后一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(A.length&lt;=<span class="number">1</span> || A==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下三角</span></span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.length; i++)</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上三角，用一个数纪录累乘结果</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">//i=0时，即B[0]也是要计算的</span></span><br><span class="line">            tmp = tmp*A[i+<span class="number">1</span>];</span><br><span class="line">            B[i] = B[i]*tmp;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">		<span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字在排序数组中出现的次数">04 数字在排序数组中出现的次数</h3>
<p><strong>题目描述</strong></p>
<p>统计一个数字在升序数组中出现的次数。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,3,3,3,4,5],3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(logn\)</span>) 空间复杂度：O(1)</p>
<p>使用二分法分别找到 左边界left和右边界right，易得数字target的数量为 right - left - 1。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/2.png" style="zoom: 67%;"></p>
<ol type="1">
<li>初始化： 左边界 i = 0，右边界 j = len(nums) - 1。</li>
<li>循环二分： 当闭区间 [i, j] 无元素时跳出（不满足i<span class="math inline">\(\leq\)</span>j时）；
<ol type="1">
<li>计算中点 m = (i + j) / 2（向下取整）；</li>
<li>若 nums[m] &lt; target ，则 target在闭区间 [m + 1, j] 中，因此执行 i = m + 1；</li>
<li>若 target &lt; nums[m] ，则 target在闭区间 [i, m - 1] 中，因此执行 j = m - 1;</li>
<li>若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；左边界 left 在闭区间 [i, m-1] 中。因此分为以下两种情况：
<ol type="1">
<li>若查找 右边界 right ，则执行 i = m + 1，可以并入nums[m] &lt; target的情况 ；（跳出时 i 指向右边界）</li>
<li>若查找 左边界 left ，则执行 j = m - 1，可以并入target &lt; nums[m] 的情况 ；（跳出时 j 指向左边界）</li>
</ol></li>
</ol></li>
<li>返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right - left - 1 即可。</li>
</ol>
<p>注意到，如果不存在target的时候，right就是最接近target的那个比target大的数，left亦然。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//寻找右边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&lt;=k)&#123; <span class="comment">//这里是将(nums[m] &lt; target) 和 (nums[m] == target &amp;&amp; 探寻右边界) 的情况合并在一起</span></span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rbound = i;</span><br><span class="line">        <span class="comment">//此时i指向右边界，j指向最右边的target</span></span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//寻找左边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&lt;k)&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lbound = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rbound - lbound - <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种简化代码的方式就是只寻找右边界。</p>
<h3 id="和为s的两个数字">05 和为S的两个数字</h3>
<p><strong>题目描述</strong></p>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>返回值描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,4,7,11,15],15</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,11]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span> || array==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> small = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> large = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = Integer.MAX_VALUE; <span class="comment">//判断两数的乘积</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[left]+array[right]&lt;sum)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[left]+array[right]&gt;sum)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(array[left]*array[right]&lt;tmp)&#123;</span><br><span class="line">                    small = array[left];</span><br><span class="line">                    large = array[right];</span><br><span class="line">                    tmp = small*large;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                      </span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(tmp != Integer.MAX_VALUE)&#123;</span><br><span class="line">            res.add(small);</span><br><span class="line">            res.add(large);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中重复的数字">06 数组中重复的数字</h3>
<p><strong>题目描述</strong></p>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p>返回描述：</p>
<p>如果数组中有重复的数字，函数返回true，否则返回false。</p>
<p>如果数组中有重复的数字，把重复的数字放到参数duplication[0]中。（ps:duplication已经初始化，可以直接赋值使用。）</p>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>)：可以设想把交换数字、查找数字解耦，分开看。在此方法下，每访问数组的一个单元格 nums[i] ，就可以把一个数字填到属于它的位置；因此， 将 n 个数字填到正确的位置最多需要 N 次操作，复杂度为 O(N) 。而搜索重复数字的条件是 <code>nums[nums[i]] == nums[i]</code> ，找到这样的数字只需要遍历一遍数组，复杂度为 O(N)。这里只是将两个步骤合在一起写了。 空间复杂度：O(1)</p>
<p>原地交换</p>
<p><strong>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内</strong> 。 此说明含义：数组元素的 索引和 值 是 一对多 的关系。 因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/3.png" style="zoom:67%;"></p>
<p>nums[i]为当前遍历到的数组中的数字，它分为如下三种情况：</p>
<p>若 nums[i] = i： 说明此数字已在对应索引位置，无需交换，因此跳过； 若 nums[nums[i]] = nums[i]： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找到一组重复值，返回此值 nums[i]； 否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。</p>
<p>注意，每遍历到一个位置，都要交换到数组中的数字和下标相同为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==i)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发现数组中的值，和要交换的目标相同，即发现重复</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[ numbers[i] ])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前遍历到的数字交换到它所对应的下标上</span></span><br><span class="line">            <span class="keyword">int</span> tmp = numbers[numbers[i]];</span><br><span class="line">            numbers[numbers[i]] = numbers[i];</span><br><span class="line">            numbers[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组中的查找">07 二维数组中的查找</h3>
<p><strong>题目描述</strong></p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(n\)</span>) 空间复杂度：O(1)</p>
<p>将矩阵旋转后可以发现类似二叉搜索树，根节点为左下角或右上角，选左下角较为方便。暴力遍历二维矩阵的复杂度为O(<span class="math inline">\(mn\)</span>)。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/4.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//令根节点为左下角</span></span><br><span class="line">        <span class="keyword">int</span> row = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( row &gt;= <span class="number">0</span> &amp;&amp; col &lt; array[<span class="number">0</span>].length )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[row][col] &lt; target)&#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[row][col] &gt; target)&#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调整数组顺序使奇数位于偶数前面">08 调整数组顺序使奇数位于偶数前面</h3>
<p>题目描述</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(n^2\)</span>) 空间复杂度：O(1)</p>
<p>插入排序思想，从前往后遍历，不断地挪动位置来使得相对位置保持不变。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/5.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//基数继续移动，偶数停止移动</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; array.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">//偶数继续移动，基数停止移动</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找不到基数则可以停止</span></span><br><span class="line">            <span class="keyword">if</span>(j == array.length)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//此时将a[j]插入到a[i]的位置，即把基数插入到前面</span></span><br><span class="line">            <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j-<span class="number">1</span>; k&gt;=i ; k--)&#123;</span><br><span class="line">                array[k+<span class="number">1</span>] = array[k];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i] = tmp;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(<span class="math inline">\(n^2\)</span>) 空间复杂度：O(1)</p>
<p>冒泡排序思想，即每次将一个偶数交换到最后一个位置，同样可以保持相对顺序不变，冒泡排序稍微快一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123; <span class="comment">//第一个循环只是用来表明有几个数被交换了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)&#123; <span class="comment">// -i是因为已经将i个偶数交换到最后了</span></span><br><span class="line">                <span class="keyword">if</span>(array[j]%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; array[j+<span class="number">1</span>]%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺时针打印矩阵">09 顺时针打印矩阵</h3>
<p>题目描述</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[1,2,3],[4,5,6],[7,8,9]][[1,2],[3,4]]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度：O(<span class="math inline">\(mn\)</span>) 空间复杂度：O(1)</p>
<p>时间复杂度为遍历矩阵。直接模拟遍历，主要是设置四个边界，并将边界往中间缩减。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/6.png" style="zoom: 50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义边界</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在四个方向上移动</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 左右移动，在上边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r; j++) res.add( matrix[t][j] );</span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>; <span class="comment">//++t&gt;b 等价于先给t自增1 ，再判断。这里非常巧妙地避免了重复打印，又缩小边界</span></span><br><span class="line">            <span class="comment">// 上下移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j &lt;= b; j++) res.add( matrix[j][r] );</span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 右左移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = r; j &gt;= l; j--) res.add( matrix[b][j] );</span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 下上移动</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = b; j &gt;= t; j--) res.add( matrix[j][l] );</span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把数组排成最小的数">10 把数组排成最小的数</h3>
<p><strong>题目描述</strong></p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,32,321]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;321323&quot;</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(nlogn\)</span>) 空间复杂度：O(<span class="math inline">\(n\)</span>)</p>
<p>自定义排序规则，将所有数字转为字符串（空间复杂度），若<code>a+b &lt; b+a</code>，为了使得组合数字尽可能小，因此得到规则<code>a&lt;b</code>，将a尽可能放到前面（排序，时间复杂度）。</p>
<p>Java中的compareto方法，返回参与比较的前后a、b两个字符串的asc码的差值，负数则说明a&lt;b。</p>
<p>Java编译器对String做了特殊处理，使得可以直接用+拼接字符串。在循环拼接字符串的过程中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//转成字符串</span></span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(numbers[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义排序规则并排序</span></span><br><span class="line">        Arrays.sort(strs, (x,y)-&gt; (x+y).compareTo((y+x)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; numbers.length; i++)</span><br><span class="line">            res.append(strs[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="机器人的运动范围">11 机器人的运动范围</h3>
<p><strong>题目描述</strong></p>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5,10,10</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(mn\)</span>) 遍历整个矩阵计算是否可达 空间复杂度：O(<span class="math inline">\(mn\)</span>) 记录是否已经到达过</p>
<p>由于机器人从(0,0)开始走，因此可以只向右走和向下走，就能遍历到矩阵的所有元素，不会漏掉。</p>
<p>求数位和的方法就是不断地取模10，累加余数。</p>
<p>Java中布尔型(boolean)变量默认值为false。</p>
<p>采用DFS方法，回溯地遍历整个整个矩阵。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义求数位和的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x !=<span class="number">0</span> )&#123;</span><br><span class="line">            res = res + x % <span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">return</span> dfs(rows, cols, threshold, visited, <span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> threshold, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断终止条件</span></span><br><span class="line">        <span class="keyword">if</span>( x &gt;= rows || y &gt;= cols || visited[x][y] || sums(x) + sums(y) &gt; threshold ) <span class="comment">//注意先判断是否越界，否则visited可能会导致数组越界异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归遍历</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(rows, cols, threshold, visited, x, y+<span class="number">1</span>) + dfs(rows, cols, threshold, visited, x+<span class="number">1</span>, y);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中的逆序对">12 数组中的逆序对</h3>
<p><strong>题目描述</strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>对于50%的数据,<span class="math inline">\(size\leq 10^4\)</span> 对于75%的数据,<span class="math inline">\(size\leq 10^5\)</span> 对于100%的数据,<span class="math inline">\(size\leq 2*10^5\)</span></p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,0]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度：O(<span class="math inline">\(nlogn\)</span>) 空间复杂度：O(<span class="math inline">\(n\)</span>)</p>
<p>利用归并排序的思想，在两个有序数组的归并过程中，统计逆序对的数量。这样就将蛮力法两次循环的复杂度（<span class="math inline">\(O(n^2)\)</span>），降低为归并排序的复杂度。</p>
<p>假设我们有两个已排序的序列等待合并，分别是$ L = { 8, 12, 16, 22, 100 }<span class="math inline">\(和\)</span>R={9,26,55,64,91}<span class="math inline">\(。一开始我们用指针\)</span>lPtr = 0<span class="math inline">\(指向\)</span>L<span class="math inline">\(的首部，\)</span>rPtr = 0$ 指向<span class="math inline">\(R\)</span>的头部。记已经合并好的部分为 M。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; []</span><br><span class="line">     |                          |</span><br><span class="line">   lPtr                       rPtr</span><br></pre></td></tr></table></figure>
<p>lPtr 指向的元素小于 rPtr 指向的元素，于是把 lPtr 指向的元素放入辅助数组，并把 lPtr 后移一位。这个时候把左边的 8 加入了辅助数组，可以发现发现右边没有数比 8 小，所以 8 对逆序对总数的「贡献」为 0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>
<p>接着继续合并，把 9 加入了辅助数组，此时 lPtr 指向 12，rPtr 指向 26。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8, 9]</span><br><span class="line">        |                          |</span><br><span class="line">       lPtr                       rPtr</span><br></pre></td></tr></table></figure>
<p>然后，继续合并，将左边的12加入辅助数组。此时 lPtr 比 rPtr 小，把 lPtr 对应的数加入答案，并考虑它对逆序对总数的贡献为 rPtr 相对 R 首位置的偏移 1（即右边只有一个数比 12 小，所以只有它和 12 构成逆序对），以此类推。</p>
<p>用这种「算贡献」的思想在合并的过程中计算逆序对的数量的时候，只在 lPtr 右移的时候计算，当前 lPtr 指向的数字比 rPtr 小，但是比 R 中 [0 ... rPtr - 1] 的其他数字大，[0 ... rPtr - 1] 的其他数字本应当排在 lPtr 对应数字的左边，但是它排在了右边，所以这里就贡献了 rPtr 个逆序对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">//全局变量记录结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span> || array == <span class="keyword">null</span> || left == right) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//此时左右数组皆为有序</span></span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right) &#123;</span><br><span class="line">            </span><br><span class="line">            result = array[l]&lt;array[r]? (result+r-(mid+<span class="number">1</span>))%<span class="number">1000000007</span> : result; <span class="comment">//左指针数字更小，则发生判断表明右边产生逆序对，即右指针的偏移量</span></span><br><span class="line">            help[p++] = array[l]&lt;array[r]? array[l++] : array[r++]; <span class="comment">//进行排序，将小的数字放入辅助数组</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缺点就在这个位置</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid)&#123; </span><br><span class="line">            result = (result + right-mid)%<span class="number">1000000007</span>;</span><br><span class="line">            help[p++] = array[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right) help[p++] = array[r++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将辅助数组的值复制到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;help.length; i++)</span><br><span class="line">            array[left+i] = help[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到，统计右边数组的偏移量时，假如右边数组先偏移完成，会导致左边数组每次偏移的时候都要统计一遍，因为此时左数组中的每个值都比右数组大，因此左边数组剩下的每一个数都可以和右边数组产生逆序对。</p>
<p>因此做出如下改动，当右数组的值小于左数组的时候，将右数组的值加入辅助数组，左数组剩余的个数即为逆序对个数，因为此时左数组中剩余的数都可以和当前右数组的数构成逆序对。</p>
<p><strong>即当左数组偏移的时候，表明左数组的数小，不和右数组构成逆序对。当右数组偏移的时候，表明右数组的数小，左数组剩余的数每个都可以和当前右数组的值构成逆序对。因此，不会产生遗漏。</strong></p>
<p>例如此时，12比9大，因此将9加入辅助数组，此时可以发现，左数组中剩余的每个数，都可以和当前右数组中的值9构成逆序对，因此发生统计行为。所以此时是右数组发生偏移的时候，才产生统计操作，而非左数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br></pre></td></tr></table></figure>
<p>接着继续合并，把 9 加入了辅助数组，此时 lPtr 指向 12，rPtr 指向 26。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">//全局变量记录结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span> || array == <span class="keyword">null</span> || left == right) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//此时左右数组皆为有序</span></span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=right) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[l] &lt;= array[r])&#123;</span><br><span class="line">                help[p++] = array[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//右数组的数小，左数组每个剩余的数都可以和当前右数组数构成逆序对</span></span><br><span class="line">                result = (result + mid-l+<span class="number">1</span>)%<span class="number">1000000007</span>;</span><br><span class="line">                help[p++] = array[r++];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l&lt;=mid) help[p++] = array[l++];   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(r&lt;=right) help[p++] = array[r++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将辅助数组的值复制到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;help.length; i++)</span><br><span class="line">            array[left+i] = help[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最快的方法是不要每次都新开数组help，直接在一开始就开辟一个同样长度的数组，然后每次都在这个数组上进行操作。</p>
<h3 id="旋转数组的最小数字">013 旋转数组的最小数字</h3>
<p><strong>题目描述</strong></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,4,5,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(logn\)</span>)：二分法的复杂度，当数组中的数字全部相同时退化为O(<span class="math inline">\(n\)</span>) 空间复杂度O(1)：</p>
<p>排序数组的查找问题，首先想到二分法。旋转后数组可以分为两部分，前半部分比后半部分都要大，因此每次二分时有如下情况：</p>
<p>1、mid &gt; high，比后半部分数组大的情况，说明mid现在在前半部分数组中，要找的最小数字应该在mid之后，low = mid + 1。</p>
<p>2、mid &lt; high， 比后半部分数组小的情况，说明mid现在在后半部分数组中，要找的最小数字应该在mid之前，high = mid。注意！这里不是high = mid -1，因为要找的最小数字可能是mid！</p>
<p>3、当mid = high，无法判断mid所在位置，将high--缩小范围。</p>
<p>直到 low == high时，找到最小的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt; array[high])</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; array[high])</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连续子数组的最大和">014 连续子数组的最大和</h3>
<p>题目描述</p>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,-2,3,10,-4,7,2,-5]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历一遍数组 空间复杂度O(<span class="math inline">\(n\)</span>)：使用辅助数组，或者直接在原数组上修改也可</p>
<p>首先，注意是<strong>连续子数组</strong>。</p>
<p>使用一维数组动态规划的方法，dp[i]代表以元素 array[i] 为结尾的连续子数组最大和。</p>
<p>讨论，dp[i]和dp[i-1]的关系，假如dp[i-1]为负数或者0，说明dp[i-1]对dp[i]没有产生贡献，即dp[i-1]+array[i]还不如array[i]本身要大。<strong>此时连续子数组的开头变更为array[i]</strong>。</p>
<p>因此，注意dp[array.length -1]，即到最后一个元素时，<strong>以最后一个元素为结尾的连续子数组最大和并不一定是最大的</strong>！可能是前面的某个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= array.length-<span class="number">1</span>; i++)&#123;            </span><br><span class="line">            dp[i] = Math.max( array[i], array[i]+dp[i-<span class="number">1</span>] );</span><br><span class="line">            max = Math.max( max, dp[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中只出现一次的数字及2">015 数组中只出现一次的数字（及2）</h3>
<p>题目描述</p>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：需要遍历两遍数组 空间复杂度O(1)：不使用额外空间</p>
<p>异或运算：相同为0，不同为1</p>
<p>异或运算拥有如下性质：</p>
<p>任何数和0异或，仍为本身：a⊕0 = a 任何数和本身异或，为0：a⊕a = 0 异或运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b</p>
<p>则可以知道，当<strong>任何数出现两次之后，其异或值都为0，即可以消去</strong>。假如将数组中的所有数都异或，则剩下那两个只出现一次的数的异或结果，这是<strong>由异或的交换律和结合律</strong>决定的：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/7.png" style="zoom:33%;"></p>
<p>当得到两个数的异或结果时，由异或不同位置为1的计算可以知道，<strong>这两个数在有1的位置上，肯定是有一个是1，有一个是0</strong> 。那么，<strong>将剩余的数按照这个位置分成两组，两组内分别异或</strong>之后就可以消去出现两次的数，则分别只剩下只出现一次的数。</p>
<p>问题1：如何找到异或结果中为1的位置？</p>
<p>x &amp; (-x) 来保留最右边的 1。</p>
<p>一个数（x）的负数（-x），其二进制表示为反码+1（~x+1）。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/8.png" style="zoom: 43%;"></p>
<p>某个数最右边的1，反码之后为0，加1肯定是这个位置变成1（因为它是最右边，或者进位），因此x &amp; (-x) 的运算结果就是二进制下保留最右边的 1，其余位置皆为0。</p>
<p>问题2：如何将剩余的数按照某个位置分成组？</p>
<p>x &amp; 010 即可对 x 进行分组。</p>
<p>因为只有一位为1，因此&amp;就运算结果为0的就分为一组，不为0的就可以分为另一组。</p>
<p>最后，初始化两个变量为0，分别和不同分组的数做异或运算即可（初始化为0利用了a⊕0 = a的性质）。</p>
<p>因此，整个算法流程如下：</p>
<p>1、所有数做异或运算，得到仅出现一次的两个数的异或结果。</p>
<p>2、x &amp; (-x) 来保留异或结果最右边的 1</p>
<p>3、利用&amp;操作对数字进行分组，再次对所有数进行异或，即可得到两个结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//得到仅出现一次的两个数的异或结果</span></span><br><span class="line">        <span class="keyword">int</span> xorall = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)</span><br><span class="line">            xorall = xorall ^ i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//x &amp; (-x) 来保留异或结果最右边的 1</span></span><br><span class="line">        <span class="keyword">int</span> split = xorall &amp; (-xorall);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//利用&amp;操作对数字进行分组，并再次对所有数进行异或</span></span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>; num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)&#123;      </span><br><span class="line">            <span class="keyword">if</span>((i&amp;split) == <span class="number">0</span>)</span><br><span class="line">            	num1[<span class="number">0</span>] = num1[<span class="number">0</span>] ^ i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] = num2[<span class="number">0</span>] ^ i;         </span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目描述</strong></p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>输入: [2,2,3,2] 输出: 3</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(32n\)</span>)：整数二进制一共有32位，每一位都要遍历一遍数组，统计1的个数 空间复杂度O(1)：不使用额外空间</p>
<p>由于出现多次的数字变成了奇数，因此不能用异或进行消去。转为二进制<strong>考虑数组中所有数字，转为二进制后，每一位上面1个个数和</strong>：</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/9.png" style="zoom:43%;"></p>
<p>如果其他数都出现 3 次，只有目标数出现 1 次，那么每一位的 1 的个数无非有这2种情况，为 3 的倍数（全为出现三次的数） 或 3 的倍数 +1（包含出现一次的数）。这个 3 的倍数 +1 的情况也就是我们的目标数的那一位。</p>
<p>因此算法首先将结果初始化为0，然后统计每一位上1的个数，并将%3!=0的位置修改为1。</p>
<p><strong>&lt;&lt;</strong> 左移动运算符：运算数的各二进位全部左移若干位，高位丢弃，低位补0。（将二进制的1挪动到需要的位置上）</p>
<p><strong>&gt;&gt;</strong> 右移动运算符：运算数的各二进位全部右移若干位，低位丢弃，高位补0。（判断每位的1的个数时，移动到该位置）</p>
<p>a &amp; 1：a &amp; 1 中 1 只有最后一位为 1，其余位皆为 0 ，因此 a &amp; 1的作用就是判断 a 的最后一位是否为 1。（判断每位的1的个数）</p>
<p>a | 1：只要对应的二个二进制位有一个为1时，结果位就为1。（将结果的某个位置修改为1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">              <span class="comment">//先将数右移，并求出最后一位为 1 的个数</span></span><br><span class="line">              <span class="comment">//比如 0 3 4，就会先判断4，再到3，再到0</span></span><br><span class="line">              <span class="keyword">if</span> ((nums[j] &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;             </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//找到某一位取余为 1 的数，把1左移到那个位置，再和结果取或，就可以把对应位置修改为1</span></span><br><span class="line">          <span class="keyword">if</span> (count % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">              res = <span class="number">1</span> &lt;&lt; i | res;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="和为s的连续正数序列">016 和为s的连续正数序列</h3>
<p><strong>题目描述</strong></p>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<p>输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：</p>
<p>输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：最多循环n次（left和right都到达n/2） 空间复杂度O(1)：不使用额外空间</p>
<p>注意到题目中所说的连续序列，则联想到滑动窗口。</p>
<p>滑动窗口可以看成<strong>数组中框起来的一个部分</strong>。滑动窗口一般表示成一个<strong>左闭右开区间</strong>。在一开始，i=1, j=1，滑动窗口位于序列的最左侧，窗口大小为零。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E6%95%B0%E7%BB%84/10.png" style="zoom:50%;"></p>
<p>则可以知道每次判断滑动窗口内数字的和，根据和的大小来判断左右端点的变化。</p>
<ul>
<li>当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li>
<li>当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li>
<li>当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i, j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动。</li>
</ul>
<p>左端点最多只能到target/2处，它加上后面的任何一个数都已经比target要大了。</p>
<p><strong>实际上，把题目中的正整数序列换成任意的递增整数序列，滑动窗口方法都可以解。</strong></p>
<p>滑动窗口的重要性质是：窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">       </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;<span class="comment">//注意右边是开区间，不能取到这个数</span></span><br><span class="line">        <span class="keyword">int</span> tmpsum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= sum/<span class="number">2</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tmpsum &lt; sum)&#123; <span class="comment">//扩展窗口右边界，增大tmpsum</span></span><br><span class="line">                tmpsum = tmpsum + right;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &gt; sum)&#123; <span class="comment">//扩展窗口左边界，减小tmpsum</span></span><br><span class="line">                tmpsum = tmpsum - left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//记录结果</span></span><br><span class="line">                ArrayList&lt;Integer&gt; tmpres = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++)</span><br><span class="line">                    tmpres.add(i);</span><br><span class="line">                res.add(tmpres);</span><br><span class="line">                </span><br><span class="line">                tmpsum = tmpsum - left;<span class="comment">//扩展窗口左边界，减小tmpsum</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>数字在排序数组中出现的次数：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/</p>
<p>数组中重复的数字：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/</p>
<p>二维数组中的查找：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/</p>
<p>调整数组顺序使奇数位于偶数前面：牛客Ariser.cn</p>
<p>顺时针打印矩阵：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/</p>
<p>机器人的运动范围：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/jian-zhi-offerer-shua-javadfs-bfs-tu-jie-py05/</p>
<p>数组中的逆序对：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</p>
<p>旋转数组的最小数字：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</p>
<p>连续子数组的最大和：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</p>
<p>数组中只出现一次的数字（及2）：https://leetcode-cn.com/problems/single-number/solution/dong-hua-dong-tu-yi-ding-hui-by-yuan-chu-vs4p/</p>
<p>和为s的连续正数序列：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 字符串</title>
    <url>/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>剑指Offer中关于字符串的题目解析。</p>
<a id="more"></a>
<h3 id="左旋转字符串">01 左旋转字符串</h3>
<p>题目描述</p>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;abcXYZdef&quot;,3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;XYZdefabc&quot;</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中<span class="math inline">\(n\)</span>为字符串<span class="math inline">\(s\)</span>的长度，字符串切片函数为线性时间复杂度 空间复杂度 O(<span class="math inline">\(n\)</span>)： 两个字符串切片的总长度为<span class="math inline">\(n\)</span></p>
<p>字符串切片：新建两切片字符串，并将两切片拼接为结果字符串，无冗余操作，效率最高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当n超过数组长度时，对n取模使得分割下标位于数组长度以内</span></span><br><span class="line">        <span class="keyword">int</span> sub_index = n % str.length() ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意切片时不包括末尾的下标</span></span><br><span class="line">        <span class="keyword">return</span> str.substring(sub_index, str.length())+str.substring(<span class="number">0</span>, sub_index); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>列表遍历拼接：先把后面的字符加入StringBuilder，再将前面的字符加入。列表(Python) 和 StringBuilder(Java) 都是可变对象，每轮遍历拼接字符时，只是向列表尾部添加一个新的字符元素。最终拼接转化为字符串时，系统 仅申请一次内存 。</p>
<p>字符串遍历拼接：也是先把后面的字符加入，但是用的是字符串拼接。string + string，在 Python 和 Java 中，字符串是 “不可变对象” 。因此，每轮遍历拼接字符时，都需要新建一个字符串；因此，系统 需申请 n 次内存 ，数据量较大时效率低下。</p>
<h3 id="反转单词序列">02 反转单词序列</h3>
<p>题目描述</p>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;nowcoder. a am I&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;I am a nowcoder.&quot;</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中<span class="math inline">\(n\)</span>为字符串<span class="math inline">\(s\)</span>的长度。 空间复杂度 O(<span class="math inline">\(n\)</span>)： 因为给定的是不可变的String，因此需要额外开辟空间存储。</p>
<p>每个字母的顺序并没有反转，仅反转单词顺序。可以采用先反转每个单词，再将整个句子反转的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] cha = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= cha.length; i++)&#123; <span class="comment">//注意这里有个等号，用来处理最后一个单词</span></span><br><span class="line">            <span class="keyword">if</span>( i == cha.length || cha[i] == <span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">//注意这个位置，先判断是不是超过数组，否则cha[i]会发生越界</span></span><br><span class="line">                Reverse(cha, j, i-<span class="number">1</span>);</span><br><span class="line">                j = i+<span class="number">1</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        Reverse(cha, <span class="number">0</span>, cha.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        不可以用toString！！！</span></span><br><span class="line"><span class="comment">        一般类的toString()方法返回的是该类所在的地址值。</span></span><br><span class="line"><span class="comment">        而由于String类和Integer类已经重写了toString()方法，所以输出的是类对象中存储的内容</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(cha); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将一段数组内的字符全部反转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> [] str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">            Swap(str, left++, right--);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> [] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = str[i];</span><br><span class="line">        str[i] = str[j];</span><br><span class="line">        str[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符流中第一个不重复的字符-及其位置">03 字符流中第一个不重复的字符 （及其位置）</h3>
<p><strong>题目描述</strong></p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。</p>
<p>返回值描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果当前字符流没有存在出现一次的字符，返回#字符。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong>：</p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 其中<span class="math inline">\(n\)</span>为字符串<span class="math inline">\(s\)</span>的长度，遍历字符流和有序哈希表的复杂度是<span class="math inline">\(O(n)\)</span>，有序哈希表的查找操作是<span class="math inline">\(O(1)\)</span>，哈希表的插入操作复杂度是？？？？； 空间复杂度 O(<span class="math inline">\(1\)</span>)： 由于题目中指出的是字符流，LinkedHashMap 中字符的个数是有限的256个</p>
<p>Java 使用 LinkedHashMap 实现<strong>有序哈希表</strong>。有序哈希表中的<strong>键值对是按照插入顺序排序的</strong>。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为1的字符”。</p>
<p>LinkedHashMap中put方法参数为key和value，表示插入key与value。如果key存在，则旧值被替换。containsKey方法表示是否含有该key，含有则返回true。（本题中，含有则表示字符之前已经出现过了）</p>
<p>使用哈希表的本质原因是为了给每个字符进行统计。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Character, Boolean&gt; res = <span class="keyword">new</span> LinkedHashMap&lt;Character, Boolean&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.put(ch, res.containsKey(ch)); <span class="comment">//如果首次加入，则不包含该值，会返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//遍历有序哈希表，就是元素加入的顺序，找到第一个为false的即可</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d: res.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(d.getValue() == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">return</span> d.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种简单的方式是用HashMap的值储存元素出现的次数，遍历两次字符串即可，但是这样的问题是当字符串很长且前面有很多重复元素时，时间效率低下。</p>
<p><strong>第一个只出现一次的字符位置</strong></p>
<p><strong>题目描述</strong></p>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;google&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历两次字符数组的复杂度是<span class="math inline">\(O(n)\)</span>，有序哈希表的查找操作是<span class="math inline">\(O(1)\)</span> 空间复杂度 O(<span class="math inline">\(1\)</span>)： 由于题目中指出的是字符流，HashMap中字符的个数是有限的256个</p>
<p>若要求取位置，则就用HashMap，并且采用两次遍历的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Character, Boolean&gt; hm = <span class="keyword">new</span> HashMap&lt;Character, Boolean&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> [] array = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : array)&#123;</span><br><span class="line">            hm.put(c, hm.containsKey(c)); <span class="comment">//首次加入时因为没有而是false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hm.get(array[i]) == <span class="keyword">false</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="替换空格">04 替换空格</h3>
<p><strong>题目描述</strong> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历统计和遍历修改的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(1\)</span>)： 由于是原地扩展字符串的长度，因此使用<span class="math inline">\(O(1)\)</span>额外空间。</p>
<p>一种简单的思路是构建StringBuilder，然后遇到空格就添加%20，但是这样会额外使用O(<span class="math inline">\(n\)</span>)的空间，因此考虑直接在原字符串（StringBuffer类型，直接String类型则无法修改）上进行修改。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/0.png" style="zoom:67%;"></p>
<p>具体做法就是先统计空格的数量，然后增加原字符串的长度，并用双指针从后往前移动字符。因为后指针每次遇到空格都会比前指针多走，所以当两个指针相遇时，即表示前面已经无空格，可停止算法。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/1.png" style="zoom:45%;"></p>
<p>Java中StringBuffer类型有方法setLength()、setCharAt()、toString()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">//统计空格数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//增加StringBuffer长度</span></span><br><span class="line">        <span class="keyword">int</span> ol = str.length();</span><br><span class="line">        <span class="keyword">int</span> nl = ol+count*<span class="number">2</span>;</span><br><span class="line">        str.setLength(nl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//双指针移动</span></span><br><span class="line">        <span class="keyword">int</span> left = ol - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nl - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果是空格，则right处填充符号</span></span><br><span class="line">            <span class="keyword">if</span>(str.charAt(left) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                str.setCharAt(right - <span class="number">2</span>, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                str.setCharAt(right - <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                str.setCharAt(right, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                right = right - <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//不是空格，则移动left处数值</span></span><br><span class="line">                str.setCharAt(right, str.charAt(left)); </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            left--;</span><br><span class="line">            right--;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表示数值的字符串">05 表示数值的字符串</h3>
<p><strong>题目描述</strong></p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;123.45e+6&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;1.2.3&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历字符串的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(1\)</span>)： 使用<span class="math inline">\(O(1)\)</span>额外空间。</p>
<p>表示数值的字符串可以分为A.B<strong>e</strong>C或A.B<strong>E</strong>C。整数部分为A，小数部分为B，指数部分为C，按顺序判断是否包含这三部分。如果符合条件，则指针可以指向字符串的末尾。</p>
<p>使用全局index遍历字符串。</p>
<p>scanInteger扫描有符号整数，用来匹配A和C部分。</p>
<p>scanUnsignedInteger扫描无符号整数，用来匹配B部分。</p>
<p>每次匹配元素时，都要判断下标是否发生越界，此问题可以用加入终止符号来解决，但是本例是数组，因此只能每次判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局下标</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//scanUnsignedInteger扫描无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> before = index; <span class="comment">//判断指针是否移动，成功移动才说明匹配成功       </span></span><br><span class="line">        <span class="keyword">while</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; (str[index]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; str[index]&lt;=<span class="string">&#x27;9&#x27;</span>) )</span><br><span class="line">            index++;        </span><br><span class="line">        <span class="keyword">return</span> index &gt; before;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//scanInteger扫描有符号整数（可能有也可能没有正负号）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; (str[index] == <span class="string">&#x27;+&#x27;</span> || str[index] == <span class="string">&#x27;-&#x27;</span>)) </span><br><span class="line">            index++;       </span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始匹配整个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">boolean</span> res;</span><br><span class="line">               </span><br><span class="line">        <span class="comment">//首先匹配A</span></span><br><span class="line">        res = scanInteger(str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如存在小数点</span></span><br><span class="line">        <span class="comment">//如果是a.xx这种，则index停留在非数值处，不会进入小数点匹配</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; str[index]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            index++; <span class="comment">//匹配小数点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*+.5、5.、.5都是可行的，即 scanInteger.scanUnsignedInteger 即为合法</span></span><br><span class="line"><span class="comment">             ||只要满足第一个条件，后面的条件就不再判断</span></span><br><span class="line"><span class="comment">             若为 res || scanUnsignedInteger(str) 则只要scanInteger部分为true则不再判断，这不可行，因为要判断</span></span><br><span class="line"><span class="comment">             小数点后是否存在非数字，如1.a</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            res = scanUnsignedInteger(str) || res;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如存在科学计数法e或E</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;= str.length-<span class="number">1</span> &amp;&amp; (str[index] == <span class="string">&#x27;e&#x27;</span> || str[index] == <span class="string">&#x27;E&#x27;</span>))&#123;</span><br><span class="line">            </span><br><span class="line">            index++;</span><br><span class="line">            res = res &amp;&amp; scanInteger(str) ; <span class="comment">//&amp;&amp;只要第一个条件不满足，后面条件就不再判断，这里相当于提前返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//指针成功移动到末尾则表明符合判断</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        需要res，比如12e，当进入有e时执行scanInteger(str)会返回false，因为没有数字没有发生移动</span></span><br><span class="line"><span class="comment">        但此时指针依然指向最后一位，所以不能光靠是否移动到结尾判断</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> (index == str.length ) &amp;&amp; res == <span class="keyword">true</span> ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种解法为有限状态自动机，正则表达式的内部实现即为有限状态自动机，不用正则表达式则需手动实现各种状态的转换。</p>
<h3 id="扑克牌顺子">06 扑克牌顺子</h3>
<p><strong>题目描述</strong></p>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历数组的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(n\)</span>)： 使用<span class="math inline">\(O(n)\)</span>额外空间，额外使用数据结构HashSet来保证无重复。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/2.png" style="zoom: 67%;"></p>
<p>顺子即不能出现重复的数字，并且顺子中最大值减去最小值的差距小于5。</p>
<p>Java中Set数据结构不允许出现重复元素，不保证集合中元素出现的顺序。</p>
<p>Set是一个接口，实例化Set可以采用HashSet， HashSet类按照哈希算法来存取集合中的对象，存取速度比较快 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先判断元素个数</span></span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length != <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用集合去重</span></span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">14</span>; <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//跳过0，因为0可以重复</span></span><br><span class="line">            min = Math.min(min, numbers[i]);</span><br><span class="line">            max = Math.max(max, numbers[i]);</span><br><span class="line">            <span class="keyword">if</span>(res.contains(numbers[i])) <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            res.add(numbers[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用空间复杂度低，时间复杂度高的方法，就是先排序，然后遍历数组的同时判断是否有重复，并记录最大最小值。</p>
<h3 id="把字符串转换成整数">07 把字符串转换成整数</h3>
<p><strong>题目描述</strong></p>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>)： 遍历字符串的复杂度是<span class="math inline">\(O(n)\)</span> 空间复杂度 O(<span class="math inline">\(n\)</span>)： 使用<span class="math inline">\(O(1)\)</span>额外空间，即结果处的整数。</p>
<p>首先是整数，因此不存在'.'和'E'、'e'等任何字符，只存在正负号这个特殊字符。</p>
<p>然后就是越界问题，整数的范围是<span class="math inline">\([-2^{31},2^{31}-1]\)</span>，即<span class="math inline">\([-2147483648,2147483647]\)</span>。整数最多只能是十位数，因此只需要判断每次转换一个数字时是否到达边界<span class="math inline">\(bndry = Integer.MAX\_VALUE /10 = 214748364\)</span>，以及该边界处的处理情况。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/3.png" style="zoom:67%;"></p>
<p>注意牛客网中超过该范围时返回的时非法情况，leetcode中则返回最大最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理符号</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">true</span>; <span class="comment">//表示正数</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            index++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            sign = <span class="keyword">false</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历字符串判断边界</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bndry = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt; str.length(); index++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//不是数字立刻返回</span></span><br><span class="line">            <span class="keyword">char</span> ca = str.charAt(index);</span><br><span class="line">            <span class="keyword">if</span>(ca &gt; <span class="string">&#x27;9&#x27;</span> || ca &lt; <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	判断加入该数后是否越界，越界则直接返回 </span></span><br><span class="line"><span class="comment">            	现在是214748364x，判断x，整数位数最多十位，因此在这里就要返回</span></span><br><span class="line"><span class="comment">            	若是 214748363 38，则此刻 res == 214748363 3依然超过bndry，可直接返回</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; bndry) <span class="comment">//这里其实有两种情况，一种是res的长度刚好是9位，另一种刚好是10位，然后判断下一位数字，10位时直接越界，因为还存在第11位</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( res == bndry)&#123;                </span><br><span class="line">                <span class="keyword">if</span>(sign)&#123;<span class="comment">//如果是正数越界直接返回,否则加入该数，到字符串尾部了就会跳出循环，否则下一轮res &gt; bndry越界</span></span><br><span class="line">                    <span class="keyword">if</span>( ca &gt; <span class="string">&#x27;7&#x27;</span> ) <span class="keyword">return</span>  <span class="number">0</span> ;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果是负数</span></span><br><span class="line">                    <span class="keyword">if</span>( ca &gt; <span class="string">&#x27;8&#x27;</span> ) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                            </span><br><span class="line">            <span class="comment">//加入该数</span></span><br><span class="line">            res = res * <span class="number">10</span> + (ca - <span class="string">&#x27;0&#x27;</span>);                        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign == <span class="keyword">true</span> ? res : -res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串的排列-子串包含">08 字符串的排列 &amp; 子串包含</h3>
<p>题目描述</p>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;ab&quot;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;ab&quot;,&quot;ba&quot;]</span><br></pre></td></tr></table></figure>
<p>题解</p>
<p>时间复杂度O(<span class="math inline">\(n!\)</span>)：比如3个字符的全排列有6种。 空间复杂度O(1)：原地交换。</p>
<p>字符串的全排列就是序列中的字符不断与后面的字符做交换，通过<strong>递归</strong>进行实现。字典序打印就是排列完成后进行排序即可。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/5.png" style="zoom:50%;"></p>
<p>注意到，假如当前元素和要交换的元素是重复元素时，不进行交换，来节省时间，除非是首个元素自己和自己交换。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/6.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全局结果</span></span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> [] cha = str.toCharArray();</span><br><span class="line">        recurPermu(cha, <span class="number">0</span>);       </span><br><span class="line">        Collections.sort(res);<span class="comment">//注意这个sort是不返回东西的</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurPermu</span><span class="params">(<span class="keyword">char</span> [] cha, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(index == cha.length - <span class="number">1</span>) <span class="comment">//只剩最后一个char，不用交换</span></span><br><span class="line">            res.add(<span class="keyword">new</span> String(cha));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; cha.length; i++)&#123; <span class="comment">//将首个char和后面所有元素交换</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                cha[index] != cha[i] 防止重复元素交换浪费时间</span></span><br><span class="line"><span class="comment">                index == i 数组中首个元素必须能够进入进行递归</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span>( cha[index] != cha[i] || index == i  )&#123;</span><br><span class="line">                    swap(cha, index, i);</span><br><span class="line">                    recurPermu(cha, index+<span class="number">1</span>); <span class="comment">//将位置往后移动一个，进行递归交换</span></span><br><span class="line">                    swap(cha, index, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> [] cha, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = cha[i];</span><br><span class="line">        cha[i] = cha[j];</span><br><span class="line">        cha[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目描述</strong></p>
<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>
<p>示例1:</p>
<p>输入: s1 = "ab" s2 = "eidbaooo" 输出: True 解释: s2 包含 s1 的排列之一 ("ba").</p>
<p>注意：</p>
<p>输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(l_1 + 26*(l_2 - l1)\)</span>)： <span class="math inline">\(l_1、l_2\)</span>均为字符串长度，即初始化时间+遍历<span class="math inline">\(l_2\)</span>并判断的时间。 空间复杂度 O(<span class="math inline">\(1\)</span>)： 使用O<span class="math inline">\((1)\)</span>常数级额外空间，因为只有26个字符。</p>
<p>滑动窗口解法。</p>
<p>将排列转换为比较字母出现的次数是否相同。</p>
<p>求s2中是否存在s1的全排列，即窗口大小为s1的长度，在这个窗口长度内，两个字符串是否存在所有字母个数一一对应。</p>
<p>字母从a-z，所以可以使用两个长度为26的int数组来表示出现的个数，即哈希表的长度可以仅维持在26，并且滑动窗口始终维护同一个哈希表，而不是每次移动都要建立一个新的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() &gt; s2.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//因为字符串都是a-z的字母，所以我们可以使用一个长度为26的int数组来存储每个字母出现的个数</span></span><br><span class="line">        <span class="keyword">int</span>[] s1map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s2map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//s2map实际上代表了字符串s2在窗口内所有字母的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            s1map[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="comment">//窗口大小为s1.length，索引从[0 —— s1.length-1]到[s2.length-s1.length —— s2.length-1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length() - s1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//如果匹配，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (matches(s1map, s2map))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果不匹配，窗口向后移动一位</span></span><br><span class="line">            <span class="comment">//窗口加入下一个字母</span></span><br><span class="line">            s2map[s2.charAt(i + s1.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="comment">//窗口移除第一个字母</span></span><br><span class="line">            s2map[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matches(s1map, s2map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="keyword">int</span>[] s1map, <span class="keyword">int</span>[] s2map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1map[i] != s2map[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配">09 正则表达式匹配</h3>
<p><strong>题目描述</strong></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。</p>
<p>'.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(mn\)</span>)： 遍历两个字符串的复杂度。 空间复杂度 O(<span class="math inline">\(mn\)</span>)： dp数组的空间。</p>
<p>字符串匹配的题目可以使用动态规划的解法。</p>
<p>s表示string，p表示pattern。</p>
<p><span class="math inline">\(dp[i][j]\)</span> 表示字符串中s中的前i个字符与字符串p中的前j个字符是否能够匹配。因此当p[i-1]和s[i-1]能够发生匹配时，需要判断它们的状态从哪里转移过来，如果不能匹配则直接为false状态。以下情况都是发生匹配时的状态转移，这里假设数组的下标从1开始：</p>
<ul>
<li><p>当 s[i] == p[j] 或 p[j] == '.'时</p>
<p><span class="math inline">\(dp[i][j] = dp[i-1][j-1]\)</span>。</p>
<p>即包括当前两个字符的前i个字符和前j个字符的整个字符串的匹配状态，由前 i-1 个字符和 s 前 j-1 个字符的匹配状态决定，能匹配就匹配，不能匹配就不匹配。</p></li>
<li><p>p[j] == '*'时，有两种情况。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%AD%97%E7%AC%A6%E4%B8%B2/4.png" style="zoom: 50%;"></p>
<ul>
<li><p>s[i] == p[j-1]（p[j-1] == '.'）</p>
<p>即'*'之前的字符能和当前string中的字符发生匹配。</p>
<p><span class="math inline">\(dp[i][j] = dp[i-1][j]\)</span>。</p>
<p>也是就相当于看string前一个字符和当前pattern中'*'的状态。（这个状态在确认的时候会检查条件s[i-1]和p[j-1]，如此递归下去。）</p>
<p>即使能发生匹配，也可以不使用这个匹配。（因为'*'表明可以是0次）</p>
<p><span class="math inline">\(dp[i][j] = dp[i][j-2]\)</span>。</p>
<p>直接删除'*'及其前一个字符，并检查s[i]和p[j-2]时的匹配情况。</p></li>
<li><p>s[i] != p[j-1]</p>
<p>即'*'之前的字符不能和当前string中的字符发生匹配。</p>
<p><span class="math inline">\(dp[i][j] = dp[i][j-2]\)</span>。</p>
<p>直接删除'*'及其前一个字符，并检查s[i]和p[j-2]时的匹配情况。</p></li>
</ul></li>
</ul>
<p>注意初始化的时候，当string为''时，pattern为'.*'也是可以匹配的，因为'*'可以表示不取。所以此时要单独初始化dp数组中的第一行，初始化的准则是，当dp数组第一行奇数位不管什么字符都是false（包括.，因为.指的是任意字符，必须存在），dp数组中偶数位为* 时则: dp[0][i] = dp[0][i - 2]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s_len = str.length;</span><br><span class="line">        <span class="keyword">int</span> p_len = pattern.length;</span><br><span class="line">        <span class="keyword">boolean</span> [][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s_len+<span class="number">1</span>][p_len+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化动态规划数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理 i = 0， j的情况，即string是空字符，pattern不为空</span></span><br><span class="line">        <span class="comment">//dp数组中奇数位不管什么字符都是false（包括.，因为.指的是任意字符，必须存在），dp数组中偶数位为* 时则: dp[0][i] = dp[0][i - 2]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; p_len + <span class="number">1</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( pattern[i-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//双层循环遍历两个字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s_len+<span class="number">1</span>; i++ )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p_len + <span class="number">1</span>; j++ )&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(str[i-<span class="number">1</span>] == pattern[j-<span class="number">1</span>] || pattern[j-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(pattern[j-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;                    </span><br><span class="line">                    <span class="keyword">if</span>(str[i-<span class="number">1</span>] == pattern[j-<span class="number">2</span>] || pattern[j-<span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">2</span>];                                                            </span><br><span class="line">                &#125;</span><br><span class="line">                               </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直接返回最后一个位置的情况</span></span><br><span class="line">        <span class="keyword">return</span> dp[s_len][p_len];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解来源">题解来源</h3>
<p>左旋转字符串：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/mian-shi-ti-58-ii-zuo-xuan-zhuan-zi-fu-chuan-qie-p/</p>
<p>字符流中第一个不重复的字符：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/mian-shi-ti-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-3/</p>
<p>替换空格：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/</p>
<p>表示数值的字符串：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/zui-jian-dan-si-lu-xiang-xi-zhu-shi-zheng-shu-xiao/</p>
<p>扑克牌顺子：https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solution/mian-shi-ti-61-bu-ke-pai-zhong-de-shun-zi-ji-he-se/</p>
<p>把字符串转为整数：https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/mian-shi-ti-67-ba-zi-fu-chuan-zhuan-huan-cheng-z-4/</p>
<p>字符串的排列 &amp; 字串：https://leetcode-cn.com/problems/permutation-in-string</p>
<p>https://leetcode-cn.com/problems/permutation-in-string/solution/hua-dong-chuang-kou-by-mu-da-bai-yi-ndu7/</p>
<p>https://leetcode-cn.com/problems/permutation-in-string/solution/zi-fu-chuan-de-pai-lie-by-leetcode/</p>
<p>正则表达式匹配：https://leetcode-cn.com/problems/regular-expression-matching/solution/10-zheng-ze-biao-da-shi-pi-pei-by-ming-zhi-shan-yo/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 堆栈</title>
    <url>/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>剑指Offer中关于堆栈的题目解析。</p>
<a id="more"></a>
<h3 id="用两个栈实现队列">01 用两个栈实现队列</h3>
<p><strong>题目描述</strong> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>题解</strong></p>
<p>Push：</p>
<p>时间复杂度O(<span class="math inline">\(1\)</span>)：stack1每次仅涉及一个元素的操作。</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：stack1中存储<span class="math inline">\(n\)</span>个元素。</p>
<p>Pop：</p>
<p>时间复杂度O(<span class="math inline">\(n\)</span>)：在最坏情况下，stack2 为空，算法需要从 stack1 中弹出 <span class="math inline">\(n\)</span> 个元素，然后再压入stack2中；最好情况下stack2不为空，则复杂度为O(1)。</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：stack2中存储<span class="math inline">\(n\)</span>个元素。</p>
<p>栈，是一种先进后出的数据结构。队列，是一种先进先出的数据结构。</p>
<p>有两个栈stack1和stack2，当队列进入元素时（Push），压入stack1中。</p>
<p>当需要出队时（Pop），若stack2中有元素，则先将stack2中元素弹出，直到为空，再将stack1中元素全部弹出压入stack2中，然后继续弹出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                stack2.push( stack1.pop() );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包含min函数的栈最小栈">02 包含min函数的栈/最小栈</h3>
<p><strong>题目描述</strong> 定义栈的数据结构，请在该类型中实现一个能够获得栈中所含最小元素的min函数（时间复杂度应为O(1)）。</p>
<p><strong>题解</strong></p>
<p>时间复杂度O(1)：所有操作的复杂度均为O(1)。</p>
<p>空间复杂度O(<span class="math inline">\(n\)</span>)：一共有n个待入栈元素，最差情况下栈中存储所有待入栈元素。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/0.png" style="zoom:67%;"></p>
<p>可通过建立辅助栈实现； 数据栈 A： 栈 A用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。 辅助栈 B： 栈 B中存储栈 A中所有 非严格降序 的元素，则栈 A中的最小元素始终对应栈 B的栈顶元素，即 min() 函数只需返回栈 B的栈顶元素即可。 因此，只需设法维护好 栈 B的元素，使其保持非严格降序，即可实现 min() 函数的 O(1)复杂度。维护则分为push和pop，只有小于等于当前栈顶的才push，只有A pop的元素和栈顶相等才pop。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; master = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; slave = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        master.push(node);</span><br><span class="line">        <span class="keyword">if</span>(slave.size() == <span class="number">0</span>)</span><br><span class="line">            slave.push(node);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(slave.peek() &gt;= node)</span><br><span class="line">                slave.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node = master.pop();</span><br><span class="line">        <span class="keyword">if</span>(node == slave.peek())</span><br><span class="line">            slave.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> master.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> slave.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈的压入弹出序列">03 栈的压入、弹出序列</h3>
<p>题目描述</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5],[4,3,5,1,2]</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2<span class="math inline">\(n\)</span> 次出入栈操作。 空间复杂度 O(<span class="math inline">\(n\)</span>) ： 辅助栈 stack 最多同时存储 <span class="math inline">\(n\)</span> 个元素。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/1.png" style="zoom: 50%;"></p>
<p>考虑借用一个辅助栈 stack，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p>
<p>入栈操作： 按照压栈序列的顺序执行。 出栈操作： <strong>每次</strong>入栈后，循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。</p>
<p>若最终能够全部弹出，则表明该弹出序列是满足条件的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//模拟栈</span></span><br><span class="line">        Stack&lt;Integer&gt; sta = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个指针，一个指向压入序列，一个指向弹出序列</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按照压入序列逐个压入</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; pushA.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            sta.push(pushA[i]);</span><br><span class="line">            <span class="comment">//每次压入后都判断是否能够弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!sta.isEmpty() &amp;&amp; sta.peek() == popA[j])&#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最终若能全部弹出则满足条件</span></span><br><span class="line">        <span class="keyword">return</span> sta.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据流中的中位数">04 数据流中的中位数</h3>
<p>题目描述 如何得到一个数据流中的中位数？</p>
<p>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(logn\)</span>) ： 优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的。 空间复杂度 O(<span class="math inline">\(n\)</span>) ： 使用了三个辅助空间，其中两个堆的空间复杂度是 O(<span class="math inline">\(n/2\)</span>)， 一个表示数据流元素个数的计数器占用空间O(1)。</p>
<p>一种最容易想到的思路是，数据流新进来一个数，都把它与已经读出来的数进行一次排序，这样中位数就可以很容易得到。这样做不好的地方是：排序的时间复杂度为 O(<span class="math inline">\(nlogn\)</span>)，但事实上，对除了中位数以外的其它位置的元素并不关心。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/2.png" style="zoom:67%;"></p>
<p>通过维护一个大顶堆表示前有序数组，维护一个小顶堆表示后有序数组，解决求取中位数的问题。</p>
<p>堆可以通过java中的优先队列PriorityQueue实现。</p>
<p>注意到，大顶堆堆顶元素必须小于小顶堆堆顶元素，这可以通过先将数据加入大顶堆再加入小顶堆实现。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/3.png" style="zoom: 60%;"></p>
<p>大顶堆存储<span class="math inline">\(n\)</span>个或<span class="math inline">\(n+1\)</span>个数，取决于数据流的总数据量是偶数还是奇数，小顶堆存储<span class="math inline">\(n\)</span>个元素。</p>
<p>每当一个元素到来时，先将其添加到大顶堆，然后取出堆顶元素表示大顶堆中的最大值，加入小顶堆中。</p>
<p>若总数据量是偶数，则两边存储元素数目一样，不做任何操作。</p>
<p>若总数据量是奇数，则大顶堆应该多存储一个值表示中位数，因此将小顶堆堆顶元素取出表示堆中最小值，并加入大顶堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数可以优化成boolean</span></span><br><span class="line">    <span class="comment">//PriorityQueue&lt;Integer&gt; left = new PriorityQueue&lt;Integer&gt;((x, y)-&gt;(y-x)); //左边大顶堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;( <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125; ); <span class="comment">//传入lambda表达式会慢非常多    </span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();<span class="comment">//右边默认小顶堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        left.add(num);</span><br><span class="line">        right.add( left.remove() );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            left.add( right.remove() );</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        奇数情况下，可以先判断num是否大于小顶堆中的最小值，如果大于则需要插入并删除堆顶，</span></span><br><span class="line"><span class="comment">        否则直接插入大顶堆即可，这样就免去了维护小顶堆的时间</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        if(count%2 == 1)&#123;    </span></span><br><span class="line"><span class="comment">            if(right.size()&gt;0 &amp;&amp; num &gt; right.peek() )&#123;</span></span><br><span class="line"><span class="comment">                right.add(num);</span></span><br><span class="line"><span class="comment">                num = right.remove();</span></span><br><span class="line"><span class="comment">            &#125;      </span></span><br><span class="line"><span class="comment">            left.add( num );            </span></span><br><span class="line"><span class="comment">        &#125;else&#123;            </span></span><br><span class="line"><span class="comment">            left.add(num);</span></span><br><span class="line"><span class="comment">            right.add( left.remove() );            </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (left.peek()+right.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)left.peek(); <span class="comment">//注意数据类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口的最大值堆或双端队列">05 滑动窗口的最大值/堆或双端队列</h3>
<p>题目描述</p>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<p>窗口大于数组长度的时候，返回空</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2,3,4,2,6,2,5,1],3</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,4,6,6,6,5]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(nlogk\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为数组长度，<span class="math inline">\(logk\)</span>为重建堆的时间复杂度。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 维护窗口中元素的堆。</p>
<p>对滑动窗口中的元素维护一个最大堆。堆通过java中的优先队列PriorityQueue实现。每次窗口移动时，先删除掉窗口上一个元素，然后将新元素加入堆，则堆顶就是窗口元素的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length == <span class="number">0</span> || num.length &lt; size || size == <span class="number">0</span>) <span class="comment">//注意size不能为0</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//声明最大堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;( <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;                 </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用第一个窗口初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">            pq.add(num[j]);</span><br><span class="line">        res.add(pq.peek());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//窗口移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i+size &lt;= num.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            pq.remove(num[i-<span class="number">1</span>]);</span><br><span class="line">            pq.add(num[i+size-<span class="number">1</span>]);</span><br><span class="line">            res.add(pq.peek());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(<span class="math inline">\(n\)</span>) ： 只需要遍历一次数组，同时每一个下标恰好被放入队列一次，并且最多被弹出队列一次。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 双端队列中存储的元素。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/4.png"></p>
<p>双端队列，既可以从队头出队，也可以从队尾出队，则不用遵循先进先出的规则。</p>
<p>双端队列中，本质上是维护了窗口中<strong>以最大值为开始的递减序列</strong>。非递减序列中的数值则被删除，不会出现在双端队列中。当窗口移动时，只有那些递减序列中的值才有可能被删除。</p>
<p>整个过程为：</p>
<p>1.想将我们第一个窗口的所有值存入单调双端队列中，单调队列里面的值为单调递减的。如果发现队尾元素小于要加入的元素，则将队尾元素出队，直到队尾元素大于新元素时，再让新元素入队，目的就是维护一个单调递减的队列。</p>
<p>2.我们将第一个窗口的所有值，按照单调队列的规则入队之后，因为队列为单调递减，所以队头元素必为当前窗口的最大值，则将队头元素添加到数组中。</p>
<p>3.移动窗口，<strong>判断当前窗口前的元素是否和队头元素相等，如果相等则出队</strong>。</p>
<p>4.继续然后按照规则进行入队，维护单调递减队列。</p>
<p>5.每次将队头元素存到返回数组里。</p>
<p>最终返回数组。</p>
<p>使用Java中的LinkedList类来实现双端队列，其中有offerFirst()、offerLast()、removeFirst()、removeLast()、peekFirst()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length == <span class="number">0</span> || size == <span class="number">0</span> || size &gt; num.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立一个双端队列</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化双端队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="comment">//当队列中的元素小于当前元素时，出队</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;num[i]) deque.removeLast();</span><br><span class="line">            <span class="comment">//将当前元素加入队列</span></span><br><span class="line">            deque.offerLast(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(deque.peekFirst());<span class="comment">//注意这里也要加入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始滑动窗口,注意此时新加入的元素是num[i+size-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num.length - size; i++ )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断是否要出队列</span></span><br><span class="line">            <span class="keyword">if</span>(num[i-<span class="number">1</span>] == deque.peekFirst()) deque.removeFirst();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当队列中的元素小于当前新加入的元素，出队</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;num[i+size-<span class="number">1</span>]) deque.removeLast();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前元素加入队列</span></span><br><span class="line">            deque.offerLast(num[i+size-<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            res.add(deque.peekFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小的k个数快速选择">06 最小的K个数/快速选择</h3>
<p><strong>题目描述</strong></p>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[4,5,1,6,2,7,3,8],4</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>时间复杂度 O(<span class="math inline">\(nlogk\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为数组长度，每个元素都要进行一次入堆操作，<span class="math inline">\(logk\)</span>为重建堆的时间复杂度。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 维护窗口中元素的堆。</p>
<p>维护一个堆。</p>
<p><img src="/2021/04/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%89%91%E6%8C%87_%E5%A0%86%E6%A0%88/5.png" style="zoom:67%;"></p>
<p>平均时间复杂度 O(<span class="math inline">\(n\)</span>)，最坏情况下为O(<span class="math inline">\(n^2\)</span>) ： 其中 <span class="math inline">\(n\)</span> 为数组长度，时间复杂度根据不同主元的选择而不同。 空间复杂度 O(<span class="math inline">\(k\)</span>) ： 维护窗口中元素的堆。</p>
<p>“查找第 k 大的元素”是一类算法问题，称为<strong>选择问题</strong>。找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p>
<p>回顾快速排序的思路。快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边，如下图所示：</p>
<p>这个 partition 操作是原地进行的，需要 O(n)的时间，接下来，快速排序会递归地排序左右两侧的数组。</p>
<p>而快速选择（quick select）算法的不同之处在于，接下来只需要<strong>递归地选择一侧的数组</strong>。快速选择算法想当于一个“<strong>不完全</strong>”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并<strong>不需要知道它们的顺序</strong>。</p>
<p>目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p>
<ul>
<li>若 k=m，我们就找到了最小的 k 个数，就是左侧的数组；</li>
<li>若 k&lt;m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li>
<li>若 k&gt;m，则左侧数组中的 mm 个数都属于最小的 kk 个数，我们还需要在右侧数组中寻找最小的 k-mk−m 个数，对右侧数组递归地 partition 即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传入的全部是数组中的下标，所以传入k-1</span></span><br><span class="line">        recur(input, <span class="number">0</span>, input.length-<span class="number">1</span>, k-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将数组中的值进行复制</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left == right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = input[left];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; input[i] &lt; pivot) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; pivot &lt; input[j]) j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= j)&#123; <span class="comment">//++、--之后可能会不满足i&lt;=j的条件，需要进行判断</span></span><br><span class="line">                swap(input, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断递归条件，这里只会递归左数组或者右数组之一，此时 j+1 = i 或 i == j</span></span><br><span class="line">        <span class="keyword">if</span>( left &lt;= k &amp;&amp; k &lt;= j) recur(input, left, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( i &lt;= k &amp;&amp; k &lt;= right) recur(input, i, right, k);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = input[i];</span><br><span class="line">        input[i] = input[j];</span><br><span class="line">        input[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归版本</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行划分</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = input.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = input[left];</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">//注意这里不能等</span></span><br><span class="line">                                   </span><br><span class="line">            pivot = input[left]; i = left; j = right;</span><br><span class="line">             <span class="keyword">while</span>(i &lt;= j)&#123; <span class="comment">//进行多次交换</span></span><br><span class="line">                <span class="keyword">while</span>(i &lt;= j &amp;&amp; input[i] &lt; pivot) i++;</span><br><span class="line">            	<span class="keyword">while</span>(i &lt;= j &amp;&amp; pivot &lt; input[j] )  j--;           </span><br><span class="line">            	<span class="keyword">if</span>(i &lt;= j)&#123;</span><br><span class="line">                    swap(input, i, j);</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">//判断，并更改left、right的范围</span></span><br><span class="line">            <span class="comment">//注意这里只能if else，不能用if else if把递归的条件照搬（会导致同时满足条件？暂不清楚）</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt;= k-<span class="number">1</span> &amp;&amp; k-<span class="number">1</span> &lt;= j) right = j;</span><br><span class="line">            <span class="keyword">else</span> left = i;</span><br><span class="line">            </span><br><span class="line">        &#125;       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将数组中的值进行复制</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = input[i];</span><br><span class="line">        input[i] = input[j];</span><br><span class="line">        input[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考题解">参考题解</h3>
<p>包含min函数的栈：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/</p>
<p>栈的压入、弹出序列：https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/mian-shi-ti-31-zhan-de-ya-ru-dan-chu-xu-lie-mo-n-2/</p>
<p>https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/tan-xin-by-z1m/</p>
<p>数据流中的中位数：https://leetcode-cn.com/problems/find-median-from-data-stream/solution/you-xian-dui-lie-python-dai-ma-java-dai-ma-by-liwe/</p>
<p>滑动窗口的最大值：https://leetcode-cn.com/problems/sliding-window-maximum/solution/zhe-hui-yi-miao-dong-bu-liao-liao-de-hua-7fy5/</p>
<p>最小的k个数：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/tu-jie-top-k-wen-ti-de-liang-chong-jie-fa-you-lie-/</p>
<p>https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/wei-ruan-mian-shi-jiao-xun-x-by-jerry_nju/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令</title>
    <url>/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>常用Linux命令：top</p>
<a id="more"></a>
<h3 id="top">Top</h3>
<p>对系统资源和进程的信息进行监控。</p>
<h4 id="统计信息区系统资源信息区">统计信息区（系统资源信息区）</h4>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/0.png"></p>
<p><strong>第一行：输出系统任务队列信息</strong></p>
<p><strong>18:46:38</strong>：系统当前时间</p>
<p><strong>up 2days 1:54</strong>：系统开机后到现在的总运行时间</p>
<p><strong>1 user</strong>：当前登录用户数</p>
<p><strong>load average: 0, 0.01, 0.05</strong>：系统负载，系统运行队列的平均利用率，可认为是可运行进程的平均数；三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值；单核CPU中load average的值=1时表示满负荷状态，多核CPU中满负载的load average值为1*CPU核数</p>
<p><strong>第二行：任务进程信息</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/5.png"></p>
<p><strong>total</strong>：系统全部进程的数量</p>
<p><strong>running</strong>：运行状态的进程数量</p>
<p><strong>sleeping</strong>：睡眠状态的进程数量</p>
<p><strong>stoped</strong>：停止状态的进程数量</p>
<p><strong>zombie</strong>：僵尸进程数量</p>
<p><strong>第三行：CPU信息</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/1.png"></p>
<p><strong>us</strong>：用户空间占用CPU百分比</p>
<p><strong>sy</strong>：内核空间占用CPU百分比</p>
<p><strong>ni</strong>：已调整优先级的用户进程的CPU百分比</p>
<p><strong>id</strong>：空闲CPU百分比，越低说明CPU使用率越高</p>
<p><strong>wa</strong>：等待IO完成的CPU百分比</p>
<p><strong>hi</strong>：处理硬件中断的占用CPU百分比</p>
<p><strong>si</strong>：处理软中断占用CPU百分比</p>
<p><strong>st</strong>：虚拟机占用CPU百分比</p>
<p><strong>第四行：物理内存信息</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/2.png"></p>
<p>以下内存单位均为MB</p>
<p><strong>total</strong>：物理内存总量</p>
<p><strong>free</strong>：空闲内存总量</p>
<p><strong>used</strong>：使用中内存总量</p>
<p><strong>buff/cacge</strong>：用于内核缓存的内存量</p>
<p><strong>第五行：交互区内存信息</strong></p>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/3.png"></p>
<p><strong>total</strong>：交换区总量</p>
<p><strong>free</strong>：空闲交换区总量</p>
<p><strong>used</strong>：使用的交换区总量</p>
<p><strong>avail Mem</strong>：可用交换区总量</p>
<p>注：如果used不断在变化， 说明内核在不断进行内存和swap的数据交换，说明内存真的不够用了</p>
<p>问题：内存空间还剩多少空闲呢？</p>
<p>答案：空闲内存=空闲内存总量+缓冲内存量 +可用交换区总量</p>
<blockquote>
<p>SWAP交换空间，当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中。</p>
</blockquote>
<h4 id="进程信息区进程列表">进程信息区（进程列表）</h4>
<p><img src="/2021/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_Linux%E5%91%BD%E4%BB%A4/4.png" style="zoom: 80%;"></p>
<p><strong>PID</strong>：进程号</p>
<p><strong>USER</strong>：运行进程的用户</p>
<p><strong>PR</strong>：优先级</p>
<p><strong>NI</strong>：nice值。负值表示高优先级，正值表示低优先级</p>
<p><strong>VIRT</strong>：占用虚拟内存，单位kb。VIRT=SWAP+RES</p>
<p><strong>RES</strong>：占用真实内存，单位kb</p>
<p><strong>SHR</strong>：共享内存大小，单位kb</p>
<p><strong>S</strong>：进程状态</p>
<p><strong>%CPU</strong>：占用CPU百分比</p>
<p><strong>%MEM</strong>：占用内存百分比</p>
<p><strong>TIME+</strong>：上次启动后至今的总运行时间</p>
<p><strong>COMMAND</strong>：命令名or命令行</p>
<p><strong>进程状态</strong></p>
<p>R=运行状态</p>
<p>S=睡眠状态</p>
<p>D=不可中断的睡眠状态</p>
<p>T=跟踪/停止</p>
<p>Z=僵尸进程</p>
<h3 id="参考资料">参考资料</h3>
<p>https://cloud.tencent.com/developer/article/1640762 （Top命令）</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 案例</title>
    <url>/2021/04/19/Spark_%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>一些样例代码。</p>
<a id="more"></a>
<h3 id="wordcount">WordCount</h3>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCounts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Spark Context</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取文件并计算词频</span></span><br><span class="line">    <span class="keyword">val</span> source: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;hdfs://node01:8020/dataset/wordcount.txt&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = source.flatMap &#123; line =&gt; line.split(<span class="string">&quot; &quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> wordsTuple: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map &#123; word =&gt; (word, <span class="number">1</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> wordsCount: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordsTuple.reduceByKey &#123; (x, y) =&gt; x + y &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查看执行结果</span></span><br><span class="line">    println(wordsCount.collect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    String line = value.toString();</span><br><span class="line">    String[] split = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String word : split) &#123;</span><br><span class="line">    	context.write(<span class="keyword">new</span> Text(word),<span class="keyword">new</span> LongWritable(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">LongWritable</span>,<span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义我们的reduce逻辑</span></span><br><span class="line"><span class="comment">* 所有的key都是我们的单词，所有的values都是我们单词出现的次数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> values</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">    	count += value.get();</span><br><span class="line">    &#125;</span><br><span class="line">    context.write(key,<span class="keyword">new</span> LongWritable(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobMain</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Job job = Job.getInstance(<span class="keyword">super</span>.getConf(),</span><br><span class="line">	JobMain.class.getSimpleName());</span><br><span class="line">	<span class="comment">//打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span></span><br><span class="line">	job.setJarByClass(JobMain.class);</span><br><span class="line">    <span class="comment">//第一步：读取输入文件解析成key，value对</span></span><br><span class="line">    job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">    TextInputFormat.addInputPath(job,<span class="keyword">new</span></span><br><span class="line">    Path(<span class="string">&quot;hdfs://192.168.52.250:8020/wordcount&quot;</span>));</span><br><span class="line">    <span class="comment">//第二步：设置我们的mapper类</span></span><br><span class="line">    job.setMapperClass(WordCountMapper.class);</span><br><span class="line">    <span class="comment">//设置我们map阶段完成之后的输出类型</span></span><br><span class="line">    job.setMapOutputKeyClass(Text.class);</span><br><span class="line">    job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//第三步，第四步，第五步，第六步，省略</span></span><br><span class="line">    <span class="comment">//第七步：设置我们的reduce类</span></span><br><span class="line">    job.setReducerClass(WordCountReducer.class);</span><br><span class="line">    <span class="comment">//设置我们reduce阶段完成之后的输出类型</span></span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(LongWritable.class);</span><br><span class="line">    <span class="comment">//第八步：设置输出类以及输出路径</span></span><br><span class="line">    job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">    TextOutputFormat.setOutputPath(job,<span class="keyword">new</span> Path(<span class="string">&quot;hdfs://192.168.52.250:8020/wordcount_out&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> b = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> b?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 程序main函数的入口类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">	Tool tool = <span class="keyword">new</span> JobMain();</span><br><span class="line">	<span class="keyword">int</span> run = ToolRunner.run(configuration, tool, args);</span><br><span class="line">	System.exit(run);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spark</category>
        <category>Spark Core</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>Spark Core</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/04/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式（Design pattern）是代码设计经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解，保证代码可靠性。常用设计模式：单例模式</p>
<a id="more"></a>
<h3 id="单例模式">单例模式</h3>
<p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 私有构造方法，防止被实例化 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 静态工程方法，创建实例 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 线程安全</span></span><br><span class="line"><span class="comment">	public static Singleton getInstance() &#123;</span></span><br><span class="line"><span class="comment">		if (instance == null) &#123;</span></span><br><span class="line"><span class="comment">			synchronized (instance) &#123;</span></span><br><span class="line"><span class="comment">				if (instance == null) &#123;</span></span><br><span class="line"><span class="comment">					instance = new Singleton();</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		return instance;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="观察者模式发布-订阅模式">观察者模式/发布-订阅模式</h3>
<p>多个对象间存在一对多关系，当一个对象发生改变时，会把这种改变通知给其他多个对象，从而影响其他对象的行为。</p>
<h3 id="工厂模式">工厂模式</h3>
<p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/sugar_no1/article/details/88317950</p>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法</title>
    <url>/2021/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<p>回溯算法，建立在深度优先搜索之上。DFS 是一直往某一个方向搜索直到最终结果就结束，而回溯算法是在搜索过程中，达到结束条件后，恢复被改变的状态，回溯上一层，再次搜索，因此回溯算法与 DFS 的区别就是<strong>有无状态重置</strong>。</p>
<a id="more"></a>
<h3 id="回溯">回溯</h3>
<h4 id="问题类型">问题类型</h4>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>题目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>子集、组合</td>
<td>子集、子集 II、组合、组合总和、组合总和 II</td>
</tr>
<tr class="even">
<td>全排列</td>
<td>全排列、全排列 II、字符串的全排列、字母大小写全排列</td>
</tr>
<tr class="odd">
<td>搜索</td>
<td>解数独、单词搜索、N皇后、分割回文串、二进制手表</td>
</tr>
</tbody>
</table>
<h3 id="子集组合">子集/组合</h3>
<p>子集、组合与排列是不同性质的概念。子集、组合是无关顺序的，如 [1，2] 和 [2，1] 是同一个组合(子集)；而排列是和元素顺序有关的， [1,2] 和 [2,1] 是两种不一样的排列，因此被分为两类问题。</p>
<h4 id="子集">子集</h4>
<p><strong>题目描述</strong></p>
<p>给定一组<strong>不含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）</p>
<p>解集不能包含重复的子集。你可以按任意顺序返回解集。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]</p>
<p>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>
</blockquote>
<p><strong>题解</strong></p>
<p>时间复杂度 <span class="math inline">\(O(n*2^n)\)</span>：回溯法复杂度，对于每个位置有选和不选两种方式，因此复杂度为<span class="math inline">\(O(2^n)\)</span>；对于每个位置要递归下去，探讨选和不选，因此每个位置遍历的复杂度为<span class="math inline">\(O(n)\)</span>，因此总的复杂度为<span class="math inline">\(O(n*2^n)\)</span>。</p>
<p>空间复杂度 <span class="math inline">\(O(n)\)</span>：临时寄存结果List&lt;Integer&gt; tmp的空间占用为<span class="math inline">\(O(n)\)</span>，递归的复杂度为<span class="math inline">\(O(n)\)</span>。</p>
<p>子集，就是求组合，可以发现对于每个位置，就有选和不选两种方式，<strong>代码实现上就是先选，然后再撤销原来的选择，对于每个位置都通过循环的方式实现</strong>。</p>
<p><img src="/2021/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%9E%E6%BA%AF%E6%B3%95/0.png" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//暂存结果的List</span></span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, <span class="number">0</span>, tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;Integer&gt; tmp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为结果中包括了空的情况，所以直接加入</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(tmp));</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//进行回溯算法，关键是通过循环实现</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="comment">//对于当前位置，选</span></span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">                <span class="comment">//往下递归，注意是i+1不是index+1！</span></span><br><span class="line">                dfs(nums, i+<span class="number">1</span>, tmp);</span><br><span class="line">                <span class="comment">//撤销选择，把不选的情况交给循环</span></span><br><span class="line">                tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子集-ii剪枝">子集 II（剪枝）</h4>
<p><strong>题目描述</strong></p>
<p>给定一个可能<strong>包含重复元素</strong>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：nums = [1,2,2]</p>
<p>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</p>
</blockquote>
<p><strong>题解</strong></p>
<p>时间复杂度 <span class="math inline">\(O(n*2^n)\)</span>：有重复元素的数组需要排序，复杂度为<span class="math inline">\(O(nlogn)\)</span>；回溯法复杂度，对于每个位置有选和不选两种方式，因此复杂度为<span class="math inline">\(O(2^n)\)</span>；对于每个位置要递归下去，探讨选和不选，因此每个位置遍历的复杂度为<span class="math inline">\(O(n)\)</span>，因此总的复杂度为<span class="math inline">\(O(n*2^n)\)</span>。</p>
<p>空间复杂度 <span class="math inline">\(O(n)\)</span>：临时寄存结果List&lt;Integer&gt; tmp的空间占用为<span class="math inline">\(O(n)\)</span>，递归的复杂度为<span class="math inline">\(O(n)\)</span>。</p>
<p>有重复元素，意味着组合之中存在着重复计算的过程，需要进行<strong>剪枝</strong>，比如对于两个2来说，单独选择它们的时候是重复的，因此不需要进行计算，递归的时候如果紧挨的两个元素是相同的，就需要跳过他们不需要往下递归，即把它们所在的分支剪掉。</p>
<p><img src="/2021/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%9E%E6%BA%AF%E6%B3%95/1.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//注意！这里必须让数组是有序的</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums, <span class="number">0</span>, tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;Integer&gt; tmp)</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//因为结果中包括了空的情况，所以直接加入</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(tmp));</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//进行回溯算法，关键是通过循环实现</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果当前位置和上一轮位置上数值是一样的，就不需要考虑它的情况</span></span><br><span class="line">                <span class="comment">//注意 i = index的情况它不会continue，这保证了 1,2,2 是可以出现的</span></span><br><span class="line">                <span class="comment">//即nums[1] = 2 和 nums[2] = 2时，nums[2]便不再考虑</span></span><br><span class="line">                <span class="comment">//但是1,2,2是在nums[1]处进入递归，然后index+1后处于nums[2]，此时nums[2]就不会被continue，就可以加入</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;index &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//对于当前位置，选</span></span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">                <span class="comment">//往下递归，注意是i+1不是index+1！             </span></span><br><span class="line">                dfs(nums, i+<span class="number">1</span>, tmp);</span><br><span class="line">                <span class="comment">//撤销选择，把不选的情况交给循环</span></span><br><span class="line">                tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>02 Flink架构体系</title>
    <url>/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>介绍Flink的架构组件，编程模型（支持的API类型），任务的提交流程，程序的流程，并行度以及槽。</p>
<a id="more"></a>
<h3 id="flink架构">Flink架构</h3>
<h3 id="flink编程模型">Flink编程模型</h3>
<p>编程模型指的是Flink提供的API的类型，根据不同的抽象级别提供不同的API进行流处理或批处理。</p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/Blog\source\_posts\Flink02_架构体系\0.png" style="zoom: 50%;"></p>
<ul>
<li><p>Stateful Stream Process</p>
<p>最底层的API进行的是有状态的流式计算，它提供的过程函数（Process Function） 与 DataStream API 相集成， 使其可以对某些特定的操作进行底层的抽象， 它允许用户可以自由地处理来自一个或多个数据流的事件。这类API可以<strong>获得状态数据和事件的时间</strong>，从而可以注册事件时间并处理时间回调，完成复杂的逻辑。</p></li>
<li><p>DataStream/DataSet API</p>
<p><strong>针对流处理和批处理</strong>分别封装了DataStream API（有界或无界流数据） 和 DataSet API（有界数据集），提供了一些进行数据处理的通用算子如转换 （ transformations） ， 连接（joins） ， 聚合（aggregations） ， 窗口操作（windows） 等。</p></li>
<li><p>Table API</p>
<p>将数据封装成<strong>二维表格</strong>的形式，提供进行表格处理的API， 其中表可能会动态变化（流式数据） 。 Table API 可以提供例如 select、 project、 join、 group-by、 aggregate 等操作。 此外，Table API 程序在执行之前会经过内置优化器进行优化，可以在表格与DataStream/DataSet 之间无缝切换 ，允许程序混用 Table API 与 DataStream/DataSet API。</p></li>
<li><p>SQL</p>
<p>以SQL形式抽象的API和Table API比较相似，SQL 查询可以直接在 Table API 定义的表上执行。</p></li>
</ul>
<h3 id="任务的提交流程">任务的提交流程</h3>
<h3 id="程序与数据流">程序与数据流</h3>
<h4 id="flink中的程序">Flink中的程序</h4>
<p>可以将Flink中的程序分成三个步骤：数据读取（Source）、数据转换（Transformation）、数据写入（Sink）。</p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/Blog\source\_posts\Flink02_架构体系\1.png" style="zoom:50%;"></p>
<p>每个 Flink 上运行的程序会被映射成一个 Streaming Dataflows，它包含了 Streams 和 Transformations Operators。</p>
<p>一个 Stream 可 以看成一个中间结果，即<strong>数据</strong>。</p>
<p>一个 Transformations 是以一个或多个 Stream 作为输入的某种 Operator，即操作，该 Operator 利用这些 Streams 进行计算从而产生一个或多个 Result Stream。</p>
<h4 id="flink中的并行并行度">Flink中的并行（并行度）</h4>
<p>Flink 程序的执行具有并行、分布式的特性。在执行过程中，一个 Stream 包含一个或多个 Stream Partition。而每个 Operator 包含一个或多个 Operator Subtask，这些 Operator Subtasks 在不同的<strong>线程</strong>、不同的<strong>物理机</strong>或不同的<strong>容器</strong>中彼此互不依赖的执行。</p>
<p>一个特定 Operator 的 Subtask 的个数被称之为其 <strong>Parallelism(并行度)</strong>，注意这里指的是Operator的并行度，不是整个Flink程序的并行度。一个 Stream 的并行度总是等同于产生它的 Operator 的并行度。一个程序中，不同的 Operator 可能具有不同的并行度。</p>
<blockquote>

</blockquote>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/Blog\source\_posts\Flink02_架构体系\2.png" style="zoom: 80%;"></p>
<p>如上图，Source被分成Source1和Source2，它们分别为Source这个Operator的Subtask。每一个Operator Subtask都是在不同的线程当中独立执行的。一个Operator的并行度，就等于Operator Subtask的个数。上图Source这个Operator的并行度为2。而一个Stream的并行度就等于它生成的Operator的并行度。</p>
<p>数据在两个Operator之间传递的时候有两种模式，这取决于Operator的种类：</p>
<p><strong>One to One</strong>模式：两个operator用此模式传递的时候，会保持数据的分区数和数据的排序；如上图中的Source1到Map1，它就保留的Source的分区特性，以及分区元素处理的有序性。（此时，可以把这两个Operator合并为一个Operator Chain）</p>
<p><strong>Redistributing</strong> （重新分配）模式：这种模式会<strong>改变数据的分区数</strong>；每个一个Operator Subtask会根据选择Transformation把数据发送到不同的目标subtasks，比如keyBy()会通过<strong>hashcode重新分区</strong>，broadcast()和rebalance()方法会<strong>随机重新分区</strong>，这些操作都会引起 Redistributing 过程，而 Redistributing 过程就类似 于 Spark 中的 shuffle 过程。</p>
<h4 id="operator-chain">Operator Chain</h4>
<p>Flink的所有操作都称之为Operator，客户端在提交任务的时候会对Operator进行优化操作，<strong>能进行合并的</strong>Operator（One to One模式）会被合并为一个Operator，<strong>合并后的Operator称为Operator Chain</strong>，实际上就是一个执行链它包括了多个操作，每个执行链会在TaskManager上一个独立的<strong>线程</strong>中执行。</p>
<p>每个Operator Chain或Operator就称为一个<strong>Task</strong>，每个Task会在一个单独的线程中执行。将 Operators 链接成 Task 是非常有效的优化，它能减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。</p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/Blog\source\_posts\Flink02_架构体系\3.png" style="zoom:67%;"></p>
<h3 id="slot槽与-sharing-slot共享槽">Slot（槽）与 Sharing Slot（共享槽）</h3>
<h4 id="slot">Slot</h4>
<p>每个<strong>TaskManager是一个JVM的进程</strong>, 可以在不同的线程中执行一个或多个子任务。 通过Task Slot来控制能接收多少个Task，至少要有一个Task Slot。</p>
<p>每个Task Slot表示TaskManager中拥有一定资源的一个固定大小的子集，<strong>代表一个线程</strong>，它能够执行一个Task。</p>
<p><strong>一个Flink程序的最大并行度由集群中所有Task Manager的Slot的数量决定。</strong></p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/Blog\source\_posts\Flink02_架构体系\4.png" style="zoom: 80%;"></p>
<p>一般来说，<strong>槽的个数都是和一台主机中CPU的核数相等</strong>，比如8核，那么就分配8个槽。</p>
<p>同时这个Task Manager进程的内存被划分到多个Slot中。图中有2个TaskManager，每个TaskManager有3个Slot的，每个Slot占有约1/3的TaskManager进程的内存。</p>
<p>内存被划分到不同的Slot之后可以获得如下好处:</p>
<ul>
<li>TaskManager最多能同时并发执行的任务是可以控制的，那就是3个，因为不能超过Slot的数量。</li>
<li>Slot有独占的内存空间，这样在一个TaskManager中可以运行多个不同的作业，作业之间不受影响。</li>
</ul>
<h4 id="sharing-slot">Sharing Slot</h4>
<p>Flink允许子任务（Operator）共享槽，即使它们是不同任务（Operator）的子任务（Operator Subtask），只要它们来自同一个作业即可。</p>
<p><img src="/2021/05/05/Flink02_%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/Blog\source\_posts\Flink02_架构体系\5.png" style="zoom:90%;"></p>
<p>允许槽共享有几个主要好处：</p>
<ul>
<li><p>只需计算一个作业（Job）中最高的并行度（parallelism）所需要的Task Slot即可，只要这个满足，整个作业都能满足。</p></li>
<li><p>资源分配更加公平，如果有比较空闲的Slot可以将更多的任务分配给它。图中若没有任务槽共享，负载较低的Source/Map等Subtask将会占据许多资源，而负载较高的窗口Subtask则会缺乏资源。</p></li>
<li><p>有了槽共享，可以将基本并行度（base parallelism）从2提升到6（不允许槽共享，则一个TaskManager中只有一个槽执行该作业的Task），提高了槽资源的利用率。</p></li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p>https://blog.csdn.net/weixin_44318830/article/details/107453663?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162022478716780261941913%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162022478716780261941913&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>blog</sub>first_rank_v2~rank_v29-8-107453663.pc_v2_rank_blog_default&amp;utm_term=flink</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>01 Flink简介</title>
    <url>/2021/05/03/Flink01_%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><img src="/2021/05/03/Flink01_%E7%AE%80%E4%BB%8B/0.jpg" style="zoom:67%;"></p>
<p>Apache Flink是一个分布式的计算框架，用于在无界数据（流处理）和有界数据（批处理）上进行有状态的计算。本文主要介绍了分布式计算框架的四个阶段，以及对Flink的简介，主要包括Flink的四大基石及其特性，以及Flink包括的技术栈。</p>
<a id="more"></a>
<h3 id="flink">Flink</h3>
<p>Apache Flink是一个分布式的计算框架，用于在无界数据（流处理）和有界数据（批处理）上进行有状态的计算。</p>
<h4 id="分布式计算框架">分布式计算框架</h4>
<ul>
<li><p>Hadoop的MapReduce，将计算过程严格区分为Map阶段和Reduce阶段，当需要实现复杂的操作时，需要编写多个Map和Reduce程序实现这个过程，因此会发生多次的磁盘溢写。</p></li>
<li><p>Apache Tez，在Hadoop Yarn之上基于DAG（有向无环图，Directed Acyclic Graph）的计算框架，可以将多个有依赖的MapReduce作业转换为一个作业（这样只需写一次HDFS），从而大大提升DAG作业的性能。</p></li>
<li><p>Spark，基于内存的计算，提供Spark Streaming支持微批次的计算（伪实时），将流处理和批处理本质上都看成是批处理进行计算（不考虑Struct Streaming）。</p></li>
<li><p>Flink，同样支持基于内存的计算，将流处理和批处理本质上都看成流处理进行计算，进一步提升实时性，提供适用于机器学习的迭代计算。</p></li>
</ul>
<h4 id="无界有界数据">无界/有界数据</h4>
<ul>
<li>无界数据：数据不停地产生，对每条数据进行处理。</li>
<li>有界数据：将数据划分（按照时间等标准）成多组数据，每次处理一个组内的数据。</li>
</ul>
<h4 id="spark-streaming-vs-flink">Spark Streaming VS Flink</h4>
<table>
<thead>
<tr class="header">
<th></th>
<th>Spark Streaming</th>
<th>Flink</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>实时计算</td>
<td>基于RDD的微批次处理</td>
<td>流处理</td>
</tr>
<tr class="even">
<td>容错</td>
<td>血缘机制和Checkpoint</td>
<td>基于快照的轻量级Checkpoint（成本低）</td>
</tr>
<tr class="odd">
<td>内存管理</td>
<td>通过JVM实现内存管理，需要用户注意程序的编写</td>
<td>由Flink实现的一套内存管理机制</td>
</tr>
<tr class="even">
<td>延迟</td>
<td>100ms</td>
<td>10ms</td>
</tr>
</tbody>
</table>
<h3 id="flink四大基石">Flink四大基石</h3>
<h4 id="checkpoint">Checkpoint</h4>
<p>Checkpoint 是 Flink 实现容错机制最核心的功能，基于chandy-lamport算法实现分布式计算任务的一致性语义。</p>
<p>根据配置周期性地基于 Stream 中各个 Operator/Task 的状态来生成快照，从而将这些状态数据定期 持久化存储下来，当 Flink 程序一旦</p>
<p>意外崩溃时，重新运行程序时可以有选择地从这些快照进行 恢复，从而修正因为故障带来的程序数据异常。</p>
<h4 id="state">State</h4>
<p>Flink支持状态管理机制，state 一般指一个具体的 task/operator 的状态，可以认为状态管理机制保存了程序的中间计算结果或者是历史计算结果。</p>
<h4 id="window">Window</h4>
<p>窗口机制是一种将无界数据按照一定的规则切割为有界数据的方式，它将一个无限的数据流拆分成有限大小的数据组，并在每一组数据上进行处理。</p>
<h4 id="time">Time</h4>
<p>Flink可以根据不同的时间标准来处理数据。</p>
<p>Event Time：是事件创建的时间。它通常由事件中的时间戳描述，例如采集的日志数据中，每一条日志都会记录自己的生成时间</p>
<p>Ingestion Time：是数据进入 Flink 的时间。</p>
<p>Processing Time：是每一个执行基于时间操作的算子的本地系统时间，与机器相关。</p>
<h3 id="flink特性">Flink特性</h3>
<ul>
<li><p>支持高吞吐、低延迟、高性能的流处理</p></li>
<li><p>有状态计算的Exactly-once语义。状态是指flink能够维护数据在时序上的聚类和聚合，同时它的checkpoint机制</p></li>
<li><p>支持带有事件时间（event time）语义的流处理和窗口处理。事件时间的语义使流计算的结果更加精确，尤其在事件到达无序或者延迟的情况下。</p></li>
<li><p>支持高度灵活的窗口（window）操作。支持基于time、count、session，以及data-driven的窗口操作，能很好的对现实环境中的创建的数据进行建模。</p></li>
<li><p>轻量的容错处理（ fault tolerance）。 它使得系统既能保持高的吞吐率又能保证exactly-once的一致性。通过轻量的state snapshots实现</p></li>
<li><p>支持savepoints 机制（一般手动触发）。即可以将应用的运行状态保存下来；在升级应用或者处理历史数据是能够做到无状态丢失和最小停机时间。</p></li>
<li><p>支持大规模的集群模式，支持yarn、Mesos。可运行在成千上万的节点上</p></li>
<li><p>运行时同时支持流处理和批处理</p></li>
<li><p>支持具有Backpressure（背压）功能的持续流模型</p></li>
<li><p>Flink在JVM内部实现了自己的内存管理</p></li>
<li><p>支持迭代计算</p></li>
<li><p>支持程序自动优化：避免特定情况下Shuffle、排序等昂贵操作，中间结果进行缓存</p></li>
</ul>
<h3 id="flink技术栈">Flink技术栈</h3>
<p><img src="/2021/05/03/Flink01_%E7%AE%80%E4%BB%8B/0.png" style="zoom: 67%;"></p>
<ul>
<li><p>Deployment层： 该层主要涉及了Flink的部署模式，Flink支持多种部署模式：本地、集群（Standalone/YARN）、云（GCE/EC2）。</p></li>
<li><p>Runtime层：Runtime层提供了支持Flink计算的全部核心实现，比如支持分布式Stream处理、JobGraph到ExecutionGraph的映射、调度等，为上层API层提供基础服务。</p></li>
<li><p>API层： 主要实现了面向无界数据的流处理 DataStream API 和 面向有界数据的批处理 DataSet API。</p></li>
<li><p>Libraries层：Flink应用框架层，构建满足特定应用的计算框架，分别对应于面向流处理和面向批处理两类。面向流处理支持：CEP（复杂事件处理）、基于SQL的操作（基于Table的关系操作）；面向批处理支持：FlinkML（机器学习库）、Gelly（图计算）、基于SQL的操作（基于Table的关系操作）。</p></li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p>https://www.jianshu.com/p/2ee7134d7373（特性）</p>
<p>https://blog.csdn.net/weixin_43563705/article/details/107614714（基石）</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>04 Flink Dataset</title>
    <url>/2021/05/09/Flink04_DatasetAPI/</url>
    <content><![CDATA[<p>Flink中对有界数据进行计算（批处理）。</p>
<a id="more"></a>
<h3 id="基础">基础</h3>
<h4 id="换算单位">换算单位</h4>
<h3 id="并行度设置">并行度设置</h3>
<p>一个Flink程序由多个Operator组成(source、transformation和 sink)。一个Operator由多个并行的Task(线程)来执行， 一个Operator的并行Task(线程)数目就被称为该Operator(任务)的并行度(Parallel)。</p>
<p>1、Operator Level（算子级别）</p>
<p>Operator的并行度可以通过调用 setParallelism()方法来指定。</p>
<p><img src="/2021/05/09/Flink04_DatasetAPI/0.png" style="zoom: 80%;"></p>
<p>2、Execution Environment Level（Env级别）</p>
<p>执行环境的默认并行度可以通过调用setParallelism()方法指定。执行环境的并行度可以通过显式设置算子的并行度而改变。</p>
<p><img src="/2021/05/09/Flink04_DatasetAPI/1.png" style="zoom:80%;"></p>
<p>3、Client Level（客户端级别）</p>
<p>并行度可以在客户端将job提交到Flink时设定，可以通过-p参数指定并行度：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/flink run -p 10 WordCount-java.jar</span><br></pre></td></tr></table></figure>
<p>4、System Level（系统默认级别）</p>
<p>在系统级可以通过设置flink-conf.yaml文件中的parallelism.default属性来指定所有执行环境的默认并行度。</p>
<p>总结：</p>
<p>1、并行度的优先级：算子级别 &gt; env级别 &gt; Client级别 &gt; 系统默认级别 (越靠前具体的代码并行度的优先级越高)</p>
<p>2、建议不设置算子并行度，如果算子并行度发生变化，可能会在算子之间发生Redistributing，造成数据的shuffle;</p>
<p>3、不建议使用系统默认配置，配置太过于死板，修改起来比较麻烦；</p>
<p>4、可以设置env级别或者Client级别。</p>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>05 Flink DataStream</title>
    <url>/2021/05/09/Flink05_DataStreamAPI/</url>
    <content><![CDATA[<p>Flink中对无界数据进行计算（流处理）。</p>
<a id="more"></a>
<h3 id="流处理的wordcount">流处理的WordCount</h3>
<p>与批处理对比：</p>
<p>1、运行环境对象不同，StreamExecutionEnvironment。</p>
<p>2、某些算子不同，如批处理中按key分组是groupby，流处理中按key分组是keyby。</p>
<p>3、程序是一直运行，除非手动停止。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">KeyedStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">流式计算的wordcount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCountDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     1 创建一个流处理的运行环境</span></span><br><span class="line"><span class="comment">     2 构建socket source数据源</span></span><br><span class="line"><span class="comment">     3 接收到的数据转为（单词，1）</span></span><br><span class="line"><span class="comment">     4 对元组使用keyby分组（类似于批处理中的groupby）</span></span><br><span class="line"><span class="comment">     5 使用窗口进行5s的计算</span></span><br><span class="line"><span class="comment">     6 sum出单词数量</span></span><br><span class="line"><span class="comment">     7 打印输出</span></span><br><span class="line"><span class="comment">     8 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2 构建socket source数据源</span></span><br><span class="line">    <span class="comment">//  socketTextStream参数：ip,port </span></span><br><span class="line">    <span class="comment">//  返回值类型是datastream</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//这里可以在node1节点上使用nc -lk 9999命令开启一个服务器，并可以往里面写入数据</span></span><br><span class="line">    <span class="comment">//-l 用于指定netcat将处于侦听模式,指定该参数意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。</span></span><br><span class="line">    <span class="comment">//-k 表示持续打开连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3 接收到的数据转为（单词，1）</span></span><br><span class="line">    <span class="keyword">val</span> tupleDs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = socketDs.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4 对元组使用keyby分组（类似于批处理中的groupby）</span></span><br><span class="line">    <span class="keyword">val</span> keyedStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = tupleDs.keyBy(<span class="number">0</span>) <span class="comment">//选择key value中的key</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5 使用窗口进行5s的计算,每5s计算一次</span></span><br><span class="line">    <span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = keyedStream.timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6 已经按照key进行了分组，因此这里对key value中的value进行求和</span></span><br><span class="line">    <span class="keyword">val</span> resDs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = windowStream.sum(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7 打印输出    </span></span><br><span class="line">    resDs.print()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8 执行   流处理中一定要使用env.execute()来执行程序，不管有无print</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="source">Source</h3>
<p>从数据源读取数据形成数据流DataStream。</p>
<h4 id="custom-source-自定义数据源">Custom Source 自定义数据源</h4>
<p>除了预定义的Source外，可以通过实现SourceFunction/ParallelSourceFunction/RichParallelSourceFunction等接口自定义数据源Source。</p>
<p>然后，可以在运行环境上指定使用的数据源，用StreamExecutionEnvironment.addSource( source )添加自定义数据源。</p>
<p>非并行数据源：SourceFunction, source不能设置大于1的并行度，效率会比较低。</p>
<p>并行数据源：ParallelSourceFunction，source可以设置大于1的并行度，效率更高。</p>
<p>富并行数据源：RichParallelSourceFunction，source可以设置大于1的并行度，此外还提供了open，close等方法。</p>
<h5 id="非并行数据源">非并行数据源</h5>
<p>此时addSource这个Operator的并行度（线程数量）只能设置为1，否则报错。</p>
<ul>
<li><p>创建一个class实现SourceFunction接口</p></li>
<li><p>重写写run方法，定义生产数据的业务逻辑，重写cancle方法定义取消发送数据</p></li>
<li><p>senv.addSource()添加自定义的source</p></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.<span class="type">SourceFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自定义非并行数据源实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MySourceNoParalle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="keyword">val</span> myDs: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MyNoParalleSourceFunction</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    myDs.print()</span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SourceFunction泛型是自定义source的返回数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNoParalleSourceFunction</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">Long</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ele: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//发送数据，生产数据的方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Long</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      ele += <span class="number">1</span></span><br><span class="line">      <span class="comment">//通过上下文对象发送数据</span></span><br><span class="line">      ctx.collect(ele)</span><br><span class="line">      <span class="comment">//降低发送速度</span></span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消方法，取消是通过控制一个变量来影响run方法中的while循环，从而控制是否停止发送数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    isRunning = <span class="literal">false</span> <span class="comment">//取消发送数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="并行数据源">并行数据源</h5>
<p>ParallelSourceFunction</p>
<p>只需要将非并行自定义数据源实现的接口改为ParallelSourceFunction即可。</p>
<p>可以在Source Operator上设置大于1的并行度，从而并行读取数据。此时，发送数据是重复的，可以理解为有多个线程都在执行run这个方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.&#123;<span class="type">ParallelSourceFunction</span>, <span class="type">SourceFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">并行数据源实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyParallelSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="keyword">val</span> myDs: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MyParalleSourceFunction</span>).setParallelism(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    myDs.print()</span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ParallelSourceFunction泛型是我们自定义source的返回数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParalleSourceFunction</span> <span class="keyword">extends</span> <span class="title">ParallelSourceFunction</span>[<span class="type">Long</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ele: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//发送数据，生产数据的方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Long</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      ele += <span class="number">1</span></span><br><span class="line">      <span class="comment">//通过上下文对象发送数据</span></span><br><span class="line">      ctx.collect(ele)</span><br><span class="line">      <span class="comment">//降低发送速度</span></span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消方法，取消是通过控制一个变量来影响run方法中的while循环，从而控制是否停止发送数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    isRunning = <span class="literal">false</span> <span class="comment">//取消发送数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RichParallelSourceFunction</p>
<p>富并行数据源，可以提供open，close等方法（如果操作数据库可以实现在open或者close打开关闭连接），也可以在其中获取到上下文执行更复杂的操作。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.&#123;<span class="type">RichParallelSourceFunction</span>, <span class="type">SourceFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">富并行数据源实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyRichParallelSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="keyword">val</span> myDs: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MyRichParalleSourceFunction</span>).setParallelism(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    myDs.print()</span><br><span class="line">    <span class="comment">//启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SourceFunction泛型是我们自定义source的返回数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRichParalleSourceFunction</span> <span class="keyword">extends</span> <span class="title">RichParallelSourceFunction</span>[<span class="type">Long</span>] </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//todo 初始化方法比如打开数据库连接等昂贵操作</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = <span class="keyword">super</span>.open(parameters)</span><br><span class="line">  <span class="comment">//todo 关闭连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = <span class="keyword">super</span>.close()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ele: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//发送数据，生产数据的方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Long</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      ele += <span class="number">1</span></span><br><span class="line">      <span class="comment">//通过上下文对象发送数据</span></span><br><span class="line">      ctx.collect(ele)</span><br><span class="line">      <span class="comment">//降低发送速度</span></span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消方法，取消是通过控制一个变量来影响run方法中的while循环</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    isRunning = <span class="literal">false</span> <span class="comment">//取消发送数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>订单数据源样例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">UUID</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">TimeUnit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.&#123;<span class="type">RichParallelSourceFunction</span>, <span class="type">SourceFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自定义数据源，练习 生成订单数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//订单信息(订单ID、用户ID、订单金额、时间戳)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">id: <span class="type">String</span>, userId: <span class="type">Int</span>, money: <span class="type">Long</span>, createTime: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">OrderCustomSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 创建订单样例类</span></span><br><span class="line"><span class="comment">    2. 获取流处理环境</span></span><br><span class="line"><span class="comment">    3. 创建自定义数据源</span></span><br><span class="line"><span class="comment">       - 循环1000次</span></span><br><span class="line"><span class="comment">       - 随机构建订单信息</span></span><br><span class="line"><span class="comment">       - 上下文收集数据</span></span><br><span class="line"><span class="comment">       - 每隔一秒执行一次循环</span></span><br><span class="line"><span class="comment">    4. 打印数据</span></span><br><span class="line"><span class="comment">    5. 执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//1  获取流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 2 加载自定义的order数据源,RichParallelSourceFunction泛型是生产的数据类型，order</span></span><br><span class="line">    <span class="keyword">val</span> orderDs: <span class="type">DataStream</span>[<span class="type">Order</span>] = env.addSource(<span class="keyword">new</span> <span class="type">RichParallelSourceFunction</span>[<span class="type">Order</span>] &#123;</span><br><span class="line">      <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.1生成订单数据方法</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Order</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">//2.1.1 生成订单 业务逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">          <span class="comment">//orderid</span></span><br><span class="line">          <span class="keyword">val</span> orderId = <span class="type">UUID</span>.randomUUID().toString</span><br><span class="line">          <span class="comment">//userid</span></span><br><span class="line">          <span class="keyword">val</span> userId = <span class="type">Random</span>.nextInt(<span class="number">3</span>)</span><br><span class="line">          <span class="comment">//money</span></span><br><span class="line">          <span class="keyword">val</span> money = <span class="type">Random</span>.nextInt(<span class="number">101</span>)</span><br><span class="line">          <span class="comment">//createTime</span></span><br><span class="line">          <span class="keyword">val</span> createTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">          ctx.collect(<span class="type">Order</span>(orderId, userId, money, createTime))</span><br><span class="line">          <span class="comment">//每隔一秒中执行一次</span></span><br><span class="line">          <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>.sleep(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.2 取消数据的生成方法</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        isRunning = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;) <span class="comment">//.setParallelism(1) 并行度设置可不用</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    orderDs.print()</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 4 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="mysql数据源">MySQL数据源</h5>
<p>选择RichParallelSourceFunction接口作为要实现的接口，利用提供的open和close方法打开和关闭mysql的链接，实现链接的重用。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Connection</span>, <span class="type">DriverManager</span>, <span class="type">PreparedStatement</span>, <span class="type">ResultSet</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">TimeUnit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.&#123;<span class="type">RichParallelSourceFunction</span>, <span class="type">SourceFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示自定义并行数据源读取mysql</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义student 样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">Int</span>, name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">MysqlRichParallelSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="keyword">val</span> stuDs: <span class="type">DataStream</span>[<span class="type">Student</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MysqlRichParalleleSource</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    stuDs.print()</span><br><span class="line">    <span class="comment">//4 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2自定义mysql并行数据源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlRichParalleleSource</span> <span class="keyword">extends</span> <span class="title">RichParallelSourceFunction</span>[<span class="type">Student</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ps: <span class="type">PreparedStatement</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> connection: <span class="type">Connection</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.1 开启mysql连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//驱动方式</span></span><br><span class="line">    connection = <span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:mysql://node1:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">    <span class="comment">//准备sql语句查询表中全部数据</span></span><br><span class="line">    <span class="keyword">var</span> sql = <span class="string">&quot;select id ,name,age from t_student&quot;</span>;</span><br><span class="line">    <span class="comment">//准备执行语句对象</span></span><br><span class="line">    ps = connection.prepareStatement(sql)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.3 释放资源，关闭连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      connection.close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">null</span>) ps.close()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> isRunning = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2 读取mysql数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Student</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      <span class="comment">//读取mysql中的数据</span></span><br><span class="line">      <span class="keyword">val</span> result: <span class="type">ResultSet</span> = ps.executeQuery()</span><br><span class="line">      <span class="keyword">while</span> (result.next()) &#123;</span><br><span class="line">        <span class="keyword">val</span> userId = result.getInt(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> name = result.getString(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> age = result.getInt(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">        <span class="comment">//收集并发送</span></span><br><span class="line">        ctx.collect(<span class="type">Student</span>(userId, name, age))</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//休眠5s,执行一次</span></span><br><span class="line">      <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>.sleep(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    isRunning = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="kafka数据源">Kafka数据源</h5>
<p>Flink提供了基于Kafka的数据源实现类FlinkKafkaConsumer011等 ，可以通过addSource添加该Kafka数据源。FlinkKafkaConsumer011等实现类最终是实现了RichParallelSourceFunction接口。</p>
<p><img src="/2021/05/09/Flink05_DataStreamAPI/Blog\source\_posts\Flink05_DataStreamAPI\0.png" style="zoom: 50%;"></p>
<p>FlinkKafkaConsumer等集成了Flink的检查点机制，可提供一次性处理语义。为实现这一目标，Flink并不完全依赖Kafka的消费者群体偏移跟踪，而是在内部实现了跟踪和检查这些偏移的机制。</p>
<ul>
<li><p>构造函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> flinkKafkaConsumer: <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>](topic, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), prop)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>主题名称/主题名称列表</p></li>
<li><p>DeserializationSchema / KeyedDeserializationSchema</p>
<p>作用：对kafka里获取的二进制数据进行反序列化</p>
<p>反序列化Schema类型(接口)：DeserialzationSchema(只反序列化value)、KeyedDeserializationSchema(反序列化key和value)</p>
<p>FlinkKafkaConsumer需要知道如何将kafka中的二进制数据转换成Java/Scala对象，这两个接口定义了该转换模式，从kafka获取的每条消息都会通过其中的方法T deserialize(byte[] message)进行反序列化处理。接口源码为：</p>
<p><img src="/2021/05/09/Flink05_DataStreamAPI/Blog\source\_posts\Flink05_DataStreamAPI\1.png" style="zoom: 54%;"></p>
<p><img src="/2021/05/09/Flink05_DataStreamAPI/Blog\source\_posts\Flink05_DataStreamAPI\2.png" style="zoom:50%;"></p>
<p>常用的反序列化Schema：</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Schema</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SimpleStringSchema</td>
<td>可以将消息反序列化为字符串。当接收到消息并且反序列化失败的时候，会出现以下两种情况: <br>1) Flink从deserialize(..)方法中抛出异常，这会导致job的失败，然后job会重启；<br>2) 在deserialize(..) 方法出现失败的时候返回null，这会让Flink Kafka Consumer忽略这条消息。如果配置了checkpoint 为enable，由于consumer的失败容忍机制，失败的消息会被继续消费，因此还会继续失败，这就会导致job被不断自动重启</td>
</tr>
<tr class="even">
<td>JSONDeserializationSchema<br>JSONKeyValueDeserializationSchema</td>
<td>可以把序列化后的Json反序列化成ObjectNode，ObjectNode可以通过objectNode.get(“field”).as(Int/String/…)() 来访问指定的字段</td>
</tr>
<tr class="odd">
<td>TypeInformationSerializationSchema<br>TypeInformationKeyValueSerializationSchema</td>
<td>适合读写均是flink的场景。这会基于Flink的TypeInformation来创建Schema。这对于那些从Flink写入，又从Flink读出的数据是很有用的。这种Flink-Specific的反序列化会比其他通用的序列化方式带来更高的性能。</td>
</tr>
</tbody>
</table></li>
<li><p>Kafka消费者的属性。需要以下属性： “bootstrap.servers”（以逗号分隔的Kafka集群列表）</p>
<p>“group.id”消费者群组的ID</p>
<p>“zookeeper.connect”（逗号分隔的Zookeeper服务器列表）（仅Kafka 0.8需要）</p></li>
</ol></li>
<li><p>FlinkKafkaConsumer消费模式设置</p>
<p>这指定了了FlinkKafkaConsumer究竟是如何从Kafaka中消费数据的。</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<tbody>
<tr class="odd">
<td>setStartFromEarliest</td>
<td>从队列头开始，最早的记录。内部的consumer递交到kafka/zk的偏移量将被忽略。</td>
</tr>
<tr class="even">
<td>setStartFromLatest</td>
<td>从队列尾开始，最新的记录 内部的consumer递交到kafka/zk的偏移量将被忽略。</td>
</tr>
<tr class="odd">
<td>setStartFromGroupOffsets</td>
<td>默认值，从当前消费组记录的偏移量开始，接着上次的偏移量消费。以consumer递交到kafka/zk中的偏移量为起始位置开始消费，group.id设置在consumer的properties里面。<br>如果没有找到记录的偏移量，则使用consumer的properties的auto.offset.reset设置的策略。</td>
</tr>
<tr class="even">
<td>setStartFromSpecificOffsets(Map&lt;TopicPartition, Long&gt;的参数)</td>
<td>从指定的具体位置开始消费。</td>
</tr>
<tr class="odd">
<td>setStartFromTimestamp(long)</td>
<td>从指定的时间戳开始消费 对于每个分区，时间戳大于或者等于指定时间戳的记录将用作起始位置，如果一个分区的最新时间早于时间戳，那么只需要从最新记录中读取该分区，在此模式下，kafka/zk中递交的偏移量将被忽略。<br>时间戳指的是kafka中消息自带的时间戳。</td>
</tr>
</tbody>
</table>
<ul>
<li><p>setStartFromEarliest()/ setStartFromLatest()</p>
<p>只会从最新或最老的地方开始消费。 注意：properties.setProperty("auto.offset.reset", "latest")和kafkaConsumer010.setStartFromLatest()不是一回事。</p></li>
<li><p>setStartFromGroupOffsets</p>
<p>任务从检查点重启，按照重启前的offset进行消费，如果直接重启不从检查点重启并且group.id不变，程序会按照上次提交的offset的位置继续消费。如果group.id改变了，则程序按照auto.offset.reset设置的属性进行消费。但是如果程序带有状态的算子，还是建议使用检查点重启。</p></li>
<li><p>setStartFromSpecificOffsets</p>
<p>从每个分区指定的偏移量读取。</p>
<p>注意 1：如果使用者需要读取在提供的偏移量映射中没有指定偏移量的分区，则它将回退到setStartFromGroupOffsets()该特定分区的默认组偏移行为。 注意 2：当作业从故障中自动恢复或使用保存点手动恢复时，这些起始位置配置方法不会影响起始位置。在恢复时，每个Kafka分区的起始位置由存储在保存点或检查点中的偏移量确定。</p>
<p>下面的示例将消费者配置为从主题“myTopic”的分区0,1和2的指定偏移量开始读取消息。偏移值应该是消费者应为每个分区读取的下一条记录的位置：</p>
<p><img src="/2021/05/09/Flink05_DataStreamAPI/Blog\source_posts\Flink05_DataStreamAPI\3.png"></p></li>
<li><p>setStartFromTimestamp</p>
<p>允许用户从指定的时间戳消费Kafka中的数据，指定一个时间戳即可，单位毫秒。从时间戳消费者忽略Zookeeper / Kafka代理中任何提交的组偏移量。消费者将查找时间戳大于或等于的最早偏移量到Kafka的特定时间戳。如果没有这样的偏移量，消费者将使用从kafka读取数据的最新偏移量。</p></li>
</ul></li>
<li><p>容错</p>
<p>启用Flink的检查点后，Flink Kafka Consumer将使用主题中的记录，并以一致的方式定期检查其所有Kafka偏移以及其他操作的状态。如果作业失败，Flink会将流式程序恢复到最新检查点的状态，从存储在检查点中的偏移量开始重新使用来自Kafka的消息数据。因此，设置检查点的间隔定义了程序在发生故障时最多可以返回多少。flink在使用kafka是要实现容错，需要在执行环境中启用拓扑的检查点：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">env.enableCheckpointing(<span class="number">1000</span>) <span class="comment">// checkpoint every 1000 msecs</span></span><br></pre></td></tr></table></figure>
<p>如果未启用检查点，Kafka（kafka 0.9 以前）使用者将定期向Zookeeper提交偏移量，kafka 0.9 以后提交到broker，都是将topic提交给__consumer_offsets函数来执行。</p>
<p>注意 ：如果flink任务 不通过检查点重启，而是直接重启（groupId不变），可能会丢失数据。</p>
<p>原因：kafka自动更新offset时，fetch到消息后就可以定期更新offset，无论是否消费成功。如果在kafka更新offset的间期内数据没有写入第三方介质，任务挂掉这部分数据就会丢失。</p></li>
<li><p>动态分区检测</p>
<p>随着业务增长数据量也会同步增长，将导致原有的 Kafka 分区数不满足数据写入所需的并发度，需要扩展 Kafka 的分区或者增加 Kafka 的 topic，这时实时处理框架能动态发现新增Topic分区并消费处理新增分区的数据。Flink则是通过创建一个线程，该线程会定期检测 Kafka 新增分区，然后将其添加到 KafkaFetcher 里。</p>
<p>Flink需要将 flink.partition-discovery.interval-millis 属性设置为大于 0 ，属性值为时间间隔，单位为毫秒。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态感知kafka主题分区的增加 单位毫秒</span></span><br><span class="line">properties.setProperty(<span class="string">&quot;flink.partition-discovery.interval-millis&quot;</span>, <span class="string">&quot;5000&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>并行度</p>
<p>如果没有指定，Source Operator的个数与集群中的TaskManager的个数相等。如果手动设置，建议将总的Slot数量设为和Kafka的主题分区数相同。</p></li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer011</span></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.<span class="type">ConsumerConfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">验证flinkkafkaconsumer如何消费kafka中的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFlinkKafkaConsumer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 添加自定义的数据源</span></span><br><span class="line">    <span class="comment">//2.1 构建properties对象</span></span><br><span class="line">    <span class="keyword">val</span> prop = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    <span class="comment">//kafka 集群地址</span></span><br><span class="line">    prop.setProperty(<span class="type">ConsumerConfig</span>.<span class="type">BOOTSTRAP_SERVERS_CONFIG</span>, <span class="string">&quot;node1:9092,node2:9092&quot;</span>)</span><br><span class="line">    <span class="comment">//消费者组</span></span><br><span class="line">    prop.setProperty(<span class="type">ConsumerConfig</span>.<span class="type">GROUP_ID_CONFIG</span>, <span class="string">&quot;flink&quot;</span>)</span><br><span class="line">    <span class="comment">//动态分区检测</span></span><br><span class="line">    prop.setProperty(<span class="string">&quot;flink.partition-discovery.interval-millis&quot;</span>, <span class="string">&quot;5000&quot;</span>)</span><br><span class="line">    <span class="comment">//设置kv的反序列化使用的类</span></span><br><span class="line">    prop.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    prop.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    <span class="comment">//设置默认消费的便宜量起始值</span></span><br><span class="line">    prop.setProperty(<span class="type">ConsumerConfig</span>.<span class="type">AUTO_OFFSET_RESET_CONFIG</span>, <span class="string">&quot;latest&quot;</span>) <span class="comment">//从最新处消费</span></span><br><span class="line">    <span class="comment">//定义topic</span></span><br><span class="line">    <span class="keyword">val</span> topic = <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得了kafkaconsumer对象</span></span><br><span class="line">    <span class="comment">//泛型限定了从kafka读取数据的类型</span></span><br><span class="line">    <span class="keyword">val</span> flinkKafkaConsumer: <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>](topic, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), prop)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">val</span> kafkaDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.addSource(flinkKafkaConsumer)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//3 打印数据</span></span><br><span class="line">    kafkaDs.print()</span><br><span class="line">    <span class="comment">//4 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可用的版本：</p>
<blockquote>
<p>Maven 依赖：flink-connector-kafka-0.11_2.11</p>
<p>Flink支持到的版本 ：1.4.0</p>
<p>生产者和消费者类的名称：FlinkKafkaConsumer011、FlinkKafkaProducer011</p>
<p>Kafka Version：0.11.x</p>
<p>描述：0.11.x Kafka不支持scala 2.10。此连接器支持Kafka事务性消息传递，为生产者提供一次语义。</p>
<p>​</p>
</blockquote>
<h4 id="socket-source">Socket Source</h4>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line"><span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2 构建socket source数据源</span></span><br><span class="line"><span class="comment">//  socketTextStream参数：ip,port </span></span><br><span class="line"><span class="comment">//  返回值类型是datastream</span></span><br><span class="line"><span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br></pre></td></tr></table></figure>
<h4 id="集合source">集合Source</h4>
<h4 id="文件source">文件Source</h4>
<h3 id="transformation">Transformation</h3>
<p>对DataStream进行各种转换操作。</p>
<h4 id="keyby">keyby</h4>
<p>类似批处理中的group by算子，对数据流按照指定规则进行分区。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">keyby的实现单词统计</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KeyByDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 加载socketstream</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//3 对接收到的数据切分压平转成单词，1的元组</span></span><br><span class="line">    <span class="keyword">val</span> wordAndOneDs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = socketDs.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map(_ -&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 4 按照单词分组</span></span><br><span class="line"><span class="comment">//    wordAndOneDs.keyBy(_._1).sum(1).print()</span></span><br><span class="line">    wordAndOneDs.keyBy(<span class="number">0</span>).sum(<span class="number">1</span>).print()</span><br><span class="line">    <span class="comment">//5 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="connect">connect</h4>
<p>将两个DataStream合并为一个流，数据类型可以不同。批处理中union算子必须要求数据类型一致才能union。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.<span class="type">TimeUnit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.<span class="type">SourceFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">ConnectedStreams</span>, <span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flink中connect的用法，把两个数据流连接到一起</span></span><br><span class="line"><span class="comment">需求：</span></span><br><span class="line"><span class="comment">创建两个流，一个产生数值，一个产生字符串数据</span></span><br><span class="line"><span class="comment">使用connect连接两个流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConnectDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 加载source</span></span><br><span class="line">    <span class="keyword">val</span> numDs: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.addSource(<span class="keyword">new</span> <span class="type">MyNumberSource</span>)</span><br><span class="line">    <span class="keyword">val</span> strDs = env.addSource(<span class="keyword">new</span> <span class="type">MyStrSource</span>)</span><br><span class="line">    <span class="comment">// 3 使用connect进行两个连接操作</span></span><br><span class="line">     <span class="keyword">val</span> connectedDs: <span class="type">ConnectedStreams</span>[<span class="type">Long</span>, <span class="type">String</span>] = numDs.connect(strDs)</span><br><span class="line">    <span class="comment">//传递两个函数，分别处理数据</span></span><br><span class="line">    <span class="keyword">val</span> resDs: <span class="type">DataStream</span>[<span class="type">String</span>] = connectedDs.map(l=&gt;<span class="string">&quot;long&quot;</span>+l, s=&gt;<span class="string">&quot;string&quot;</span>+s)</span><br><span class="line">    <span class="comment">//connect意义在哪里呢？只是把两个合并为一个，但是处理业务逻辑都是按照自己的方法处理？</span></span><br><span class="line">    <span class="comment">//connect之后两条流可以共享状态数据</span></span><br><span class="line">    resDs.print()</span><br><span class="line">    <span class="comment">//5 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义产生递增的数字 第一个数据源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumberSource</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">Long</span>]</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> num=<span class="number">1</span>L</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">Long</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">      num +=<span class="number">1</span></span><br><span class="line">      ctx.collect(num)</span><br><span class="line">      <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>.sleep(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    flag=<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义产生从1开始递增字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStrSource</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">String</span>]</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> num=<span class="number">1</span>L</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">      num +=<span class="number">1</span></span><br><span class="line">      ctx.collect(<span class="string">&quot;str&quot;</span>+num)</span><br><span class="line">      <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>.sleep(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    flag=<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="splitselect">split+select</h4>
<p>实现对数据流的切分，使用split切分流，通过select获取到切分之后的流。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">SplitStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">示例</span></span><br><span class="line"><span class="comment">加载本地集合(1,2,3,4,5,6), 使用split进行数据分流,分为奇数和偶数. 并打印奇数结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SplitSelectDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2 加载source</span></span><br><span class="line">    <span class="keyword">val</span> numDs: <span class="type">DataStream</span>[<span class="type">Int</span>] = env.fromCollection(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 3 转换 使用split把数据流中的数据分为奇数和偶数</span></span><br><span class="line">    <span class="keyword">val</span> splitStream: <span class="type">SplitStream</span>[<span class="type">Int</span>] = numDs.split(</span><br><span class="line">      item =&gt; &#123;</span><br><span class="line">        <span class="comment">//模以2</span></span><br><span class="line">        <span class="keyword">var</span> res = item % <span class="number">2</span></span><br><span class="line">        <span class="comment">//模式匹配的方式</span></span><br><span class="line">        res <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="type">List</span>(<span class="string">&quot;even&quot;</span>) <span class="comment">//偶数  even与odd只是名称，代表数据流的名称，但是必须放在list集合</span></span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="type">List</span>(<span class="string">&quot;odd&quot;</span>) <span class="comment">//奇数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 4 从splitStream中获取奇数流和偶数流</span></span><br><span class="line">    <span class="keyword">val</span> evenDs: <span class="type">DataStream</span>[<span class="type">Int</span>] = splitStream.select(<span class="string">&quot;even&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> oddDs = splitStream.select(<span class="string">&quot;odd&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> allDs: <span class="type">DataStream</span>[<span class="type">Int</span>] = splitStream.select(<span class="string">&quot;even&quot;</span>,<span class="string">&quot;odd&quot;</span>)</span><br><span class="line">    <span class="comment">// 5打印结果</span></span><br><span class="line">    <span class="comment">//evenDs.print()</span></span><br><span class="line">    <span class="comment">//oddDs.print()</span></span><br><span class="line">    allDs.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5启动程序</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sink">Sink</h3>
<h4 id="mysql-sink">MySQL Sink</h4>
<p>大致流程：</p>
<p>1、创建class实现RichSinkFunction接口，并通过addSink方法添加给DataStream实现数据的保存。</p>
<p>2、重写invoke方法，设置SQL语句中的数值，执行真正写入逻辑的方法。</p>
<p>3、利用open和close方法实现对数据库连接的管理</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Connection</span>, <span class="type">DriverManager</span>, <span class="type">PreparedStatement</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.sink.&#123;<span class="type">RichSinkFunction</span>, <span class="type">SinkFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flink程序计算结果保存到mysql中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义student case class</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">Int</span>, name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SinkToMysqlDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    读取数据然后直接写入mysql,需要自己实现mysql sinkfunction</span></span><br><span class="line"><span class="comment">    自定义class实现RichSinkFunction重写open,invoke,close方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 2 加载source</span></span><br><span class="line">    <span class="keyword">val</span> stuDs: <span class="type">DataStream</span>[<span class="type">Student</span>] = env.fromElements(<span class="type">Student</span>(<span class="number">0</span>, <span class="string">&quot;tony&quot;</span>, <span class="number">18</span>))</span><br><span class="line">    <span class="comment">// 3 直接写出到mysql</span></span><br><span class="line">    stuDs.addSink(<span class="keyword">new</span> <span class="type">MySqlSinkFunction</span>)</span><br><span class="line">    <span class="comment">// 4 执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备自定义mysql sinkfunciton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySqlSinkFunction</span> <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>[<span class="type">Student</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ps: <span class="type">PreparedStatement</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> connection: <span class="type">Connection</span> = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 3.1 打开连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 3.1.1驱动方式</span></span><br><span class="line">    connection = <span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:mysql://node1:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">    <span class="comment">//3.1.2准备sql语句插入数据到mysql表中</span></span><br><span class="line">    <span class="keyword">var</span> sql = <span class="string">&quot;insert into t_student(name,age) values(?,?)&quot;</span>;</span><br><span class="line">    <span class="comment">//3.1.3准备执行语句对象</span></span><br><span class="line">    ps = connection.prepareStatement(sql)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//关闭连接</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      connection.close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">null</span>) ps.close()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.2 这个方法负责写入数据到mysql中,value就是上游datastream传入需要写入mysql的数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invoke</span></span>(value: <span class="type">Student</span>, context: <span class="type">SinkFunction</span>.<span class="type">Context</span>[_]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 3.2.1设置参数</span></span><br><span class="line">    ps.setString(<span class="number">1</span>, value.name)</span><br><span class="line">    ps.setInt(<span class="number">2</span>, value.age)</span><br><span class="line">    <span class="comment">//3.2.2执行插入动作</span></span><br><span class="line">    ps.executeUpdate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kafka-sink">Kafka Sink</h4>
<p>利用Flink提供的FlinkKafkaProducer这个类，实现写出数据到Kafka中，此时Flink作为生产者，Kafka作为消费者。</p>
<p>FlinkKafkaProducer的构造参数需要指定序列化数据的Schema，下面的案例使用keyedSerializationWrapper：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaProducer011</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.util.serialization.<span class="type">KeyedSerializationSchemaWrapper</span></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.<span class="type">ProducerConfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flink程序计算结果保存到kafka</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//定义student case class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">Int</span>, name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SinkToKafkaDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flink读取数据然后把数据写入kafka中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2 加载source</span></span><br><span class="line">    <span class="keyword">val</span> stuDs: <span class="type">DataStream</span>[<span class="type">Student</span>] = env.fromElements(<span class="type">Student</span>(<span class="number">0</span>, <span class="string">&quot;tony&quot;</span>, <span class="number">18</span>))</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//3 直接使用flinkkafkaproducer来生产数据到kafka</span></span><br><span class="line">    <span class="comment">//3.1 准备一个flinkkafkaproducer对象</span></span><br><span class="line">    <span class="comment">//param1 Kafaka中的主题名称</span></span><br><span class="line">    <span class="keyword">var</span> topic=<span class="string">&quot;test&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//param2 指定序列化所使用的Schema</span></span><br><span class="line">    <span class="keyword">val</span> keyedSerializationWrapper: <span class="type">KeyedSerializationSchemaWrapper</span>[<span class="type">String</span>] =</span><br><span class="line">      <span class="keyword">new</span> <span class="type">KeyedSerializationSchemaWrapper</span>(<span class="keyword">new</span> <span class="type">SimpleStringSchema</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//param3 指定属性，Kafka集群地址</span></span><br><span class="line">    <span class="keyword">val</span> prop = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    prop.setProperty(<span class="type">ProducerConfig</span>.<span class="type">BOOTSTRAP_SERVERS_CONFIG</span>,<span class="string">&quot;node1:9092,node2:9092&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//泛型指定写入kafka的数据类型      </span></span><br><span class="line">    <span class="keyword">val</span> flinkKafkaProducer: <span class="type">FlinkKafkaProducer011</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">FlinkKafkaProducer011</span>[<span class="type">String</span>](</span><br><span class="line">      topic,keyedSerializationWrapper,prop)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 4 sink 操作</span></span><br><span class="line">    stuDs.map(_.toString).addSink(flinkKafkaProducer)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 5 执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="redis-sink">Redis Sink</h4>
<p>借助Flink提供的Redis Sink我们可以方便的把数据写入Redis中。使用Redis Sink需要提供两项内容：</p>
<p>1、连接Redis的配置文件</p>
<p>2、提供一个RedisMapper接口的实现类的对象，其中重写三个方法，分别定义了操作的数据结构，写入的key和value。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.redis.<span class="type">RedisSink</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.redis.common.config.<span class="type">FlinkJedisPoolConfig</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.redis.common.mapper.&#123;<span class="type">RedisCommand</span>, <span class="type">RedisCommandDescription</span>, <span class="type">RedisMapper</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flink程序计算结果保存到redis，使用flink提供的redissink</span></span><br><span class="line"><span class="comment">从socket接收数据然后计算出单词的次数，最终使用redissink写数据到redis中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SinkToRedisDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 创建一个流处理的运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2 加载socket数据，</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    单词计数的逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//3 转换</span></span><br><span class="line">    <span class="keyword">val</span> resDs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = socketDs.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map(_ -&gt;<span class="number">1</span>).keyBy(<span class="number">0</span>).sum(<span class="number">1</span>)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//4 Sink 操作 使用Redis Sink</span></span><br><span class="line">    <span class="comment">//4.1 redissink的构造：1、需要redis配置文件（连接信息），2、RedisMapper接口的实现类的对象</span></span><br><span class="line">    <span class="comment">//4.1.1 jedisconfig</span></span><br><span class="line">    <span class="keyword">val</span> config: <span class="type">FlinkJedisPoolConfig</span> = <span class="keyword">new</span> <span class="type">FlinkJedisPoolConfig</span>.<span class="type">Builder</span>().setHost(<span class="string">&quot;node2&quot;</span>).setPort(<span class="number">6379</span>).build()</span><br><span class="line"></span><br><span class="line">    resDs.addSink(<span class="keyword">new</span> <span class="type">RedisSink</span>[(<span class="type">String</span>, <span class="type">Int</span>)](config,<span class="keyword">new</span> <span class="type">MyRedisMapper</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.1.2 RedisMapper的对象，泛型就是DataStream的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRedisMapper</span> <span class="keyword">extends</span> <span class="title">RedisMapper</span>[(<span class="type">String</span>, <span class="type">Int</span>)]</span>&#123;</span><br><span class="line">  <span class="comment">//获取命令描述器，确定数据结构,使用hash结构</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCommandDescription</span></span>: <span class="type">RedisCommandDescription</span> = &#123;</span><br><span class="line">    <span class="comment">//指定使用hset命令，并提供hash结构的第一个key</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">RedisCommandDescription</span>(<span class="type">RedisCommand</span>.<span class="type">HSET</span>,<span class="string">&quot;REDISSINK&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定key</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getKeyFromData</span></span>(data: (<span class="type">String</span>, <span class="type">Int</span>)): <span class="type">String</span> = &#123;</span><br><span class="line">    data._1</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//指定value</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getValueFromData</span></span>(data: (<span class="type">String</span>, <span class="type">Int</span>)): <span class="type">String</span> = &#123;</span><br><span class="line">    data._2.toString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意导入Maven依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;flink-connector-redis_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.1.5&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>06 Flink四大基石：窗口与时间</title>
    <url>/2021/05/13/Flink06_WindowAndTime/</url>
    <content><![CDATA[<h3 id="window">Window</h3>
<p>窗口 Window 是Flink中用来收集一定范围内数据的一种方式。</p>
<p>滑动窗口，指的是把源源不断的数据看成是已经存在的，然后通过滑动设定好的窗口来对每个窗口内的数据进行计算。滑动窗口有两个属性，一个是窗口大小，一个是滑动间隔。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513182928464.png" style="zoom:67%;"></p>
<p>当 滑动窗口大小 = 滑动间隔时，所有的数据都能参与计算，且窗口内的数据不重复，此时称这样的窗口为滚动窗口。</p>
<a id="more"></a>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513183200282.png" style="zoom:67%;"></p>
<p>当 滑动窗口大小 &gt; 滑动间隔时，所有的数据都能参与计算，且窗口内的数据有重复，会重复地参与计算。</p>
<h4 id="窗口划分方式">窗口划分方式</h4>
<p>在 Flink 中 Window 可以是时间驱动的(Time Window)，即以时间为标准对数据进行划分，也可以是数据驱动的(Count Window)，即以数据的数量为标准对流式数据进行划分。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/0.png" style="zoom:80%;"></p>
<p>如果根据时间划分窗口，那么它就是一个time-window，比如每1分钟统计一次或每10分钟统计一次。如果根据数据划分窗口，那么它就是一个count-window，比如每5个数据统计一次或每50个数据统计一次。</p>
<p>Flink支持窗口的两个重要属性窗口长度size和滑动间隔interval。</p>
<ul>
<li>如果size = interval，那么就会形成tumbling-window(无重叠数据)：滚动窗口。</li>
<li>如果size(1min) &gt; interval（30s），那么就会形成sliding-window(有重叠数据)：正常的滑动窗口<br>
</li>
<li>如果size&lt;interval，那么这种窗口将会丢失数据。比如每5秒钟，统计过去3秒的通过路口汽车的数据，将会漏掉2秒钟的数据。</li>
</ul>
<p>因此，通过窗口的划分标准和窗口属性进行组合，可以得到四种基本的窗口：</p>
<p>time-tumbling-window：无重叠数据的时间窗口，设置方式举例：timeWindow(Time.seconds(5))---基于时间的滚动窗口</p>
<p>time-sliding-window：有重叠数据的时间窗口，设置方式举例：timeWindow(Time.seconds(10), Time.seconds(5))---基于时间的滑动窗口</p>
<p>count-tumbling-window：无重叠数据的数量窗口，设置方式举例：countWindow(5)---基于数量的滚动窗口</p>
<p>count-sliding-window：有重叠数据的数量窗口，设置方式举例：countWindow(10,5)---基于数量的滑动窗口</p>
<p>注意：Flink中还支持一个特殊的窗口:会话窗口SessionWindows</p>
<h4 id="time-windows">Time-Windows</h4>
<p>对于基于时间来进行数据划分的TimeWindow，可以根据窗口实现原理的不同分成三类：滚动窗口(Tumbling Window)、滑动窗口(Sliding Window)和会话窗口(Session Window)。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513195510260.png" style="zoom:67%;"></p>
<p>滚动窗口将数据依据固定的窗口长度对数据进行切分，窗口内的数据不重复。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513195540682.png" style="zoom:67%;"></p>
<p>滑动窗口的窗口长度大于滑动的间隔，因此窗口内会产生重复的数据。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513195913227.png" style="zoom: 58%;"></p>
<p>Session窗口在一个固定的时间周期内不再收到元素，即非活动间隔产生，那个这个窗口就会关闭。</p>
<p>使用窗口对数据进行统计的案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">AllWindowedStream</span>, <span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.&#123;<span class="type">EventTimeSessionWindows</span>, <span class="type">SlidingEventTimeWindows</span>, <span class="type">TumblingEventTimeWindows</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送内容</span></span><br><span class="line"><span class="comment">路灯编号,通过的数量</span></span><br><span class="line"><span class="comment">9,3</span></span><br><span class="line"><span class="comment">9,2</span></span><br><span class="line"><span class="comment">9,7</span></span><br><span class="line"><span class="comment">4,9</span></span><br><span class="line"><span class="comment">2,6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求</span></span><br><span class="line"><span class="comment">每5秒钟统计一次，在这过去的5秒钟内，各个路口通过红绿灯汽车的数量--滚动窗口</span></span><br><span class="line"><span class="comment">每5秒钟统计一次，在这过去的10秒钟内，各个路口通过红绿灯汽车的数量--滑动窗口</span></span><br><span class="line"><span class="comment">在30秒内无数据接入则触发窗口计算--会话窗口(需要事件时间支持):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamingTimeWindow</span> </span>&#123;</span><br><span class="line">  <span class="comment">//样例类CarWC(信号灯id,数量)</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">sensorId: <span class="type">Int</span>, carCnt: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1.准备环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2.接收数据</span></span><br><span class="line">    <span class="keyword">val</span> socketData = env.socketTextStream(<span class="string">&quot;node01&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//3.处理数据socketData-&gt;carWcData</span></span><br><span class="line">    <span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line">    <span class="keyword">val</span> carData: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketData.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">String</span>] = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">      <span class="type">CarWc</span>(arr(<span class="number">0</span>).toInt, arr(<span class="number">1</span>).toInt)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//nokeyed数据</span></span><br><span class="line">    <span class="comment">//val value: AllWindowedStream[CarWc, TimeWindow] = carData.timeWindowAll(Time.seconds(5),Time.seconds(5))</span></span><br><span class="line">    <span class="comment">//keyed数据</span></span><br><span class="line">    <span class="comment">//val value1: WindowedStream[CarWc, Tuple, TimeWindow] = carData.keyBy(0).timeWindow(Time.seconds(5),Time.seconds(5))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.窗口聚合</span></span><br><span class="line">    <span class="comment">//4.1 滚动窗口</span></span><br><span class="line">    <span class="comment">//每5秒钟统计一次，在这过去的5秒钟内，各个路口通过红绿灯汽车的数量</span></span><br><span class="line">    <span class="comment">//无重叠数据，所以只需要给一个参数即可，每5秒钟统计一下各个路口通过红绿灯汽车的数量</span></span><br><span class="line">    <span class="keyword">val</span> result1: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carData.keyBy(<span class="number">0</span>)</span><br><span class="line">      <span class="comment">//.timeWindow(Time.seconds(5),Time.seconds(5))</span></span><br><span class="line">      .timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">      .sum(<span class="number">1</span>)</span><br><span class="line">    result1.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 滑动窗口</span></span><br><span class="line">    <span class="comment">//每5秒钟统计一次，在这过去的10秒钟内，各个路口通过红绿灯汽车的数量。</span></span><br><span class="line">    <span class="keyword">val</span> result2: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carData.keyBy(<span class="number">0</span>)</span><br><span class="line">      .timeWindow(<span class="type">Time</span>.seconds(<span class="number">10</span>),<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">      .sum(<span class="number">1</span>)</span><br><span class="line">    result2.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 会话窗口(需要时间事件支持)</span></span><br><span class="line">    <span class="comment">//指定会话超时，即会话之间的时间间隔，是指在规定的时间内如果没有数据活跃接入，则认为窗口结束，触发窗口计算</span></span><br><span class="line">    <span class="comment">// .window(EventTimeSessionWindows.withGap(Time.seconds(30)))</span></span><br><span class="line">    <span class="comment">//如果有时间事件,滚动窗口和滑动窗口也可以使用如下API</span></span><br><span class="line">    <span class="comment">//.window(TumblingEventTimeWindows.of(Time.seconds(5)))</span></span><br><span class="line">    <span class="comment">//.window(SlidingEventTimeWindows.of(Time.seconds(10),Time.seconds(5)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.启动执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="count-window">Count-Window</h4>
<p>对于基于数据个数来进行数据划分的CountWindow，可以根据窗口实现原理的不同分成两类：滚动窗口(Tumbling Window)、滑动窗口(Sliding Window)。</p>
<p>tumbling-count-window（无重叠数据）按照个数进行统计，比如：对每个路口分别统计，统计在最近5条消息中，各自路口通过的汽车数量，相同的key每出现5次进行统计；即对应的key出现的次数达到5次作为一个窗口，即相同的key出现5次才做一次sum聚合。</p>
<p>sliding-count-window （有重叠数据）窗口长度大于滑动间隔，比如：对每个路口分别统计，统计在最近5条消息中，各自路口通过的汽车数量，相同的key每出现3次进行统计。</p>
<p>这里<strong>窗口长度是5，滑动间隔是3，也就是说，每收到3个相同key的数据就计算一次，每一次计算的窗口是这个key里面前后输入的5个范围的元素</strong>（如果只是单纯统计个数的话，最大就是窗口的大小5个）。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">StreamExecutionEnvironment</span>, _&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送内容</span></span><br><span class="line"><span class="comment">路灯编号,通过的数量</span></span><br><span class="line"><span class="comment">9,3</span></span><br><span class="line"><span class="comment">9,2</span></span><br><span class="line"><span class="comment">9,7</span></span><br><span class="line"><span class="comment">4,9</span></span><br><span class="line"><span class="comment">2,6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求</span></span><br><span class="line"><span class="comment">对每个路口分别统计,统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现5次进行统计(对应的key出现的次数达到5次作为一个窗口,即相同的key出现5次才做一次sum聚合)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对每个路口分别统计,统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现3次进行统计。</span></span><br><span class="line"><span class="comment">每收到3个相同key的数据就计算一次，每一次计算的窗口是前后输入的5个范围的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamingCountWindow</span> </span>&#123;</span><br><span class="line">  <span class="comment">//样例类CarWC(信号灯id,数量)</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">sensorId: <span class="type">Int</span>, carCnt: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1.准备环境</span></span><br><span class="line">    <span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//2.接收数据</span></span><br><span class="line">    <span class="keyword">val</span> socketData = env.socketTextStream(<span class="string">&quot;node01&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//3.处理数据 socketData-&gt;carWcData</span></span><br><span class="line">    <span class="keyword">val</span> carData: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketData.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> arr = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">      <span class="type">CarWc</span>(arr(<span class="number">0</span>).toInt, arr(<span class="number">1</span>).toInt)</span><br><span class="line">    &#125;)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//4.窗口聚合</span></span><br><span class="line">    <span class="comment">//4.1对每个路口分别统计,统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现5次进行统计</span></span><br><span class="line">    <span class="comment">//对应的key出现的次数达到5次作为一个窗口,即相同的key出现5次才做一次sum聚合</span></span><br><span class="line">    carData.keyBy(<span class="number">0</span>)</span><br><span class="line">        .countWindow(<span class="number">5</span>)</span><br><span class="line">        .sum(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//.print()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2对每个路口分别统计,统计在最近5条消息中,各自路口通过的汽车数量,相同的key每出现3次进行统计</span></span><br><span class="line">    carData.keyBy(<span class="number">0</span>)</span><br><span class="line">        .countWindow(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">        .sum(<span class="number">1</span>)</span><br><span class="line">        .print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.启动执行</span></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于sliding-count-window，又比如假设有一个滑动计数窗口，每2个元素计算一次最近4个元素的总和，此时窗口长度为4，滑动间隔为2，那么窗口工作示意图如下所示：</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513204137999.png" style="zoom:67%;"></p>
<p>按照上述逻辑实现的字符串相加的示例代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.utils.ParameterTool;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.ReduceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkCountWindowDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ParameterTool params = ParameterTool.fromArgs(args);</span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.getConfig().setGlobalJobParameters(params);</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> windowSize = params.getInt(<span class="string">&quot;window&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> slideSize = params.getInt(<span class="string">&quot;slide&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read source data</span></span><br><span class="line">        DataStreamSource&lt;Tuple2&lt;String, String&gt;&gt; inStream = env.addSource(<span class="keyword">new</span> StreamDataSource());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, String&gt;&gt; outStream = </span><br><span class="line">        inStream</span><br><span class="line">        .keyBy(<span class="number">0</span>)</span><br><span class="line">        .countWindow(windowSize, slideSize)</span><br><span class="line">        .reduce(</span><br><span class="line">        <span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, String&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, String&gt; value1, Tuple2&lt;String, String&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> Tuple2.of(value1.f0, value1.f1 + <span class="string">&quot;&quot;</span> + value2.f1);</span><br><span class="line">                                                                   &#125;</span><br><span class="line">                                                               &#125;</span><br><span class="line">                                                           );</span><br><span class="line">        outStream.print();</span><br><span class="line">        env.execute(<span class="string">&quot;WindowWordCount&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="time">Time</h3>
<h4 id="时间分类">时间分类</h4>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210513211157290.png" style="zoom:67%;"></p>
<ul>
<li><p><strong>EventTime</strong> 事件时间</p>
<p>事件发生的时间，例如：点击网站上的某个链接的时间，每一条日志都会记录自己的生成时间。</p>
<p>如果以EventTime为基准来定义时间窗口那将形成EventTimeWindow,要求消息本身就应该携带EventTime。</p>
<p>EvenetTime通常使用</p></li>
<li><p><strong>IngestionTime</strong> 摄入时间</p>
<p>数据进入Flink的时间，即某个Flink节点的source operator接收到数据的时间，例如：某个source消费到kafka中的数据的时间。</p>
<p>如果以IngesingtTime为基准来定义时间窗口那将形成IngestingTimeWindow，以source的系统时间为准。</p></li>
<li><p><strong>ProcessingTime</strong> 处理时间</p>
<p>某个Flink节点执行某个operation的时间，例如：timeWindow处理数据时的系统时间，默认的时间属性就是ProcessingTime</p>
<p>如果以ProcessingTime基准来定义时间窗口那将形成ProcessingTimeWindow，以operator的系统时间为准。</p></li>
</ul>
<p>在Flink的流式处理中，绝大部分的业务都会使用EventTime，一般只在EventTime无法使用时，才会被迫使用ProcessingTime或者IngestionTime。<strong>如果要使用EventTime，那么需要引入EventTime的时间属性</strong>，引入方式如下所示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>) <span class="comment">//设置使用事件时间</span></span><br></pre></td></tr></table></figure>
<h4 id="watermark-水位线">Watermark 水位线</h4>
<p>Watermark是一种机制，用来解决数据延迟到达时因为窗口关闭无法计算数据的问题。Watermark需要和窗口机制Window配合起来使用。</p>
<p>Watermark本质上是一个时间戳，只能是单项递增的，用来判断究竟哪些窗口需要关闭。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210515151731959.png" style="zoom:67%;"></p>
<h5 id="理解">理解</h5>
<p>Watermark表示最大允许数据延迟达到多久，任何窗口结束时间<strong>小于等于</strong>这个Watermark的窗口，都需要被关闭并进行计算，简单理解来看就是 <strong>水位线 = 事件时间 - 延迟时间</strong>：</p>
<blockquote>
<p>Watermark = Event Time - Delay Time</p>
<p>10:09:57 = 10:10:00 - 3s</p>
</blockquote>
<p>Watermark通常使用在基于Event Time数据的场景，这种数据自身需要包含一个timestamp，例如1472693399700（2016-09-01 09:29:<strong>59</strong>.700），代表这个数据的Event Time，而这条数据的Watermark则可能是：</p>
<p>Watermark(1472693399700) = 1472693396700 (2016-09-01 09:29:<strong>56</strong>.700)</p>
<p>这个Watermark代表的含义是，timestamp小于1472693396700 (2016-09-01 09:29:<strong>56</strong>.700) 的数据，都已经到达了。</p>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210515144519581.png" style="zoom:67%;"></p>
<p>上图表示了一组数据到达某个Operator时，水位线变化情况以及数据的计算。</p>
<p>纵轴表示Processing Time，<strong>这是每个数据到达Operator的时间</strong>，也可以认为是当前系统的时间。</p>
<p>横轴表示Event Time，这是每个数据的产生时间。</p>
<p>由图可以看出出，理想情况下数据一产生就被处理，因此理想的Watermark中，Processing Time = Event Time表示没有任何延迟。</p>
<p>但是实际情况下可能产生延迟，此时 Event Time - Delay Time = Actual Watermark。可以看到，当实际时间是12:06的时候，水位线触发了第一个窗口的计算，<strong>也就是12:06分到达的某个数据，它的 Event Time - Delay Time恰好等于12:02，把水位线提高了</strong>，因此触发了第一个窗口的计算，使得窗口关闭，该窗口的计算总和为5。（注意这里水位线的单位并不是纵轴的Processing Time，也不是横轴的Event Time，<strong>它只代表了当前有某个数据到达了，触发了当前窗口的计算，只有这个水位线下面的数值才能参与计算</strong>）</p>
<p>当实际时间是12:08分多几秒的时候，可以看到标定为9的数据，虽然它的Event Time在12:01至12:02之间，可是此时它在水位线的上方，窗口已经关闭，因此无法参与计算。</p>
<p>总之，水位线的工作流程可以看成：</p>
<blockquote>
<p>1、一组数据流到来，根据数据流中数据的Event Time判断该数据属于哪个窗口，并将数据分配到这个窗口。</p>
<p>2、在数据流到来的同时每隔一定时间（定期水位线）根据这段时间内的所有数据计算出一个水位线。</p>
<p>3、将水位线以下的窗口进行数据计算，并关闭这个窗口，完成计算。</p>
</blockquote>
<h5 id="解决问题">解决问题</h5>
<p>Watermark是用于处理<strong>乱序</strong>事件的，通常用Watermark机制结合Window来实现。</p>
<blockquote>
<p>流处理从事件产生，到流经source，再到operator，中间是有一个过程和时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生（out-of-order或者说late element）。</p>
<p>对于late element，不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发window去进行计算，这个机制就是Watermark。</p>
</blockquote>
<h5 id="窗口的开始和结束时间">窗口的开始和结束时间</h5>
<p>TimeWindow extends Window；TumblingEventTimeWindows调用了TimeWindow 中的getWindowStartWithOffset(timestamp, offset, size)方法，获得窗口的开始时间。</p>
<blockquote>
<p>https://github.com/apache/flink/blob/master/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/assigners/TumblingEventTimeWindows.java</p>
<p>https://github.com/apache/flink/blob/d241759b89ae3455afae5e434a9384ebdc3c1f5f/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/windowing/windows/TimeWindow.java#L264</p>
</blockquote>
<p>TimeWindow类中写明了一个窗口的开始时间的计算方法，其中 timestamp 就是数据的EventTime，windowSize就是窗口的大小。<strong>即窗口的开始时间取决于第一条数据的EventTime</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method to get the window start for a timestamp.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp epoch millisecond to get the window start.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset The offset which window start would be shifted by.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> windowSize The size of the generated windows.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> window start</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getWindowStartWithOffset</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">long</span> offset, <span class="keyword">long</span> windowSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp - (timestamp - offset + windowSize) % windowSize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>窗口的结束时间就是开始时间+窗口大小</strong>。</p>
<h5 id="watermark-api">Watermark API</h5>
<p>Flink中可以通过调用 DataStream 中的两个 API 来提取时间和分配Watermark，它们被称为水位线分配器，分别是 AssignerWithPunctuatedWatermarks 和 AssignerWithPeriodicWatermarks：</p>
<ul>
<li><p>标点水位线(Punctuated Watermark)</p>
<p>标点水位线（Punctuated Watermark）通过<strong>数据流中某些特殊标记事件来触发新Watermark</strong>的生成**。这种方式下窗口的触发与时间无关，而是决定于何时收到标记事件。</p>
<p>在实际的生产中Punctuated方式在TPS很高的场景下会产生大量的Watermark在一定程度上对下游算子造成压力，所以只有在实时性要求非常高的场景才会选择Punctuated的方式进行Watermark的生成。</p>
<p>对应接口<strong>AssignerWithPunctuatedWatermarks</strong>。</p></li>
<li><p>定期水位线(Periodic Watermark) <strong>周期性的（允许一定时间间隔或者达到一定的记录条数）产生一个Watermark</strong>。水位线提升的时间间隔是由用户设置的，在两次水位线提升时隔内会有一部分消息流入，用户可以根据这部分数据来计算出新的水位线。</p>
<p>举个例子，最简单的水位线算法就是取目前为止最大的事件时间。比如时间间隔是200ms，在这200ms内流入的所有数据中，取它们最大的Evenet Time，然后计算出Watermark，然后根据这个Watermark判断有哪些窗口需要被关闭进行计算。然而这种方式比较暴力，对乱序事件的容忍程度比较低，容易出现大量迟到事件。</p>
<p>在实际的生产中Periodic的方式必须结合时间和积累条数两个维度继续周期性产生Watermark，否则在极端情况下会有很大的延时。</p>
<p>对应接口<strong>AssignerWithPeriodicWatermarks</strong>。</p></li>
</ul>
<p>基本步骤是：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定为evenTime时间语义</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"><span class="comment">//生成watermark的周期</span></span><br><span class="line">env.getConfig.setAutoWatermarkInterval(watermarkInterval)</span><br><span class="line"><span class="comment">//指定方式</span></span><br><span class="line">dataStream.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">Element</span>](<span class="type">Time</span>.seconds(allowDealy)) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">Element</span>): <span class="type">Long</span> = element.dT <span class="comment">//该方法用来提取数据流中的EventTime</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>使用定期水位线的案例如下，简单来说，需要先在数据流中定义水位线的插入方式，再定义窗口及其处理函数。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.timestamps.<span class="type">BoundedOutOfOrdernessTimestampExtractor</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">WindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示使用周期性方式生成Watermark</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求：</span></span><br><span class="line"><span class="comment">编写代码, 计算5秒内（滚动时间窗口），每个信号灯汽车数量</span></span><br><span class="line"><span class="comment">信号灯数据(信号ID(String)、通过汽车数量、时间戳(事件时间))，要求添加Watermark来解决网络延迟问题。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 创建流处理运行环境</span></span><br><span class="line"><span class="comment">2. 设置处理时间为EventTime，设置Watermark的周期间隔，定期生成Watermark的时间</span></span><br><span class="line"><span class="comment">3. 定义CarWc 样例类</span></span><br><span class="line"><span class="comment">4. 使用socketstream发送数据</span></span><br><span class="line"><span class="comment">5. 添加Watermark</span></span><br><span class="line"><span class="comment">   - 允许延迟2秒</span></span><br><span class="line"><span class="comment">   - 在获取Watermark方法中，打印Watermark时间、事件时间和当前系统时间</span></span><br><span class="line"><span class="comment">6. 按照用户进行分流</span></span><br><span class="line"><span class="comment">7. 设置5秒的时间窗口</span></span><br><span class="line"><span class="comment">8. 进行聚合计算</span></span><br><span class="line"><span class="comment">9. 打印结果数据</span></span><br><span class="line"><span class="comment">10. 启动执行流处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义CarWc 样例类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">id: <span class="type">String</span>, num: <span class="type">Int</span>, ts: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">WatermarkDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//创建流处理运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//设置处理时间为事件时间，</span></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">    <span class="comment">//生成Watermark的周期 默认200ms</span></span><br><span class="line">    env.getConfig.setAutoWatermarkInterval(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认程序并行度是机器的核数，8个并行度，注意在flink程序中如果是多并行度</span></span><br><span class="line">    <span class="comment">// Watermark时间是每个并行度下所有数据比较之后，最小的Watermark作为当前流的统一Watermark</span></span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加socketsource</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">    <span class="keyword">val</span> carWcDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketDs.map(</span><br><span class="line">      line =&gt; &#123;</span><br><span class="line">        <span class="comment">//按照逗号切分数据组成carwc</span></span><br><span class="line">        <span class="keyword">val</span> arr = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="type">CarWc</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>).trim.toInt, arr(<span class="number">2</span>).trim.toLong)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// ****添加Watermark****</span></span><br><span class="line">    <span class="comment">// 调用DataStream中assignTimestampsAndWatermarks添加Watermark</span></span><br><span class="line">    <span class="comment">// 分配周期性水位线的接口为AssignerWithPeriodicWatermarks </span></span><br><span class="line">    <span class="comment">// 使用其子类BoundedOutOfOrdernessTimestampExtractor</span></span><br><span class="line">    <span class="comment">// 该子类策略就是最大EventTime作为Watermark，构造参数：Watermark允许的延迟时间,泛型是stream中的数据类型</span></span><br><span class="line">    <span class="keyword">val</span> watermarkDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carWcDs.assignTimestampsAndWatermarks(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">CarWc</span>](<span class="type">Time</span>.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// Watermark机制是在eventtime基础之上减去一段时间，就是flink允许数据延迟的范围</span></span><br><span class="line">        <span class="comment">// eventtime是来自数据，flink是不知道eventtime是多少，以及是哪个字段</span></span><br><span class="line">        <span class="comment">// 这个方法就是告诉flink数据哪个字段是eventime</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">CarWc</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">          element.ts</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 设置窗口 5s的滚动窗口</span></span><br><span class="line">    <span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[<span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = </span><br><span class="line">      watermarkDs.keyBy(<span class="number">0</span>).</span><br><span class="line">      window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>)))</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用apply方法对窗口进行计算</span></span><br><span class="line">    <span class="keyword">val</span> windowDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = windowStream.apply(</span><br><span class="line">      <span class="comment">//泛型：1 carwc,2 carwc,3 tuple,4 timewindow</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">WindowFunction</span>[<span class="type">CarWc</span>, <span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">        <span class="comment">//key:tuple,window:当前触发计算的window对象，input:当前窗口的数据，out:计算结果收集器</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(key: <span class="type">Tuple</span>, window: <span class="type">TimeWindow</span>, input: <span class="type">Iterable</span>[<span class="type">CarWc</span>], out: <span class="type">Collector</span>[<span class="type">CarWc</span>]): 			<span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> wc: <span class="type">CarWc</span> = input.reduce(</span><br><span class="line">            (c1, c2) =&gt; &#123;</span><br><span class="line">              <span class="type">CarWc</span>(c1.id, c1.num + c2.num, c2.ts) <span class="comment">//累加出通过的汽车数量，关于时间在这里我们不关心</span></span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">          <span class="comment">//发送计算结果</span></span><br><span class="line">          out.collect(wc)</span><br><span class="line">          <span class="comment">//获取到窗口开始和结束时间</span></span><br><span class="line">          println(<span class="string">&quot;窗口开始时间》》&quot;</span> + window.getStart + <span class="string">&quot;=====;窗口结束时间》》&quot;</span> + window.getEnd + <span class="string">&quot;;窗口中的数					  据》》&quot;</span> + input.iterator.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    windowDs.print()</span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自定义定期水位线的分配器：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.<span class="type">AssignerWithPeriodicWatermarks</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">WindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.watermark.<span class="type">Watermark</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示使用周期性方式生成水印 -复杂版本--手动实现watermark机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">id: <span class="type">String</span>, num: <span class="type">Int</span>, ts: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">WatermarkDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建流处理运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 设置处理时间为事件时间，</span></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">    <span class="comment">// 生成水印的周期 默认200ms</span></span><br><span class="line">    env.getConfig.setAutoWatermarkInterval(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认程序并行度是机器的核数，8个并行度，注意在flink程序中如果是多并行度</span></span><br><span class="line">    <span class="comment">// Watermark时间是每个并行度下所有数据比较之后，最小的Watermark作为当前流的统一Watermark</span></span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加socketsource</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">// 数据处理</span></span><br><span class="line">    <span class="keyword">val</span> carWcDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketDs.map(</span><br><span class="line">      line =&gt; &#123;</span><br><span class="line">        <span class="comment">//按照逗号切分数据组成carwc</span></span><br><span class="line">        <span class="keyword">val</span> arr = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="type">CarWc</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>).trim.toInt, arr(<span class="number">2</span>).trim.toLong)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ****添加Watermark****</span></span><br><span class="line">    <span class="comment">// 添加周期性水位线  </span></span><br><span class="line">    <span class="comment">// new AssignerWithPeriodicWatermarks&#123;&#125; 通过匿名内部类方式实现这个这个接口</span></span><br><span class="line">    <span class="comment">//参照子类BoundedOutOfOrdernessTimestampExtractor的写法</span></span><br><span class="line">    <span class="keyword">val</span> watermarkDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carWcDs.assignTimestampsAndWatermarks(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">AssignerWithPeriodicWatermarks</span>[<span class="type">CarWc</span>] &#123;</span><br><span class="line">        <span class="comment">// watermark=eventtime -延迟时间</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 定义允许延迟的时间 2s</span></span><br><span class="line">        <span class="keyword">val</span> delayTime=<span class="number">2000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义当前最大的时间戳</span></span><br><span class="line">        <span class="keyword">var</span> currentMaxTimestamp=<span class="number">0</span>L</span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** The timestamp of the last emitted watermark. */</span></span><br><span class="line">         <span class="keyword">var</span> lastEmittedWatermark = <span class="type">Long</span>.<span class="type">MinValue</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// todo 获取watermark时间  实现watermark不会倒退</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">          <span class="comment">// 计算watermark</span></span><br><span class="line">          <span class="keyword">val</span> watermarkTime: <span class="type">Long</span> = currentMaxTimestamp - delayTime</span><br><span class="line">          <span class="keyword">if</span> (watermarkTime &gt;lastEmittedWatermark)&#123;</span><br><span class="line">            lastEmittedWatermark =watermarkTime</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">new</span> <span class="type">Watermark</span>(lastEmittedWatermark)</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//todo 抽取时间戳 element:新到达的元素，previousElementTimestamp：之前元素的时间戳</span></span><br><span class="line">        <span class="comment">// 抽取时间戳 计算watermark</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">CarWc</span>, previousElementTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">          <span class="comment">//获取到时间</span></span><br><span class="line">          <span class="comment">//注意的问题：时间倒退的问题：消息过来是乱序的，每次新来的消息时间戳不是一定变大的，所以会导致水印有可能倒退</span></span><br><span class="line">          <span class="keyword">var</span> eventTime = element.ts</span><br><span class="line">          <span class="keyword">if</span> (eventTime &gt;currentMaxTimestamp)&#123;  <span class="comment">//比较与之前最大的时间戳进行比较</span></span><br><span class="line">            currentMaxTimestamp =eventTime</span><br><span class="line">          &#125;</span><br><span class="line">          eventTime</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 设置窗口 5s的滚动窗口</span></span><br><span class="line">    <span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[<span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = </span><br><span class="line">      watermarkDs.keyBy(<span class="number">0</span>).</span><br><span class="line">      window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>)))</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用apply方法对窗口进行计算</span></span><br><span class="line">    <span class="keyword">val</span> windowDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = windowStream.apply(</span><br><span class="line">      <span class="comment">//泛型：1 carwc,2 carwc,3 tuple,4 timewindow</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">WindowFunction</span>[<span class="type">CarWc</span>, <span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">        <span class="comment">//key:tuple,window:当前触发计算的window对象，input:当前窗口的数据，out:计算结果收集器</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(key: <span class="type">Tuple</span>, window: <span class="type">TimeWindow</span>, input: <span class="type">Iterable</span>[<span class="type">CarWc</span>], out: <span class="type">Collector</span>[<span class="type">CarWc</span>]): 			<span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> wc: <span class="type">CarWc</span> = input.reduce(</span><br><span class="line">            (c1, c2) =&gt; &#123;</span><br><span class="line">              <span class="type">CarWc</span>(c1.id, c1.num + c2.num, c2.ts) <span class="comment">//累加出通过的汽车数量，关于时间在这里我们不关心</span></span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">          <span class="comment">//发送计算结果</span></span><br><span class="line">          out.collect(wc)</span><br><span class="line">          <span class="comment">//获取到窗口开始和结束时间</span></span><br><span class="line">          println(<span class="string">&quot;窗口开始时间》》&quot;</span> + window.getStart + <span class="string">&quot;=====;窗口结束时间》》&quot;</span> + window.getEnd + <span class="string">&quot;;窗口中的数					  据》》&quot;</span> + input.iterator.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    windowDs.print()</span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="watermark-源码">Watermark 源码</h5>
<p><img src="/2021/05/13/Flink06_WindowAndTime/image-20210515134823755.png" style="zoom: 67%;"></p>
<h4 id="allowedlateness与侧道输出">allowedLateness与侧道输出</h4>
<p>当数据的延迟太久的时候，即使存在Watermark也无法处理延迟到达的数据，因为窗口已经关闭了，此时数据被丢弃。因此通过如下两种策略进行数据延迟的更多处理：</p>
<ul>
<li><p>allowedLateness(lateness: Time)</p>
<p>这种方式设置的允许延迟时间与水印的延迟时间是一个累加的效果。</p>
<p>但是注意这个时间并不会影响窗口触发计算的标准，当Watermark &gt;= Window-EndTime依旧会触发计算。</p>
<p>只是如果这设置了这个时间，窗口不会关闭和销毁而是继续等待，直到到达总的延迟时间为止，窗口才会关闭。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置允许延迟时间  --》在Watermark基础上再次增加允许延迟时间</span></span><br><span class="line"><span class="type">WindowedStream</span>.allowedLateness(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>侧道输出</p>
<p>这种机制能够将极端延迟的数据（就是找不到对应窗口的那些数据）保存起来，之后可以再取出。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置侧道输出</span></span><br><span class="line"><span class="keyword">val</span> outputTag: <span class="type">OutputTag</span>[<span class="type">CarWc</span>] = <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">CarWc</span>](<span class="string">&quot;lateCarwc&quot;</span>)</span><br><span class="line"><span class="type">WindowedStream</span>.sideOutputLateData(outputTag)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取侧道输出</span></span><br><span class="line"><span class="type">DataStream</span>.getSideOutput(outputTag)      </span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用allowedLateness与侧道输出的案例为：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.<span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.<span class="type">AssignerWithPeriodicWatermarks</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">WindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>, <span class="type">WindowedStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.watermark.<span class="type">Watermark</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示使用周期性方式生成水印 -复杂版本--手动实现watermark机制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CarWc</span>(<span class="params">id: <span class="type">String</span>, num: <span class="type">Int</span>, ts: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">WatermarkDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 创建流处理运行环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// 设置处理时间为事件时间，</span></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">    <span class="comment">// 生成水印的周期 默认200ms</span></span><br><span class="line">    env.getConfig.setAutoWatermarkInterval(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认程序并行度是机器的核数，8个并行度，注意在flink程序中如果是多并行度</span></span><br><span class="line">    <span class="comment">// Watermark时间是每个并行度下所有数据比较之后，最小的Watermark作为当前流的统一Watermark</span></span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加socketsource</span></span><br><span class="line">    <span class="keyword">val</span> socketDs: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">// 数据处理</span></span><br><span class="line">    <span class="keyword">val</span> carWcDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = socketDs.map(</span><br><span class="line">      line =&gt; &#123;</span><br><span class="line">        <span class="comment">//按照逗号切分数据组成carwc</span></span><br><span class="line">        <span class="keyword">val</span> arr = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="type">CarWc</span>(arr(<span class="number">0</span>), arr(<span class="number">1</span>).trim.toInt, arr(<span class="number">2</span>).trim.toLong)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ****添加Watermark****</span></span><br><span class="line">    <span class="comment">// 添加周期性水位线  </span></span><br><span class="line">    <span class="comment">// new AssignerWithPeriodicWatermarks&#123;&#125; 通过匿名内部类方式实现这个这个接口</span></span><br><span class="line">    <span class="comment">//参照子类BoundedOutOfOrdernessTimestampExtractor的写法</span></span><br><span class="line">    <span class="keyword">val</span> watermarkDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = carWcDs.assignTimestampsAndWatermarks(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">AssignerWithPeriodicWatermarks</span>[<span class="type">CarWc</span>] &#123;</span><br><span class="line">        <span class="comment">// watermark=eventtime -延迟时间</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 定义允许延迟的时间 2s</span></span><br><span class="line">        <span class="keyword">val</span> delayTime=<span class="number">2000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义当前最大的时间戳</span></span><br><span class="line">        <span class="keyword">var</span> currentMaxTimestamp=<span class="number">0</span>L</span><br><span class="line">          </span><br><span class="line">        <span class="comment">/** The timestamp of the last emitted watermark. */</span></span><br><span class="line">         <span class="keyword">var</span> lastEmittedWatermark = <span class="type">Long</span>.<span class="type">MinValue</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// todo 获取watermark时间  实现watermark不会倒退</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">          <span class="comment">// 计算watermark</span></span><br><span class="line">          <span class="keyword">val</span> watermarkTime: <span class="type">Long</span> = currentMaxTimestamp - delayTime</span><br><span class="line">          <span class="keyword">if</span> (watermarkTime &gt;lastEmittedWatermark)&#123;</span><br><span class="line">            lastEmittedWatermark =watermarkTime</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">new</span> <span class="type">Watermark</span>(lastEmittedWatermark)</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//todo 抽取时间戳 element:新到达的元素，previousElementTimestamp：之前元素的时间戳</span></span><br><span class="line">        <span class="comment">// 抽取时间戳 计算watermark</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">CarWc</span>, previousElementTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">          <span class="comment">//获取到时间</span></span><br><span class="line">          <span class="comment">//注意的问题：时间倒退的问题：消息过来是乱序的，每次新来的消息时间戳不是一定变大的，所以会导致水印有可能倒退</span></span><br><span class="line">          <span class="keyword">var</span> eventTime = element.ts</span><br><span class="line">          <span class="keyword">if</span> (eventTime &gt;currentMaxTimestamp)&#123;  <span class="comment">//比较与之前最大的时间戳进行比较</span></span><br><span class="line">            currentMaxTimestamp =eventTime</span><br><span class="line">          &#125;</span><br><span class="line">          eventTime</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 设置窗口</span></span><br><span class="line">    <span class="keyword">val</span> outputTag: <span class="type">OutputTag</span>[<span class="type">CarWc</span>] = <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">CarWc</span>](<span class="string">&quot;lateCarwc&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[<span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = </span><br><span class="line">      watermarkDs.keyBy(<span class="number">0</span>)</span><br><span class="line">      .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>)))</span><br><span class="line">      <span class="comment">//设置允许延迟时间  --》在Watermark基础上再次增加允许延迟时间</span></span><br><span class="line">      .allowedLateness(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">      <span class="comment">//设置侧道输出</span></span><br><span class="line">      .sideOutputLateData(outputTag)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用apply方法对窗口进行计算</span></span><br><span class="line">    <span class="keyword">val</span> windowDs: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = windowStream.apply(</span><br><span class="line">      <span class="comment">//泛型：1 carwc,2 carwc,3 tuple,4 timewindow</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">WindowFunction</span>[<span class="type">CarWc</span>, <span class="type">CarWc</span>, <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">        <span class="comment">//key:tuple,window:当前触发计算的window对象，input:当前窗口的数据，out:计算结果收集器</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(key: <span class="type">Tuple</span>, window: <span class="type">TimeWindow</span>, input: <span class="type">Iterable</span>[<span class="type">CarWc</span>], out: <span class="type">Collector</span>[<span class="type">CarWc</span>]): 			<span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> wc: <span class="type">CarWc</span> = input.reduce(</span><br><span class="line">            (c1, c2) =&gt; &#123;</span><br><span class="line">              <span class="type">CarWc</span>(c1.id, c1.num + c2.num, c2.ts) <span class="comment">//累加出通过的汽车数量，关于时间在这里我们不关心</span></span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">          <span class="comment">//发送计算结果</span></span><br><span class="line">          out.collect(wc)</span><br><span class="line">          <span class="comment">//获取到窗口开始和结束时间</span></span><br><span class="line">          println(<span class="string">&quot;窗口开始时间》》&quot;</span> + window.getStart + <span class="string">&quot;=====;窗口结束时间》》&quot;</span> + window.getEnd + <span class="string">&quot;;窗口中的数					  据》》&quot;</span> + input.iterator.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    windowDs.print()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取侧道输出的数据</span></span><br><span class="line">    <span class="keyword">val</span> lateCarWc: <span class="type">DataStream</span>[<span class="type">CarWc</span>] = windowDs.getSideOutput(outputTag)</span><br><span class="line">    lateCarWc.printToErr(<span class="string">&quot;侧道输出数据》》&quot;</span>)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 启动</span></span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://zhuanlan.zhihu.com/p/342854047 （CountWindow）</p>
<p>https://blog.csdn.net/xsdxs/article/details/82726031 （CountWindow）</p>
<p>https://zhuanlan.zhihu.com/p/102325190 （窗口）</p>
<p>https://blog.csdn.net/xsdxs/article/details/82415450 （窗口开始时间）</p>
<p>https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43864.pdf （Watermark图）</p>
<p>https://www.cnblogs.com/rossiXYZ/p/12286407.html</p>
<p>https://www.jianshu.com/p/a883262241ef</p>
<p>https://blog.csdn.net/lmalds/article/details/52704170</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>常用SQL</title>
    <url>/2021/04/17/SQL_SQL/</url>
    <content><![CDATA[<p>SQL 是用于访问和处理数据库的标准的计算机语言。</p>
<a id="more"></a>
<h3 id="函数">函数</h3>
<h4 id="lfet-join函数">LFET JOIN函数</h4>
<p>on和where的区别：</p>
<p>where 是在两个表join完成后，再附上where条件。</p>
<p>而 and 则是在表连接前过滤A表或B表里面哪些记录符合连接条件。它会保留左表的全部记录。</p>
<h4 id="limit-offset函数">LIMIT OFFSET函数</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#选择排名第二高的工资</span><br><span class="line">select</span><br><span class="line">ifnull(</span><br><span class="line">(</span><br><span class="line">    select distinct Salary from Employee order by Salary desc limit 1 offset 1</span><br><span class="line">)</span><br><span class="line">,</span><br><span class="line">null</span><br><span class="line">)</span><br><span class="line">as SecondHighestSalary</span><br></pre></td></tr></table></figure>
<h4 id="窗口函数">窗口函数</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每个部门里面工资前三高的员工</span><br><span class="line">select d.name as department, a.name as employee, a.salary as salary</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">    #利用排名函数 dense_rank() 获得分区下的排名</span><br><span class="line">    select *, dense_rank() over( partition by departmentid order by salary desc) as t</span><br><span class="line">    from Employee</span><br><span class="line">)</span><br><span class="line">as a </span><br><span class="line">inner join department as d # 用部门id连接</span><br><span class="line">on a.DepartmentId &#x3D; d.Id </span><br><span class="line">where t &lt;&#x3D; 3 #选择排名高的</span><br></pre></td></tr></table></figure>
<h4 id="case-when">CASE WHEN</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="type">Date</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">Result</span> <span class="keyword">when</span> <span class="string">&#x27;胜&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;胜&#x27;</span>,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">Result</span> <span class="keyword">when</span> <span class="string">&#x27;负&#x27;</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;负&#x27;</span></span><br><span class="line"><span class="keyword">from</span> test</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="type">date</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    STUDENT_NAME,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> score <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="string">&#x27;不及格&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">&#x27;及格&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="string">&#x27;优秀&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> score <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;缺席考试&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;异常&#x27;</span> <span class="keyword">END</span>) <span class="keyword">AS</span> REMARK</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure>
<h3 id="面试">面试</h3>
<h4 id="查询连续登录用户">查询连续登录用户</h4>
<p>1、因为每天用户登录次数可能不止一次，所以需要先将用户每天的登录日期去重。</p>
<p>2、再用row_number() over(partition by _ order by _)函数将用户id分组，按照登陆时间进行排序。</p>
<p>3、计算登录日期减去第二步骤得到的结果值，用户连续登陆情况下，每次相减的结果都相同。</p>
<p>4、按照id和日期分组并求和，筛选大于等于7的即为连续7天登陆的用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># id, date</span><br><span class="line"># 用户ID，用户登录时间</span><br><span class="line"></span><br><span class="line">#最后先按照id和结果列进行 group by，然后统计结果，旋转连续天数大于7的用户id</span><br><span class="line">select id,count(*) from </span><br><span class="line">(</span><br><span class="line">    #date函数仅返回日期部分，不返回时间部分，结果列表示  用户连续登陆情况下，每次相减的结果都相同</span><br><span class="line">    select *,date(日期)-cum as 结果 from </span><br><span class="line">    (</span><br><span class="line">        #按照用户分组，按照时间排序, cum是排名</span><br><span class="line">        select *,row_number() over(PARTITION by id order by 日期) as cum from </span><br><span class="line">        (</span><br><span class="line">            #给时间去重</span><br><span class="line">            select DISTINCT date(date) as 日期,id from orde) a </span><br><span class="line">    )b</span><br><span class="line">)c GROUP BY id,结果 having count(*)&gt;&#x3D;7;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="计算用户在线峰值">计算用户在线峰值</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#(timestampe:String, uid:Int, logtype:Int)</span><br><span class="line">#时间戳 用户ID 上线下线状态(-1下线，1上线)</span><br><span class="line"></span><br><span class="line">select</span><br><span class="line">    max(max_users)</span><br><span class="line">from </span><br><span class="line">(</span><br><span class="line">    select</span><br><span class="line">        sum(logtype) over(order by &#96;timestampe&#96;) as max_users #排序后第一行到本行的和，就统计了当前时刻究竟有多少人在线</span><br><span class="line">    from</span><br><span class="line">    (</span><br><span class="line">        select</span><br><span class="line">            uid,</span><br><span class="line">            unix_timestamp(timestampe) as &#96;timestampe&#96;, #unix_timestamp 自&#39;1970-01-01 00:00:00&#39;的到当前时间的秒数差</span><br><span class="line">            logtype</span><br><span class="line">        from</span><br><span class="line">            mytable</span><br><span class="line">    ) as a  #将登录时间和登出时间多列成多行</span><br><span class="line">)as b</span><br></pre></td></tr></table></figure>
<h4 id="前n个阅读量最高的文章">前N个阅读量最高的文章</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#给定用户id，文章id，阅读时间</span><br><span class="line">select 文章id, count(*) as 阅读量</span><br><span class="line">from biao</span><br><span class="line">group by 文章id</span><br><span class="line">order by 阅读量 desc</span><br><span class="line">limit 5</span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
<p>https://www.codeleading.com/article/5399898432/ （在线峰值）</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL窗口函数</title>
    <url>/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p>窗口指的是记录的集合。窗口函数也就是在满足某种条件的记录集合上执行的特殊函数。</p>
<a id="more"></a>
<h4 id="基本用法">基本用法</h4>
<blockquote>
<p>函数名 OVER (子句)</p>
</blockquote>
<p>函数名部分即表示窗口函数。</p>
<p>over关键字用来指定函数执行的窗口范围，若后面括号中什么都不写，则窗口函数基于所有行进行计算；如果不为空，则支持以下4中语法来设置窗口：</p>
<ul>
<li><p><code>PARTITION BY</code> 子句：窗口按照哪些字段进行分组，窗口函数在不同的分组上分别执行；</p></li>
<li><p><code>ORDER BY</code>子句：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号；</p></li>
<li><p><code>FRAME</code>子句：FRAME是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用</p></li>
<li><p>window_name：给窗口指定一个别名。如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">rank</span> ( ) <span class="keyword">over</span> w1 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee <span class="keyword">window</span> w1 <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> )</span><br><span class="line">    </span><br><span class="line"># <span class="keyword">from</span> <span class="keyword">table</span>后面加了一个关键字<span class="keyword">WINDOW</span>，后面跟了一个子句，这样在<span class="keyword">select</span>中就可以使用这个w1作为窗口了。</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="窗口函数">窗口函数</h4>
<p>窗口函数，在某些记录的集合上执行的函数。</p>
<h5 id="序号函数">序号函数</h5>
<p>row_number()/rank()/dense_rank()</p>
<p>作用：显示分区中的当前行号（排名是需要通过<code>ORDER BY</code>子句实现的）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,</span><br><span class="line">   <span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> ranking,</span><br><span class="line">   <span class="built_in">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> dese_rank,</span><br><span class="line">   <span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> row_num</span><br><span class="line"><span class="keyword">from</span> 班级;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/0.png" style="zoom:67%;"></p>
<ul>
<li><p>rank函数：如果有并列名次的行，会占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，4。</p></li>
<li><p>dense_rank函数：如果有并列名次的行，不占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，2。</p></li>
<li><p>row_number函数：不考虑并列名次的情况。比如前3名是并列的名次，排名是正常的1，2，3，4。</p></li>
</ul>
<h5 id="分布函数">分布函数</h5>
<p>percent_rank()/cume_dist()</p>
<p>percent_rank()</p>
<p>用途：和之前的RANK()函数相关，每行按照公式进行计算：(rank - 1) / (rows - 1)</p>
<p>其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数该函数可以用来计算分位数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">percent_rank</span> ( ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ),</span><br><span class="line">    Company,</span><br><span class="line">    Salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Company <span class="operator">=</span> <span class="string">&#x27;Microsoft&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/1.png" style="zoom:67%;"></p>
<p>cume_dist()</p>
<p>用途：分组内小于等于当前rank值的行数/分组内总行数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">cume_dist</span> ( ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ),</span><br><span class="line">    Company,</span><br><span class="line">    Salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Company <span class="operator">=</span> <span class="string">&#x27;Microsoft&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/2.png" style="zoom:67%;"></p>
<h5 id="聚合函数">聚合函数</h5>
<p>sum/avg/max/min/count</p>
<p>用途：在窗口中每条记录动态应用聚合函数(sum/avg/max/min/count)，可以动态计算在指定的窗口内的各种聚合函数值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">avg</span>( Salary ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Company <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ),</span><br><span class="line">    Company,</span><br><span class="line">    Salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employee </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    Company <span class="operator">=</span> <span class="string">&#x27;Microsoft&#x27;</span></span><br></pre></td></tr></table></figure>
<p>按照分组的每一行，求累计的平均值。根据over子句分组之后，挨个行进行select，并执行over前面的函数，因为over子句已经把记录变成了符合条件的一些行集，所以select的方式就改变了。</p>
<p><img src="/2021/04/13/SQL_%E7%AA%97%E5%8F%A3/3.png" style="zoom:67%;"></p>
<h4 id="参考资料">参考资料</h4>
<p>https://leetcode-cn.com/problems/department-top-three-salaries/solution/tu-jie-sqlmian-shi-ti-jing-dian-topnwen-ti-by-houz/</p>
<p>https://www.jianshu.com/p/e5c5bfb1e28b</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库分层</title>
    <url>/2021/07/11/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<p>将数据仓库中的数据进行分层存储，本质上是为了构建清晰的数据链路，便于规划和管理数据。</p>
<p>在阿里巴巴的数据体系中，将数据仓库分为三层，从数据源开始自下而上为：</p>
<ul>
<li>数据引入层（ODS，Operation Data Store）</li>
<li>数据公共层（CDM，Common Data Model）</li>
<li>数据应用层（ADS，Application Data Service）</li>
</ul>
<p><img src="/2021/07/11/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82/image-20210711151440351.png" alt="image-20210711151440351" style="zoom:67%;"></p>
<a id="more"></a>
<h3 id="数据引入层ods">数据引入层（ODS）</h3>
<p>存放未经过处理的原始数据至数据仓库系统，结构上与源系统保持一致，是数据仓库的数据准备区。</p>
<p>主要完成基础数据引入到数据仓库（阿里云的数仓工具为MaxCompute）的职责，同时记录基础数据的历史变化。</p>
<h3 id="数据公共层cdm">数据公共层（CDM）</h3>
<p>主要完成数据加工与整合，本质上是建立明细表和宽表，这些表是可复用的、面向分析和统计的。</p>
<p>在这一层内又可以划分为多层。</p>
<p><img src="/2021/07/11/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82/image-20210711152514618.png" alt="image-20210711152514618" style="zoom:67%;"></p>
<h4 id="明细层dwd">明细层（DWD ）</h4>
<p>Data Warehouse Detail</p>
<p>该层一般保持和ODS层一样的数据粒度，并且提供一定的数据质量保证。同时，为了提高数据明细层的易用性，该层会采用一些维度退化手法，将维度退化至事实表中，减少事实表和维表的关联。</p>
<p>另外，在该层也会做一部分的数据聚合，将相同主题的数据汇集到一张表中，提高数据的可用性。</p>
<h4 id="公共层dwbdws">公共层（DWB/DWS）</h4>
<p>DWB：data warehouse base 基础数据层，存储的是客观数据，一般用作中间层，可以认为是大量指标的数据层。</p>
<p>该层会在DWD层的数据基础上，对数据做<strong>轻度的聚合</strong>操作，生成一系列的中间表，提升公共指标的<strong>复用性</strong>，减少重复加工。本质上，就是对通用的核心维度进行聚合操作，算出相应的统计指标。</p>
<p>DWS：data warehouse service 服务数据层，基于DWB上的基础数据，整合汇总成分析某一个主题域的服务数据，一般是宽表。</p>
<p>DWS又称<strong>数据集市或宽表</strong>。按照业务划分，如流量、订单、用户等，生成字段比较多的宽表，用于提供后续的业务查询，OLAP分析，数据分发等。</p>
<p>一般来讲，该层的数据表会相对比较少，一张表会涵盖比较多的业务内容，由于其字段较多，因此一般也会称该层的表为宽表。</p>
<p>在实际计算中，如果直接从DWD或者ODS计算出宽表的统计指标，会存在<strong>计算量太大</strong>并且维度太少的问题，因此一般的做法是，在DWB层先计算出多个小的中间表，然后再拼接成一张DWS的宽表。由于宽和窄的界限不易界定，也可以去掉DWB这一层，只留DWS层，将所有的数据在放在DWS亦可。</p>
<h4 id="维度层dim">维度层（DIM）：</h4>
<p>Dimension。</p>
<p>基于维度建模理念思想，建立整个企业一致性维度。</p>
<p>主要包含两部分数据：</p>
<p>高基数维度数据：一般是用户资料表、商品资料表类似的<strong>资料表</strong>。数据量可能是千万级或者上亿级别。</p>
<p>低基数维度数据：一般是<strong>配置表</strong>，比如枚举值对应的中文含义，或者日期维表。数据量可能是个位数或者几千几万。</p>
<h3 id="数据应用层ads">数据应用层（ADS）</h3>
<p>存放数据产品个性化的统计指标数据。根据CDM与ODS层加工生成。本质上就是业务方需要展示的数据表。</p>
<h3 id="分层的优点">分层的优点</h3>
<ul>
<li>清晰结构 每一个数据分层都有它的作用域，在使用表的时候能更方便地定位和理解整个数据链路的构造。</li>
<li>数据追踪 简单来说，我们最终给业务呈现的是一个能直接使用业务表，但是它的来源有很多，如果有一张来源表出问题了，希望能够快速准确地定位到问题，并清楚它的危害范围。</li>
<li>减少重复开发 规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算。</li>
<li>把复杂问题简单化 将一个复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，比较简单和容易理解。而且便于维护数据的准确性，当数据出现问题之后，可以不用修复所有的数据，只需要从有问题的步骤开始修复。</li>
<li>屏蔽原始数据的异常 屏蔽业务的影响，不必改一次业务就需要重新接入数据。例如假如某一层的时间单位被修改了，则只影响这一层。</li>
</ul>
<h3 id="总结">总结</h3>
<p>数仓分成其实大致可以分为数据引入（数据源解耦）、数据公共（数仓）、数据应用（业务）这三层。</p>
<p>数据公共层又可以分为明细层（DWD）、公共层（DWB/DWS）、维度层（DIM）等。</p>
<p>总结下来可以大致分为：</p>
<table>
<thead>
<tr class="header">
<th>数仓分层</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数据应用层（ADS）</td>
<td>存放不同产品的统计指标数据。</td>
</tr>
<tr class="even">
<td>维度层（DIM）</td>
<td>用户资料表，配置表</td>
</tr>
<tr class="odd">
<td>服务数据层（DWS）</td>
<td>根据不同业务生成字段较多的宽表，用于提供后续的业务查询</td>
</tr>
<tr class="even">
<td>基础数据层（DWB/DWM）</td>
<td>对数据做轻度的聚合操作，生成一系列的中间表，提升公共指标的复用性</td>
</tr>
<tr class="odd">
<td>明细层（DWD）</td>
<td>提供一定的数据质量保证，减少表关联</td>
</tr>
<tr class="even">
<td>数据引入层（ODS）</td>
<td>存放未经过处理的原始数据</td>
</tr>
<tr class="odd">
<td>数据源</td>
<td>存储在消息队列MQ和数据库OLTP中的数据</td>
</tr>
</tbody>
</table>
<p><img src="/2021/07/11/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82/image-20210711155449936.png" alt="image-20210711155449936" style="zoom:67%;"></p>
<h3 id="参考资料">参考资料</h3>
<p>https://help.aliyun.com/document_detail/114447.html</p>
<p>https://cloud.tencent.com/developer/article/1396891</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库与数据库</title>
    <url>/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>数据仓库，英文名称为Data Warehouse，可简写为DW或DWH，是一种用于报告和数据分析的系统，被认为是商业智慧（BI，Business Intelligence）的核心组件。 数据仓库将一个或多个数据源的数据集成到中央存储库中，将当前和历史数据存储在一起，用于创建分析报告。 存储在仓库中的数据从运行系统（例如营销或销售）上传。</p>
<a id="more"></a>
<h3 id="数据仓库与数据库">数据仓库与数据库</h3>
<p>数据库 Database (Oracle, Mysql)主要用于事务处理，数据仓库 Data Warehouse (Hive)主要用于数据分析。用途上的不同决定了这两种架构的特点不同。</p>
<p>数据库(Database)的特点是：</p>
<ul>
<li>相对复杂的表格结构，存储结构相对紧致，少冗余数据。</li>
<li>读和写都有优化。</li>
<li>相对简单的read/write query，单次作用于相对的少量数据。</li>
</ul>
<p>数据仓库(Datawarehouse)的特点是：</p>
<ul>
<li>相对简单的(Denormalized)表格结构，存储结构相对松散，多冗余数据。</li>
<li>一般只是读优化。</li>
<li>相对复杂的read query，单次作用于相对大量的数据（历史数据）。</li>
</ul>
<p>用图书表格系统举例子，可以从如下方面看出两者的区别。</p>
<h4 id="表结构">表结构</h4>
<p>如下表示数据库(Database)的表结构。这里有六张表，分别记录了作者，图书，图书种类，发行商以及他们之间的关系。可以看出每张表都相对紧致，冗余的数据较少。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/0.png" style="zoom:50%;"></p>
<p>如下表示数据仓库(Data Warehouse)的表结构。需要对原始表格进行Denormalization。数据仓库中仅剩余一张表格。</p>
<blockquote>
<p>Denormalization是一种策略，用于已经预先Normalized的数据库上以提高性能。Denormalization尝试通过增加数据的冗余副本或对数据进行分组来提高数据库的读取性能，但以牺牲一些写入性能为代价。</p>
</blockquote>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/1.png" style="zoom:50%;"></p>
<p>Denormalization可以通过对数据库中的表格执行如下的SQL语句脚本实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Denormalization Script -- </span><br><span class="line">select </span><br><span class="line">b.id,</span><br><span class="line">b.title,</span><br><span class="line">b.copyright,</span><br><span class="line">b.isbn,</span><br><span class="line">g.genre,</span><br><span class="line">a.firstname as AuthorFirstName,</span><br><span class="line">a.lastname as AuthorLastName,</span><br><span class="line">a.dateofbirth,</span><br><span class="line">a.gender,</span><br><span class="line">p.name as PublisherName</span><br><span class="line">from BOOKS b</span><br><span class="line">left join GENRE g on b.genre &#x3D; g.id</span><br><span class="line">left join AUTHOR_BOOK_MAP abm on b.id &#x3D; abm.bookid</span><br><span class="line">left join AUTHORS a on a.id &#x3D; abm.authorid</span><br><span class="line">left join PUBLISHER_BOOK_MAP pbm on b.id &#x3D; pbm.bookid</span><br><span class="line">left join PUBLISHER p on p.id &#x3D; pbm.publisherid;</span><br></pre></td></tr></table></figure>
<h4 id="存储空间">存储空间</h4>
<p>很明显，因为在Denormalization的过程中，如果数据库主表和次表不是一对一的关系，那么最终数据仓库主表或者次表一定会出现重复的数据。所以从存储空间角度讲，相比于数据库紧密的存储结构，数据仓库则存在大量冗余重复的数据。</p>
<p>数据库(Database)表单存储紧凑：</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/2.png" style="zoom: 67%;"></p>
<p>数据仓库(Datawarehouse)表单里有大量冗余：</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/3.png" style="zoom:67%;"></p>
<h4 id="读写优化">读写优化</h4>
<h5 id="基本读read操作对比">基本读(Read)操作对比</h5>
<p>如下所示的两种查询，一个是找一本书（Primary Key）的信息，另一个是找一位作者（Non-Key）所有的作品信息。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/4.png" style="zoom:67%;"></p>
<p>由于数据库需要利用表之间的关联才能找到所有需要的数据，在<strong>效率上会相对低下</strong>。相比之下数据仓库把这些关联关系转化成重复数据记录到同一张表上了，查询效率相对就会较高。数据仓库相当于牺牲了空间换取了查询效率。</p>
<p>此外，在数据库里面写这段Query的时候，<strong>需要了解表单的结构与他们之间的关系</strong>，这对于做数据报告或者数据分析非常不友好，尤其是在表单结构很复杂的时候（比如表单使用了逻辑树的储存结构）。这时候数据仓库简单明了的Denormalized表单结构就对于生成数据报告就非常有优势了。</p>
<p>并且，由于数据报告和数据分析常常涉及到大规模的查询，这些<strong>查询很可能会占用很高的CPU资源</strong>，从而可能影响到数据库的常规读写操作，因为数据库常常是Single-Instance的（接下来会提到）；这一点上数据仓库的Multi-instances的结构就不会有太多这个问题。</p>
<h5 id="大数据读read操作对比">大数据读(Read)操作对比</h5>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/5.png" style="zoom: 50%;"></p>
<p>当数据量非常大的时候，特定条件下的数据仓库的读优化所带来的优势可以全面超越数据库。大部分的数据库都是Single-instance的，而数据仓库则是Multi-instances的<strong>分布式系统</strong>。数据仓库在分配储存的节点的时候是根据PrimaryKey/PartitionKey来分配的，查询的时候不仅<strong>根据查询键的值来搜索对应节点位置</strong>，同时<strong>进行大量的并行查询</strong>，可以极大提升查询的性能。</p>
<p>但是，并不是所有的读操作，数据仓库一直都有优势。比如在如下两种情况时，数据仓库的读表现并不如数据库：</p>
<p>1、在对小量数据进行读取操作的时候，由于数据仓库要进行寻找数据所在的节点位置之类的预运算，整体效率上反倒不如数据库。</p>
<p>2、如果读取操作的目标不是主键(PrimaryKey)或者分区键(PartitionKey)，那么数据仓库的查询也需要进行全局扫描，效率上就不好说是否胜过数据库了。</p>
<p>这两点也是为什么现在即使有像Amazon Redshift这般强大的Data Warehouse应用，SQL Database仍然无法被取代的一部分主要原因。</p>
<h5 id="写write操作">写(Write)操作</h5>
<p>多数情况下，数据仓库不太会进行精确的写操作。因为冗余行数太多，有时候只是改一个很小的字段，也会修改大量的行数。而对于数据库来说，由于其紧凑的表格结构，写操作就可以非常精细有效了。比如需要修改《Java Complete》这本书的版权，从1999改到2002，数据库里面只需要该一行，而数据仓库里面需要改5行。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/6.png"></p>
<p>数据仓库的写操作都是整段(表)刷新或者整段数据插入, 这也和它做数据分析的用途有关系。由于数据仓库的整表刷新和分布式储存的特质，我们可以通过把PartitionKey设置成数据创建/更新的时间，然后记录一段时间内的历史数据。这对于数据分析以及利用数据进行决策都有重要意义。</p>
<h3 id="数据仓库与数据库结合">数据仓库与数据库结合</h3>
<p>可以通过将两者的架构结合发挥出两者的优势。</p>
<p>通常的软件架构简化一下就是用户通过API和数据库交互。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/7.png" style="zoom:55%;"></p>
<p>这里如果要直接在数据库上做数据分析，数据监控等等任务的话，会有以下几个问题：</p>
<p>1、数据分析通常涉及大量数据查询，可能会<strong>占用太多CPU</strong>从而影响软件的基本功能。</p>
<p>2、数据库的表单结构通常比较复杂，<strong>需要数据分析人员对DB结构有深入的了解</strong>。</p>
<p>3、数据库在进行<strong>大量数据查询的时候效率较低</strong>。</p>
<p>4、开放数据库访问<strong>权限</strong>（即便只是读权限），尤其是给外组人员，会有安全隐患。</p>
<p>为了解决以上四个问题，我们可以通过利用脚本，每隔一段时间把数据库里面的所有数据Denormalize到数据仓库里面，在数据仓库里面进行数据分析。根据之前提到的数据仓库的所有的特性（独立不影响业务，表结构简单，读数据速度快，相对安全），这四个问题都可以得到很好的解决。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/8.png" style="zoom: 50%;"></p>
<p>但是这里还是有一个小问题。如果有很多不同的组需要共享这个Data Warehouse，那么同样他们的脚本可能会相互影响。这里引入一下数据目录(Data Catalog)的概念来解决这个问题。</p>
<blockquote>
<p>数据目录是一种元数据管理工具，旨在帮助公司查找和管理存储在其各个系统中的大量数据（包括表、文件和数据库） 。</p>
</blockquote>
<p>通过数据目录储存元数据，然后发布出去让不同组的数据仓库都可以同步这个数据。这样，每个不同组的数据仓库都拿到了同样的Denormalized数据，但是却相互独立开了。</p>
<p><img src="/2021/05/03/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/9.png" style="zoom: 33%;"></p>
<h3 id="总结">总结</h3>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 45%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>数据库</th>
<th>数据仓库</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作用</td>
<td>主要用于事务处理（增删改）。</td>
<td>主要用于数据分析。</td>
</tr>
<tr class="even">
<td>表格结构</td>
<td>一个存储的主题通常由多张表格及其之间的关系（Schema）组成。</td>
<td>一个存储的主题可以由一张表格形成，它里面包含了大量冗余的数据（Denormalization增加数据的冗余副本）。</td>
</tr>
<tr class="odd">
<td>存储空间</td>
<td>表格存储紧凑。</td>
<td>表格存在冗余。</td>
</tr>
<tr class="even">
<td>基本读操作</td>
<td>1、需要利用表之间的关联才能找到所有需要的数据，在<strong>效率上会相对低下</strong>。2、需要<strong>了解表格的结构与他们之间的关系</strong>进行查询。3、Single-Instance的数据库在执行大规模查询时<strong>占用大量CPU资源</strong>。</td>
<td>1、数据仓库包含<strong>大量冗余数据</strong>，可以不用对多个表格进行关联就能查询到数据。2、Denormalized策略使得<strong>不需要理解表格之间的关系</strong>就可以进行查询。3、数据仓库通常是<strong>分布式存储</strong>的，可以通过分布式计算框架操作数据。</td>
</tr>
<tr class="odd">
<td>大规模读操作</td>
<td>基于Single-Instance的数据库在执行大规模查询时不能并行查找，效率低下。</td>
<td>基于分布式存储系统和分布式计算框架的数据仓库在面临大规模查询时可以进行并行查找，效率较高。（小量数据查询、查询目标非主键/分区键时，无法保证效率）</td>
</tr>
<tr class="even">
<td>写操作</td>
<td>更新数据时仅涉及少量的行。</td>
<td>由于数据是冗余存储的，更新数据时涉及到大量的行更新。</td>
</tr>
<tr class="odd">
<td>两者结合</td>
<td>每隔一段时间把数据库里面的所有数据Denormalize到数据仓库里面，在数据仓库里面进行数据分析。</td>
<td>不同数据仓库通过订阅数据目录中的元数据信息来获取Denormalized之后的数据。</td>
</tr>
</tbody>
</table>
<h3 id="参考资料">参考资料</h3>
<p>转载自： https://www.zhihu.com/question/20623931/answer/750367153</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>数据仓库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式</title>
    <url>/2021/07/23/%E9%9D%A2%E8%AF%95_%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="分布式锁">分布式锁</h3>
<p>https://blog.csdn.net/wuzhiwei549/article/details/80692278</p>
<h3 id="分布式事务">分布式事务</h3>
<p>https://zhuanlan.zhihu.com/p/183753774</p>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>0725 拼多多笔试</title>
    <url>/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/</url>
    <content><![CDATA[<h2 id="一">一</h2>
<a id="more"></a>
<p><img src="/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/image-20210725220515830.png" alt="image-20210725220515830" style="zoom: 67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">本题是仿照覆盖区间问题，暴力法也可以过</span><br><span class="line">思路一：</span><br><span class="line"><span class="number">1</span>、按照开始的位置排序</span><br><span class="line"><span class="number">2</span>、判断下一个是不是在上一个里面</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入组成二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">7</span>,<span class="number">10</span>&#125;,&#123;<span class="number">13</span>,<span class="number">18</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据线段的起始点排序</span></span><br><span class="line">        Arrays.sort(nums, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断前一个线段是否包含当前线段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//包含则输出并返回</span></span><br><span class="line">            <span class="keyword">if</span>( nums[i][<span class="number">1</span>] &lt;= nums[i-<span class="number">1</span>][<span class="number">1</span>] )&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不包含输出false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">思路二：</span><br><span class="line">直接暴力</span><br></pre></td></tr></table></figure>
<h2 id="二">二</h2>
<p><img src="/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/image-20210725220631616.png" alt="image-20210725220631616" style="zoom: 67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 模拟法，注意是牌多的人赢</span></span><br><span class="line"><span class="comment">* 注意每轮获胜后，放下牌需要再次判断是不是再次获胜，不能直接到下一个人发牌。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* https://www.nowcoder.com/discuss/690459?type=post&amp;order=create&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当有重复牌出现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">winIt</span><span class="params">(ArrayList&lt;Integer&gt; list,HashMap&lt;Integer,Integer&gt; where,<span class="keyword">int</span>[] win,<span class="keyword">int</span> person,<span class="keyword">int</span> put)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获得重复牌下标</span></span><br><span class="line">        <span class="keyword">int</span> index=where.get(put);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//累加它的筹码</span></span><br><span class="line">        win[person]+=list.size()-index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移走这些牌</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=index;i--)&#123;</span><br><span class="line">            <span class="comment">//删除记录的下标，注意不单只删除那个重复的，所有中间的都要删除</span></span><br><span class="line">            where.remove(list.get(i));</span><br><span class="line">            <span class="comment">//在牌局中删除牌</span></span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int[] arr = &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; collect = Arrays.stream(arr).boxed().collect(Collectors.toList());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//两者手中的牌</span></span><br><span class="line">        List&lt;Integer&gt; person1 = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>&#125;).boxed().collect(Collectors.toList());</span><br><span class="line">        List&lt;Integer&gt; person2 = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">8</span>,<span class="number">25</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>&#125;).boxed().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//牌局</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录每个牌的位置</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; where=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两者剩余的牌的下标，只需要用index即可，出过的牌就没了</span></span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录获胜的筹码</span></span><br><span class="line">        <span class="keyword">int</span>[] win=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当两者都还有牌</span></span><br><span class="line">        <span class="keyword">while</span>(index1&lt;person1.size() || index2&lt;person2.size())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//person1有牌</span></span><br><span class="line">            <span class="keyword">if</span>(index1&lt;person1.size())&#123;</span><br><span class="line">                <span class="comment">//拿到牌</span></span><br><span class="line">                <span class="keyword">int</span> put1=person1.get(index1);</span><br><span class="line">                index1++;</span><br><span class="line">                <span class="comment">//放入牌局</span></span><br><span class="line">                list.add(put1);</span><br><span class="line">                <span class="comment">//有重复牌</span></span><br><span class="line">                <span class="keyword">while</span>(where.get(put1)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//累加筹码并从牌局中删除牌</span></span><br><span class="line">                    winIt(list,where,win,<span class="number">0</span>,put1);</span><br><span class="line">                    <span class="comment">//是否有牌可出</span></span><br><span class="line">                    <span class="keyword">if</span>(index1&gt;=person1.size())</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//出牌</span></span><br><span class="line">                    put1=person1.get(index1);</span><br><span class="line">                    index1++;</span><br><span class="line">                    list.add(put1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//记录下标</span></span><br><span class="line">                where.put(put1,list.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//person2重复上述过程</span></span><br><span class="line">            <span class="keyword">if</span>(index2&lt;person2.size())&#123;</span><br><span class="line">                <span class="keyword">int</span> put2=person2.get(index2);</span><br><span class="line">                index2++;</span><br><span class="line">                list.add(put2);</span><br><span class="line">                <span class="keyword">while</span>(where.get(put2)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    winIt(list,where,win,<span class="number">1</span>,put2);</span><br><span class="line">                    <span class="keyword">if</span>(index2&gt;=person2.size()) <span class="keyword">break</span>;</span><br><span class="line">                    put2=person2.get(index2);</span><br><span class="line">                    index2++;</span><br><span class="line">                    list.add(put2);</span><br><span class="line">                &#125;</span><br><span class="line">                where.put(put2,list.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历剩余牌局中的牌，按奇数偶数累加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                win[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                win[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(win[<span class="number">0</span>]+<span class="string">&quot; &quot;</span>+win[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三">三</h2>
<p><img src="/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/image-20210725220754513.png" alt="image-20210725220754513" style="zoom: 67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  看 Q能否写成 （C^n）*A+m*B</span></span><br><span class="line"><span class="comment">*  Q = （C^n）*A+m*B</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*https://www.nowcoder.com/discuss/690445?type=post&amp;order=time&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> Q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(C == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (Q-A)%B==<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp_C = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( temp_C*A &lt;= Q )&#123;     <span class="comment">//如果 A*C 比Q小</span></span><br><span class="line">                <span class="keyword">if</span>((Q-temp_C*A)%B==<span class="number">0</span>)   <span class="comment">//如果Q能被拆开，则成功</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                temp_C = temp_C*C; <span class="comment">//否则继续递增C</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println( can(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四">四</h2>
<p><img src="/2021/07/25/%E7%AC%94%E8%AF%95_0725%E6%8B%BC%E5%A4%9A%E5%A4%9A/image-20210725221050444.png" alt="image-20210725221050444" style="zoom: 67%;"></p>
<p>例如：0 4 0 0 0 0 0 0 0 0：</p>
<p>输出：121（解释：因为有4个1，最大组成 11 * 11 = 121）</p>
<p>例如：2 3 0 1 0 0 0 0 0 0：</p>
<p>输出：34100（解释：1个3，2个0，三个1 最大组成3100 * 11 = 34100）</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 乘积最大的规律是：大数尽可能排在高位，两个两位数的差尽可能小。</span></span><br><span class="line"><span class="comment">* 最后必然是2个数相乘。</span></span><br><span class="line"><span class="comment">* 高位必须放前面，所以从后往前遍历。</span></span><br><span class="line"><span class="comment">* 然后每个数组优先给2个乘数中较小的那个（也就是数字长度更短的那个，长度相等情况下是较小的那个），来保证两数在满足大数字在前的前提下尽可能接近些。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* https://www.nowcoder.com/discuss/690459?type=post&amp;order=create&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟数字</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终都会成为两个数的乘积，所以仅需要考虑两个数乘积什么时候最大</span></span><br><span class="line">        ArrayList&lt;Integer&gt; left=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        ArrayList&lt;Integer&gt; right=<span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配数字给两个乘数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//把最大的数字给左边的最高位</span></span><br><span class="line">                <span class="keyword">if</span>(left.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    left.add(i);</span><br><span class="line">                    arr[i]--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//其次给右边数的最高位</span></span><br><span class="line">                <span class="keyword">if</span>(right.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    right.add(i);</span><br><span class="line">                    arr[i]--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果左边数的长度比较长，那么就把数字给右边的数</span></span><br><span class="line">                <span class="keyword">if</span>(checkIt(left,right))&#123;</span><br><span class="line">                    right.add(i);</span><br><span class="line">                    arr[i]--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 反之</span></span><br><span class="line">                    left.add(i);</span><br><span class="line">                    arr[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终获得结果</span></span><br><span class="line">        getResult(left,right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkIt</span><span class="params">(ArrayList&lt;Integer&gt; left,ArrayList&lt;Integer&gt; right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果左边的数比较长则返回true，数字给到右边</span></span><br><span class="line">        <span class="keyword">if</span>(left.size()&gt;right.size()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(right.size()&gt;left.size()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果两个长度相等</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;left.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.get(i).equals(right.get(i))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> left.get(i) &gt; right.get(i); <span class="comment">//左边数的数字比较大则返回true，数字会给到右边</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数字全部相等也返回true，数字给到右边</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList转换成字符，然后再转成数字，最后使用大整数乘法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">(ArrayList&lt;Integer&gt; left,ArrayList&lt;Integer&gt; right)</span></span>&#123;</span><br><span class="line">        BigInteger l1=<span class="keyword">new</span> BigInteger(getString(left));</span><br><span class="line">        BigInteger l2=<span class="keyword">new</span> BigInteger(getString(right));</span><br><span class="line">        BigInteger ret=l1.multiply(l2);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList转换成字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(ArrayList&lt;Integer&gt; arr)</span></span>&#123;</span><br><span class="line">        StringBuilder ret=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Integer e:arr)&#123;</span><br><span class="line">            ret.append(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark</title>
    <url>/2021/07/24/%E9%9D%A2%E8%AF%95_Spark/</url>
    <content><![CDATA[<a id="more"></a>
<p><strong>spark 中一个worker有多少executor ？</strong></p>
<p>最直接的方式worker上有多少个cpu core就克制配置多少个executor，当然可以根据cpu的性能、每个做调整。跑在yarn上也一样，根据container来，container一般也是根据cpu core来计算数量的。</p>
<p><strong>spark提交参数含义</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spark-submit</span><br><span class="line">--master yarn </span><br><span class="line">--deploy-mode client </span><br><span class="line">--class com.practiceSpark.jar</span><br><span class="line">--executor-memory 10G </span><br><span class="line">--num-executors 20 </span><br><span class="line">--executor-cores 2 </span><br><span class="line">--driver-memory 8g </span><br><span class="line">--queue spark </span><br><span class="line">--conf spark.driver.maxResultSize=6G </span><br><span class="line">--conf spark.network.timeout=300 </span><br><span class="line">--conf spark.executor.heartbeatInterval=30 </span><br><span class="line">-conf spark.task.maxFailures=4 </span><br><span class="line">--conf spark.speculation=<span class="literal">true</span> </span><br><span class="line">--conf spark.shuffle.service.enabled=<span class="literal">true</span> </span><br><span class="line">--conf spark.executor.memoryOverhead=8g  </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>--master</td>
<td>master 的地址，提交任务到哪里执行，例如 spark://host:port, yarn, local</td>
</tr>
<tr class="even">
<td>--deploy-mode</td>
<td>在本地 (client) 启动 driver 或在 cluster 上启动，默认是 client</td>
</tr>
<tr class="odd">
<td>--class</td>
<td>应用程序的主类，仅针对 java 或 scala 应用</td>
</tr>
<tr class="even">
<td>--name</td>
<td>应用程序的名称</td>
</tr>
<tr class="odd">
<td>--packages</td>
<td>包含在driver 和executor 的 classpath 中的 jar 的 maven 坐标</td>
</tr>
<tr class="even">
<td>--driver-memory</td>
<td>Driver内存，默认 1G</td>
</tr>
<tr class="odd">
<td>--driver-cores</td>
<td>Driver 的核数，默认是1。在 yarn 或者 standalone 下使用</td>
</tr>
<tr class="even">
<td>--executor-memory</td>
<td>每个 executor 的内存，默认是1G</td>
</tr>
<tr class="odd">
<td>--executor-core</td>
<td>每个 executor 的核数。在yarn或者standalone下使用</td>
</tr>
<tr class="even">
<td>--conf PROP=VALUE</td>
<td>指定 spark 配置属性的值，</td>
</tr>
</tbody>
</table>
<p><strong>spark执行页面关注什么</strong></p>
<p>代表executors页面</p>
<p>这里可以看到执行者申请使用的内存以及shuffle中input和output等数据。比较常用了，一方面通过它可以看出来每个excutor是否发生了数据倾斜，另一方面可以具体分析目前的应用是否产生了大量的shuffle，是否可以通过数据的本地性或者减小数据的传输来减少shuffle的数据量。</p>
<p><img src="/2021/07/24/%E9%9D%A2%E8%AF%95_Spark/image-20210724152629279.png" alt="image-20210724152629279" style="zoom:67%;"></p>
<blockquote>
<p>其他UI界面</p>
<p>https://blog.csdn.net/u013013024/article/details/73498508</p>
</blockquote>
<p><strong>spark类型推断</strong></p>
<p>在spark中，假如需要将读取的数据集，转换成表格的形式，使得它能够支持SQL，那么需要知道这个表的schema，即表结构，有两种方式能够实现这样的操作：</p>
<p>1、通过反射推断出Schema：即定义case class样例类，从指定的地址创建RDD后，将RDD中的数据映射乘case class，通过隐式转换转成DF。</p>
<p>2、通过StructType直接指定Schema：通过StructType直接指定每个字段的Schema,相当于是表的描述信息，在createDataFrame中传入这个StructType，将RDD转为数据表</p>
<p><strong>spark中两个表join不产生shuffle</strong></p>
<p>当两个rdd分区数和分区方式一样时做join就不会产生shuffle，因为分区数和分区方式一样的时候，相同Key的数据都在同一个机器上，发生join操作时可以在本机上执行，不需要数据迁移，所以不会发生shuffle。</p>
<p>（在join之前给两个RDD增加groupByKey()算子，发生shuffle）</p>
<p><strong>参考资料</strong></p>
<p>https://www.cnblogs.com/hexu105/p/8182472.html （spark执行页面）</p>
<p>https://blog.csdn.net/tototuzuoquan/article/details/74936717（自动推断）</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive</title>
    <url>/2021/07/24/%E9%9D%A2%E8%AF%95_Hive/</url>
    <content><![CDATA[<p>Hive数据倾斜</p>
<p><strong>Hive中order by，sort by，distribute by，cluster by的区别</strong></p>
<p>order by：会对输入做全局排序，因此只有一个Reducer，导致当输入规模较大时，消耗较长的计算时间。</p>
<p>sort by：不是全局排序，其在数据进入reducer前完成排序，因此，如果用sort by进行排序，并且设置mapred.reduce.tasks&gt;1，则sort by只会保证每个reducer的输出有序，并不保证全局有序。对输出的数据再执行归并排序，即可得到全部结果。</p>
<p>distribute by：根据字段的hash值和reducer的个数进行模除后，余数相同的分到一个区。将具有相同字段的map输出分发到一个reduce节点上做处理。</p>
<p>cluster by：如果 distribute by 和 sort by 中所用的列相同，就可以缩写为 cluster by。</p>
<a id="more"></a>
<p><strong>Hive内部表和外部表的区别</strong></p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 46%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>内部表（默认）</th>
<th>外部表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>修饰符</td>
<td>无</td>
<td>external</td>
</tr>
<tr class="even">
<td>管理者</td>
<td>Hive</td>
<td>HDFS</td>
</tr>
<tr class="odd">
<td>删除结果</td>
<td>删除内部表会直接删除元数据（metadata）及存储数据</td>
<td>删除外部表仅仅会删除元数据，HDFS上的文件并不会被删除</td>
</tr>
<tr class="even">
<td>存储位置</td>
<td>hive.metastore.warehouse.dir指定，默认认：/user/hive/warehouse</td>
<td>由建表语句LOCATION参数指定，如果没有指定则Hive将在HDFS上的/user/hive/warehouse文件夹下以外部表的表名创建一个文件夹，并将属于这个表的数据存放在这里</td>
</tr>
</tbody>
</table>
<p><strong>Hive join原理</strong></p>
<p>Reduce Join</p>
<p>Map阶段：为了构造Key-Value型数据，以on 条件中的字段为 key（on中有多个字段，则将其组合后作为key），以select 或者 where 中用到的字段为value；同时在 value 中还会包含表的 Tag 信息，用于标明此 value 对应哪个表。</p>
<p>Shuffle 阶段：将数据根据Key进行hash，传送到不同的reducer中，相同Key的数据在同一个reducer中（同一个reducer中的key却不一定相同）。</p>
<p>Reduce阶段：对相同Key值的这些数据，根据select语句进行处理，把来自不同表的数据进行组合。</p>
<p><img src="/2021/07/24/%E9%9D%A2%E8%AF%95_Hive/image-20210724120435658.png" alt="image-20210724120435658" style="zoom:67%;"></p>
<p>Map Join</p>
<p>适用于大表连接小表的场景。</p>
<p>前提：小表在每个mapper上有完整的拷贝，常使用Distributed Cache将小表分发到各个节点上</p>
<p>Map Join把小表全部读入内存中，在Map阶段直接用大表的部分数据和内存中小表数据做连接，直接输出结果，没有shuffle和reduce的阶段，因此有多少个mapper就有多少个结果文件。</p>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2021/07/29/%E5%A4%A7%E6%95%B0%E6%8D%AEZookeeper%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<p>Zookeeper（分布式协调服务）帮助Hadoop解决的问题</p>
<a id="more"></a>
<p>主要是为了实现高可用机制</p>
<p>首先所有的NN在启动的时候会竞争写一个zookeeper上的临时节点，所有的standby nn向这个节点注册一个观察器，当这个节点出现异常或挂掉时，起在zookeeper上创建的临时节点也会被删除，standy的nn节点检测到该节点发生变化时，会重新发起竞争，直到产生一个Active节点。</p>
<p>写入高可用。 集群中的写入操作都是先通知Leader，Leader再通知Follower写入，实际上当超过一半的机器写入成功后，就认为写入成功了，所以就算有些机器宕机，写入也是成功的。</p>
<p>读取高可用。 zookeeperk客户端读取数据时，可以读取集群中的任何一个机器。所以部分机器的宕机并不影响读取。 zookeeper服务器必须是奇数台，因为zookeeper有选举制度，角色有：领导者、跟随者、观察者，选举的目的是保证集群中数据的一致性。</p>
<p>https://blog.csdn.net/eric_sunah/article/details/46610167</p>
<p>https://www.jianshu.com/p/87976ec5f45f</p>
<p>kafka</p>
<p>分布式的发布-订阅消息系统。</p>
<p>Kafka可以将主题划分为多个分区（Partition），会根据分区规则选择把消息存储到哪个分区中，如果分区规则设置的合理，那么所有的消息将会被均匀的分布到不同的分区中，这样就实现了负载均衡 和水平扩展。</p>
<p>一个分区可以有多个副本，这些副本保存在不同的broker上。每个分区的副本中都会有一个作为 Leader。当一个broker失败时，Leader在这台broker上的分区都会变得不可用，kafka会自动移除 Leader，再其他副本中选一个作为新的Leader。</p>
<p>消息同步：先写入到leader中，follower再同步。Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW（即offset）并且向Producer发送ACK。</p>
<p>数据库与数据仓库的区别</p>
<p>数据库是面向事务型，用户较为关心操作的响应时间。数据仓库是面向分析型的，一般针对历史数据进行分析，允许一定的冗余存在便于挖掘数据。</p>
<p>HIVE SQL与SQL的区别</p>
<p>HIVE就是利用SQL语句在HDFS上执行map reduce操作。</p>
<p>4.Hive不支持将数据插入现有的表或分区中 Hive仅支持覆盖重写整个表。 insert overwrite 表 （重写覆盖）</p>
<p>Hive不支持等值连接：</p>
<p>SQL中内关联可以这样写： select * from a , b where a.key = b.key Hive中应该这样写： select * from a join b on a.key = b.key</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ</title>
    <url>/2021/07/29/%E9%9D%A2%E8%AF%95_MQ/</url>
    <content><![CDATA[<h4 id="总结">总结</h4>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th>问题</th>
<th>解答</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>为什么用</td>
<td>缓冲、解耦、冗余、健壮与异步</td>
</tr>
<tr class="even">
<td>可靠性</td>
<td>partition向producer发送ack</td>
</tr>
<tr class="odd">
<td>ack机制</td>
<td>接收没写入、leader落盘、全部落盘</td>
</tr>
<tr class="even">
<td>Exactly Once</td>
<td>At Least Once（数据重复） + 幂等性（仅持久化一条） = Exactly Once（数据不重复且不丢失）；对&lt; PID, Partition, SeqNumber&gt;主键做缓存</td>
</tr>
<tr class="odd">
<td>速度快的原因</td>
<td>磁盘顺序写入、数据分段以及段内索引、内存文件映射</td>
</tr>
<tr class="even">
<td>副本同步策略</td>
<td>全部follower完成同步，才发送ack，需要的副本数较少（n+1）</td>
</tr>
<tr class="odd">
<td>ISR</td>
<td>意为和leader保持同步的follower集合，未定期发送ack者被踢出去</td>
</tr>
<tr class="even">
<td>故障处理</td>
<td>HW之前的数据才会对Consumer可见，所以出现故障的时候，Consumer从HW处继续消费消息</td>
</tr>
<tr class="odd">
<td>读写分离</td>
<td>延时敏感应用，数据一致性问题和延迟问题（经过磁盘）</td>
</tr>
<tr class="even">
<td>消费者分区分配策略</td>
<td>range（分区/线程）RoundRobinAssignor（排序加轮询）StickyAssignor（分区数最多差1，与上次分配相同）</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h4 id="为什么要使用-kafka">为什么要使用 kafka？</h4>
<p>1、缓冲：上游数据流量暴增，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的处理速度处理数据。</p>
<p>2、解耦：解耦重要业务，提高扩展能力（需求不确定的时候）</p>
<p>3、冗余：将一个消息提供给多个topic，被不同业务使用</p>
<p>4、健壮：缓存消息，防止消费者挂掉丢失消息</p>
<p>5、异步：缓存消息，需要的时候再处理消息</p>
<h4 id="kafka的数据可靠性怎么保证">kafka的数据可靠性怎么保证</h4>
<p>ack机制。</p>
<p>为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p>
<h4 id="ack应答机制">ack应答机制</h4>
<p>Kafka提供三种可靠性级别，根据对可靠性和延迟的要求进行权衡。acks参数配置：</p>
<ul>
<li>0：producer不等待broker的ack，<strong>最低的延迟</strong>，<strong>broker一接收到还没有写入磁盘</strong>就已经返回，当broker故障时有可能丢失数据。</li>
<li>1：producer等待broker的ack，<strong>partition的leader落盘成功后返回ack</strong>，如果在follower同步成功之前leader故障，那么follower将会丢失数据。</li>
<li>-1（all）：producer等待broker的ack，<strong>partition的leader和follower全部落盘成功后才返回ack</strong>。但是如果在follower同步完成后，broker发送ack之前，leader发生故障，那么会造成数据重复。</li>
</ul>
<h4 id="exactly-once语义pidseq">Exactly Once语义（&lt;PID,Seq&gt;）</h4>
<p>将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即At Least Once语义。将服务器ACK级别设置为0，可以保证生产者每条消息只会被发送一次，即At Most Once语义。</p>
<p>At Least Once可以保证数据不丢失，但是不能保证数据不重复；</p>
<p>At Most Once可以保证数据不重复，但是不能保证数据不丢失。</p>
<blockquote>
<p>但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即Exactly Once语义。在0.11版本以前的Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p>
</blockquote>
<p>0.11版本的Kafka，引入了一项重大特性：幂等性。</p>
<p><strong>幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条</strong>。开启幂等性enable.idempotence=true。</p>
<p>因此，At Least Once（数据重复） + 幂等性（仅持久化一条） = Exactly Once（数据不重复且不丢失）</p>
<p><strong>Exactly Once的语义就是保证Producer的每条消息不会丢失且仅被持久化一条。</strong></p>
<p>Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会<strong>对&lt; PID, Partition, SeqNumber&gt;做缓存</strong>，当具有相同主键的消息提交时，Broker只会持久化一条。</p>
<p>但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once。</p>
<blockquote>
<p>流式计算中怎么Exactly Once语义？以flink为例</p>
<p>1、souce：</p>
<p>使用执行ExactlyOnce的数据源，比如kafka等。</p>
<p>内部使用FlinkKafakConsumer，并开启CheckPoint，<strong>偏移量会保存到StateBackend中</strong>，并且默认会将偏移量写入到topic中去，即 _ consumer_offsets Flink设置CheckepointingModel.EXACTLY_ONCE</p>
<p>2、sink</p>
<p>存储系统支持幂等性：如Redis,Hbase,ES等</p>
<p>存储系统不支持幂等性：需要支持事务(预写式日志或者两阶段提交)，两阶段提交可参考Flink集成的kafka sink的实现。</p>
</blockquote>
<h4 id="kafka为什么速度会快">Kafka为什么速度会快？</h4>
<p>kafka使用的是磁盘存储。</p>
<p>1、顺序写入：因为硬盘每次读写都会先寻址再写入，其中寻址是是耗时的。所以硬盘在顺序I/O的时候能够减少耗时。因此为了提高读写硬盘的速度，Kafka就是使用顺序I/O。</p>
<p>2、高效文件存储设计：<strong>数据文件分段以及每个段内建立索引</strong>。</p>
<blockquote>
<p>数据文件分段：Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</p>
<p>比如有100条Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文件里面，数据文件以该段中 小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段中。</p>
<p>建立索引：为了避免顺序扫描才能找到对应offset的Message，进一步提高查找的效率，Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index</p>
</blockquote>
<p>3、Memory Mapped Files（内存映射文件）：64位操作系统中一般可以表示20G的数据文件，它的工作原理是<strong>直接利用操作系统的Page来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上</strong>。</p>
<h4 id="副本数据同步策略">副本数据同步策略</h4>
<p>副本数包含leader和follower，全部follower完成同步才发送ack。</p>
<blockquote>
<p>Producer 只将该消息发送到该 Partition 的Leader。Leader 会将该消息写入其本地 Log。每个 Follower都从 Leader pull 数据。这种方式上，Follower 存储的数据顺序与 Leader 保持一致。Follower 在收到该消息并写入其Log 后，向 Leader 发送 ACK。一旦 Leader 收到了 ISR 中的所有 Replica 的 ACK，该消息就被认为已经 commit 了，Leader 将增加 HW(HighWatermark)并且向 Producer 发送ACK。</p>
</blockquote>
<p>有两个方案对比如下：</p>
<p>半数以上follower完成同步，就发送ack（优点：延迟低；缺点：选举新的leader时，容忍n台节点的故障，需要2n+1个副本）</p>
<p>全部follower完成同步，才发送ack（优点：选举新的leader时，容忍n台节点的故障，需要n+1个副本；缺点：延迟高）</p>
<p>kafka采用零拷贝技术优化数据传输，因此网络延迟对kafka的影响较小，所以选择全部follower完成同步，才发送ack。</p>
<blockquote>
<p>https://blog.csdn.net/qq_43437122/article/details/108359748</p>
<p>假设有5台机器，现在存在一个topic为A，它有一个分区。5台机器最多容忍4台机器故障（如果全故障那你的Kafka Cluster不就凉了?），现在假设有4台机器故障，只有1台机器健康。</p>
<p>全同步策略：由于是全部follower完成同步，才发送ack，所以topic A 分区下的5个副本（leader + fllower）分别位于这5台机器上，那么那台没有故障的机器（也就是broker）的副本（fllower，假设此时leader故障）就会成为leader继续工作。也即是全同步策略下，容忍n台节点故障，需要n+1个副本。</p>
<p>半数同步策略：现在是4（n）台机器发生了故障，副本数为5（n+1），由于是半数机制，所以topic A 分区下的副本数只要存在3个（leader + flllower）broker就会发送ack。可是此时四台节点故障，<strong>Kafka集群里面只有三个副本，这就不能保证没故障的节点存在topic A 分区下的副本</strong>。副本数应设置为9个（2n+1）。如果副本数为9，topic A分区下副本数量为5时broker才会发送ack， 这<strong>就保证了每个节点都存在topic A 分区下的一个副本</strong>，此时如果4台节点故障（假设leader故障），那台没故障的机器就会成为leader继续工作。也即是半同步策略下，容忍n台节点故障，需要2n+1个副本。</p>
</blockquote>
<h4 id="isr">ISR</h4>
<p>in-sync replica set (ISR)，意为和leader保持同步的follower集合。</p>
<blockquote>
<p>问题产生原因：如果采用全部完成同步，才发送ack的副本的同步策略的话，若所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？</p>
</blockquote>
<p>当ISR中的follower完成数据的同步之后，leader就会给follower发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定。Leader发生故障之后，就会从ISR中选举新的leader。</p>
<h4 id="故障处理">故障处理</h4>
<p>LEO（Log End Offset）：指的是每个副本最大的offset。</p>
<p>HW（High Watermark）：指的是消费者能见到的最大的offset，ISR队列中最小的LEO。</p>
<p>HW之前的数据才会对Consumer可见，所以出现故障的时候，Consumer从HW处继续消费消息，就不会产生重复消费消息的问题。</p>
<p><img src="/2021/07/29/%E9%9D%A2%E8%AF%95_MQ/image-20210729080554829.png" alt="image-20210729080554829" style="zoom: 50%;"></p>
<h4 id="kafka事务">kafka事务</h4>
<p>Kafka从0.11版本开始引入了事务支持。事务可以保证Kafka在Exactly Once语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p>
<ul>
<li>Producer端事务</li>
</ul>
<p>为了实现跨分区跨会话的事务，需要引入一个<strong>全局唯一的Transaction ID，并将Producer获得的PID和Transaction ID绑定</strong>。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的PID。</p>
<p>为了管理Transaction，Kafka引入了一个新的组件Transaction Coordinator。Producer就是通过和Transaction Coordinator交互获得Transaction ID对应的任务状态。Transaction Coordinator还负责将事务所有写入Kafka的一个内部Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p>
<ul>
<li>Consumer端事务</li>
</ul>
<p>对于Consumer而言，事务的保证就会相对较弱，尤其无法保证Commit的信息被精确消费。这是由于Consumer可以通过offset访问任意信息，而且不同的Segment File生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p>
<h4 id="kafka为什么不支持读写分离"><strong>Kafka为什么不支持读写分离？</strong></h4>
<p>在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。</p>
<p>Kafka 并不支持主写从读，因为主写从读有 2 个很明显的缺点:</p>
<p>1、数据一致性问题：数据从主节点转到从节点必然会有一个<strong>延时的时间窗口</strong>，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。</p>
<p>2、延时问题：类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经历 网络→主节点内存→网络→从节点内存 这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历 网络→主节点内存→<strong>主节点磁盘</strong>→网络→从节 点内存→从节点磁盘 这几个阶段。</p>
<p>对延时敏感的应用而言，主写从读的功能并不太适用。</p>
<h4 id="kafka的消费分区分配策略负载均衡">kafka的消费分区分配策略（负载均衡）</h4>
<p>一个consumer group中有多个consumer，一个topic有多个partition，所以必然会涉及到partition的分配问题，即确定哪个partition由哪个consumer来消费。</p>
<p>Kafka有三种分配策略，一是RoundRobin，一是Range。高版本还有一个StickyAssignor策略。</p>
<p>将分区的所有权从一个消费者移到另一个消费者称为重新平衡（rebalance）。当以下事件（消费者增加或减少）发生时，Kafka 将会进行一次分区分配：</p>
<ul>
<li><p>同一个 Consumer Group 内新增消费者。</p></li>
<li><p>消费者离开当前所属的Consumer Group，包括shuts down或crashes。</p></li>
</ul>
<p><strong>Range</strong></p>
<p>用<strong>partition数除以消费者线程的总数</strong>来决定每个消费者线程消费几个partition，每一个消费者都能获得尽可能多的分区。</p>
<p>首先对同一个Topic里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。然后用Partitions分区的个数除以消费者线程的总数来决定每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。</p>
<p>假设n=分区数/消费者数量，m=分区数%消费者数量，那么前m个消费者每个分配n+1个分区，后面的（消费者数量-m）个消费者每个分配n个分区。</p>
<blockquote>
<p>假如有10个分区，3个消费者线程，把分区按照序号排列</p>
<p>0，1，2，3，4，5，6，7，8，9</p>
<p>消费者线程为</p>
<p>C1-0，C2-0，C2-1</p>
<p>在例子里面，有10个分区，3个消费者线程，10/3 = 3，而且除除不尽，那么消费者线程C1-0将会多消费一个分区，所以最后分区分配的结果看起来是这样的：</p>
<p>C1-0：0，1，2，3</p>
<p>C2-0：4，5，6</p>
<p>C2-1：7，8，9</p>
<p>假如有两个主题T1,T2，分别有10个分区，最后的分配结果将会是这样：</p>
<p>C1-0：T1（0，1，2，3） T2（0，1，2，3）</p>
<p>C2-0：T1（4，5，6） T2（4，5，6）</p>
<p>C2-1：T1（7，8，9） T2（7，8，9）</p>
</blockquote>
<p><strong>RoundRobinAssignor</strong></p>
<p>将消费组内所有消费者以及消费者所订阅的所有topic的partition按照字典序排序，然后<strong>通过轮询方式</strong>逐个将分区以此分配给每个消费者，即先排序后轮询分配。</p>
<p>前提是：</p>
<p>1、同一个消费者组里面的所有消费者的num.streams（线程数）必须相等。</p>
<p>2、每个消费者订阅的主题必须相同。</p>
<blockquote>
<p>假如按照 hashCode 排序完的topic-partitions组依次为</p>
<p>T1-5, T1-3, T1-0, T1-8, T1-2, T1-1, T1-4, T1-7, T1-6, T1-9</p>
<p>我们的消费者线程排序为</p>
<p>C1-0, C1-1, C2-0, C2-1</p>
<p>最后分区分配的结果为轮询分配的结果：</p>
<p>C1-0 将消费 T1-5, T1-2, T1-6 分区</p>
<p>C1-1 将消费 T1-3, T1-1, T1-9 分区</p>
<p>C2-0 将消费 T1-0, T1-4 分区</p>
<p>C2-1 将消费 T1-8, T1-7 分区</p>
</blockquote>
<p><strong>StickyAssignor</strong></p>
<p>Kafka从0.11.x版本开始引入这种分配策略，他主要解决当某个消费者离开的时候再分配的问题。</p>
<p>1、分区的分配要尽可能的均匀，分配给消费者者的主题分区数最多相差一个</p>
<p>2、<strong>分区的分配尽可能的与上次分配的保持相同</strong></p>
<p>3、当两者发生冲突时，第一个目标优先于第二个目标。</p>
<blockquote>
<p>原因是：</p>
<p>如果发生分区重分配，那么对于同一个分区而言有可能之前的消费者和新指派的消费者不是同一个，对于之前消费者进行到一半的处理还要在新指派的消费者中再次复现一遍，这显然很浪费系统资源。StickyAssignor策略如同其名称中的“sticky”一样，让分配策略具备一定的“粘性”，尽可能地让前后两次分配相同，进而减少系统资源的损耗以及其它异常情况的发生。</p>
</blockquote>
<p>所有消费者订阅所有主题的案例：</p>
<blockquote>
<p>假设消费组内有3个消费者</p>
<p>C0、C1、C2</p>
<p>它们都订阅了4个主题：</p>
<p>t0、t1、t2、t3</p>
<p>并且每个主题有2个分区，也就是说整个消费组订阅了</p>
<p>t0p0、t0p1、t1p0、t1p1、t2p0、t2p1、t3p0、t3p1这8个分区</p>
<p>最终的分配结果如下：</p>
<p>消费者C0：t0p0、t1p1、t3p0</p>
<p>消费者C1：t0p1、t2p0、t3p1</p>
<p>消费者C2：t1p0、t2p1</p>
<p>这样初看上去似乎与采用RoundRobinAssignor策略所分配的结果相同</p>
<p>此时<strong>假设消费者C1脱离了消费组</strong>，那么消费组就会执行再平衡操作，进而消费分区会重新分配。如果采用RoundRobinAssignor策略，那么此时的分配结果如下：</p>
<p>消费者C0：t0p0、t1p0、t2p0、t3p0</p>
<p>消费者C2：t0p1、t1p1、t2p1、t3p1</p>
<p>如分配结果所示，RoundRobinAssignor策略会按照消费者C0和C2进行重新轮询分配。而如果此时使用的是StickyAssignor策略，那么分配结果为：</p>
<p>消费者C0：t0p0、t1p1、t3p0、t2p0</p>
<p>消费者C2：t1p0、t2p1、t0p1、t3p1</p>
<p>可以看到分配结果中<strong>保留了上一次分配中对于消费者C0和C2的所有分配结果，并将原来消费者C1的“负担”分配给了剩余的两个消费者C0和C2</strong>，最终C0和C2的分配还保持了均衡。</p>
</blockquote>
<p>消费者订阅不同主题的案例：</p>
<blockquote>
<p>消费组内有3个消费者：</p>
<p>C0、C1、C2</p>
<p>集群中有3个主题：</p>
<p>t0、t1、t2</p>
<p>这3个主题分别有</p>
<p>1、2、3个分区</p>
<p>也就是说集群中有</p>
<p>t0p0、t1p0、t1p1、t2p0、t2p1、t2p2这6个分区</p>
<p>消费者C0订阅了主题t0</p>
<p>消费者C1订阅了主题t0和t1</p>
<p>消费者C2订阅了主题t0、t1和t2</p>
<p>如果此时采用RoundRobinAssignor策略：</p>
<p>消费者C0：t0p0</p>
<p>消费者C1：t1p0</p>
<p>消费者C2：t1p1、t2p0、t2p1、t2p2</p>
<p>如果此时采用的是StickyAssignor策略：</p>
<p>消费者C0：t0p0</p>
<p>消费者C1：t1p0、t1p1 （每个消费者分区数最多相差1个，C1和C2都订t1，因此不能都分给C2）</p>
<p>消费者C2：t2p0、t2p1、t2p2</p>
<p>此时消费者C0脱离了消费组，那么RoundRobinAssignor策略的分配结果为：</p>
<p>消费者C1：t0p0、t1p1</p>
<p>消费者C2：t1p0、t2p0、t2p1、t2p2</p>
<p>StickyAssignor策略，那么分配结果为：</p>
<p>消费者C1：t1p0、t1p1、t0p0</p>
<p>消费者C2：t2p0、t2p1、t2p2</p>
<p>可以看到StickyAssignor策略保留了消费者C1和C2中原有的5个分区的分配：</p>
<p>t1p0、t1p1、t2p0、t2p1、t2p2。</p>
</blockquote>
<h4 id="参考资料">参考资料</h4>
<p>https://mp.weixin.qq.com/s/ftkzB36cZ5b-D1go_87fXQ</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中类型相互转换</title>
    <url>/2021/04/01/Java_%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="char转int">char转int</h4>
<p>在Java中用2个字节，即16位，来表示一个char。</p>
<a id="more"></a>
<ul>
<li><p>当char为数字时</p>
<p>即'0'、'1'、'2'、'3'...、'9'时，则直接减去'0'可以得到对应的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> nine = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="string">&#x27;9&#x27;</span> - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//num即得到9</span></span><br></pre></td></tr></table></figure></li>
<li><p>当char为其他字符时</p>
<p>使用强制类型转换即可获得该字符表示的ASCII 编码。</p>
<p>字符<strong>0-9</strong>的ASCII码：48-57；</p>
<p>大写字母<strong>A-Z</strong>的ASCII码为：65-90；</p>
<p>小写字母<strong>a-z</strong>的ASCII码为：97-122；</p>
<p><strong>空字符</strong>的ASCII码为0；</p>
<p><strong>换行符</strong>的ASCII码为10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> tmp = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)tmp; <span class="comment">//num此时为&#x27;a&#x27;的ASCII 编码97</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="int转char">int转char</h4>
<ul>
<li><p>当int为两位以上的数字时，使用强制类型转换将变成该数字代表的ASCII码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">97</span>;</span><br><span class="line"><span class="keyword">char</span> ca = (<span class="keyword">char</span>)num; <span class="comment">//ca此时就代表了小写字母&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>当int为0到9的数字时，利用ASCII码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">char</span> ca = (<span class="keyword">char</span>)(num+<span class="number">48</span>) <span class="comment">//ca此时就代表了数字&#x27;9&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>先将int转为String，再转成char，可以将数字拆开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">4596</span>;</span><br><span class="line">String str = String.valueOf(num);</span><br><span class="line"><span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">	System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5 9 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="char转string">char转String</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = String.valueOf(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//char数组转String</span></span><br><span class="line"><span class="keyword">char</span>[] s=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">String st=String.valueOf(s);</span><br></pre></td></tr></table></figure>
<h4 id="string转char">String转char</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] array = str.toCharArray();</span><br></pre></td></tr></table></figure>
<h4 id="string转int">String转int</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;6666&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num = Integer.valueOf(str);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当str非数字时报出运行时异常</span></span><br><span class="line"><span class="comment">java.lang.NumberFormatException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stirng数组转int数组，利用Java 8中的stream方法</span></span><br><span class="line">String[] strings = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] array = Arrays.stream(strings).mapToInt(Integer::parseInt).toArray();</span><br></pre></td></tr></table></figure>
<h4 id="int转string">int转String</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">6666</span>;</span><br><span class="line">String str = String.valueOf(num);</span><br></pre></td></tr></table></figure>
<h4 id="string转arraylistinteger">String[]转ArrayList&lt;Integer&gt;</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//String数组先转int[]</span></span><br><span class="line"><span class="keyword">int</span>[] arr = Arrays.stream(strings).mapToInt(Integer::parseInt).toArray();</span><br><span class="line"><span class="comment">//int[]转ArrayList&lt;Integer&gt;</span></span><br><span class="line">ArrayList&lt;Integer&gt; collect = (ArrayList&lt;Integer&gt;) Arrays.stream(arr).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中Comparable和Comparator</title>
    <url>/2021/08/01/Java_ComparableAndComparator/</url>
    <content><![CDATA[<p>Java中Comparable和Comparator两个<strong>接口</strong>的比较。</p>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 45%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Comparable</th>
<th>Comparator</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>作用</td>
<td>可以让实现它的类的对象进行比较大小</td>
<td>在类对象的外部制定排序规则，然后作为排序策略参数传递给某些类的对象的构造函数，实现比较大小</td>
</tr>
<tr class="even">
<td>位置</td>
<td>java.lang 包</td>
<td>java.util 包</td>
</tr>
<tr class="odd">
<td>接口中的方法</td>
<td>只有一个方法 compareTo()</td>
<td>JDK 8 以前只有两个方法compare()和equals()，8以后增加多个方法</td>
</tr>
<tr class="even">
<td>使用</td>
<td>public class Test implements Comparable{} 并重写其中的compareTo()方法</td>
<td>数组工具类和集合工具类中提供的工具方法sort方法都给出了含有Comparator接口的重载方法。</td>
</tr>
<tr class="odd">
<td>排序规则</td>
<td>compareTo 方法的返回值有三种情况：e1.compareTo(e2) &gt; 0 即 e1 &gt; e2<br>e1.compareTo(e2) = 0 即 e1 = e2<br>e1.compareTo(e2) &lt; 0 即 e1 &lt; e2</td>
<td>compare函数返回正数就交换传入参数的位置，否则（负数或0）就不交换两者的位置。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="comparable">Comparable</h3>
<p>使用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//名字与价格</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(String name, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当向 TreeSet 中添加 BookBean 时，会调用这个方法进行排序</span></span><br><span class="line"><span class="comment">     * e1.compareTo(e2) &gt; 0 即 e1 &gt; e2</span></span><br><span class="line"><span class="comment">     * e1.compareTo(e2) = 0 即 e1 = e2</span></span><br><span class="line"><span class="comment">     * e1.compareTo(e2) &lt; 0 即 e1 &lt; e2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> another</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object another)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (another <span class="keyword">instanceof</span> Solution) &#123;</span><br><span class="line">            Solution anotherBook = (Solution) another;</span><br><span class="line">            <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比如这里按照书价排序</span></span><br><span class="line">            result = getCount() - anotherBook.getCount();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//或者按照 String 的比较顺序</span></span><br><span class="line">            <span class="comment">//result = getName().compareTo(anotherBook.getName());</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;   <span class="comment">//当书价一致时，再对比书名。 保证所有属性比较一遍</span></span><br><span class="line">                result = getName().compareTo(anotherBook.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一样就返回 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Solution)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Solution bean = (Solution) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getCount() != bean.getCount()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> getName().equals(bean.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 hashCode 的计算方法</span></span><br><span class="line"><span class="comment">     * 根据所有属性进行 迭代计算，避免重复</span></span><br><span class="line"><span class="comment">     * 计算 hashCode 时 计算因子 31 见得很多，是一个质数，不能再被除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用 String 的 hashCode(), 唯一表示一个字符串内容</span></span><br><span class="line">        <span class="keyword">int</span> result = getName().hashCode();</span><br><span class="line">        <span class="comment">//乘以 31, 再加上 count</span></span><br><span class="line">        result = <span class="number">31</span> * result + getCount();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BookBean&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, count=&quot;</span> + count +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="comparator">Comparator</h3>
<p>compare函数返回正数就交换传入参数的位置，否则（负数或0）就不交换两者的位置。</p>
<p>因此，对于compare(Object o1, Object o2)来说，如果写成 return o1 - o2 则为升序，反之为降序。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Character&gt; letters = <span class="keyword">new</span> ArrayList&lt;&gt;(str.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">//将英文字母先排序好</span></span><br><span class="line"><span class="comment">//此处的意思是，o1 - o2如果是负数，则o1&lt;o2，不交换两者的位置，小的数o1依旧排在前面，所以这样是升序</span></span><br><span class="line"><span class="comment">//也是默认的</span></span><br><span class="line">letters.sort(<span class="keyword">new</span> Comparator&lt;Character&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Character o1, Character o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Character.toLowerCase(o1) - Character.toLowerCase(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处的意思是，o2 - o1如果是负数，则o2&lt;o1，不交换两者的位置，小的数o2依旧排在后面，所以这样是降序</span></span><br><span class="line"><span class="comment">//o2 - o1如果是正数，则o2&gt;o1，交换两者的位置，大的数o2旧排在前面，所以这样是降序</span></span><br><span class="line">letters.sort(<span class="keyword">new</span> Comparator&lt;Character&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Character o1, Character o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Character.toLowerCase(o2) - Character.toLowerCase(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>数组工具类和集合工具类中提供的工具方法sort方法都给出了含有Comparator接口的重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(T[],Comparator&lt;? <span class="keyword">super</span> T&gt; c);</span><br><span class="line">Collections.sort(List&lt;T&gt; list,Comparator&lt;? <span class="keyword">super</span> T&gt; c);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>海量小文件问题</title>
    <url>/2021/08/02/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E5%B0%8F%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<table>
<colgroup>
<col style="width: 5%">
<col style="width: 35%">
<col style="width: 23%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Hadoop</th>
<th>Hive</th>
<th>Spark</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>小文件来源</td>
<td>数据源有大量小文件；reducer太多，每个都生成小文件</td>
<td>Hive分区表的每个分区数据量很小</td>
<td>sparkstreaming在每个batch结束后都会重新打开一个新的文件作为输出，因此每个batch下的每个分区生成大量小文件</td>
</tr>
<tr class="even">
<td>解决方案</td>
<td>1、在数据源处就合并小文件</td>
<td>1、配置map前合并和reduce后合并小文件</td>
<td>1、增加batch大小</td>
</tr>
<tr class="odd">
<td></td>
<td>2、定期运行一个MR任务，读取某一个文件夹中的所有小文件，并通过减少reduce的数量将它们重写为较少数量的大文件</td>
<td>2、使用HAR归档文件</td>
<td>2、通过coalesce和repartition减少分区数量</td>
</tr>
<tr class="even">
<td></td>
<td>3、SequenceFile将数据以KV的形式序列化到文件中，MR任务只需要为每个block启动一个map任务，并且保留文件名</td>
<td>3、减少分区表中的分区数量</td>
<td>3、自定义合并脚本</td>
</tr>
<tr class="odd">
<td></td>
<td>4、使用Hbase进行数据存储，将数据抽取过程从生成大量小HDFS文件更改为以逐条记录写入到HBase表</td>
<td>4、数据压缩，通过序列化存储方式存储数据</td>
<td>4、通过foreach输出类追加小文件</td>
</tr>
<tr class="even">
<td></td>
<td>5、CombineFileInputFormat是Hadoop提供的抽象类，在MR读取时合并小文件。合并的文件不会持久化到磁盘</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>6、自己编写特定的程序通过输出类来追加到现有的小文件</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>7、NameNode中通过Hadoop Archive(HAR)和联邦机制解决内存不足的问题</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="问题概述">问题概述</h3>
<p>海量小文件（LSOF，lots of small files）问题，使得分布式系统在在元数据管理、存储效率、访问的性能等方面面临巨大的挑战。</p>
<p>存储磁盘最适合顺序的大文件I/O读写模式，非常不适合随机的小文件I/O读写模式（顺序读写，避免寻址），这是磁盘文件系统在海量小文件应用下性能表现不佳的根本原因。磁盘文件系统的设计大多都侧重于大文件，包括元数据管理、数据布局和I/O访问流程，另外VFS系统调用机制也非常不利于海量小文件，这些软件层面的机制和实现加剧了小文件读写的性能问题。</p>
<p>Hadoop中的海量小文件问题，核心问题是它需要把文件meta信息缓存在内存里，这个内存只能是单机的，所以变成了一个很大的瓶颈。虽然后面HDFS一直尝试解决这个问题，比如引入联邦制等，但是也变相的引入了复杂性。</p>
<h3 id="存储系统性能衡量">存储系统性能衡量</h3>
<p>IOPS (Input/Output Per Second) 即每秒的输入输出量 (或读写次数) ，是衡量存储系统性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，一般以每秒处理的I/O请求数量为单位，I/O请求通常为读或写数据操作请求。随机读写频繁的应用，如OLTP(OnlineTransaction Processing)，IOPS是关键衡量指标。</p>
<p>数据吞吐量(Throughput)，指单位时间内可以成功传输的数据数量。对于大量顺序读写的应用，如VOD(VideoOn Demand)，则更关注吞吐量指标。</p>
<p>对于LOSF而言，IOPS/OPS是关键性能衡量指标。</p>
<h3 id="小文件过多引起的问题">小文件过多引起的问题</h3>
<h4 id="元数据管理低效"><strong>元数据管理低效</strong></h4>
<p>磁盘文件系统中，目录项(dentry)、索引节点(inode)和数据(data)保存在存储介质的不同位置上。因此，访问一个文件需要经历至少3次独立的访问。这样，并发的小文件访问就转变成了大量的随机访问，而这种访问对于广泛使用的磁盘来说是非常低效的。</p>
<p>同时，文件系统通常采用Hash树、B+树或B*树来组织和索引目录，这种方法不能在数以亿计的大目录中很好的扩展，海量目录下检索效率会明显下降。正是由于单个目录元数据组织能力的低效，文件系统使用者通常被鼓励把文件分散在多层次的目录中以提高性能。然而，这种方法会进一步加大路径查询的开销。</p>
<h4 id="数据布局低效"><strong>数据布局低效</strong></h4>
<p>磁盘文件系统使用块来组织磁盘数据，并在inode中使用多级指针或hash树来索引文件数据块。数据块通常比较小，一般为1KB、2KB或4KB。当文件需要存储数据时，文件系统根据预定的策略分配数据块，分配策略会综合考虑数据局部性、存储空间利用效率等因素，通常会优先考虑大文件I/O带宽。</p>
<p>对于大文件，数据块会尽量进行连续分配，具有比较好的空间局部性。</p>
<p>对于小文件，尤其是大文件和小文件混合存储或者经过大量删除和修改后，数据块分配的随机性会进一步加剧，数据块可能零散分布在磁盘上的不同位置，并且会造成<strong>大量的磁盘碎片</strong>(包括内部碎片和外部碎片)，不仅造成<strong>访问性能下降</strong>（寻址随机访问），还导致大量磁盘空间浪费。</p>
<p>对于特别小的小文件，比如小于4KB，<strong>inode与数据分开存储</strong>，这种数据布局也没有充分利用空间局部性，导致随机I/O访问，目前已经有文件系统实现了data in inode。</p>
<h4 id="io访问流程复杂">I/O访问流程复杂</h4>
<p>Linux等操作系统采用VFS或类似机制来抽象文件系统的实现，提供标准统一访问接口和流程，它提供通用的Cache机制，处理文件系统相关的所有系统调用，与具体文件系统和其他内核组件(如内存管理)交互。VFS可以屏蔽底层文件系统实现细节，简化文件系统设计，实现对不同文件系统支持的扩展。</p>
<p>VFS通用模型中有涉及四种数据类型：超级块对象(superblock object)、索引结点对象(inode object)、文件对象(file object)和目录项对象(dentry object)，进程在进行I/O访问过程中需要频繁与它们交互(如下图所示)。</p>
<p><img src="/2021/08/02/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E5%B0%8F%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/image-20210801234410484.png" alt="image-20210801234410484" style="zoom:67%;"></p>
<p>对于小文件的I/O访问过程，读写数据量比较小，这些流程太过复杂，系统调用开销太大，尤其是其中的<strong>open()操作占用了大部分的操作时间</strong>。当面对海量小文件并发访问，<strong>读写之前的准备工作</strong>占用了绝大部分系统时间，有效磁盘服务时间非常低，从而导致小I/O性能极度低下。</p>
<p>对于大多数分布式文件系统而言，通常将元数据与数据两者独立开来，即控制流与数据流进行分离，从而获得更高的系统扩展性和I/O并发性。数据和I/O访问负载被分散到多个物理独立的存储节点，从而实现系统的高扩展性和高性能，每个节点使用磁盘文件系统管理数据，比如XFS、EXT4、XFS等。</p>
<p>因此，相对于磁盘文件系统而言，每个节点的小文件问题是相同的。由于分布式的架构，分布式文件系统中的网络通信、元数据服务MDC、Cache管理、数据布局和I/O访问模式等都会对IOPS/OPS性能产生影响，进一步加剧小文件问题。</p>
<h3 id="解决方案小文件合并">解决方案：小文件合并</h3>
<p>小文件合并存储是目前优化LOSF问题最为成功的策略，已经被包括Facebook Haystack和淘宝TFS在内多个分布式存储系统采用。它通过<strong>多个逻辑文件共享同一个物理文件</strong>，将多个小文件合并存储到一个大文件中，实现高效的小文件存储。</p>
<p>（1）首先减少了大量元数据，提高了元数据的检索和查询效率，降低了文件读写的 I/O 操作延时。</p>
<p>（2）其次将可能连续访问的小文件一同合并存储，增加了文件之间的局部性，将原本小文件间的随机访问变为了顺序访问，大大提高了性能。</p>
<p>（3）同时，合并存储能够有效的减少小文件存储时所产生的磁盘碎片问题，提高了磁盘的利用率。</p>
<p>（4）最后，合并之后小文件的访问流程也有了很大的变化，由原来许多的open操作转变为了seek操作，定位到大文件具体的位置即可。</p>
<p>小文件合并存储，本质上是大文件加上索引文件，相当于一个微型文件系统。这种机制对于WORM(Write Once Read Many)模式的分布式存储系统非常适合，而不适合允许改写和删除的存储系统。（1）因为文件改写和删除操作，<strong>会造成大文件内部的碎片空洞</strong>，如果进行空间管理并在合适时候执行碎片整理，实现比较复杂而且产生额外开销。（2）如果不对碎片进行处理，采用追加写的方式，一方面会浪费存储容量，另一方面又会破坏数据局部性，增加数据分布的随机性，导致读性能下降。（3）此外，如果支持随机读写，大小文件如何统一处理，小文件增长成大文件，大文件退化为小文件，这些问题都是在实际处理时面临的挑战。</p>
<h3 id="hadoop小文件">Hadoop小文件</h3>
<h4 id="小文件来源">小文件来源</h4>
<p>一个Hadoop集群中存在小文件的可能原因如下：</p>
<p><strong>1.流式任务（如spark streaming/flink等实时计算框架）</strong></p>
<p>在做数据处理时，无论是纯实时还是基于batch的准实时，在小的时间窗口内都可能产生大量的小文件。此外对于Spark任务如果过度并行化，每个分区一个文件，产生的文件也可能会增多</p>
<p><strong>2.Hive分区表的过度分区</strong></p>
<p>这里的过度分区是指Hive分区表的每个分区数据量很小（比如小于HDFS block size）的Hive表。那么Hive Metastore Server调用开销会随着表拥有的分区数量而增加，影响性能。此时，要衡量数据量重新进行表结构设计（如减少分区粒度）。</p>
<p><strong>3.数据源有大量小文件，未做处理直接迁移到Hadoop集群。</strong></p>
<p><strong>4.对于计算引擎处理任务，以MR为例。</strong></p>
<p>大量的map和reduce task存在。在HDFS上生成的文件基本上与map数量（对于Map-Only作业）或reduce数量（对于MR作业）成正比。此外，MR任务如果未设置合理的reduce数或者未做限制，每个reduce都会生成一个独立的文件。对于数据倾斜，导致大部分的数据都shuffle到一个或几个reduce，然后其他的reduce都会处理较小的数据量并输出小文件。</p>
<p>对于Spark任务，过度并行化也是导致小文件过多的原因之一。</p>
<p>在Spark作业中，根据写任务中提到的分区数量，每个分区会写一个新文件。这类似于MapReduce框架中的每个reduce任务都会创建一个新文件。Spark分区越多，写入的文件就越多。控制分区的数量来减少小文件的生成。</p>
<h4 id="发现小文件的方式">发现小文件的方式</h4>
<p>NameNode存储了所有与文件相关的元数据，所以它将整个命名空间保存在内存中，而fsimage是NameNode的本地本机文件系统中的持久化记录。因此，我们可以通过分析fsimage来找出文件的元信息。fsimage中可用的字段有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Path, Replication, ModificationTime, AccessTime, PreferredBlockSize, BlocksCount, FileSize, NSQUOTA, DSQUOTA, Permission, UserName, GroupName</span><br></pre></td></tr></table></figure>
<p>1、通过hdfs oiv命令解析fsimage</p>
<p>拷贝Namenode数据目录下的fsimage文件到其他目录，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdfs oiv -p Delimited -delimiter <span class="string">&quot;|&quot;</span> -t /tmp/tmpdir/ -i fsimage_copy_file -o fsimage_deal.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、使用fsck命令扫描当前的HDFS目录并保存扫描后的信息。但是不建议在生产环境使用fsck命令，因为它会带来额外的开销，可能影响集群的稳定性。</p>
<h4 id="hadoop小文件合并策略和方式">Hadoop小文件合并策略和方式</h4>
<p>Hadoop中的小文件一般是指明显小于HDFS的block size（默认128M，一般整数倍配置如256M）的文件。但需要注意，HDFS上的有些小文件是不可避免的，比如jar、临时缓存文件等。但当小文件数量变的"海量"，以至于Hadoop集群中存储了大量的小文件，就需要对小文件进行处理，而处理的目标是让文件大小尽可能接近HDFS的block size大小或者整数倍。</p>
<h4 id="namenode中的小文件问题">NameNode中的小文件问题</h4>
<p>每个block的元数据都需要加载到NameNode的内存中，这导致一个Hadoop集群在NameNode中存储的对象是有上限的，并且对象太多会带来启动时间较长以及网络延迟的问题。常见的有两种解决方案：</p>
<p>1、减少集群的NameNode中的对象数量</p>
<p>2、以某种方式让NameNode使用更多的内存，但不会导致较长的启动时间</p>
<ul>
<li><p>Hadoop Archive(HAR)</p>
<p>（本质上应该是一种多级目录）</p>
<p>Hadoop archive files通过将许多小文件打包到更大的HAR文件中来缓解NameNode内存问题，类似于Linux上的TAR文件。这样可以让NameNode只处理单个HAR文件，而不是数十个或数百个小文件。可以使用har://前缀而不是hdfs://来访问HAR文件中的文件。HAR文件是基于HDFS中已有的文件创建的。因此，HAR文件不仅可以合并从数据源抽取到HDFS中的数据，也可以合并通过正常的MR处理创建的数据。HAR文件可以独立的用于解决小文件问题，除了HDFS没有其他的依赖。</p>
<p><img src="/2021/08/02/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E5%B0%8F%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/image-20210802085228880.png" alt="image-20210802085228880" style="zoom:67%;"></p>
<p>虽然HAR文件减少了NameNode中小文件对内存的占用，但访问HAR文件内容性能可能会更低。<strong>HAR文件仍然随机存储在磁盘上，并且读取HAR内的文件需要访问两个索引 - 一个用于NameNode找到HAR文件本身，一个用于在HAR文件内找到小文件的位置</strong>。在HAR中读取文件实际上可能比读取存储在HDFS上的相同文件慢。<strong>MapReduce作业的性能同样会受到影响，因为它仍旧会为每个HAR文件中的每个文件启动一个map任务</strong>。</p>
<p>所以这里我们需要有一个权衡，HAR文件可以解决NameNode内存问题，但同时会降低读取性能。如果你的小文件主要用于存档，并且不经常访问，那么HAR文件是一个很好的解决方案。如果小文件经常要被读取或者处理，那么可能需要重新考虑解决方案。</p></li>
<li><p>NameNode联邦</p>
<p>NameNode联邦允许你在一个集群中拥有多个NameNode，每个NameNode都存储元数据对象的子集。这样可以让所有的元数据对象都不止存储在单个机器上，也消除了单个节点的内存限制，因为你可以扩容。这听上去是一个很美丽的方案，但其实它也有局限性。</p>
<p>NameNode联邦隔离了元数据对象 - <strong>仅仅只有某一个NameNode知道某一个特定的元数据对象在哪里，意思就是说如果你想找到某个文件，你必须知道它是保存在哪个NameNode上的</strong>。如果你的集群中有多个租户和/或隔离的应用程序，那使用NameNode联邦是挺不错的，你可以通过租户或者应用程序来隔离元数据对象。但是，如果要在所有的应用程序之间共享数据，则该方法其实也并不是完美的。</p>
<p>由于NameNode联邦<strong>并不会改变集群中对象或者块的数量</strong>，所以<strong>它并没有解决MapReduce的性能问题</strong>。相反，联邦会增加Hadoop集群安装和维护的复杂度。所以我们说联邦可以解决小文件问题，倒不如说它提供了一种办法让你“隐藏”小文件。</p></li>
</ul>
<h4 id="mapreduce的小文件问题">MapReduce的小文件问题</h4>
<p>MR性能问题主要是由随机磁盘IO和启动/管理太多的map任务组合引起的。解决方案似乎很明显 - 合并小文件，然而这个事往往说起来容易做起来难。以下讨论一下几种解决方案：</p>
<p>注：虽然为解决MR的性能问题，但其实同样也是为了解决NameNode的压力，以及解决其他计算引擎比如Impala/Spark的性能问题。</p>
<p>解决方案：</p>
<p><strong>1、从数据源处处理</strong></p>
<p>数据源是否能生成一些大文件，或者从数据源到HDFS的数据抽取过程中进行数据处理合并小文件。如果每小时只抽取10MB的数据，考虑是否改为每天一次，这样创建1个240MB的文件而不是24个10MB的文件。</p>
<p>缺点：可能无法控制数据源的改动配合或业务对数据抽取间隔的需求，这样小文件问题无法避免，这时可能需要考虑其他的解决方案。</p>
<p><strong>2、批量文件合并</strong></p>
<p><strong>定期运行一个MR任务，读取某一个文件夹中的所有小文件，并通过减少reduce的数量将它们重写为较少数量的大文件。</strong></p>
<p>比如一个文件夹中有1000个文件，你可以在一个MR任务中指定reduce的数量为5，这样1000个输入文件会被合并为5个文件。</p>
<p>随后进行一些简单的HDFS文件/文件夹操作(将新文件覆盖回原目录)，则可以将NameNode的内存使用减少到200分之1，并且可以提高以后MR或其他计算引擎对同一数据处理的性能。</p>
<p>这些MR任务运行同样需要集群资源，所以建议调度在生产系统非繁忙时间段执行。同时，应该定期执行这种合并的MR作业，因为小文件随时或者几乎每天都可能产生。</p>
<p>但这个合并程序需要有额外的逻辑来判断存在大量小文件的目录，或者你自己是知道哪些目录是存在大量小文件的。因为假如某个目录只有3个文件，运行合并作业远不如合并一个500个文件的文件夹的性能优势提升明显。</p>
<p>检查所有文件夹并确认哪些文件夹中的小文件需要合并，目前主要是通过自定义的脚本或程序，当然一些商业工具也能做，比如Pentaho可以迭代HDFS中的一组文件夹，找到最小合并要求的文件夹。</p>
<p>缺点：批量合并文件的方法无法保留原始文件名，如果原始文件名对于你了解数据来源非常重要，则批量合并文件的方法也不适用。但一般来说，我们一般只会设计HDFS的各级目录的文件名，而不会细化到每个文件的名字，所以理论来说这种方法问题也不大。</p>
<p><strong>3、Sequence文件</strong></p>
<p>SequenceFile是Hadoop API提供的一种二进制文件，它将数据以&lt;key,value&gt;的形式序列化到文件中，这种二进制文件内部使用Hadoop的标准Writable接口实现序列化和反序列化。有如下特点：</p>
<p><img src="/2021/08/02/%E5%A4%A7%E6%95%B0%E6%8D%AE_%E6%B5%B7%E9%87%8F%E5%B0%8F%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/image-20210802004812454.png" alt="image-20210802004812454" style="zoom: 50%;"></p>
<p>（1）基于行存储。它与Hadoop API中的MapFile是互相兼容的。Hive中的SequenceFile继承自Hadoop API的SequenceFile，不过它的key为空，使用value存放实际的值，这样是为了避免MR在运行map阶段的排序过程。</p>
<p>（2）支持三种压缩类型：None、Record、Block。默认采用Record，但是Record压缩率低；一般建议使用Block压缩。</p>
<p>（3）优势是文件和Hadoop API的MapFile是相互兼容的。</p>
<p>当需要维护原始文件名时，就可以使用sequence文件。在此解决方案中，文件名作为key保存在sequence文件中，然后文件内容会作为value保存。下图给出将一些小文件存储为sequence文件的示例：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Key  |  Value  |  Key  |  Value  |  Key  |  Value</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  file1.txt  | file1 contents| file2.txt    |file2 contents  | fileN.txt    | fileN contents</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>如果一个sequence文件包含10000个小文件，则同时会包含10000个key在一个文件中。sequence文件支持块压缩，并且是可被拆分的。<strong>这样MR作业在处理这个sequence文件时，只需要为每个128MB的block启动一个map任务，而不是每个小文件启动一个map任务。当你在同时抽取数百个或者数千个小文件，并且需要保留原始文件名时，这是非常不错的方案。</strong></p>
<p>缺点：如果你一次仅抽取少量的小文件到HDFS，则sequence文件的方法也不太可行，因为sequence文件是不可变的，无法追加。比如3个10MB文件将产生1个30MB的Sequence文件，根据本文前面的定义，这仍然是一个小文件。另外一个问题是如果需要检索sequence文件中的文件名列表则需要遍历整个文件。</p>
<p>另外一个问题是Hive并不能较好的处理由该方法合并出来的sequence文件。Hive将value中的所有数据视为单行。这样会导致Hive查看这些数据不方便，因为以前小文件中的一行的所有数据也是Hive中的单行，即相当于只有一个字段。同时，Hive没办法访问这种sequence的key，即文件名（可以自定义Hive Serde来解决）</p>
<p><strong>4、使用Hbase进行数据存储</strong></p>
<p>解决小文件问题，除了HDFS存储外，当然还可以考虑HBase列式存储。使用HBase可以<strong>将数据抽取过程从生成大量小HDFS文件更改为以逐条记录写入到HBase表</strong>。如果你对数据访问的需求主要是随机查找或者叫点查，则HBase是最好的选择。HBase在架构上就是为快速插入，存储大量数据，单个记录的快速查找以及流式数据处理而设计的。但如果你对数据访问的需求主要是全表扫描，则HBase不是最适合的。</p>
<p>可以基于HBase的表的数据创建Hive表，但是查询这种Hive表对于不同的查询类型性能会不一样。当查询单行或者范围查找时，Hive on HBase会表现不错，但是如果是全表扫描则效率比较低下，大多数分析查询比如带group by的语句都是全表扫描。</p>
<p>缺点：使用HBase，可以较好的应对实时数据写入以及实时查询的场景。但是如何分配和平衡HBase与集群上其他的组件的资源使用，以及HBase本身运维都会带来额外的运维管理成本。另外，HBase的性能主要取决于你的数据访问方式，所以在选择HBase解决小文件问题之前，应该进行仔细调研和设计。</p>
<p><strong>5、使用CombineFileInputFormat</strong></p>
<p>CombineFileInputFormat是Hadoop提供的抽象类，<strong>它在MR读取时合并小文件。合并的文件不会持久化到磁盘，它是在一个map任务中合并读取到的这些小文件。好处是MR可以不用为每个小文件启动一个map任务</strong>，而且因为是自带的实现类，你不用额外将小文件先提前合并。</p>
<p>为了实现这个，需要为不同的文件类型编写Java代码扩展CombineFileInputFormat类。这样实现一个自定义的类后，就可以配置最大的split大小，然后单个map任务会读取小文件并进行合并直到满足这个大小。Hive作业直接配置参数即可实现。</p>
<p>缺点：这解决了MR作业启动太多map任务的问题，但是因为作业仍然在读取多个小文件，随机磁盘IO依旧是一个问题。另外，CombineFileInputFormat大多数情况下都不会考虑data locality，往往会通过网络从其他节点拉取数据。</p>
<p>注意以上无论是MR代码实现方式还是Hive，因为合并的文件并不会持久化保存到磁盘，因此CombineFileInputFormat方式并不会缓解NameNode内存管理问题。只是提高MR或者Hive作业的性能。</p>
<p><strong>6、通过Hive合并小文件</strong></p>
<p>如果你在使用Hive时因为"create table as"或"insert overwrite"语句输出了小文件，你可以通过设置一些参数来缓解。通过设置这些参数。Hive会在本身的SQL作业执行完毕后会单独起一个MR任务来合并输出的小文件。</p>
<p>注意这个设置仅对Hive创建的文件生效，比如你使用Sqoop导数到Hive表，或者直接抽数到HDFS等，该方法都不会起作用。</p>
<p><strong>7、使用Hadoop的文件追加特性</strong></p>
<p>Hadoop自带的Append特性，即当第一次输出是小文件时，后面的文件输出可以继续追加这些小文件，让小文件变成大文件。</p>
<p>这听上去是个不错的建议，但其实做起来挺难的。因为MR任务有一个规定，输出结果目录必须是在之前不存在的。所以MR作业肯定无法使用Append特性，由于Sqoop，Pig和Hive都使用了MR，所以这些工具也不支持Append。Flume不支持Append主要是因为它假设经过一段时间比如几秒，多少字节，多少事件数或者不活动的秒数，Flume就会关闭文件而不再打开它。</p>
<p>因此，需要自己编写特定的程序来追加到现有的文件。另外，当集群中其他应用程序如果正在读取或处理这些需要追加的文件，你就不能使用自定义的MR或者Spark程序来追加这些文件了。所以如果要使用这种方法，最好还是谨慎考虑。</p>
<h3 id="hive小文件">Hive小文件</h3>
<h4 id="解决方案">解决方案</h4>
<p>1、配置输入合并和输出合并小文件</p>
<p>配置map输入合并</p>
<p>在执行map任务前进行小文件合并：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 每个Map最大输入大小，决定合并后的文件数</span><br><span class="line"><span class="built_in">set</span> mapred.max.split.size=256000000;</span><br><span class="line">-- 一个节点上split的至少的大小 ，决定了多个data node上的文件是否需要合并</span><br><span class="line"><span class="built_in">set</span> mapred.min.split.size.per.node=100000000;</span><br><span class="line">-- 一个交换机下split的至少的大小，决定了多个交换机上的文件是否需要合并</span><br><span class="line"><span class="built_in">set</span> mapred.min.split.size.per.rack=100000000;</span><br><span class="line">-- 执行Map前进行小文件合并</span><br><span class="line"><span class="built_in">set</span> hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;</span><br></pre></td></tr></table></figure>
<p>配置hive结果端合并</p>
<p>通过设置hive的配置项在执行结束后对结果文件进行合并。hive在对结果文件进行合并时会执行一个额外的map-only脚本，mapper的数量是文件总大小除以size.per.task参数所得的值，触发合并的条件是：根据查询类型不同，相应的mapfiles/mapredfiles参数需要打开；结果文件的平均大小需要大于avgsize参数的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 在Map-only的任务结束时合并小文件</span><br><span class="line"><span class="built_in">set</span> hive.merge.mapfiles = <span class="literal">true</span></span><br><span class="line">-- 在Map-Reduce的任务结束时合并小文件</span><br><span class="line"><span class="built_in">set</span> hive.merge.mapredfiles = <span class="literal">true</span></span><br><span class="line">-- 合并文件的大小</span><br><span class="line"><span class="built_in">set</span> hive.merge.size.per.task = 256*1000*1000 </span><br><span class="line">-- 当输出文件的平均大小小于该值时，启动一个独立的map-reduce任务进行文件merge</span><br><span class="line"><span class="built_in">set</span> hive.merge.smallfiles.avgsize=16000000</span><br></pre></td></tr></table></figure>
<p>2、Hive使用HAR归档文件</p>
<p>Hadoop的归档文件格式也是解决小文件问题的方式之一。而且hive提供了原生支持：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">set</span> hive.archive.enabled=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">set</span> hive.archive.har.parentdir.settable=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">set</span> har.partfile.size=1099511627776;</span><br><span class="line">ALTER TABLE srcpart ARCHIVE PARTITION(ds= <span class="string">&#x27;2021-02-01&#x27;</span>, hr= <span class="string">&#x27;12&#x27;</span> );</span><br><span class="line">ALTER TABLE srcpart UNARCHIVE PARTITION(ds= <span class="string">&#x27;2021-02-01&#x27;</span>, hr= <span class="string">&#x27;12&#x27;</span> );</span><br></pre></td></tr></table></figure>
<p>3、数据仓库Hive表分区优化</p>
<p>数据仓库创建数仓表时，ETL开发人员基于使用习惯和处理的方便性，经常创建多级分区存储数据。但是过多的分区会消耗NameNode大量的资源，而且也会引入小文件的问题。所以对于创建数仓表的分区，要求如下（本质就是尽可能减少分区创建）：</p>
<p>（1）对于统计数据表、数据量不大的基础表、业务上无累计快照和周期性快照要求的数据表，尽可能的不创建分区，而采用数据合并回写的方式解决。</p>
<p>（2）对于一些数据量大的表，如果需要创建分区，提高插叙过程中数据的加载速度，尽可能的只做天级分区。而对于埋点数据，这种特大的数据量的，可以采用小时分区。</p>
<p>（3）对于一些周期快照和累计快照的表，我们尽可能只创建日分区。</p>
<p>4、对Hive数据进行压缩</p>
<p>出于对小文件数据治理的目的，建议使用非TexFile的序列化存储方式存储数据。并且如果一张Hive表存在大量的小文件，建议通过以下参数设置压缩：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">set</span> hive.exec.compress.output<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> parquet.compression<span class="operator">=</span>snappy;</span><br><span class="line"><span class="keyword">set</span> hive.merge.mapfiles<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.merge.mapredfiles<span class="operator">=</span><span class="literal">true</span>; </span><br><span class="line"><span class="keyword">set</span> hive.merge.mapredfiles<span class="operator">=</span><span class="literal">true</span></span><br><span class="line"><span class="keyword">set</span> hive.optiming.sort.dynamic.partition <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">--256M</span></span><br><span class="line"><span class="keyword">set</span> parquet.blocksize<span class="operator">=</span> <span class="number">268435456</span>;</span><br><span class="line"><span class="comment">--256M</span></span><br><span class="line"><span class="keyword">set</span> dfs.block.size<span class="operator">=</span><span class="number">268435456</span>; </span><br><span class="line"><span class="comment">--128M</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.smallfiles.avgsize<span class="operator">=</span><span class="number">134217728</span>; </span><br><span class="line"><span class="comment">--256M</span></span><br><span class="line"><span class="keyword">set</span> hive.merge.size.per.task <span class="operator">=</span> <span class="number">268435456</span>;</span><br></pre></td></tr></table></figure>
<h3 id="spark小文件">Spark小文件</h3>
<h4 id="问题">问题</h4>
<p>使用sparkstreaming时，如果实时计算结果要写入到HDFS，那么不可避免的会遇到一个问题，那就是<strong>在默认情况下会产生非常多的小文件</strong>，这是由sparkstreaming的微批处理模式和DStream(RDD)的分布式(partition)特性导致的，sparkstreaming为每个partition启动一个独立的线程来处理数据，一旦文件输出到HDFS，那么这个文件流就关闭了，再来一个batch的parttition任务，就再使用一个新的文件流。</p>
<p>那么假设，一个batch为10s，每个输出的DStream有32个partition，那么一个小时产生的文件数将会达到(3600/10) * 32=11520个之多。众多小文件带来的结果是有大量的文件元信息，比如文件的location、文件大小、block number等需要NameNode来维护，NameNode压力会非常大。</p>
<p>不管是什么格式的文件，parquet、text、JSON或者Avro，都会遇到这种小文件问题，这里讨论几种处理sparkstreaming小文件的典型方法。</p>
<h4 id="解决方案-1">解决方案</h4>
<p><strong>1、增加batch大小</strong></p>
<p>batch越大，从外部接收的event就越多，内存积累的数据也就越多，那么输出的文件数也就回变少，比如将上面例子中的batch时间从10s增加为100s，那么一个小时的文件数量就会减少到1152个。但是此时延迟会比较大，不适合实时性要求高的场景。</p>
<p><strong>2、coalesce和repartition</strong></p>
<p>小文件的基数是：batch_number * partition_number，而第一种方法是减少batch_number，那么这种方法就是减少partition_number了，这个api不细说，就是减少初始的分区个数。看过spark源码的童鞋都知道，对于窄依赖，一个子rdd的partition规则继承父rdd，对于宽依赖(就是那些ByKey操作)，如果没有特殊指定分区个数，也继承自父rdd。那么初始的SourceDstream是几个partiion，最终的输出就是几个partition。</p>
<p>所以coalesce大法的好处就是，可以在最终要输出的时候，来减少partition个数。</p>
<p>但是这个方法的缺点也很明显，本来是32个线程在写256M数据，现在可能变成了4个线程在写256M数据，而没有写完成这256M数据，这个batch是不算做结束的。那么一个batch的处理时延必定增长，batch挤压会逐渐增大。</p>
<p><strong>3、自定义合并脚本</strong></p>
<p>在sparkstreaming外再启动定时的批处理任务来合并sparkstreaming产生的小文件。需要注意合并任务的时间划分，避免合并正在写入的sparkstreaming文件。</p>
<p><strong>4、通过foreach输出类追加小文件</strong></p>
<p>sparkstreaming提供的foreach这个outout类api，可以让我们自定义输出计算结果的方法。那么我们其实也可以利用这个特性，那就是每个batch在要写文件时，并不是去生成一个新的文件流，而是把之前的文件打开。考虑这种方法的可行性，首先，HDFS上的文件不支持修改，但是很多都支持追加，那么每个batch的每个partition就对应一个输出文件，每次都去追加这个partition对应的输出文件，这样也可以实现减少文件数量的目的。这种方法要注意的就是不能无限制的追加，当判断一个文件已经达到某一个阈值时，就要产生一个新的文件进行追加了。</p>
<h3 id="参考资料">参考资料</h3>
<p>https://mp.weixin.qq.com/s/Bg70xFG9BIbhzO4tzMfH_A</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive DML</title>
    <url>/2021/07/25/Hive_DML/</url>
    <content><![CDATA[<p>DML（Data Manipulation Language）数据操作语言用于定义数据的基本操作，SQL中处理数据等操作统称为数据操纵语言，简而言之就是实现了基本的“增删改查”操作。</p>
<a id="more"></a>
<h2 id="load">load</h2>
<h3 id="基础">基础</h3>
<p>当在Hive中创建好表之后，就会在HDFS上创建一个与之对应的文件夹，要想让hive的表和结构化的数据文件产生映射，就需要把文件移到到表对应的文件夹下面，当然，可以在建表的时候使用location语句指定数据文件的路径。但是不管路径在哪里，必须把数据文件移动到对应的路径下面。</p>
<p>最原始暴力直接的方式就是使用hadoop fs –put等方式将数据移动到路径下面。</p>
<p>Hive官方推荐<strong>使用Load命令将数据加载到表中</strong>。</p>
<h3 id="语法">语法</h3>
<p>在将数据load加载到表中时，Hive不会进行任何转换。</p>
<p><strong>加载操作是将数据文件移动到与Hive表对应的位置的纯复制/移动操作</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)]</span><br><span class="line"></span><br><span class="line">LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)] [INPUTFORMAT &#39;inputformat&#39; SERDE &#39;serde&#39;] (3.0 or later)</span><br></pre></td></tr></table></figure>
<h4 id="filepath">filepath</h4>
<p>filepath表示的待移动数据的路径，可以引用一个文件（在这种情况下，Hive将文件移动到表中），也可以是一个目录（在这种情况下，Hive将把该目录中的所有文件移动到表中）。</p>
<p>相对路径，例如：project/data1</p>
<p>绝对路径，例如：/user/hive/project/data1</p>
<p>具有schema的完整URI，例如：hdfs://namenode:9000/user/hive/project/data1</p>
<h4 id="local">local</h4>
<p>如果指定了LOCAL， <strong>load命令将在本地文件系统中查找文件路径</strong>。如果指定了相对路径，它将相对于用户的当前工作目录进行解释。用户也可以为本地文件指定完整的URI-例如：file:///user/hive/project/data1。</p>
<p>注意，如果对HiveServer2服务运行此命令。这里的本地文件系统指的是Hiveserver2<strong>服务所在机器的本地Linux文件系统</strong>，<strong>不是Hive客户端所在的本地文件系统</strong>。</p>
<p>如果没有指定LOCAL关键字，如果filepath指向的是一个完整的URI，hive会直接使用这个URI。 否则如果没有指定schema或者authority，Hive会使用在hadoop配置文件中定义的schema 和 authority，即参数fs.default.name指定（不出意外，都是HDFS）。</p>
<p><strong>overwrite</strong></p>
<p>如果使用了OVERWRITE关键字，则目标表（或者分区）中的内容会被删除，然后再将 filepath 指向的文件/目录中的内容添加到表/分区中。</p>
<h4 id="案例">案例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- ------Load Data From Local FS or HDFS------</span><br><span class="line">-- step1:建表</span><br><span class="line">-- 建表student_local 用于演示从本地加载数据</span><br><span class="line">create table student_local(</span><br><span class="line">    num int,name string,sex string,age int,dept string) </span><br><span class="line">    row format delimited fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">-- 建表student_HDFS  用于演示从HDFS加载数据</span><br><span class="line">create external table student_HDFS(</span><br><span class="line">    num int,name string,sex string,age int,dept string) </span><br><span class="line">    row format delimited fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">-- 建表student_HDFS_p 用于演示从HDFS加载数据到分区表</span><br><span class="line">create table student_HDFS_p(</span><br><span class="line">    num int,name string,sex string,age int,dept string) </span><br><span class="line">    partitioned by(country string) </span><br><span class="line">    row format delimited fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">-- 建议使用beeline客户端 可以显示出加载过程日志信息</span><br><span class="line">-- step2:加载数据</span><br><span class="line">-- 从本地加载数据  数据位于HS2（node1）本地文件系统  本质是hadoop fs -put上传操作</span><br><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;root&#x2F;hivedata&#x2F;students.txt&#39; INTO TABLE student_local;</span><br><span class="line"></span><br><span class="line">-- 从HDFS加载数据  数据位于HDFS文件系统根目录下  本质是hadoop fs -mv 移动操作</span><br><span class="line">-- 先把数据上传到HDFS上  hadoop fs -put &#x2F;root&#x2F;hivedata&#x2F;students.txt &#x2F;</span><br><span class="line">LOAD DATA INPATH &#39;&#x2F;students.txt&#39; INTO TABLE student_HDFS;</span><br><span class="line"></span><br><span class="line">-- --从HDFS加载数据到分区表中并制定分区  数据位于HDFS文件系统根目录下</span><br><span class="line">-- 先把数据上传到HDFS上 hadoop fs -put &#x2F;root&#x2F;hivedata&#x2F;students.txt &#x2F;</span><br><span class="line">LOAD DATA INPATH &#39;&#x2F;students.txt&#39; INTO TABLE student_HDFS_p partition(country &#x3D;&quot;CHina&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="新特性">3.0 新特性</h3>
<p>Hive 3.0及更高版本中，除了移动复制操作之外，还支持其他加载操作，因为Hive在内部在某些场合下会将加载重写为INSERT AS SELECT。</p>
<p>比如，如果表具有分区，则load命令没有指定分区，则将load转换为INSERT AS SELECT，并<strong>假定最后一组列为分区列</strong>。如果文件不符合预期的架构，它将引发错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- -----hive 3.0 load命令新特性------------------</span><br><span class="line">CREATE TABLE if not exists tab1 (col1 int, col2 int)</span><br><span class="line">PARTITIONED BY (col3 int)</span><br><span class="line">row format delimited fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">LOAD DATA LOCAL INPATH &#39;&#x2F;root&#x2F;hivedata&#x2F;tab1.txt&#39; INTO TABLE tab1;</span><br><span class="line"></span><br><span class="line">-- tab1.txt内容如下</span><br><span class="line">11,22,1</span><br><span class="line">33,44,2</span><br></pre></td></tr></table></figure>
<p>本来加载的时候没有指定分区，语句是报错的，但是文件的格式符合表的结构，前两个是col1,col2,最后一个是分区字段col3，则此时会将load语句转换成为insert as select语句。</p>
<p>在Hive3.0中，还支持使用inputformat、SerDe指定任何Hive输入格式，例如文本，ORC等。</p>
<h2 id="insert-select">insert + select</h2>
<h3 id="基础-1">基础</h3>
<p>Hive中insert主要是结合select查询语句使用，<strong>将查询结果插入到表中</strong>。</p>
<h3 id="语法-1">语法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT OVERWRITE TABLE tablename1 </span><br><span class="line">[PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...) [IF NOT EXISTS]] select_statement1 FROM from_statement;</span><br><span class="line"></span><br><span class="line">INSERT INTO TABLE tablename1 </span><br><span class="line">[PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)] select_statement1 FROM from_statement;</span><br></pre></td></tr></table></figure>
<p>INSERT OVERWRITE将覆盖表或分区中的任何现有数据。</p>
<p>需要保证查询结果列的数目和需要插入数据表格的列数目一致。如果查询出来的数据类型和插入表格对应的列数据类型不一致，将会进行转换，但是不能保证转换一定成功，转换失败的数据将会为NULL。</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- step1:创建一张源表student</span><br><span class="line">drop table if exists student;</span><br><span class="line">create table student(</span><br><span class="line">    num int,name string,sex string,age int,dept string)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &#39;,&#39;;</span><br><span class="line"></span><br><span class="line">-- 加载数据</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;students.txt&#39; into table student;</span><br><span class="line"></span><br><span class="line">-- step2：创建一张目标表  只有两个字段</span><br><span class="line">create table student_from_insert(sno int,sname string);</span><br><span class="line"></span><br><span class="line">-- 使用insert+select插入数据到新表中</span><br><span class="line">insert into table student_from_insert select num,name from student;</span><br><span class="line"></span><br><span class="line">select * from student_insert1;</span><br></pre></td></tr></table></figure>
<h3 id="多重插入">多重插入</h3>
<p>从一个表中，写多个查询逻辑，并将结果输出到多个不同表（分区）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- ----------multiple inserts----------------------</span><br><span class="line">-- 当前库下已有一张表student</span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line">-- 创建两张新表</span><br><span class="line">create table student_insert1(sno int);</span><br><span class="line">create table student_insert2(sname string);</span><br><span class="line"></span><br><span class="line">-- 多重插入</span><br><span class="line">from student</span><br><span class="line">insert overwrite table student_insert1</span><br><span class="line">select num</span><br><span class="line">insert overwrite table student_insert2</span><br><span class="line">select name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="动态分区插入">动态分区插入</h3>
<p>对于分区表的数据导入加载，最常见最基础的是通过load命令加载数据。假如说现在有全球224个国家的人员名单（每个国家名单单独一个文件），导入数据到分区表中，不同国家不同分区，不可能使用load语法导入224次。</p>
<p>为此，Hive提供了动态分区插入的语法。</p>
<p>所谓动态分区插入指的是：<strong>分区的值是由后续的select查询语句的结果来动态确定的。根据查询结果自动分区</strong>。</p>
<p>配置参数</p>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 6%">
<col style="width: 61%">
</colgroup>
<tbody>
<tr class="odd">
<td>hive.exec.dynamic.partition</td>
<td>true</td>
<td>需要设置true为启用动态分区插入</td>
</tr>
<tr class="even">
<td>hive.exec.dynamic.partition.mode</td>
<td>strict</td>
<td>在strict模式下，用户必须至少指定一个静态分区，以防用户意外覆盖所有分区；在nonstrict模式下，允许所有分区都是动态的</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM page_view_stg pvs</span><br><span class="line">INSERT OVERWRITE TABLE page_view PARTITION(dt&#x3D;&#39;2008-06-08&#39;, country)</span><br><span class="line">SELECT pvs.viewTime, pvs.userid, pvs.page_url, pvs.referrer_url, null, null, pvs.ip, pvs.cnt</span><br><span class="line"></span><br><span class="line">-- 在这里，country分区将由SELECT子句（即pvs.cnt）的最后一列动态创建。</span><br><span class="line">-- 而dt分区是手动指定写死的。</span><br><span class="line">-- 如果是nonstrict模式下，dt分区也可以动态创建。</span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 动态分区插入</span><br><span class="line">-- 1、首先设置动态分区模式为非严格模式 默认已经开启了动态分区功能</span><br><span class="line">set hive.exec.dynamic.partition &#x3D; true;</span><br><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict;</span><br><span class="line"></span><br><span class="line">-- 2、当前库下已有一张表student</span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line">-- 3、创建分区表 以sdept作为分区字段</span><br><span class="line">-- 注意：分区字段名不能和表中的字段名重复。</span><br><span class="line">create table student_partition(</span><br><span class="line">    Sno int,Sname string,Sex string,Sage int) </span><br><span class="line">partitioned by(Sdept string);</span><br><span class="line"></span><br><span class="line">-- 4、执行动态分区插入操作</span><br><span class="line">insert into table student_partition partition(Sdept)</span><br><span class="line">select Sno,Sname,Sex,Sage,Sdept from student;</span><br><span class="line">-- 其中，Sno,Sname,Sex,Sage作为表的字段内容插入表中</span><br><span class="line">-- Sdept作为分区字段值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下，可以发现实现了自动分区：</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725172512400.png" alt="image-20210725172512400"><figcaption aria-hidden="true">image-20210725172512400</figcaption>
</figure>
<h2 id="insert-directory">insert + directory</h2>
<h3 id="基础-2">基础</h3>
<p>Hive支持将select查询的结果导出成文件存放在文件系统中。</p>
<h3 id="语法-2">语法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 标准语法:</span><br><span class="line">INSERT OVERWRITE [LOCAL] DIRECTORY directory1</span><br><span class="line">[ROW FORMAT row_format] </span><br><span class="line">[STORED AS file_format] (Note: Only available starting with Hive 0.11.0)</span><br><span class="line">SELECT ... FROM ...</span><br><span class="line"></span><br><span class="line">-- Hive extension (multiple inserts):</span><br><span class="line">FROM from_statement</span><br><span class="line">INSERT OVERWRITE [LOCAL] DIRECTORY directory1 select_statement1</span><br><span class="line">[INSERT OVERWRITE [LOCAL] DIRECTORY directory2 select_statement2] ...</span><br><span class="line"></span><br><span class="line">--row_format</span><br><span class="line">: DELIMITED [FIELDS TERMINATED BY char [ESCAPED BY char]] [COLLECTION ITEMS TERMINATED BY char]</span><br><span class="line">[MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，<strong>导出操作是一个OVERWRITE覆盖操作，慎重</strong>。</p>
<p>目录可以是完整的URI。如果未指定scheme或Authority，则Hive将使用hadoop配置变量fs.default.name中的方案和Authority，该变量指定Namenode URI。</p>
<p>如果使用LOCAL关键字，则Hive会将数据写入本地文件系统上的目录。</p>
<p>写入文件系统的数据被序列化为文本，列之间用^ A隔开，行之间用换行符隔开。如果任何列都不是原始类型，那么这些列将序列化为JSON格式。也可以在导出的时候指定分隔符换行符和文件格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 当前库下已有一张表student</span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line">-- 1、导出查询结果到HDFS指定目录下</span><br><span class="line">insert overwrite directory &#39;&#x2F;tmp&#x2F;hive_export&#x2F;e1&#39; select * from student;</span><br><span class="line"></span><br><span class="line">-- 2、导出时指定分隔符和文件存储格式</span><br><span class="line">insert overwrite directory &#39;&#x2F;tmp&#x2F;hive_export&#x2F;e2&#39; </span><br><span class="line">row format delimited fields terminated by &#39;,&#39;</span><br><span class="line">stored as orc</span><br><span class="line">select * from student;</span><br><span class="line"></span><br><span class="line">-- 3、导出数据到本地文件系统指定目录下</span><br><span class="line">insert overwrite local directory &#39;&#x2F;root&#x2F;hive_export&#x2F;e1&#39;</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure>
<p>导出结果：</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725175046839.png" alt="image-20210725175046839"><figcaption aria-hidden="true">image-20210725175046839</figcaption>
</figure>
<p>文件格式：</p>
<p><img src="/2021/07/25/Hive_DML/image-20210725175112816.png" alt="image-20210725175112816" style="zoom:67%;"></p>
<h2 id="hive事务updatedelete">Hive事务（update/delete）</h2>
<h3 id="背景">背景</h3>
<p>Hive本身从设计之初时，就是不支持事务的，因为<strong>Hive的核心目标是将已经存在的结构化数据文件映射成为表</strong>，<strong>然后提供基于表的SQL分析处理</strong>，是一款面向分析的工具。且映射的数据通常存储于HDFS上，而HDFS是不支持随机修改文件数据的。</p>
<p>这个定位就意味着在早期的Hive的SQL语法中是没有update，delete操作的，也就没有所谓的事务支持了，因为都是select查询分析操作。</p>
<p>从Hive0.14版本开始，具有ACID语义的事务已添加到Hive中，以解决以下场景下遇到的问题：</p>
<p>1、流式传输数据。使用如Apache Flume或Apache Kafka之类的工具将数据流式传输到Hadoop集群中。虽然这些工具可以每秒数百行或更多行的速度写入数据，但是Hive只能每隔15分钟到一个小时添加一次分区。频繁添加分区会很快导致表中大量的分区。因此通常使用这些工具将数据流式传输到现有分区中，但是这会使读者感到脏读（也就是说，他们将在开始查询后看到写入的数据），并将许多小文件留在目录中，这将给NameNode带来压力。<strong>通过事务功能，允许读者获得一致的数据视图并避免过多的文件</strong>。</p>
<p>2、尺寸变化缓慢。在典型的星型模式数据仓库中，维度表随时间缓慢变化。例如，零售商将开设新商店，需要将其添加到商店表中，或者现有商店可能会更改其平方英尺或某些其他跟踪的特征。这些更改导致插入单个记录或更新 记录（取决于所选策略）。</p>
<p>3、数据重述。有时发现收集的数据不正确，需要更正。从Hive 0.14开始，可以通过INSERT，UPDATE和 DELETE支持这些用例 。</p>
<h3 id="局限">局限</h3>
<p>虽然Hive支持了具有ACID语义的事务，但是在使用起来，并没有像在MySQL中使用那样方便，有很多局限性。原因很简单，毕竟Hive的设计目标不是为了支持事务操作，而是支持分析操作，且最终基于HDFS的底层存储机制使得文件的增加删除修改操作需要动一些小心思。具体限制如下：</p>
<p>1、尚不支持BEGIN，COMMIT和ROLLBACK。所有语言操作都是自动提交的。</p>
<p>2、仅支持ORC文件格式（STORED AS ORC）。</p>
<p>3、默认情况下事务配置为关闭。需要配置参数开启使用。</p>
<p>4、表必须是分桶表（Bucketed）才可以使用事务功能。</p>
<p>5、表<strong>参数transactional必须为true</strong>；</p>
<p>6、外部表不能成为ACID表，不允许从非ACID会话读取/写入ACID表。</p>
<h3 id="原理">原理</h3>
<h3 id="案例-1">案例</h3>
<p>如果不做任何配置修改，直接针对Hive中已有的表进行Update、Delete、Insert操作，可以发现，只有insert语句可以执行，Update和Delete操作会报错。Insert插入操作能够成功的原因在于，底层是直接把数据写在一个新的文件中的。</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725161008715.png" alt="image-20210725161008715"><figcaption aria-hidden="true">image-20210725161008715</figcaption>
</figure>
<p>事务案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Hive中事务表的创建使用</span><br><span class="line">-- 1、开启事务配置（可以使用set设置当前session生效 也可以配置在hive-site.xml中）</span><br><span class="line">set hive.support.concurrency &#x3D; true; --Hive是否支持并发</span><br><span class="line">set hive.enforce.bucketing &#x3D; true; --从Hive2.0开始不再需要  是否开启分桶功能</span><br><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict; --动态分区模式  非严格</span><br><span class="line">set hive.txn.manager &#x3D; org.apache.hadoop.hive.ql.lockmgr.DbTxnManager; --</span><br><span class="line">set hive.compactor.initiator.on &#x3D; true; --是否在Metastore实例上运行启动线程和清理线程</span><br><span class="line">set hive.compactor.worker.threads &#x3D; 1; --在此metastore实例上运行多少个压缩程序工作线程。</span><br><span class="line"></span><br><span class="line">-- 2、创建Hive事务表</span><br><span class="line">create table trans_student(</span><br><span class="line">    id int,</span><br><span class="line">    name String,</span><br><span class="line">    age int</span><br><span class="line">)clustered by (id) into 2 buckets stored as orc TBLPROPERTIES(&#39;transactional&#39;&#x3D;&#39;true&#39;);</span><br><span class="line"></span><br><span class="line">-- 3、针对事务表进行insert update delete操作</span><br><span class="line">insert into trans_student (id, name, age)</span><br><span class="line">values (1,&quot;allen&quot;,18);</span><br><span class="line"></span><br><span class="line">update trans_student</span><br><span class="line">set age &#x3D; 20</span><br><span class="line">where id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">delete from trans_student where id &#x3D;1;</span><br><span class="line"></span><br><span class="line">select * from trans_student;</span><br></pre></td></tr></table></figure>
<h2 id="select">select</h2>
<h3 id="基本语法">基本语法</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">WITH</span> CommonTableExpression (, CommonTableExpression)<span class="operator">*</span>] </span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] select_expr, select_expr, ...</span><br><span class="line">  <span class="keyword">FROM</span> table_reference</span><br><span class="line">  [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">  [<span class="keyword">GROUP</span> <span class="keyword">BY</span> col_list]</span><br><span class="line">  [<span class="keyword">ORDER</span> <span class="keyword">BY</span> col_list]</span><br><span class="line">  [CLUSTER <span class="keyword">BY</span> col_list</span><br><span class="line">    <span class="operator">|</span> [DISTRIBUTE <span class="keyword">BY</span> col_list] [SORT <span class="keyword">BY</span> col_list]</span><br><span class="line">  ]</span><br><span class="line"> [LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span>]</span><br></pre></td></tr></table></figure>
<p>查询的输入。它可以是普通物理表，视图，join查询结果或子查询结果。表名和列名不区分大小写。</p>
<p>每个select_expr表示要检索的列。必须至少有一个 select_expr。</p>
<p>ALL和DISTINCT选项指定是否应返回重复的行。如果没有给出这些选项，则默认值为ALL（返回所有匹配的行）。DISTINCT指定从结果集中删除重复的行。</p>
<p>WHERE条件是一个布尔表达式。在WHERE表达式中，可以使用Hive支持的任何函数和运算符，但聚合函数除外。</p>
<p>为什么不能在where子句中使用聚合函数？因为聚合函数要使用它的前提是结果集已经确定。而where子句还处于“确定”结果集的过程中，因而不能使用聚合函数。</p>
<p>GROUP BY 语句用于聚合函数，根据一个或多个字段对结果集进行分组。需要注意的是，<strong>出现在select_expr中的字段：要么是GROUP BY分组的字段；要么是被聚合函数应用的字段</strong>。原因很简单，避免出现一个字段多个值的歧义。比如基于category进行分组，相同颜色的分在同一组中，在select_expr中，如果出现category字段，则没有问题，因为同一组中category值一样，但是返回day就有问题了，day的结果不一样。</p>
<p>HAVING，WHERE关键字无法与聚合函数一起使用。HAVING子句可以让我们筛选分组后的各组数据,并且可以在Having中使用聚合函数，因为此时where，group by已经执行结束，结果集已经确定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 先where分组前过滤（此处是分区裁剪），再进行group by分组（含聚合）， 分组后每个分组结果集确定 再使用having过滤</span><br><span class="line">select state,sum(deaths)</span><br><span class="line">from t_usa_covid19_p</span><br><span class="line">where count_date &#x3D; &quot;2021-01-28&quot;</span><br><span class="line">group by state</span><br><span class="line">having sum(deaths) &gt; 10000;</span><br><span class="line"></span><br><span class="line">-- 这样写更好 即在group by的时候聚合函数已经作用得出结果 having直接引用结果过滤 不需要再单独计算一次了</span><br><span class="line">select state,sum(deaths) as cnts</span><br><span class="line">from t_usa_covid19_p</span><br><span class="line">where count_date &#x3D; &quot;2021-01-28&quot;</span><br><span class="line">group by state</span><br><span class="line">having cnts&gt; 10000;</span><br></pre></td></tr></table></figure>
<p>having与where的区别: 1、having是在分组后对数据进行过滤；where是在分组前对数据进行过滤 2、having后面可以使用聚合函数；where后面不可以使用聚合</p>
<p>LIMIT子句可用于约束SELECT语句返回的行数。LIMIT接受一个或两个数字参数，这两个参数都必须是非负整数常量。第一个参数指定要返回的第一行的偏移量（从 Hive 2.0.0开始），第二个参数指定要返回的最大行数。当给出单个参数时，它代表最大行数，并且偏移量默认为0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 返回结果集的前5条</span><br><span class="line">select * from t_usa_covid19_p</span><br><span class="line">where count_date &#x3D; &quot;2021-01-28&quot;</span><br><span class="line">  and state &#x3D;&quot;California&quot;</span><br><span class="line">limit 5;</span><br><span class="line"></span><br><span class="line">-- 返回结果集从第1行开始 共3行</span><br><span class="line">select * from t_usa_covid19_p</span><br><span class="line">where count_date &#x3D; &quot;2021-01-28&quot;</span><br><span class="line">  and state &#x3D;&quot;California&quot;</span><br><span class="line">limit 2,3; -- 注意 第一个参数偏移量是从0开始的</span><br></pre></td></tr></table></figure>
<h3 id="案例-2">案例</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- step1:创建普通表t_usa_covid19</span><br><span class="line">drop table itcast.t_usa_covid19;</span><br><span class="line">CREATE TABLE itcast.t_usa_covid19(</span><br><span class="line">       count_date string,</span><br><span class="line">       county string,</span><br><span class="line">       state string,</span><br><span class="line">       fips int,</span><br><span class="line">       cases int,</span><br><span class="line">       deaths int)</span><br><span class="line">row format delimited fields terminated by &quot;,&quot;;</span><br><span class="line">-- 将源数据load加载到t_usa_covid19表对应的路径下</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;us-covid19-counties.dat&#39; into table t_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- step2:创建一张分区表 基于count_date日期,state州进行分区</span><br><span class="line">CREATE TABLE itcast.t_usa_covid19_p(</span><br><span class="line">     county string,</span><br><span class="line">     fips int,</span><br><span class="line">     cases int,</span><br><span class="line">     deaths int)</span><br><span class="line">partitioned by(count_date string,state string)</span><br><span class="line">row format delimited fields terminated by &quot;,&quot;;</span><br><span class="line"></span><br><span class="line">-- step3:使用动态分区插入将数据导入t_usa_covid19_p中</span><br><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict;</span><br><span class="line"></span><br><span class="line">insert into table t_usa_covid19_p partition (count_date,state)</span><br><span class="line">select county,fips,cases,deaths,count_date,state from t_usa_covid19;</span><br></pre></td></tr></table></figure>
<p>查询结果：</p>
<p><img src="/2021/07/25/Hive_DML/image-20210725180419051.png" alt="image-20210725180419051" style="zoom:67%;"></p>
<p>通常，SELECT查询将扫描整个表（所谓的全表扫描）。如果使用PARTITIONED BY子句创建的分区表，则在查询时可以指定分区查询，减少全表扫描，也叫做分区裁剪。</p>
<p>所谓分区裁剪指的是：对分区表进行查询时，会检查WHERE子句或JOIN中的ON子句中是否存在对分区字段的过滤，如果存在，则<strong>仅访问查询符合条件的分区，即裁剪掉没必要访问的分区</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 找出来自加州，累计死亡人数大于1000的县 state字段就是分区字段 进行分区裁剪 避免全表扫描</span><br><span class="line">select * from t_usa_covid19_p where state &#x3D;&quot;California&quot; and deaths &gt; 1000;</span><br><span class="line"></span><br><span class="line">-- 多分区裁剪</span><br><span class="line">select * from t_usa_covid19_p where count_date &#x3D; &quot;2021-01-28&quot; and state &#x3D;&quot;California&quot; and deaths &gt; 1000;</span><br></pre></td></tr></table></figure>
<h3 id="高阶查询">高阶查询</h3>
<h4 id="排序">排序</h4>
<p>Hive SQL中的CLUSTER BY语法可以指定根据后面的字段将数据分组，每组内再根据这个字段正序排序（<strong>不允许指定倒序</strong>），概况起来就是：根据同一个字段，分且排序。</p>
<p>分组的规则hash散列。hash_func(col_name) % reduce task nums</p>
<p>分为几组取决于reduce task的个数。下面在Hive beeline客户端中针对student表为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- cluster by</span><br><span class="line">select * from student;</span><br><span class="line">-- 不指定reduce task个数</span><br><span class="line">-- 日志显示：Number of reduce tasks not specified. Estimated from input data size: 1</span><br><span class="line">select * from student cluster by sno;</span><br><span class="line"></span><br><span class="line">-- 手动设置reduce task个数</span><br><span class="line">set mapreduce.job.reduces &#x3D;2;</span><br><span class="line">select * from student cluster by sno;</span><br></pre></td></tr></table></figure>
<p>默认情况下，reduce task的个数由Hive在编译期间自己决定：</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725182147657.png" alt="image-20210725182147657"><figcaption aria-hidden="true">image-20210725182147657</figcaption>
</figure>
<p>手动设置reduce task个数：</p>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725182126594.png" alt="image-20210725182126594"><figcaption aria-hidden="true">image-20210725182126594</figcaption>
</figure>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725182207003.png" alt="image-20210725182207003"><figcaption aria-hidden="true">image-20210725182207003</figcaption>
</figure>
<p>执行结果如下：分为两个部分，每个部分内正序排序：</p>
<p><img src="/2021/07/25/Hive_DML/image-20210725182238798.png" alt="image-20210725182238798" style="zoom:80%;"></p>
<p>因为CLUSTER BY不允许指定倒序，因此若有倒序的需求则需要采用其他方法。</p>
<p>DISTRIBUTE BY +SORT BY就相当于把cluster by的功能一分为二：DISTRIBUTE BY负责分，SORT BY负责分组内排序，并且可以是不同的字段。如果DISTRIBUTE BY +SORT BY的字段一样，可以得出下列结论：CLUSTER BY=DISTRIBUTE BY +SORT BY（字段一样）</p>
<p>案例，把学生表数据根据性别分为两个部分，每个分组内根据年龄的倒序排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student distribute by sex sort by sage desc;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/07/25/Hive_DML/image-20210725182550180.png" alt="image-20210725182550180"><figcaption aria-hidden="true">image-20210725182550180</figcaption>
</figure>
<p>总结：</p>
<ul>
<li>order by会对输入做全局排序，因此只有一个reducer，会导致当输入规模较大时，需要较长的计算时间。</li>
<li>sort by不是全局排序，其在数据进入reducer前完成排序。因此，如果用sort by进行排序，并且设置mapred.reduce.tasks&gt;1，则sort by只保证每个reducer的输出有序，不保证全局有序。</li>
<li>distribute by(字段)根据指定字段将数据分到不同的reducer，分发算法是hash散列。</li>
<li>cluster by(字段) 除了具有Distribute by的功能外，还会对该字段进行排序。如果distribute和sort的字段是同一个时，此时，cluster by = distribute by + sort by</li>
</ul>
<h4 id="union">union</h4>
<p>UNION用于将来自多个SELECT语句的结果合并为一个结果集。</p>
<p>每个select_statement返回的<strong>列的数量和名称必须相同</strong>。</p>
<p>语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select_statement </span><br><span class="line">UNION [ALL | DISTINCT] select_statement </span><br><span class="line">UNION [ALL | DISTINCT] select_statement ...</span><br><span class="line"></span><br><span class="line">-- union</span><br><span class="line">-- 使用DISTINCT关键字与使用UNION默认值效果一样，都会删除重复行。</span><br><span class="line">select num,name from student_local</span><br><span class="line">UNION</span><br><span class="line">select num,name from student_hdfs;</span><br><span class="line">-- 和上面一样</span><br><span class="line">select num,name from student_local</span><br><span class="line">UNION DISTINCT</span><br><span class="line">select num,name from student_hdfs;</span><br><span class="line"></span><br><span class="line">-- 使用ALL关键字会保留重复行。</span><br><span class="line">select num,name from student_local</span><br><span class="line">UNION ALL</span><br><span class="line">select num,name from student_hdfs;</span><br><span class="line"></span><br><span class="line">-- 如果要将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT应用于单个SELECT</span><br><span class="line">-- 请将子句放在括住SELECT的括号内</span><br><span class="line">SELECT sno,sname FROM (select sno,sname from student_local LIMIT 2) subq1</span><br><span class="line">UNION</span><br><span class="line">SELECT sno,sname FROM (select sno,sname from student_hdfs LIMIT 3) subq2</span><br><span class="line"></span><br><span class="line">-- 如果要将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT子句应用于整个UNION结果</span><br><span class="line">-- 请将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT放在最后一个之后。</span><br><span class="line">select sno,sname from student_local</span><br><span class="line">UNION</span><br><span class="line">select sno,sname from student_hdfs</span><br><span class="line">order by sno desc;</span><br></pre></td></tr></table></figure>
<p>使用DISTINCT关键字与只使用UNION默认值效果一样，都会删除重复行。使用ALL关键字，不会删除重复行，结果集包括所有SELECT语句的匹配行（包括重复行）。</p>
<h4 id="子查询">子查询</h4>
<p>在Hive0.12版本，仅在FROM子句中支持子查询。<strong>必须要给子查询一个名称</strong>，<strong>因为FROM子句中的每个表都必须有一个名称</strong>。在Hive0.12版本，仅在FROM子句中支持子查询。而且必须要给子查询一个名称，因为FROM子句中的每个表都必须有一个名称。Hive 0.13.0和更高版本中的子查询名称之前可以包含可选关键字“ AS” 。</p>
<p>子查询返回结果中的列必须具有唯一的名称。子查询返回结果中的列在外部查询中可用，就像真实表的列一样。子查询也可以是带有UNION的查询表达式。Hive支持任意级别的子查询，也就是所谓的嵌套子查询。</p>
<p>从Hive 0.13开始，WHERE子句支持某些类型的子查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- where子句中子查询（Subqueries）</span><br><span class="line">-- 不相关子查询，相当于IN、NOT IN,子查询只能选择一个列。</span><br><span class="line">-- （1）执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。</span><br><span class="line">-- （2）执行外部查询，并显示整个结果。　　</span><br><span class="line">SELECT *</span><br><span class="line">FROM student_hdfs</span><br><span class="line">WHERE student_hdfs.num IN (select num from student_local limit 2);</span><br><span class="line"></span><br><span class="line">-- 相关子查询，指EXISTS和NOT EXISTS子查询</span><br><span class="line">-- 子查询的WHERE子句中支持对父查询的引用</span><br><span class="line">SELECT A</span><br><span class="line">FROM T1</span><br><span class="line">WHERE EXISTS (SELECT B FROM T2 WHERE T1.X &#x3D; T2.Y);</span><br></pre></td></tr></table></figure>
<h2 id="cte">CTE</h2>
<p>Common Table Expressions（CTE），即公用表表达式（CTE）是一个临时结果集，该结果集是从WITH子句中指定的简单查询派生而来的，该查询紧接在SELECT或INSERT关键字之前。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--选择语句中的CTE</span><br><span class="line">with q1 as (select sno,sname,sage from student where sno &#x3D; 95002)</span><br><span class="line">select *</span><br><span class="line">from q1;</span><br><span class="line"></span><br><span class="line">-- from风格</span><br><span class="line">with q1 as (select sno,sname,sage from student where sno &#x3D; 95002)</span><br><span class="line">from q1</span><br><span class="line">select *;</span><br><span class="line"></span><br><span class="line">-- chaining CTEs 链式</span><br><span class="line">with q1 as ( select * from student where sno &#x3D; 95002),</span><br><span class="line">     q2 as ( select sno,sname,sage from q1)</span><br><span class="line">select * from (select sno from q2) a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- union案例</span><br><span class="line">with q1 as (select * from student where sno &#x3D; 95002),</span><br><span class="line">     q2 as (select * from student where sno &#x3D; 95004)</span><br><span class="line">select * from q1 union all select * from q2;</span><br><span class="line"></span><br><span class="line">-- 视图，CTAS和插入语句中的CTE</span><br><span class="line">-- insert</span><br><span class="line">create table s1 like student;</span><br><span class="line"></span><br><span class="line">with q1 as ( select * from student where sno &#x3D; 95002)</span><br><span class="line">from q1</span><br><span class="line">insert overwrite table s1</span><br><span class="line">select *;</span><br><span class="line"></span><br><span class="line">select * from s1;</span><br><span class="line"></span><br><span class="line">-- ctas</span><br><span class="line">create table s2 as</span><br><span class="line">with q1 as ( select * from student where sno &#x3D; 95002)</span><br><span class="line">select * from q1;</span><br><span class="line"></span><br><span class="line">-- view</span><br><span class="line">create view v1 as</span><br><span class="line">with q1 as ( select * from student where sno &#x3D; 95002)</span><br><span class="line">select * from q1;</span><br><span class="line"></span><br><span class="line">select * from v1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="join">join</h2>
<h3 id="基础-3">基础</h3>
<p>根据数据库的三范式设计要求，<strong>通常不会设计一张大表把所有类型的数据都放在一起，而是不同类型的数据设计不同的表存储</strong>。比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726003928854.png" alt="image-20210726003928854" style="zoom:50%;"></p>
<p>在这种情况下，有时需要基于多张表查询才能得到最终完整的结果，SQL中<strong>join语法的出现是用于根据两个或多个表中的字段之间的关系，从这些表中共同组合查询数据</strong>，因此有时为了得到完整的结果，我们就需要执行 join。</p>
<p>Hive作为面向分析的数据仓库软件，为了更好的支持数据分析的功能丰富，也实现了join的语法，整体上来看和RDBMS中的join语法类似，只不过在某些点有自己的特色。需要特别注意。</p>
<h3 id="语法-3">语法</h3>
<p>在Hive中，当下版本3.1.2总共支持6种join语法。分别是：</p>
<p>inner join（内连接）、left join（左连接）、right join（右连接）、full outer join（全外连接）、left semi join（左半开连接）、cross join（交叉连接，也叫做笛卡尔乘积）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table_reference [INNER] JOIN table_factor [join_condition]</span><br><span class="line"> | table_reference &#123;LEFT|RIGHT|FULL&#125; [OUTER] JOIN table_reference join_condition</span><br><span class="line"> | table_reference LEFT SEMI JOIN table_reference join_condition</span><br><span class="line"> | table_reference CROSS JOIN table_reference [join_condition] (as of Hive 0.10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JOIN默认就是INNER JOIN。</p>
<p>table_reference：是join查询中使用的表名，也可以是子查询别名（查询结果当成表参与join）。</p>
<p>table_factor：与table_reference相同,是联接查询中使用的表名,也可以是子查询别名。</p>
<p>join_condition：join查询关联的条件， 如果在两个以上的表上需要连接，则使用AND关键字。</p>
<p>从Hive 0.13.0开始，支持隐式联接表示法（请参阅HIVE-5558）。这允许FROM子句连接以逗号分隔</p>
<p>的表列表，而省略JOIN关键字。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM table1 t1, table2 t2, table3 t3</span><br><span class="line">WHERE t1.id &#x3D; t2.id AND t2.id &#x3D; t3.id AND t1.zipcode &#x3D; &#39;02535&#39;;</span><br></pre></td></tr></table></figure>
<p>Hive 2.2.0开始，支持ON子句中的复杂表达式，<strong>支持不相等连接</strong>（请参阅HIVE-15211和HIVE-15251）。<strong>在此之前，Hive不支持非等值联接条件</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT a.* FROM a JOIN b ON (a.id &#x3D; b.id)</span><br><span class="line">SELECT a.* FROM a JOIN b ON (a.id &#x3D; b.id AND a.department &#x3D; b.department)</span><br><span class="line">SELECT a.* FROM a LEFT OUTER JOIN b ON (a.id &lt;&gt; b.id)</span><br></pre></td></tr></table></figure>
<h3 id="各种join">各种JOIN</h3>
<h4 id="inner-join">inner join</h4>
<p>内连接是最常见的一种连接，它也被称为普通连接，而关系模型提出者E.FCodd（埃德加•科德）最早称之为自然连接。其中inner可以省略。inner join == join 等价于早期的连接语法。</p>
<p>内连接，只有进行连接的两个表中都存在与连接条件相匹配的数据才会被留下来。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726005046850.png" alt="image-20210726005046850" style="zoom: 33%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1、inner join</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e </span><br><span class="line">inner join employee_address e_a</span><br><span class="line">on e.id &#x3D;e_a.id;</span><br><span class="line"></span><br><span class="line">-- 等价于 inner join&#x3D;join</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e </span><br><span class="line">join employee_address e_a</span><br><span class="line">on e.id &#x3D;e_a.id;</span><br><span class="line"></span><br><span class="line">-- 等价于 隐式连接表示法</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e , employee_address e_a</span><br><span class="line">where e.id &#x3D;e_a.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/25/Hive_DML/image-20210726005212922.png" alt="image-20210726005212922" style="zoom: 67%;"></p>
<h4 id="left-join">left join</h4>
<p>left join中文叫做是左外连接(Left Outer Jion)或者左连接，其中outer可以省略，left outer join是早期的写法。</p>
<p>left join的核心就在于left左。左指的是join关键字左边的表，简称左表。</p>
<p>join时以左表的全部数据为准，右边与之关联；左表数据全部返回，右表关联上的显示返回，关联不上的显示null返回。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726005345737.png" alt="image-20210726005345737" style="zoom: 33%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 2、left join</span><br><span class="line">select e.id,e.name,e_conn.phno,e_conn.email</span><br><span class="line">from employee e left join employee_connection e_conn</span><br><span class="line">on e.id &#x3D;e_conn.id;</span><br><span class="line"></span><br><span class="line">-- 等价于 left outer join</span><br><span class="line">select e.id,e.name,e_conn.phno,e_conn.email</span><br><span class="line">from employee e left outer join  employee_connection e_conn</span><br><span class="line">on e.id &#x3D;e_conn.id;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/25/Hive_DML/image-20210726005430913.png" alt="image-20210726005430913" style="zoom:67%;"></p>
<h4 id="right-join">right join</h4>
<p>right join中文叫做是右外连接(Right Outer Jion)或者右连接，其中outer可以省略。</p>
<p>right join的核心就在于Right右。右指的是join关键字右边的表，简称右表。</p>
<p>join时以右表的全部数据为准，左边与之关联；右表数据全部返回，左表关联上的显示返回，关联不上的显示null返回。</p>
<p>很明显，right join和left join之间很相似，重点在于以哪边为准，也就是一个方向的问题。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726005514782.png" alt="image-20210726005514782" style="zoom:33%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 3、right join</span><br><span class="line">select e.id,e.name,e_conn.phno,e_conn.email</span><br><span class="line">from employee e right join employee_connection e_conn</span><br><span class="line">on e.id &#x3D;e_conn.id;</span><br><span class="line"></span><br><span class="line">-- 等价于 right outer join</span><br><span class="line">select e.id,e.name,e_conn.phno,e_conn.email</span><br><span class="line">from employee e right outer join employee_connection e_conn</span><br><span class="line">on e.id &#x3D;e_conn.id;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/25/Hive_DML/image-20210726005548550.png" alt="image-20210726005548550" style="zoom:67%;"></p>
<h4 id="full-outer-join">full outer join</h4>
<p>full outer join 等价 full join ,中文叫做全外连接或者外连接。</p>
<p>包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。它等价于对这两个数据集合分别进行左外连接和右外连接，然后再使用消去重复行的操作将上述两个结果集合并为一个结果集。</p>
<p><img src="/2021/07/25/Hive_DML/image-20210726005716904.png" alt="image-20210726005716904" style="zoom:33%;"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 4、full outer join</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e full outer join employee_address e_a</span><br><span class="line">on e.id &#x3D;e_a.id;</span><br><span class="line"></span><br><span class="line">-- 等价于</span><br><span class="line">select e.id,e.name,e_a.city,e_a.street</span><br><span class="line">from employee e full  join employee_address e_a</span><br><span class="line">on e.id &#x3D;e_a.id;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/25/Hive_DML/image-20210726005755307.png" alt="image-20210726005755307" style="zoom:67%;"></p>
<h4 id="left-semi-join">left semi join</h4>
<p>左半开连接（LEFT SEMI JOIN）会返回左边表的记录，前提是其记录对于右边的表满足ON语句中的判定条件。</p>
<p>从效果上来看即inner join之后只返回左表的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 5、left semi join</span><br><span class="line">select *</span><br><span class="line">from employee e left semi join employee_address e_addr</span><br><span class="line">on e.id &#x3D;e_addr.id;</span><br><span class="line"></span><br><span class="line">-- 相当于 inner join 只不过效率高一些</span><br><span class="line">select e.*</span><br><span class="line">from employee e inner join employee_address e_addr</span><br><span class="line">on e.id &#x3D;e_addr.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="cross-join笛卡尔积">cross join（笛卡尔积）</h4>
<p>交叉连接cross join，将会返回被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积。对于大表来说，cross join慎用。</p>
<p>在HiveSQL语法中，cross join 后面可以跟where子句进行过滤，或者on条件过滤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 6、cross join</span><br><span class="line">-- 下列A、B、C 执行结果相同，但是效率不一样：</span><br><span class="line">-- A:</span><br><span class="line">select a.*,b.* from employee a,employee_address b where a.id&#x3D;b.id;</span><br><span class="line">-- B:</span><br><span class="line">select * from employee a cross join employee_address b on a.id&#x3D;b.id;</span><br><span class="line">select * from employee a cross join employee_address b where a.id&#x3D;b.id;</span><br><span class="line"></span><br><span class="line">-- C:</span><br><span class="line">select * from employee a inner join employee_address b on a.id&#x3D;b.id;</span><br><span class="line"></span><br><span class="line">-- 一般不建议使用方法A和B，因为如果有WHERE子句的话，往往会先进行笛卡尔积返回数据然后才根据WHERE条件从中选择。</span><br><span class="line">-- 因此，如果两个表太大，将会非常非常慢，不建议使用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3>
<p>1、允许使用复杂的on联接表达式</p>
<p>2、同一查询中可以连接2个以上的表（！？多表关联原理）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM </span><br><span class="line">a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key2)</span><br></pre></td></tr></table></figure>
<p>3、如果每个表在联接子句中使用相同的列，则Hive将多个表上的联接转换为单个MR作业</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key1)</span><br><span class="line">-- 由于联接中仅涉及b的key1列，因此被转换为1个MR作业来执行</span><br><span class="line"></span><br><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key2)</span><br><span class="line">-- 会转换为两个MR作业，因为在第一个连接条件中使用了b中的key1列，而在第二个连接条件中使用了b中的key2列。第一个map &#x2F; reduce作业将a与b联接在一起，然后将结果与c联接到第二个map &#x2F; reduce作业中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、join时的最后一个表会通过reducer流式传输，并在其中缓存之前的其他表，因此，将大表放置在最后有助于减少reducer阶段缓存数据所需要的内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key1)</span><br><span class="line">-- 由于联接中仅涉及b的key1列，因此被转换为1个MR作业来执行，并且表a和b的键的特定值的值被缓存在reducer的内存中。然后，对于从c中检索的每一行，将使用缓存的行来计算联接。</span><br><span class="line"></span><br><span class="line">SELECT a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key2)</span><br><span class="line">-- 计算涉及两个MR作业。其中的第一个将a与b连接起来，并缓存a的值，同时在reducer中流式传输b的值。在第二个MR作业中，将缓存第一个连接的结果，同时将c的值通过reducer流式传输。</span><br></pre></td></tr></table></figure>
<p>5、在join的时候，可以通过语法STREAMTABLE提示指定要流式传输的表。如果省略STREAMTABLE提示，则Hive将流式传输最右边的表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#x2F;*+ STREAMTABLE(a) *&#x2F; a.val, b.val, c.val </span><br><span class="line">FROM a JOIN b ON (a.key &#x3D; b.key1) </span><br><span class="line">JOIN c ON (c.key &#x3D; b.key1)</span><br><span class="line">-- a,b,c三个表都在一个MR作业中联接，并且表b和c的键的特定值的值被缓存在reducer的内存中。然后，对于从a中检索到的每一行，将使用缓存的行来计算联接。如果省略STREAMTABLE提示，则Hive将流式传输最右边的表。</span><br></pre></td></tr></table></figure>
<p>6、如果除一个要连接的表之外的所有表都很小，则可以将其作为仅map作业执行（即map端join）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#x2F;*+ MAPJOIN(b) *&#x2F; a.key, a.value </span><br><span class="line">FROM a JOIN b ON a.key &#x3D; b.key</span><br><span class="line">-- 不需要reducer。对于A的每个Mapper，B都会被完全读取。限制是不能执行FULL &#x2F; RIGHT OUTER JOIN b。</span><br></pre></td></tr></table></figure>
<p>7、join在where条件之前进行。（执行顺序？？）</p>
<p>多表关联和join的执行顺序</p>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive DDL</title>
    <url>/2021/07/25/Hive_DDL/</url>
    <content><![CDATA[<p>数据定义语言 (Data Definition Language, DDL)，是SQL语言集中对数据库内部的对象结构进行创建，删除，修改等的操作语言，这些数据库对象包括<strong>database（schema）、table、view、index</strong>等。核心语法由<strong>CREATE、ALTER与DROP</strong>三个所组成。DDL并不涉及表内部数据的操作。</p>
<a id="more"></a>
<h2 id="hive建表基础">Hive建表基础</h2>
<h3 id="hive建表语法">Hive建表语法</h3>
<p><img src="/2021/07/25/Hive_DDL/image-20210725101854386.png" alt="image-20210725101854386" style="zoom:80%;"></p>
<ul>
<li>蓝色字体是建表语法的关键字，用于指定某些功能。</li>
<li>[]中括号的语法表示可选。</li>
<li>|表示使用的时候，左右语法二选一。</li>
<li>建表语句中的语法顺序要和上述语法规则保持一致。</li>
</ul>
<blockquote>
<p>partitioned by 表示建立分区表</p>
<p>clustered by 表示建立分桶表，sorted by表示桶内排序规则</p>
<p>row format 表示文件对应的序列化类和指定分隔符</p>
</blockquote>
<h3 id="hive数据类型">Hive数据类型</h3>
<p>Hive中的数据类型指的是Hive表中的列字段类型。Hive数据类型整体分为两个类别：原生数据类型（primitive data type）和复杂数据类型（complex data type）。</p>
<p>原生数据类型包括：数值类型、时间类型、字符串类型、杂项数据类型；</p>
<p>复杂数据类型包括：array数组、map映射、struct结构、union联合体。</p>
<p>关于Hive的数据类型，需要注意： 英文字母大小写不敏感； 除SQL数据类型外，还支持Java数据类型，比如：string； int和string是使用最多的，大多数函数都支持； 复杂数据类型的使用通常需要和分隔符指定语法配合使用。 如果定义的数据类型和文件不一致，hive会尝试隐式转换，但是不保证成功。</p>
<h4 id="原生数据类型">原生数据类型</h4>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725100029573.png" alt="image-20210725100029573"><figcaption aria-hidden="true">image-20210725100029573</figcaption>
</figure>
<p>其中标注的数据类型是使用较多的。</p>
<blockquote>
<p>https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types</p>
</blockquote>
<h4 id="复杂数据类型">复杂数据类型</h4>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725100251729.png" alt="image-20210725100251729"><figcaption aria-hidden="true">image-20210725100251729</figcaption>
</figure>
<p>其中标注的数据类型是使用较多的。</p>
<blockquote>
<p>https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types</p>
</blockquote>
<h4 id="数据类型隐式显示转换">数据类型隐式、显示转换</h4>
<p>与SQL类似，HQL支持隐式和显式类型转换。 原生类型从窄类型到宽类型的转换称为隐式转换，反之则不允许。</p>
<p>显式类型转换使用CAST函数。 例如，CAST（'100'as INT）会将100字符串转换为100整数值。 如果强制转换失败，例如CAST（'INT'as INT），该函数返回NULL。</p>
<h3 id="hive-读写文件机制">Hive 读写文件机制</h3>
<h4 id="serde">SerDe</h4>
<p>SerDe是Serializer、Deserializer的简称，目的是用于序列化和反序列化。序列化是对象转化为字节码的过程；而反序列化是字节码转换为对象的过程。</p>
<p>Hive使用SerDe（和FileFormat）读取和写入行对象。</p>
<p>可以通过desc formatted tablename查看表的相关SerDe信息。默认如下：</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725100748683.png" alt="image-20210725100748683"><figcaption aria-hidden="true">image-20210725100748683</figcaption>
</figure>
<p>在Hive的建表语句中，和SerDe相关的语法为：</p>
<p><img src="/2021/07/25/Hive_DDL/image-20210725101013712.png" alt="image-20210725101013712" style="zoom:67%;"></p>
<p>其中ROW FORMAT是语法关键字，<strong>DELIMITED</strong>和<strong>SERDE</strong>二选其一。</p>
<p>如果使用<strong>delimited</strong>表示使用默认的<strong>LazySimpleSerDe</strong>类来处理数据。如果<strong>数据文件格式比较特殊</strong>可以使用ROW FORMAT SERDE serde_name指定其他的Serde类来处理数据,甚至支持用户自定义SerDe类。</p>
<p>LazySimpleSerDe：</p>
<p>LazySimpleSerDe是Hive默认的序列化类，包含4种子语法，分别用于指定字段之间、集合元素之间、map映射 kv之间、换行的分隔符号。在建表的时候可以根据数据的特点灵活搭配使用。</p>
<p><img src="/2021/07/25/Hive_DDL/image-20210725101230559.png" alt="image-20210725101230559" style="zoom:67%;"></p>
<p>默认分隔符：</p>
<p>hive建表时如果没有row format语法。此时字段之间默认的分割符是'\001'，是一种特殊的字符，使用的是ascii编码的值，键盘是打不出来的。</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725101428441.png" alt="image-20210725101428441"><figcaption aria-hidden="true">image-20210725101428441</figcaption>
</figure>
<p>在vim编辑器中，连续按下Ctrl+v/Ctrl+a即可输入'\001' ，显示^A；在一些文本编辑器中将以SOH的形式显示。</p>
<h4 id="hive读写文件流程">Hive读写文件流程</h4>
<p>Hive读取文件机制：首先调用InputFormat（默认TextInputFormat），返回一条一条kv键值对记录（默认是一行对应一条记录）。然后调用SerDe（默认LazySimpleSerDe）的Deserializer，将一条记录中的value根据分隔符切分为各个字段。</p>
<p>Hive写文件机制：将Row写入文件时，首先调用SerDe（默认LazySimpleSerDe）的Serializer将对象转换成字节序列，然后调用OutputFormat将数据写入HDFS文件中。</p>
<p><img src="/2021/07/25/Hive_DDL/image-20210725100917105.png" alt="image-20210725100917105" style="zoom:67%;"></p>
<h3 id="hive数据存储路径">Hive数据存储路径</h3>
<h4 id="默认">默认</h4>
<p>Hive表默认存储路径是由${HIVE_HOME}/conf/hive-site.xml配置文件的hive.metastore.warehouse.dir属性指定。默认值是：/user/hive/warehouse。</p>
<p>在该路径下，文件将根据所属的库、表，有规律的存储在对应的文件夹下。</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725101636846.png" alt="image-20210725101636846"><figcaption aria-hidden="true">image-20210725101636846</figcaption>
</figure>
<h4 id="指定">指定</h4>
<p>在Hive建表的时候，可以通过location语法来更改数据在HDFS上的存储路径，使得建表加载数据更加灵活方便。 语法：LOCATION '<hdfs_location>'。 对于已经生成好的数据文件，使用location指定路径将会很方便。</hdfs_location></p>
<h2 id="hive建表高阶">Hive建表高阶</h2>
<h3 id="hive内外部表">Hive内、外部表</h3>
<h4 id="基础">基础</h4>
<p>内部表（Internal table）也称为被Hive拥有和管理的托管表（Managed table）。默认情况下创建的表就是内部表，Hive拥有该表的结构和文件。换句话说，<strong>Hive完全管理表</strong>（元数据和数据）的生命周期，类似于RDBMS中的表。</p>
<p>当删除内部表时，它会删除<strong>数据以及表的元数据</strong>。</p>
<p>可以使用 DESCRIBE FORMATTED 库名.表名 来获取表的描述信息，从中可以看出表的类型：</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725102314169.png" alt="image-20210725102314169"><figcaption aria-hidden="true">image-20210725102314169</figcaption>
</figure>
<p>外部表（External table）中的数据不是Hive拥有或管理的，<strong>只管理表的元数据</strong>。要创建一个外部表，需要使用<strong>EXTERNAL</strong>语法关键字。</p>
<p>删除外部表只会删除元数据，而<strong>不会删除实际数据</strong>。在Hive外部仍然可以访问实际数据。</p>
<p>而且外部表更为方便的是可以搭配location语法指定数据的路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create external table student_ext(</span><br><span class="line">    num int,</span><br><span class="line">    name string,</span><br><span class="line">    sex string,</span><br><span class="line">    age int,</span><br><span class="line">    dept string)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &#39;,&#39;</span><br><span class="line">location &#39;&#x2F;stu&#39;;</span><br></pre></td></tr></table></figure>
<p>可以使用 DESCRIBE FORMATTED 库名.表名 来获取表的描述信息，从中可以看出表的类型：</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725103016823.png" alt="image-20210725103016823"><figcaption aria-hidden="true">image-20210725103016823</figcaption>
</figure>
<h4 id="对比">对比</h4>
<p>相同点：无论内部表还是外部表，Hive都在Hive Metastore中管理表定义及其分区信息（即元数据）。</p>
<p>不同点：删除内部表会从Metastore中删除表元数据，还会从HDFS中删除其所有数据/文件。 删除外部表，只会从Metastore中删除表的元数据，并保持HDFS位置中的实际数据不变。</p>
<p><img src="/2021/07/25/Hive_DDL/image-20210725103136669.png" alt="image-20210725103136669" style="zoom:67%;"></p>
<h4 id="选择">选择</h4>
<p>当需要通过Hive完全管理控制表的整个生命周期时，请使用内部表。</p>
<p>当文件已经存在或位于远程位置时，请使用外部表，因为即使删除表，文件也会被保留。</p>
<h3 id="hive分区表">Hive分区表</h3>
<h4 id="基础-1">基础</h4>
<p>为了优化查询速度，减少全表扫描，提出分区表的概念。</p>
<p>分区表指的是Hive中可以根据用户<strong>指定的字段进行分区</strong>，分区的字段可以是日期、地域、种类等具有标识意义的字段。比如把一整年的数据根据月份划分12个月（12个分区），后续就可以查询指定月份分区的数据，尽可能避免了全表扫描查询。</p>
<p>分区表建表语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name (</span><br><span class="line">    column1 data_type, </span><br><span class="line">    column2 data_type</span><br><span class="line">) </span><br><span class="line">PARTITIONED BY (</span><br><span class="line">    partition1 data_type, </span><br><span class="line">    partition2 data_type,….</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>需要注意，<strong>分区字段不能是表中已经存在的字段</strong>，因为分区字段最终也会以虚拟字段的形式显示在表结构上。</p>
<p>针对英雄数据，创建一张分区表t_all_hero_part，以role角色作为分区字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table t_all_hero_part(</span><br><span class="line">       id int,</span><br><span class="line">       name string,</span><br><span class="line">       hp_max int,</span><br><span class="line">       mp_max int,</span><br><span class="line">       attack_max int,</span><br><span class="line">       defense_max int,</span><br><span class="line">       attack_range string,</span><br><span class="line">       role_main string,</span><br><span class="line">       role_assist string</span><br><span class="line">) partitioned by (role string)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725104741873.png" alt="image-20210725104741873"><figcaption aria-hidden="true">image-20210725104741873</figcaption>
</figure>
<p>分区表的创建可以分为静态分区和动态分区，本质上静态分区就是数据已经按照分区的形式划分为多个不同的文件，写SQL语句进行映射即可；而动态分区则是数据未进行分区，分区字段的值通过查询结果自动推断。</p>
<h4 id="静态分区">静态分区</h4>
<p>分区的字段值是由用户在加载数据的时候手动指定的。</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725104852600.png" alt="image-20210725104852600"><figcaption aria-hidden="true">image-20210725104852600</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data [local] inpath &#39; &#39; into table tablename partition(分区字段&#x3D;&#39;分区值&#39;...);</span><br><span class="line"></span><br><span class="line">-- 案例</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;archer.txt&#39; into table t_all_hero_part partition(role&#x3D;&#39;sheshou&#39;);</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;assassin.txt&#39; into table t_all_hero_part partition(role&#x3D;&#39;cike&#39;);</span><br><span class="line">load data local inpath &#39;&#x2F;root&#x2F;hivedata&#x2F;mage.txt&#39; into table t_all_hero_part partition(role&#x3D;&#39;fashi&#39;);</span><br></pre></td></tr></table></figure>
<p>Local表示数据是位于本地文件系统还是HDFS文件系统。上述案例表示文件都位于Hive服务器所在机器本地文件系统上。</p>
<h4 id="动态分区">动态分区</h4>
<p>往hive分区表中插入加载数据时，如果需要创建的分区很多，则需要复制粘贴修改很多sql去执行，效率低。因此hive提供了一个动态分区功能，其可以基于查询参数去推断分区的名称，从而建立分区。</p>
<p>所谓动态分区指的是分区的字段值是基于查询结果自动推断出来的。核心语法就是<strong>insert+select</strong>。</p>
<p>启用hive动态分区，需要在hive会话中设置两个参数，第一个参数表示开启动态分区功能；第二个参数指定动态分区的模式，分为nonstick非严格模式和strict严格模式。strict严格模式要求至少有一个分区为静态分区。：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> hive.exec.dynamic.partition=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">set</span> hive.exec.dynamic.partition.mode=nonstrict;</span><br></pre></td></tr></table></figure>
<p>执行动态分区插入的SQL为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into table t_all_hero_part_dynamic partition(role) </span><br><span class="line">select </span><br><span class="line">	tmp.*,</span><br><span class="line">	tmp.role_main </span><br><span class="line">from t_all_hero tmp;</span><br></pre></td></tr></table></figure>
<p>这样分区role字段的值就是通过 tmp.role_main 这个查询出来的字段自动推断的。</p>
<h4 id="hdfs中分区表底层原理">HDFS中分区表（底层原理）</h4>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725105722912.png" alt="image-20210725105722912"><figcaption aria-hidden="true">image-20210725105722912</figcaption>
</figure>
<p>从文件上来看，分区就是HDFS上的一个目录，可以指定多个分区，这样在插入数据的时候，hdfs 会产生多个目录。</p>
<h4 id="分区表的使用">分区表的使用</h4>
<p>1、建表时根据业务场景设置合适的分区字段。比如日期、地域、类别等；</p>
<p>2、查询的时候尽量先使用where进行分区过滤，查询指定分区的数据，避免全表扫描。</p>
<p>比如：查询英雄主要定位是射手并且最大生命大于6000的个数。使用分区表查询和使用非分区表进行查询，SQL如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 非分区表 全表扫描过滤查询</span><br><span class="line">select count(*) from t_all_hero where role_main&#x3D;&quot;archer&quot; and hp_max &gt;6000;</span><br><span class="line"></span><br><span class="line">-- 分区表 先基于分区过滤 再查询</span><br><span class="line">select count(*) from t_all_hero_part where role&#x3D;&quot;sheshou&quot; and hp_max &gt;6000;</span><br></pre></td></tr></table></figure>
<h4 id="多重分区">多重分区</h4>
<p>通过建表语句中关于分区的相关语法可以发现，Hive支持多个分区字段：PARTITIONED BY (partition1 data_type, partition2 data_type,….)。</p>
<p>多重分区下，分区之间是一种递进关系，可以理解为在前一个分区的基础上继续分区。从HDFS的角度来看就是文件夹下继续划分子文件夹。比如：把全国人口数据首先根据省进行分区，然后根据市进行划分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 双分区表，按省份和市分区</span><br><span class="line">create table t_user_province_city (id int, name string,age int) partitioned by (province string, city string);</span><br><span class="line"></span><br><span class="line">-- 加载数据</span><br><span class="line">load data local inpath &#39;文件路径&#39; into table t_user_province_city_county partition(province&#x3D;&#39;zhejiang&#39;,city&#x3D;&#39;hangzhou&#39;,county&#x3D;&#39;xiaoshan&#39;);</span><br></pre></td></tr></table></figure>
<h4 id="总结">总结</h4>
<p>1、分区表不是建表的必要语法规则，是一种优化手段表，可选；</p>
<p>2、分区字段不能是表中已有的字段，不能重复；</p>
<p>3、分区字段是虚拟字段，其数据并不存储在底层的文件中；</p>
<p>4、分区字段值来自于用户手动指定（静态分区）或者根据查询结果位置自动推断（动态分区）</p>
<p>5、Hive支持多重分区，也就是说在分区的基础上继续分区，划分更加细粒度</p>
<h3 id="hive分桶表">Hive分桶表</h3>
<h4 id="基础-2">基础</h4>
<p>分桶表，目的是将数据分为若干部分，在分桶时，要指定根据哪个字段将数据分为几桶（几个部分）。默认规则是：桶编号 = hash_function(分桶字段) mod 桶数量。</p>
<p>可以发现桶编号相同的数据会被分到同一个桶当中。hash_function取决于分桶字段的类型：</p>
<p>如果是int类型，hash_function(int) == int;</p>
<p>如果是其他类型，比如bigint,string或者复杂数据类型，hash_function比较棘手，将是从该类型派生的某个数字，比如hashcode值。</p>
<p>建表语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [EXTERNAL] TABLE [db_name.]table_name</span><br><span class="line">[(col_name data_type, ...)]</span><br><span class="line">CLUSTERED BY (col_name) SORTED BY (col_name) ASC&#x2F;DESC INTO N BUCKETS;</span><br></pre></td></tr></table></figure>
<p>其中CLUSTERED BY (col_name)表示根据哪个字段进行分；</p>
<p>INTO N BUCKETS表示分为几桶（也就是几个部分）。</p>
<p>需要注意的是，分桶的字段必须是<strong>表中已经存在的字段</strong>。</p>
<h4 id="建立分桶表案例">建立分桶表案例</h4>
<p>现有美国2021-1-28号，各个县county的新冠疫情累计案例信息，包括确诊病例和死亡病例，数据格式如下。字段含义为：count_date（统计日期）,county（县）,state（州）,fips（县编码code）,cases（累计确诊病例）,deaths（累计死亡病例）。</p>
<blockquote>
<p>2021-01-28,Juneau City and Borough,Alaska,02110,1108,3</p>
<p>2021-01-28,Kenai Peninsula Borough,Alaska,02122,3866,18</p>
<p>2021-01-28,Ketchikan Gateway Borough,Alaska,02130,272,1</p>
</blockquote>
<p>建表语句如下，可以指定分桶内数据排序规则（也可以不排序）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 根据state州分为5桶 每个桶内根据cases确诊病例数倒序排序</span><br><span class="line">CREATE TABLE itcast.t_usa_covid19_bucket(</span><br><span class="line">      count_date string,</span><br><span class="line">      county string,</span><br><span class="line">      state string,</span><br><span class="line">      fips int,</span><br><span class="line">      cases int,</span><br><span class="line">      deaths int)</span><br><span class="line">CLUSTERED BY(state) sorted by (cases desc) INTO 5 BUCKETS;</span><br></pre></td></tr></table></figure>
<p>将数据加载到创建的分桶表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- step1:开启分桶的功能 从Hive2.0开始不再需要设置</span><br><span class="line">set hive.enforce.bucketing&#x3D;true;</span><br><span class="line"></span><br><span class="line">-- step2:把源数据加载到普通hive表中</span><br><span class="line">CREATE TABLE itcast.t_usa_covid19(</span><br><span class="line">       count_date string,</span><br><span class="line">       county string,</span><br><span class="line">       state string,</span><br><span class="line">       fips int,</span><br><span class="line">       cases int,</span><br><span class="line">       deaths int)</span><br><span class="line">row format delimited fields terminated by &quot;,&quot;;</span><br><span class="line">-- 将源数据上传到HDFS，t_usa_covid19表对应的路径下</span><br><span class="line">hadoop fs -put us-covid19-counties.dat &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;itcast.db&#x2F;t_usa_covid19</span><br><span class="line"></span><br><span class="line">-- step3:使用insert+select语法将数据加载到分桶表中</span><br><span class="line">insert into t_usa_covid19_bucket select * from t_usa_covid19;</span><br></pre></td></tr></table></figure>
<p>到HDFS上查看t_usa_covid19_bucket底层数据结构可以发现，数据被分为了5个部分：</p>
<figure>
<img src="/2021/07/25/Hive_DDL/image-20210725155054250.png" alt="image-20210725155054250"><figcaption aria-hidden="true">image-20210725155054250</figcaption>
</figure>
<h4 id="分桶表优点">分桶表优点</h4>
<p>1、基于分桶字段查询时，减少全表扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 基于分桶字段state查询来自于New York州的数据</span><br><span class="line">-- 不再需要进行全表扫描过滤</span><br><span class="line">-- 根据分桶的规则hash_function(New York) mod 5计算出分桶编号</span><br><span class="line">-- 查询指定分桶里面的数据 就可以找出结果  此时是分桶扫描而不是全表扫描</span><br><span class="line">select * from t_usa_covid19_bucket where state&#x3D;&quot;New York&quot;;</span><br></pre></td></tr></table></figure>
<p>2、JOIN时可以提高MR程序效率，减少笛卡尔积数量</p>
<p>对于JOIN操作两个表有一个相同的列，如果对这两个表都进行了分桶操作（刚好在这两列上）。那么将保存相同列值的桶进行JOIN操作就可以，可以大大较少JOIN的数据量。</p>
<p>3、 分桶表数据进行抽样</p>
<p>当数据量特别大时，对全体数据进行处理存在困难时，可以对每一个桶进行抽样。抽样可以从被抽取的数据中估计和推断出整体的特性，是科学实验、质量检验、社会调查普遍采用的一种经济有效的工作和研究方法。</p>
<h4 id="分桶表和分区表的区别">分桶表和分区表的区别</h4>
<h2 id="view-视图">View 视图</h2>
<h3 id="基础-3">基础</h3>
<p>Hive中的<strong>视图（view）是一种虚拟表，只保存定义，不实际存储数据</strong>。通常从真实的物理表查询中创建生成视图，也可以从已经存在的视图上创建新视图。</p>
<p>创建视图时，将冻结视图的架构，如果删除或更改基础表，则视图将失败，并且视图不能存储数据，操作数据，只能查询。</p>
<p>总结：视图是用来<strong>简化操作</strong>的，它其实是一张虚表，在视图中不缓存记录，也没有提高查询性能。</p>
<h3 id="语法">语法</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- hive中有一张真实的基础表t_usa_covid19</span><br><span class="line">select *</span><br><span class="line">from itcast.t_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- 1、创建视图</span><br><span class="line">create view v_usa_covid19 </span><br><span class="line">as select count_date, county,state,deaths </span><br><span class="line">from t_usa_covid19 limit 5;</span><br><span class="line"></span><br><span class="line">-- 从已有的视图中创建视图呢</span><br><span class="line">create view v_usa_covid19_from_view as select * from v_usa_covid19 limit 2;</span><br><span class="line"></span><br><span class="line">-- 2、显示当前已有的视图 </span><br><span class="line">show tables;</span><br><span class="line">show views; -- hive v2.2.0之后支持</span><br><span class="line"></span><br><span class="line">-- 3、视图的查询使用</span><br><span class="line">select *</span><br><span class="line">from v_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- 能否插入数据到视图中呢？</span><br><span class="line">-- 不行 报错  SemanticException:A view cannot be used as target table for LOAD or INSERT</span><br><span class="line">insert into v_usa_covid19 select count_date,county,state,deaths from t_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- 4、查看视图定义</span><br><span class="line">show create table v_usa_covid19;</span><br><span class="line"></span><br><span class="line">-- 5、删除视图</span><br><span class="line">drop view v_usa_covid19_from_view;</span><br><span class="line"></span><br><span class="line">-- 6、更改视图属性</span><br><span class="line">alter view v_usa_covid19 set TBLPROPERTIES (&#39;comment&#39; &#x3D; &#39;This is a view&#39;);</span><br><span class="line"></span><br><span class="line">-- 7、更改视图定义</span><br><span class="line">alter view v_usa_covid19 as  select county,deaths from t_usa_covid19 limit 2;</span><br></pre></td></tr></table></figure>
<h3 id="view的优势">View的优势</h3>
<p>1、将真实表中特定的列数据提供给用户，保护数据隐式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--通过视图来限制数据访问可以用来保护信息不被随意查询:</span><br><span class="line">create table userinfo(</span><br><span class="line">    firstname string, </span><br><span class="line">    lastname string, </span><br><span class="line">    ssn string, </span><br><span class="line">    password string);</span><br><span class="line"></span><br><span class="line">create view safer_user_info </span><br><span class="line">as select firstname, lastname from userinfo;</span><br><span class="line"></span><br><span class="line">--可以通过where子句限制数据访问，比如，提供一个员工表视图，只暴露来自特定部门的员工信息:</span><br><span class="line">create table employee(</span><br><span class="line">    firstname string, </span><br><span class="line">    lastname string, </span><br><span class="line">    ssn string,</span><br><span class="line">    password string, </span><br><span class="line">    department string);</span><br><span class="line"></span><br><span class="line">create view techops_employee </span><br><span class="line">as select firstname, lastname, ssn from userinfo </span><br><span class="line">where department &#x3D; &#39;java&#39;;</span><br></pre></td></tr></table></figure>
<p>2、降低查询的复杂度，优化查询语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 把嵌套子查询变成一个视图</span><br><span class="line">create view shorter_join as</span><br><span class="line">select * from people join cart</span><br><span class="line">on (cart.pepople_id &#x3D; people.id) where firstname &#x3D; &#39;join&#39;;</span><br><span class="line"></span><br><span class="line">-- 基于视图查询</span><br><span class="line">select lastname from shorter_join where id &#x3D; 3;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="物化视图">物化视图</h3>
<h4 id="基础-4">基础</h4>
<p>物化视图（Materialized View）是一个包括查询结果的数据库对像，可以用于预<strong>先计算并保存表连接或聚集等耗时较多的操作的结果</strong>。这样，在执行查询时，就可以避免进行这些耗时的操作，而从快速的得到结果。使用物化视图的目的就是<strong>通过预计算，提高查询性能</strong>，当然需要占用一定的存储空间。</p>
<p>Hive3.0开始尝试引入物化视图，并提供对于物化视图的查询自动重写（基于Apache Calcite实现）。值得注意的是，3.0中提供了物化视图存储选择机制，可以本地存储在hive，同时可以通过用户自定义storage handlers存储在其他系统（如Druid）。</p>
<p>Hive引入物化视图的目的就是为了优化数据查询访问的效率,相当于从数据预处理的角度优化数据访问。Hive3.0丢弃了index索引的语法支持，推荐使用物化视图和列式存储文件格式来加快查询的速度。</p>
<h4 id="与视图的区别">与视图的区别</h4>
<p>1、视图是虚拟的，逻辑存在的，只有定义没有存储数据。物化视图是真实的，物理存在的，里面存储着预计算的数据。</p>
<p>不同于视图，物化视图能够缓存数据，在创建物化视图的时候就把数据缓存起来了，hive把物化视图当成一张“表”，将数据缓存。而视图只是创建一个虚表，只有表结构，没有数据，实际查询的时候再去改写SQL去访问实际的数据表。</p>
<p>2、视图的目的是简化降低查询的复杂度，而物化视图的目的是提高查询性能。</p>
<h4 id="语法-1">语法</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--物化视图的创建语法</span><br><span class="line">CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db_name.]materialized_view_name</span><br><span class="line">    [DISABLE REWRITE]</span><br><span class="line">    [COMMENT materialized_view_comment]</span><br><span class="line">    [PARTITIONED ON (col_name, ...)]</span><br><span class="line">    [CLUSTERED ON (col_name, ...) | DISTRIBUTED ON (col_name, ...) SORTED ON (col_name, ...)]</span><br><span class="line">    [</span><br><span class="line">    [ROW FORMAT row_format]</span><br><span class="line">    [STORED AS file_format]</span><br><span class="line">    | STORED BY &#39;storage.handler.class.name&#39; [WITH SERDEPROPERTIES (...)]</span><br><span class="line">  ]</span><br><span class="line">  [LOCATION hdfs_path]</span><br><span class="line">  [TBLPROPERTIES (property_name&#x3D;property_value, ...)]</span><br><span class="line">AS SELECT ...;</span><br></pre></td></tr></table></figure>
<p>语法说明： 1、物化视图创建后，select查询执行数据自动落地，"自动"也即在query的执行期间，任何用户对该物化视图是不可见的</p>
<p>2、默认该物化视图可被用于查询优化器optimizer查询重写（在物化视图创建期间可以通过DISABLE REWRITE参数设置禁止使用）</p>
<p>3、SerDe和storage format非强制参数，可以用户配置，默认可用hive.materializedview.serde、 hive.materializedview.fileformat</p>
<p>4、物化视图可以使用custom storage handlers存储在外部系统（如druid）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE MATERIALIZED VIEW druid_wiki_mv</span><br><span class="line">STORED AS &#39;org.apache.hadoop.hive.druid.DruidStorageHandler&#39;</span><br><span class="line">AS SELECT </span><br><span class="line">__time, page, user, c_added, c_removed</span><br><span class="line">FROM src;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5、目前支持物化视图的drop和show操作，后续会增加其他操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Drops a materialized view</span><br><span class="line">DROP MATERIALIZED VIEW [db_name.]materialized_view_name;</span><br><span class="line">-- Shows materialized views (with optional filters)</span><br><span class="line">SHOW MATERIALIZED VIEWS [IN database_name];</span><br><span class="line">-- Shows information about a specific materialized view</span><br><span class="line">DESCRIBE [EXTENDED | FORMATTED] [db_name.]materialized_view_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>6、当数据源变更（新数据插入inserted、数据修改modified），物化视图也需要更新以保持数据一致性，目前需要用户主动触发rebuild</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER MATERIALIZED VIEW [db_name.]materialized_view_name REBUILD;</span><br></pre></td></tr></table></figure>
<h4 id="基于物化视图的查询重写">基于物化视图的查询重写</h4>
<p>物化视图创建后即可用于相关查询的加速，用户提交查询query，若该query经过重写后可命中已建视图，则被重写命中相关已建视图实现查询加速。</p>
<p>是否重写查询使用物化视图可以通过全局参数控制，默认为true： SET hive.materializedview.rewriting=true;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1、新建一张事务表 student_trans</span><br><span class="line">set hive.support.concurrency &#x3D; true; --Hive是否支持并发</span><br><span class="line">set hive.enforce.bucketing &#x3D; true; --从Hive2.0开始不再需要  是否开启分桶功能</span><br><span class="line">set hive.exec.dynamic.partition.mode &#x3D; nonstrict; --动态分区模式  非严格</span><br><span class="line">set hive.txn.manager &#x3D; org.apache.hadoop.hive.ql.lockmgr.DbTxnManager; --</span><br><span class="line">set hive.compactor.initiator.on &#x3D; true; --是否在Metastore实例上运行启动线程和清理线程</span><br><span class="line">set hive.compactor.worker.threads &#x3D; 1; --在此metastore实例上运行多少个压缩程序工作线程。</span><br><span class="line"></span><br><span class="line">CREATE TABLE student_trans (</span><br><span class="line">      sno int,</span><br><span class="line">      sname string,</span><br><span class="line">      sdept string)</span><br><span class="line">clustered by (sno) into 2 buckets stored as orc TBLPROPERTIES(&#39;transactional&#39;&#x3D;&#39;true&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 2、导入数据到student_trans中</span><br><span class="line">insert overwrite table student_trans</span><br><span class="line">select sno,sname,sdept</span><br><span class="line">from student;</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from student_trans;</span><br><span class="line"></span><br><span class="line">-- 3、对student_trans建立聚合物化视图</span><br><span class="line">CREATE MATERIALIZED VIEW student_trans_agg</span><br><span class="line">AS SELECT sdept, count(*) as sdept_cnt from student_trans group by sdept;</span><br><span class="line"></span><br><span class="line">-- 注意 这里当执行CREATE MATERIALIZED VIEW，会启动一个MR对物化视图进行构建</span><br><span class="line">-- 可以发现当下的数据库中有了一个物化视图</span><br><span class="line">show tables;</span><br><span class="line">show materialized views;</span><br><span class="line"></span><br><span class="line">-- 4、对原始表student_trans查询</span><br><span class="line">-- 由于会命中物化视图，重写query查询物化视图，查询速度会加快（没有启动MR，只是普通的table scan）</span><br><span class="line">SELECT sdept, count(*) as sdept_cnt from student_trans group by sdept;</span><br><span class="line"></span><br><span class="line">-- 5、查询执行计划可以发现 查询被自动重写为TableScan alias: itcast.student_trans_agg</span><br><span class="line">-- 转换成了对物化视图的查询  提高了查询效率</span><br><span class="line">explain SELECT sdept, count(*) as sdept_cnt from student_trans group by sdept;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="参考资料">参考资料</h3>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
</search>
